{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/melody/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":0,"renderable":1},{"_id":"themes/melody/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/melody/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/melody/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/melody/source/js/copy.js","path":"js/copy.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/fireworks.js","path":"js/fireworks.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/head.js","path":"js/head.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/transition.js","path":"js/transition.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","path":"js/third-party/reveal/markdown.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","path":"js/third-party/reveal/notes.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","path":"js/third-party/reveal/math.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","path":"js/third-party/reveal/marked.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","path":"js/third-party/reveal/zoom.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","path":"js/third-party/reveal/reveal.min.js","modified":0,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","path":"js/third-party/reveal/highlight.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"6120073d59858b998f93b2e2ada21d3af5d412c7","modified":1512389840000},{"_id":"source/CNAME","hash":"134939cefd1f0f6033f31cdb2ecaa7b6963e6348","modified":1530589340000},{"_id":"source/.DS_Store","hash":"a03b7ff33f800f836459132e896a4fdbdca7e79f","modified":1548901848904},{"_id":"themes/melody/.eslintignore","hash":"55f36fe3be2270ae2746eddbb2982e4e1472bc31","modified":1525245109000},{"_id":"themes/melody/.eslintrc","hash":"cfcd1b454efdd6cc1a0d43be7bc79027b84531f7","modified":1525245109000},{"_id":"themes/melody/.gitignore","hash":"7ed73f0edfb682b12a42070fd2730d5d712ec2fa","modified":1525245109000},{"_id":"themes/melody/_config.yml","hash":"3b5a941575d21469d717a984909516d3231a2222","modified":1538909895000},{"_id":"themes/melody/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1525245109000},{"_id":"themes/melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1538909895000},{"_id":"themes/melody/README.md","hash":"a3053d735e36ad9f9a588a1d130e21b54683553c","modified":1538909895000},{"_id":"themes/melody/package.json","hash":"495095311146f977731de6ad30d608505f9c423f","modified":1538909895000},{"_id":"themes/melody/stylus_format.json","hash":"2fbe63b06901d202773457d7ce658ab6aa85d02b","modified":1525245109000},{"_id":"themes/melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525245109000},{"_id":"source/_data/melody.yml","hash":"e4523d91ba51586e87576f71cce058b1b98ec9be","modified":1538910199000},{"_id":"source/_posts/.DS_Store","hash":"1fbc616afe31bc448d7d5483e560425f6129cf7f","modified":1548728382143},{"_id":"source/_posts/Avoiding-singletons-in-Swift.md","hash":"d9ca6a1fa2723e28457c75cf6d286612bce5440c","modified":1538911077000},{"_id":"source/_posts/Capturing-objects-in-Swift-closures.md","hash":"ab86b55ff0ec477924349906465dee39d5a721fa","modified":1510536746000},{"_id":"source/_posts/Dependency-injection-using-factories-in-Swift.md","hash":"f3aff59d8af42980c78b6979d380d7d8d398f961","modified":1514043901000},{"_id":"source/_posts/Handling-non-optional-optionals-in-Swift.md","hash":"94920d5b1cc7f80b67c6218de5b69934f6d84277","modified":1510674232000},{"_id":"source/_posts/How-We-Created-Guillotine-Menu-Animation-for-iOS.md","hash":"8533595c2fb5b86c395941a6dd41d4b19cde96f7","modified":1495370078000},{"_id":"source/_posts/In-App-Purchase.md","hash":"17c6035fec291ff68f6c16019f3180fdc74b5d20","modified":1538910572000},{"_id":"source/_posts/Initializer-in-Swift.md","hash":"50918d0e63a8fbe6b41d2cc5c8e63f56772d78ee","modified":1538912194000},{"_id":"source/_posts/Modular-Xcode-projects.md","hash":"903551ba3b52a3095e448ae3182fb28208875292","modified":1538911172000},{"_id":"source/_posts/My-Favorite-Mac-Apps.md","hash":"ec7cda0ad3c2a434c166384b69bda720a4c9ed39","modified":1538910563000},{"_id":"source/_posts/MyFirstPost.md","hash":"ddb564014200252cb9515794c7eda4c8a29cf55e","modified":1495370110000},{"_id":"source/_posts/.Ulysses-Group.plist","hash":"7f993ccfd85cd0522d43a99567cfcebf3f42fa68","modified":1548642977000},{"_id":"source/_posts/MyReadingProcess.md","hash":"a9501d2332d4bb77a00dccaf8437810a040cdb74","modified":1540102021000},{"_id":"source/_posts/Read-SourceCode-of-PNChart.md","hash":"c8b3eb92e674a11ab1fd43731441153a94e716ee","modified":1508242831000},{"_id":"source/_posts/Reading-Garbage-Collection.md","hash":"cb92f41a09d801dae2c95644b8e7cc635bb3d36f","modified":1510490292000},{"_id":"source/_posts/Send-to-2Do.md","hash":"3abac5cfcd76623a6d8aa9a3d94c263f002eff0f","modified":1543751537000},{"_id":"source/_posts/Swift-and-Modules.md","hash":"0cd09a01c12be632d35b4f2f279c4dee5ceec845","modified":1546834350428},{"_id":"source/_posts/Testing-Swift-code-that-uses-system-singletons-in-3-easy-steps.md","hash":"110204651aea0a30128a78593f2c27deb2cecd95","modified":1531821283000},{"_id":"source/_posts/Thread-Programming-Guide.md","hash":"9c6605f514eff5ad1d4374f40c51aae8345fed10","modified":1508242706000},{"_id":"source/_posts/Understanding-Responders-and-the-Responder-Chain.md","hash":"cb83571c74ec4ba6329660f8560c990fc2a427ec","modified":1525257975000},{"_id":"source/_posts/Understanding-the-Objective-C-Runtime.md","hash":"4418cc861f65068e8127477e052bb317a130cd33","modified":1538910595000},{"_id":"source/_posts/Objective-C中Category的一点东西.md","hash":"9c9b2d8498e84896379acd7262a51a344de137e4","modified":1495370436000},{"_id":"source/_posts/Elastic-view-animation-using-UIBezierPath.md","hash":"9e102d043ff96f55696a8f8a3da2ea27a6b221ed","modified":1495370072000},{"_id":"source/_posts/UserDefaults-and-Keychain.md","hash":"2762f253673229e946b4931e4c568c38b57fd534","modified":1546525567844},{"_id":"source/_posts/Different-flavors-of-dependency-injection-in-Swift.md","hash":"2901189b867498dbe8026180c5154f8ea489512b","modified":1531800094000},{"_id":"source/_posts/What-is-LLVM.md","hash":"89ce167ec5ce638b0df4475a63345bb03cc3f527","modified":1531800519000},{"_id":"source/_posts/autoclosure-escape.md","hash":"77f8fe2c1cf96902a2ae3564c873041d1cc44d2e","modified":1548217000185},{"_id":"source/_posts/iOS-Push-Notification.md","hash":"d711f048dc1801bb3735968c273705398cc276b2","modified":1495356028000},{"_id":"source/_posts/leetCode-001-Maximum-Product-Subarray.md","hash":"9ffb3a35f39ca1cc84a8e267bb8203100f94ba9d","modified":1525257784000},{"_id":"source/_posts/leetCode-002-Reverse-Words-in-a-String.md","hash":"76ea10969fc693e50b69dec196d3844fe9e601d1","modified":1525258221000},{"_id":"source/_posts/leetCode-003-Intersection-of-Two-Linked-lists.md","hash":"ae922718cc4bc44ad56a301aa407aa836462ed68","modified":1525258279000},{"_id":"source/_posts/leetCode-003-Two-Sum.md","hash":"d6e550f21f11b56fa469edaff60c5d017382957c","modified":1525258041000},{"_id":"source/_posts/leetCode-018-LengthOfLastWord.md","hash":"322156d671b9240e390c88a3c55360de411455e5","modified":1525257807000},{"_id":"source/_posts/leetCode-021-ImplementStrstr.md","hash":"eff89eacb6ef7624a2577881d6a1b8896433d491","modified":1525257952000},{"_id":"source/_posts/关于-SS-流量丢失的原因探索.md","hash":"3c5f06de645acd7385810dfef5a470d34e99581f","modified":1548901821000},{"_id":"source/_posts/iOS-Notification.md","hash":"cca99f02769d76108ad518ab0a49451829c7677d","modified":1525265773000},{"_id":"source/_posts/leetCode-019-BinaryTreePaths.md","hash":"e0aa4813074b7ff3c0f592f6099c21731055625d","modified":1525257965000},{"_id":"source/_posts/关于单链表的那些事儿.md","hash":"a822b8abf3eb87d7dc9b0757d9df9e339cfe21b6","modified":1495355469000},{"_id":"source/about/index.md","hash":"519367fefe3bd7a6252b37b35f49ed1ef3d0ec45","modified":1495369169000},{"_id":"source/categories/index.md","hash":"d7dfcdb38a8bda0766f0a6ab40ea60bfeb987a54","modified":1525257474000},{"_id":"source/gallery/index.md","hash":"f5dd1592af5702f99a0bfda3d2e42b72c0e649b2","modified":1525246593000},{"_id":"source/tags/index.md","hash":"54c97e54c3dd0d3cc8ed7a916fd9cb5bfb133151","modified":1525257096000},{"_id":"source/_posts/scala第二天.md","hash":"7c274ca948ec2409ea276095d758f4de5bd27728","modified":1495370485000},{"_id":"source/_posts/关于Lambda的一点梳理.md","hash":"284aa68c1360879f71cebf6bf898bcf0604865ee","modified":1495355590000},{"_id":"themes/melody/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1525245103000},{"_id":"themes/melody/.git/FETCH_HEAD","hash":"763f8b14a39de77d716a3b3dfb2a6e56ff34fcf3","modified":1538909895000},{"_id":"themes/melody/.git/ORIG_HEAD","hash":"8398f9cd2d04f43310a3f779bfa507052e9d3de7","modified":1538909895000},{"_id":"themes/melody/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1525245103000},{"_id":"themes/melody/.git/config","hash":"dbc9583c30072395a2108cf3384f87973212d53c","modified":1525245109000},{"_id":"themes/melody/.git/index","hash":"3c130e34a2ad5bcbb94c16ba98bda09e388e86a9","modified":1540097820000},{"_id":"themes/melody/.git/packed-refs","hash":"02affdb0cb4416f488c94e22a58a37a01bea2a82","modified":1525245109000},{"_id":"themes/melody/.github/ISSUE_TEMPLATE.md","hash":"c5f14119189d9930fd7afd6e8822592fcd314ecf","modified":1538909895000},{"_id":"themes/melody/.vscode/launch.json","hash":"3098e8e395a33fa130747d2fd104a21278f266a6","modified":1525245109000},{"_id":"themes/melody/.vscode/settings.json","hash":"2e4acade0812cbeaf1363971c696a1d52d4f05ba","modified":1525245109000},{"_id":"themes/melody/languages/default.yml","hash":"f50471d72cd682673affd4b8ced45ffbcb528d3a","modified":1538909895000},{"_id":"themes/melody/languages/en.yml","hash":"f50471d72cd682673affd4b8ced45ffbcb528d3a","modified":1538909895000},{"_id":"themes/melody/languages/zh-Hans.yml","hash":"5e29425c8fdf9ff42818ea9cd852d7e63bc074d0","modified":1538909895000},{"_id":"themes/melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1525245109000},{"_id":"themes/melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1525245109000},{"_id":"themes/melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1525245109000},{"_id":"themes/melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1525245109000},{"_id":"themes/melody/layout/page.pug","hash":"6bb4336f74784679ac3f8691b0cce427f2282e02","modified":1538909895000},{"_id":"themes/melody/layout/post.pug","hash":"84268639485e56638f07805f65b965caf69c201a","modified":1538909895000},{"_id":"themes/melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1525245109000},{"_id":"themes/melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1525245109000},{"_id":"themes/melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1525245109000},{"_id":"themes/melody/scripts/replace-config.js","hash":"7476015a4e091203c3048c5377ec5d67439520fa","modified":1538909895000},{"_id":"themes/melody/source/favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1525245109000},{"_id":"themes/melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525245109000},{"_id":"source/_posts/.MWebMetaData/ImgUpload-232537C6207FFAEED181916D8231CE1C.data","hash":"fba362a450931203156904efb86ed2adcb2208f5","modified":1539701020000},{"_id":"source/_posts/.MWebMetaData/ImgUpload-49CCF481EDDE0D684AF1D3B560EDF5C0.data","hash":"d4cd047ff00a6303d55a97066fee384c6cfb8e6f","modified":1538907926000},{"_id":"source/_posts/.MWebMetaData/ImgUpload-789BC35C8078E26CAF7692AB513DCDD2.data","hash":"c4fa38b6cf45a30eb71fc806cb029ddebf9264ad","modified":1531822203000},{"_id":"source/_posts/.MWebMetaData/95A060A77B4D164CBD6D984B3CD82EF0.data","hash":"28f29000dc8bf02631fe2c296477d3de25fb7a4a","modified":1546582745793},{"_id":"source/_posts/.MWebMetaData/ImgUpload-AA07BC8B558F2E91EB3ED339E65328B8.data","hash":"6cee2b6923030bb7cb46e339d42e5587ef738999","modified":1531455158000},{"_id":"source/_posts/.MWebMetaData/ImgUpload-9477DA98EC4C1D07A9914EFB606BB5F5.data","hash":"e7d05591cffb4b94f6623f8dd6a1817b89be72dd","modified":1538907307000},{"_id":"source/_posts/.MWebMetaData/ImgUpload-910F9E40DA2E4C05BB1EAE12FBDAF2BA.data","hash":"0bf155faf2097c65bb0a9f1ba3b43bea976d54e0","modified":1548731396335},{"_id":"source/_posts/.MWebMetaData/ImgUpload-56FBD62632B847C085B1D9FB879D9708.data","hash":"32ac0cbb1c687bd8d498790c78b6f54f4470d661","modified":1543751486000},{"_id":"source/_posts/.MWebMetaData/ImgUpload-D0939243F0863EE76AE80ACE9C807874.data","hash":"2397314c678a57369337a91369e532eaae2f6625","modified":1538905168000},{"_id":"source/_posts/media/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1546524791648},{"_id":"source/_posts/media/9146792.png","hash":"9738c45276248178d9eceea880ad2c1316ef7fe8","modified":1538906870000},{"_id":"source/_posts/media/CleanShot 2019-01-28 at 19.52.09.png","hash":"029806e715d7071d93b92936e9b1eb2b8ecbb597","modified":1548676333236},{"_id":"source/_posts/media/CleanShot 2019-01-29 at 11.09.26.png","hash":"8a59e3531bf27e5cf482cc2660d37869a5a4e154","modified":1548731373752},{"_id":"source/_posts/media/MWeb 2019-01-28 at 19.51.52.png","hash":"cb14938981c87114eb85d5fa621bdb8d656e5d58","modified":1548676316646},{"_id":"source/_posts/media/TinkerTool.png","hash":"8f39f7fc35de2a3c6ed7d684c00d66e39512b122","modified":1538892990000},{"_id":"source/_posts/media/apple-touch-icon-144x144.png","hash":"c9f36228308ebf75e1c50435d855f373c966c2ed","modified":1538906863000},{"_id":"source/_posts/media/initializerDelegation02_2x.png","hash":"ad61a1409fc23c50f7c8b74905eb25ca91a6403e","modified":1538912174000},{"_id":"source/_posts/media/modular-carthage.png","hash":"fd73eb78abfe69c0823a44989d513c98d62e62c3","modified":1538906871000},{"_id":"source/_posts/media/modular-dependencies.png","hash":"e89f3cdc2558b571839e050b46a170722153945c","modified":1538906860000},{"_id":"source/_posts/media/modular-cocoapods.png","hash":"6c572360a6dfa10c41e57346b4c30d6168b4ad8e","modified":1538906867000},{"_id":"source/_posts/media/modular-linking.png","hash":"be5201963498b50d0eed85ffb0dd561399329458","modified":1538906853000},{"_id":"source/_posts/media/modular-workspace.png","hash":"75924c837a9c22e65de06e1c044eab214dc47514","modified":1538906834000},{"_id":"source/_posts/media/nf1.png","hash":"160ff775073ec424344b8b321e69fd3cedb245f1","modified":1538907849000},{"_id":"source/_posts/media/nf2.png","hash":"769b60352a40f02b1eeb134429e2abe9d1401090","modified":1538907850000},{"_id":"source/_posts/media/nf3.png","hash":"18e3937fd9ab0d6b07996bbbb39f8ebee7c5b133","modified":1538907852000},{"_id":"source/_posts/media/using-tunnelblick-menu-2016-03-04.png","hash":"f2a258950c6cfb60809c12985cf412cad6d4678e","modified":1538888053000},{"_id":"themes/melody/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1525245103000},{"_id":"themes/melody/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1525245103000},{"_id":"themes/melody/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1525245103000},{"_id":"themes/melody/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1525245103000},{"_id":"themes/melody/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1525245103000},{"_id":"themes/melody/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1525245103000},{"_id":"themes/melody/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1525245103000},{"_id":"themes/melody/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1525245103000},{"_id":"themes/melody/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1525245103000},{"_id":"themes/melody/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1525245103000},{"_id":"themes/melody/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1525245103000},{"_id":"themes/melody/.git/logs/HEAD","hash":"6ca67d6691c178db887737d51f8b98030d95f23f","modified":1538909895000},{"_id":"themes/melody/layout/includes/additional-js.pug","hash":"307400d70a7dd259bfa38074ca8f4a2173f8a8b4","modified":1538909895000},{"_id":"themes/melody/layout/includes/config.pug","hash":"b55265d49832decb34d57f222deb64f04cc9aa12","modified":1538909895000},{"_id":"themes/melody/layout/includes/footer.pug","hash":"0e9f1778f021f1c205f0b1be83014fba576797af","modified":1538909895000},{"_id":"themes/melody/layout/includes/head.pug","hash":"4e301e441c5279795eca1d8c088905a48d40a9ad","modified":1538909895000},{"_id":"themes/melody/layout/includes/nav.pug","hash":"f6aa2a23675700098ebcb4e8c991e69da8aefdea","modified":1538909895000},{"_id":"themes/melody/layout/includes/pagination.pug","hash":"556d055e2f0c30d41ec16ef7943bd3227afcdfd1","modified":1525245109000},{"_id":"themes/melody/layout/includes/layout.pug","hash":"a5ce123fcfc0b8b441e73822d8a764f389e4790d","modified":1538909895000},{"_id":"themes/melody/layout/includes/header.pug","hash":"cba312acd94934596e2f6b70f20cfb63c7099b88","modified":1538909895000},{"_id":"themes/melody/layout/includes/sidebar.pug","hash":"9035d96124b936a3592d1b0ff7ece938884ba46e","modified":1538909895000},{"_id":"themes/melody/layout/includes/recent-posts.pug","hash":"aefcb3462d1b9ed2fb8d16414a4f580fc4e7a4e7","modified":1538909895000},{"_id":"themes/melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1525245109000},{"_id":"themes/melody/source/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1525245109000},{"_id":"themes/melody/source/js/copy.js","hash":"cfae08721664d19cf0059172b994c0a2e253d334","modified":1525245109000},{"_id":"themes/melody/source/js/fireworks.js","hash":"5e3da1344966d5d6328a410cad69e92297699f3b","modified":1525245109000},{"_id":"themes/melody/source/js/head.js","hash":"212a32f824cadea0167bf4204c9714df5b7e5f5d","modified":1525245109000},{"_id":"themes/melody/source/js/fancybox.js","hash":"0c2c506559129a5108893cf054b9aa46fe878fc3","modified":1525245109000},{"_id":"themes/melody/source/js/scroll.js","hash":"73d57e7cf9921ba5724ad48b8d0e8b25dbce059f","modified":1525245109000},{"_id":"themes/melody/source/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1525245109000},{"_id":"themes/melody/source/js/transition.js","hash":"998c3bb6523a248d4dd4d747510c03a914a6378d","modified":1525245109000},{"_id":"themes/melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1525245109000},{"_id":"themes/melody/source/css/index.styl","hash":"111ec52cde3e5fae92cf61dc2a1bd8726b3aa8f9","modified":1525245109000},{"_id":"themes/melody/source/css/var.styl","hash":"bd6ea71543a39a4b255db5281f591f04a81feb5d","modified":1538909895000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_01-20-47_PM.png","hash":"36c0ef3535e25d9e926ef10742d3e69223d3ed86","modified":1538889647000},{"_id":"source/_posts/media/15437514515997.jpg","hash":"9398cf73b50f388625ca40ebcf6735c21bd0205a","modified":1543751451000},{"_id":"source/_posts/media/IMG_0118.jpg","hash":"70943808398e87d4b33d1b6ecc0b87b4dad8b7c7","modified":1538893370000},{"_id":"source/_posts/media/IMG_0129.jpg","hash":"1be0f01dd28c9d686ab2d80721b0420954458a3b","modified":1538894420000},{"_id":"source/_posts/media/macros.png","hash":"eef83ef0282678043668d2f494b52713731e19ff","modified":1538893689000},{"_id":"source/_posts/media/ios-runtime-class.png","hash":"fa51bf201c27b88823e6182bb9e321d397a1d1da","modified":1538907748000},{"_id":"themes/melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525245109000},{"_id":"source/_posts/media/IMG_0069.jpg","hash":"c6c619bf90eb42bbadc602c08e4422a28373ec40","modified":1538887687000},{"_id":"source/_posts/media/IMG_0063.jpg","hash":"e56ab51f3e487ab8c689ef0ed48b2c07f5e96fc5","modified":1538887606000},{"_id":"source/_posts/media/IMG_0127.jpg","hash":"0902a98298c66cf1cd7233d9f18a478e41e2963a","modified":1538893948000},{"_id":"source/_posts/media/f895c9f1f6.png","hash":"bceec0ee9ad864978f6ffd3e9d375c3aa95e3f6b","modified":1539681735000},{"_id":"themes/melody/.git/objects/pack/pack-e7a92464b380878dbc9fd7ee13f06ca00feef333.idx","hash":"8370e412cd9f506dd0970a0fcc69f2b94aaad577","modified":1538909895000},{"_id":"themes/melody/.git/refs/heads/master","hash":"f4ee9a2e59bf336ef09f72930f16eddb82e1ea9f","modified":1538909895000},{"_id":"themes/melody/.git/refs/tags/v1.5.6","hash":"e130bb74f884f9ce42319333f5f544d32adec585","modified":1538909895000},{"_id":"themes/melody/.git/refs/tags/v1.5.4","hash":"e63b441fb5b9be32efbbc69dfde5ccd080cb935d","modified":1538909895000},{"_id":"themes/melody/.git/refs/tags/v1.5.5","hash":"b0e9c54f90bfedd34cfbab4a5ea50165e3b865b0","modified":1538909895000},{"_id":"themes/melody/layout/includes/comments/index.pug","hash":"6c16214e5945142e5f3b58e7694397e26f28849d","modified":1525245109000},{"_id":"themes/melody/layout/includes/comments/gitment.pug","hash":"4a9e172c2b7a9f6f1f8c313d0d45266de828f209","modified":1525245109000},{"_id":"themes/melody/layout/includes/comments/disqus.pug","hash":"989de5ed05fb462e5a46601eb41ab3963b4d4e9d","modified":1525245109000},{"_id":"themes/melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1525245109000},{"_id":"themes/melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1525245109000},{"_id":"themes/melody/layout/includes/comments/valine.pug","hash":"e87eca6aed5a7e234a8acaa93e08ed674cb1531e","modified":1538909895000},{"_id":"themes/melody/layout/includes/count/busuanzi.pug","hash":"43fd52287adef41dc083738e25f24390d72b572c","modified":1525245109000},{"_id":"themes/melody/layout/includes/mixins/article-sort.pug","hash":"da7572fcc4aac6b63a651a3320e5d853ea07b347","modified":1525245109000},{"_id":"themes/melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1525245109000},{"_id":"themes/melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1525245109000},{"_id":"themes/melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1525245109000},{"_id":"themes/melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1525245109000},{"_id":"themes/melody/layout/includes/search/local-search.pug","hash":"f88070a84379bc06fb385e1193448fae6a8a54e1","modified":1538909895000},{"_id":"themes/melody/layout/includes/share/index.pug","hash":"65ea837388ddf806f89c3b9082ceb31776dc6be5","modified":1525245109000},{"_id":"themes/melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1525245109000},{"_id":"themes/melody/layout/includes/share/share-js.pug","hash":"f428b3bbc7a22d176098826c5e0aadf32b47f865","modified":1538909895000},{"_id":"themes/melody/layout/includes/slide/layout.pug","hash":"6b24f298d442e409c1149e4c1df38efce0453883","modified":1538909895000},{"_id":"themes/melody/layout/includes/third-party/mathjax.pug","hash":"035656871566bdcb8c45d3a0fe0b0835c524eb11","modified":1525245109000},{"_id":"themes/melody/layout/includes/slide/script.pug","hash":"c35c2af397f41bb858070032c702e8503371fd07","modified":1538909895000},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1525245109000},{"_id":"themes/melody/source/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1538909895000},{"_id":"themes/melody/source/js/search/local-search.js","hash":"56a92344aee6427345af106aa44b8555f9429b96","modified":1538909895000},{"_id":"themes/melody/source/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1525245109000},{"_id":"themes/melody/source/css/_global/index.styl","hash":"be8558033858fa050d7efb1ff2ed1956d54c2a56","modified":1538909895000},{"_id":"themes/melody/source/css/_search/algolia.styl","hash":"534e5641e3efe2452db95cc25ec8da0111ceadcf","modified":1538909895000},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1525245109000},{"_id":"themes/melody/source/css/_search/index.styl","hash":"63cae4465ac54b71361c1795206534c7f2e6e5b1","modified":1538909895000},{"_id":"themes/melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1525245109000},{"_id":"themes/melody/source/css/_search/local-search.styl","hash":"d7970b385265fef782cdcaaf4fe68a2217625467","modified":1538909895000},{"_id":"themes/melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1525245109000},{"_id":"themes/melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1525245109000},{"_id":"themes/melody/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1525245109000},{"_id":"themes/melody/source/css/_highlight/highlight.styl","hash":"67a26d07cf8f2dca0a28521728aeecabb740669c","modified":1538909895000},{"_id":"themes/melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1538909895000},{"_id":"themes/melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1525245109000},{"_id":"themes/melody/source/css/_layout/head.styl","hash":"f8c4bdd331907b6156be7309f7404ea5df38f302","modified":1538909895000},{"_id":"themes/melody/source/css/_layout/footer.styl","hash":"a72a6bb4477c18a14a2b779db183df22b4cba272","modified":1525245109000},{"_id":"themes/melody/source/css/_layout/page.styl","hash":"79d551beaea2458abcedbf585618b9fa8d3d22e5","modified":1525245109000},{"_id":"themes/melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1525245109000},{"_id":"themes/melody/source/css/_layout/post.styl","hash":"8658737ba289559077c5233b491e424cd5ddca5e","modified":1538909895000},{"_id":"themes/melody/source/css/_layout/sidebar.styl","hash":"e8315401a6c791d00617c031be01f45df70fe7fd","modified":1538909895000},{"_id":"source/_posts/media/1_rVeJuWwnhjB5NyK2lhPP4Q.png","hash":"4b148eb356873902faa7b58e374884a78c0c677e","modified":1538900356000},{"_id":"source/_posts/media/IMG_0059.jpg","hash":"a9de9559e165e4e8a5d598e2afdd8c47f29aa3dc","modified":1538887339000},{"_id":"source/_posts/media/IMG_0085.jpg","hash":"14f3538c855dfc147d69a20ced434c8b3d328d3a","modified":1538888328000},{"_id":"source/_posts/media/IMG_0087.jpg","hash":"43c80947fbb708593b6066f0bbb09736c582c2d1","modified":1538889048000},{"_id":"source/_posts/media/IMG_0095.jpg","hash":"74ca7a2847355ceba099db0e0bb66246dc3f17f5","modified":1538889296000},{"_id":"source/_posts/media/IMG_0255.jpg","hash":"7cbc43f20703ee4e60e037aac5491d5b2d85de99","modified":1538899121000},{"_id":"source/_posts/media/IMG_0257.jpg","hash":"50757b482ad0ac23c19f01146bd5c3d73cb68786","modified":1538899258000},{"_id":"source/_posts/media/Microsoft.VisualStudio.Services.Screenshots.jpg","hash":"bc6ed8e8930348e630d783b59e1e53b03d9b9a55","modified":1538899963000},{"_id":"source/_posts/media/Screen shot 2010-01-15 at 10.18.04 AM.png","hash":"3965b6aa1de716f99375b061110eb5ff86ad2bbc","modified":1538907354000},{"_id":"source/_posts/media/Screen shot 2010-01-15 at 10.18.04 AM-1.png","hash":"3965b6aa1de716f99375b061110eb5ff86ad2bbc","modified":1538907369000},{"_id":"source/_posts/media/Untitled-3@0,5x_2.8cc4d624.jpg","hash":"721d4e07aafae0dbb5fce503c5d86cf37d37ae3c","modified":1538893569000},{"_id":"themes/melody/.git/objects/pack/pack-c7d655652f16268e8936f2dd4292a2f76bd2d876.idx","hash":"75a497ee804e74f5ff50f70fce8052cfcd6c3017","modified":1525245109000},{"_id":"themes/melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1525245109000},{"_id":"source/_posts/media/IMG_0142.jpg","hash":"d3189fdd8768a7eb8bcdd3f3f25c88c8a79b03b6","modified":1538895280000},{"_id":"source/_posts/media/IMG_0166.jpg","hash":"93dd0344a9b54a541842bf35ba6256e7549a052a","modified":1538897108000},{"_id":"source/_posts/media/IMG_0182.jpg","hash":"1565c099a392baf7c0b526224aaf8a9e6a7c3e47","modified":1538900191000},{"_id":"source/_posts/media/IMG_0184.jpg","hash":"8025bf8c61b8d3685dfd16c82028a8e070a6236d","modified":1538900261000},{"_id":"themes/melody/.git/logs/refs/heads/master","hash":"6ca67d6691c178db887737d51f8b98030d95f23f","modified":1538909895000},{"_id":"themes/melody/.git/refs/remotes/origin/dev","hash":"8905f951bb971f3c09d4ef320d0fdd6fbdc8eb02","modified":1538909895000},{"_id":"themes/melody/.git/refs/remotes/origin/master","hash":"f4ee9a2e59bf336ef09f72930f16eddb82e1ea9f","modified":1538909895000},{"_id":"themes/melody/.git/refs/remotes/origin/HEAD","hash":"2c142208129b78a4616cbb6798f96f4fb3580296","modified":1525245109000},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1525245109000},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1525245109000},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1525245109000},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1525245109000},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1525245109000},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1525245109000},{"_id":"source/_posts/media/IMG_0104-1.jpg","hash":"dbd0ac46743306ba63b0c40b720bc1e8d8abf3d9","modified":1538892794000},{"_id":"source/_posts/media/IMG_0115.jpg","hash":"2f3d83d23dee944428b960aaf68b579ee714da16","modified":1538893276000},{"_id":"source/_posts/media/IMG_0159.jpg","hash":"ce9dcdf1810e5a87f46d67359e57d203697460d4","modified":1538896186000},{"_id":"source/_posts/media/opengraph-home.png","hash":"f5779b2b1dc9a7ea20e6dcb1ec2f2e363e73359e","modified":1538899940000},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1525245109000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_02-11-33_PM.png","hash":"3db207e3f1074c623df2d713e1e05092b8211c01","modified":1538892693000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_02-25-01_PM-1.png","hash":"db0b515ed2cc477b495909a8b0b68c637615dddd","modified":1538893502000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_02-25-01_PM.png","hash":"db0b515ed2cc477b495909a8b0b68c637615dddd","modified":1538893502000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_02-30-13_PM-1.png","hash":"3368eb12a3b2a817bd4e1189bba1c854d4541d05","modified":1538893813000},{"_id":"source/_posts/media/Capto_Capture 2018-10-16_06-16-32_PM.png","hash":"a52eafbba96ae43c37b3622aa66d2012f20c5c9b","modified":1539684993000},{"_id":"source/_posts/media/IMG_0075.jpg","hash":"ab90fe5fff780798067c79ff5ff115d9de82c779","modified":1538888175000},{"_id":"source/_posts/media/IMG_0104.jpg","hash":"dbd0ac46743306ba63b0c40b720bc1e8d8abf3d9","modified":1538892794000},{"_id":"source/_posts/media/IMG_0111.jpg","hash":"e3386f9eea7e3c5608401943733b3a4617e099f4","modified":1538893107000},{"_id":"source/_posts/media/IMG_0135.jpg","hash":"a8c6bbb232ad560c5e2c3a0a195b06d28cf57f60","modified":1538894652000},{"_id":"source/_posts/media/IMG_0171.jpg","hash":"477ace7ec4d15b7a6c7d0e2125e5a09af228dc85","modified":1538897262000},{"_id":"source/_posts/media/IMG_0251.jpg","hash":"cbb82b11cbefd301a79e745b72ec8ddf68fa0914","modified":1538898965000},{"_id":"source/_posts/media/Safari 2019-01-28 at 18.08.21.png","hash":"1505eeefd7dbdc9a1e88dcccbf56d4618384fab6","modified":1548670103172},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 5.42.01 PM -2-.png","hash":"138d39795e42958993f2609b509e8a19505e9567","modified":1539682924000},{"_id":"source/_posts/media/Safari_FavoritesBar.png","hash":"a97950f3b1e3052a9e7f0e7a25309589d863f6ca","modified":1543216002000},{"_id":"source/_posts/media/Starter Project - 2018-10-16 22.26.17.png","hash":"d68cad43261420efa0830e664b563d9651ac69a1","modified":1539700958000},{"_id":"source/_posts/media/development-environment.png","hash":"15b4effd822f82d658dd90ae4dc4bdf342cb879f","modified":1538897517000},{"_id":"themes/melody/.git/objects/pack/pack-e7a92464b380878dbc9fd7ee13f06ca00feef333.pack","hash":"0d96c239a1d41155a51881a43c6742ea52bc5bd8","modified":1538909895000},{"_id":"themes/melody/.git/logs/refs/remotes/origin/master","hash":"1a233c8ba0348b086573153c9e092a796f42eccc","modified":1538909895000},{"_id":"themes/melody/.git/logs/refs/remotes/origin/HEAD","hash":"5c6a00e21761bf19f6a30fda8640fd2412c4fa16","modified":1525245109000},{"_id":"themes/melody/.git/logs/refs/remotes/origin/dev","hash":"7109dd803509b2296c1bbd6e41d91d5387390908","modified":1538909895000},{"_id":"source/_posts/media/5b57b32a873ab61be774a70e_Select_drag_tablet.png","hash":"12a86b39ca5348f7cb57a47c13f74ef71304dda1","modified":1539681931000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_02-30-13_PM.png","hash":"3368eb12a3b2a817bd4e1189bba1c854d4541d05","modified":1538893813000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_04-26-02_PM.png","hash":"061584049f66c2098f0c50ed5c2387ef17097771","modified":1538900763000},{"_id":"source/_posts/media/IMG_0073.jpg","hash":"bdced12fd91599928c4e8b9c07ca660792402e8e","modified":1538887953000},{"_id":"source/_posts/media/IMG_0137.jpg","hash":"b6d8556ef32996173e04f5badc6ae6da89103dea","modified":1538894904000},{"_id":"source/_posts/media/IMG_0160.jpg","hash":"c79f35a9cf74a3e19ab2ac09b3287f4f200a961d","modified":1538896263000},{"_id":"source/_posts/media/IMG_0176.jpg","hash":"039a347ebe54877192093a10ef0fc05f5d107aba","modified":1538897432000},{"_id":"source/_posts/media/IMG_0247.jpg","hash":"2017b01d8b5dc492211d34a4ced0e3badf2d4cc7","modified":1538898932000},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 5.52.02 PM -2-.png","hash":"1653a336e595a0934d46a7da7c4d338dab09e63e","modified":1539683583000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_05-38-04_PM.png","hash":"56b0ce33d71d52539a9b953b5f013335953fe283","modified":1538905084000},{"_id":"source/_posts/media/paw-lg.jpg","hash":"6d81db25584a007781d19908a122649da9084ed3","modified":1538900596000},{"_id":"source/_posts/media/sip-color-format-mac-2016.jpg","hash":"3a3e74dff737ad3034f55ce59cabfb4ae3cb2b63","modified":1538900515000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_05-38-04_PM-1.png","hash":"56b0ce33d71d52539a9b953b5f013335953fe283","modified":1538905084000},{"_id":"source/_posts/media/IMG_0124.jpg","hash":"29a4bc630356b8d72ec6e30fbb163abe991d91a3","modified":1538893745000},{"_id":"source/_posts/media/reveal_front_darkmode@2x-a401e4f92726f86092e56800b13889c7dabd57a336581fb38d864844da65a57f.jpg","hash":"58541fae2d50b473d3f505cfc27d3aa9ba2c0c38","modified":1538899359000},{"_id":"source/_posts/media/1_MKc6R_QRPKC2ESy3Gl33Gg.png","hash":"6a524636eee18b68061c6584f35c31a8bd41c6b1","modified":1538900540000},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 5.59.14 PM -2-.png","hash":"c4d7a76b953c9943eb4221eaefb7dccd9cc17872","modified":1539683960000},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 6.00.52 PM -2-.png","hash":"6d230a2a7c684266f1798f5d56b6f548b5823b4f","modified":1539684056000},{"_id":"source/_posts/media/banner.jpg","hash":"8e8cda712797de1c3bbcf8a4399f4d47f6ba3740","modified":1539681961000},{"_id":"source/_posts/media/screencast-6af6f67fd43cb7a6dc46336be1f9f9d6e1cd266023eee8f96abdf1a1f29308eb.jpg","hash":"6abedba514a6f8157327c0b4580b0ebd64dc66f7","modified":1538899416000},{"_id":"themes/melody/.git/objects/pack/pack-c7d655652f16268e8936f2dd4292a2f76bd2d876.pack","hash":"fc4cf1db054684489fb9784a5a2824d7fe1846ad","modified":1525245109000},{"_id":"source/_posts/media/Capto_Capture 2018-10-07_02-10-03_PM.png","hash":"c4e45f26c1332a737c4d1c915579307a15dbbe45","modified":1538892603000},{"_id":"source/_posts/media/IMG_0093.jpg","hash":"9d623eaea28eb6f32b249d8131010f3fc9e2496b","modified":1538889196000},{"_id":"source/_posts/media/IMG_0152.jpg","hash":"1ef5e2d0d656700371e57f6b14bccb2b095e1698","modified":1538895530000},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 5.43.55 PM -2-.png","hash":"491fa29fce9e1d154a4644d01c892169250a4f23","modified":1539683041000},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 5.45.50 PM -2-.png","hash":"8a92aaf7661dc44966ddf849b93aa26ea62f1257","modified":1539683156000},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 6.08.00 PM -2-.png","hash":"fcf297744e66704826c35aeff32f4c6f9645d27d","modified":1539684486000},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1525245109000},{"_id":"source/_posts/media/Mac Apps.png","hash":"d88b4c8cca067196d721ebc8a8ac795d570f94dd","modified":1538886686000},{"_id":"source/_posts/media/Google Chrome 2019-01-28 at 17.53.23.png","hash":"7268cd4cdc4fbccd8111d4feaa131d145dff5e5e","modified":1548669205251},{"_id":"source/_posts/media/CleanShot 2019-01-28 at 18.07.07.png","hash":"1b18d0d3b030f0391afa09e8cb095322df3c69ca","modified":1548670029120},{"_id":"source/_posts/media/CleanShot 2019-01-28 at 17.20.56.png","hash":"2d382ff3af1cda7d5e8df5643877507b1cd93414","modified":1548667256413},{"_id":"source/_posts/media/CleanShot 2019-01-28 at 18.04.14.png","hash":"ed20f0fdc5e6d9a77a85d30a43f3ad0db66e9ca8","modified":1548669855747},{"_id":"source/_posts/media/CleanShot 2019-01-28 at 18.01.32.png","hash":"15dafc328dd35b2bd042eee220c2158c73d4292e","modified":1548669694531},{"_id":"source/_posts/media/Screen Shot 2018-10-16 at 5.54.03 PM.png","hash":"fcacc59e931c2264fe0bf9d55d6ec86a8c785523","modified":1539683645000},{"_id":"source/_posts/media/IMG_DBCE7237829E-1.jpeg","hash":"6e6fc461565541befeadffc2e3a0756ebe8ae8d8","modified":1539685830000},{"_id":"source/_posts/media/IMG_17BD79F12F2E-1.jpeg","hash":"46ecaa4273cdb82303d3c3f0726d1582e8c18d62","modified":1539685780000},{"_id":"public/img/algolia.svg","hash":"278ffcea4876b37657f2e192bda48c6bc7dd8784","modified":1548905735231},{"_id":"public/img/avatar.png","hash":"291127a40e487ff0dcb601c44cd6f5ef602315b6","modified":1548905735231},{"_id":"public/404.html","hash":"218db8b056ed4814926b600f925494a973d3f716","modified":1548905665679},{"_id":"public/atom.xml","hash":"b73b23fd0b56deaf49063e172c672ea109668d6e","modified":1548905665679},{"_id":"public/sitemap.xml","hash":"042b891d61ac6e58917efccf162daed77fe9d960","modified":1548905665679},{"_id":"public/about/index.html","hash":"4c7206fcf6dfab98f0ce910c4f89fe0499d609b8","modified":1548905735193},{"_id":"public/categories/index.html","hash":"53257c699a3aa08fea510e4bcb3c232959f071ae","modified":1548905735193},{"_id":"public/gallery/index.html","hash":"11b30470a16ec579472703e519f20899a481ad94","modified":1548905735194},{"_id":"public/tags/index.html","hash":"38dcbabeaa93c590c8a807f3144f0b8922b92520","modified":1548905735194},{"_id":"public/2019/01/28/关于-SS-流量丢失的原因探索/index.html","hash":"00fbf6d4263e1cbbbe14fb9870e2199d2542d582","modified":1548905735194},{"_id":"public/2019/01/03/Swift-and-Modules/index.html","hash":"7e48b1334cdb99a6bd5aed6ac41e042c7a4395fb","modified":1548905735194},{"_id":"public/2018/12/21/UserDefaults-and-Keychain/index.html","hash":"a55ccea120a317d70072bb6b082ba79346399f7f","modified":1548905735194},{"_id":"public/2018/11/26/Send-to-2Do/index.html","hash":"843b52b803a014f3ec3754744bb996e5387f318e","modified":1548905735194},{"_id":"public/2018/10/16/MyReadingProcess/index.html","hash":"be9c1f3dc0797bdaaed6b4ebd4ad3a66486618e6","modified":1548905735194},{"_id":"public/2018/07/17/Testing-Swift-code-that-uses-system-singletons-in-3-easy-steps/index.html","hash":"2c0a8cedd0de969da84f84f313b67b6c7cb31cff","modified":1548905735195},{"_id":"public/2018/07/16/Avoiding-singletons-in-Swift/index.html","hash":"314f755fed4cbeee5867ad72a26f11e125ab9e8e","modified":1548905735195},{"_id":"public/2018/07/16/Different-flavors-of-dependency-injection-in-Swift/index.html","hash":"e3ef1836966b8438792c32b6b6c8fe343b8f0e67","modified":1548905735195},{"_id":"public/2018/07/11/My-Favorite-Mac-Apps/index.html","hash":"aca2dcf7af9889adef9bd60e95ab485ddf0f62ed","modified":1548905735195},{"_id":"public/2018/07/10/What-is-LLVM/index.html","hash":"4c89eecfe36682f94710a88705626adce22af512","modified":1548905735195},{"_id":"public/2018/05/24/In-App-Purchase/index.html","hash":"7a14dab7cbb44141b41c3e970c411a17c5182bd0","modified":1548905735195},{"_id":"public/2017/11/19/Modular-Xcode-projects/index.html","hash":"aebdf73453f0ae051e04581421a1bc5f7571d987","modified":1548905735195},{"_id":"public/2017/11/19/Dependency-injection-using-factories-in-Swift/index.html","hash":"969e322ac81e9e20d5c8e5e67b44c3dcba10dced","modified":1548905735195},{"_id":"public/2017/11/15/Initializer-in-Swift/index.html","hash":"2138d2e3edef5d041eb646ece3b6d4a4edb3fc9a","modified":1548905735195},{"_id":"public/2017/11/14/Handling-non-optional-optionals-in-Swift/index.html","hash":"c9b21ac240d11e5cb1e4509b287503ae3d2368a9","modified":1548905735196},{"_id":"public/2017/11/13/Understanding-Responders-and-the-Responder-Chain/index.html","hash":"c71f35b18b34e0efe373620a008e420ac1049f68","modified":1548905735196},{"_id":"public/2017/11/12/Capturing-objects-in-Swift-closures/index.html","hash":"784611d6e8a7e60f0b124c7b8b2fd2c833a3de98","modified":1548905735196},{"_id":"public/2017/11/12/autoclosure-escape/index.html","hash":"6ac6fb151bdea1f0c06b93e69388ecd7da48cbae","modified":1548905735196},{"_id":"public/2017/10/17/Thread-Programming-Guide/index.html","hash":"d2f1bf74911358dfb57546eda1aa8c2c53cfa4bf","modified":1548905735196},{"_id":"public/2017/05/20/iOS-Notification/index.html","hash":"4fbcbfa529e0676b825c8c3b693e98fe87ea92b0","modified":1548905735196},{"_id":"public/2017/02/12/Reading-Garbage-Collection/index.html","hash":"f9c6b0f45b3feb5d08b29039ea9145312147db04","modified":1548905735196},{"_id":"public/2017/02/12/Read-SourceCode-of-PNChart/index.html","hash":"9fe1dd21a3a9f0fbfd4581fcca64ee32bdb3fceb","modified":1548905735196},{"_id":"public/2015/12/02/Elastic-view-animation-using-UIBezierPath/index.html","hash":"c479fa60b30c53e8d1db628c931340913a6af2bb","modified":1548905735197},{"_id":"public/2015/09/14/Objective-C中Category的一点东西/index.html","hash":"841330bc6b0323116cb126d845fe5f1b962dacef","modified":1548905735197},{"_id":"public/2015/09/07/Understanding-the-Objective-C-Runtime/index.html","hash":"7fb64b5674d04be40abd4cce23a2e3a64f916ba7","modified":1548905735197},{"_id":"public/2015/09/01/How-We-Created-Guillotine-Menu-Animation-for-iOS/index.html","hash":"ee4ddb46226e8a17ae47edf6ce8ce39c81ba8e84","modified":1548905735197},{"_id":"public/2015/08/21/leetCode-021-ImplementStrstr/index.html","hash":"bd2a6a2705871589a4c4cfb09a93d072e6342bd2","modified":1548905735197},{"_id":"public/2015/08/18/leetCode-019-BinaryTreePaths/index.html","hash":"659e322f45074e185f54950bf0e44d6a65e7a8a8","modified":1548905735197},{"_id":"public/2015/08/18/leetCode-018-LengthOfLastWord/index.html","hash":"96d3eafb7d524314a9b213975148d7e776c1b0b3","modified":1548905735197},{"_id":"public/2015/07/30/iOS-Push-Notification/index.html","hash":"4a834f63d6385418d7b718db8f484dc51df03e9d","modified":1548905735198},{"_id":"public/2015/05/07/关于单链表的那些事儿/index.html","hash":"c02619491b85584986bf4aa9266adfb664e83a59","modified":1548905735199},{"_id":"public/2015/05/01/leetCode-002-Reverse-Words-in-a-String/index.html","hash":"c8d2854762ab7c67743d4b54f6caf2f7ee7b3a29","modified":1548905735199},{"_id":"public/2015/04/29/leetCode-003-Two-Sum/index.html","hash":"515ac78eafa3ef1e6396581f012ed4beb8ba5db5","modified":1548905735200},{"_id":"public/2015/04/29/leetCode-003-Intersection-of-Two-Linked-lists/index.html","hash":"fa8ce0a25fee5966de59d22aaac164ea6b19626f","modified":1548905735201},{"_id":"public/2015/04/29/关于Lambda的一点梳理/index.html","hash":"b066984fd92f2e91b788f06e837e8ca9f34236e3","modified":1548905735201},{"_id":"public/2015/04/29/leetCode-001-Maximum-Product-Subarray/index.html","hash":"20d2cd77c44fcc11a3afc74e79670ad6214a0146","modified":1548905735202},{"_id":"public/2015/04/16/scala第二天/index.html","hash":"7b56baaa8a8ef4538e042a424db1e549f22bfced","modified":1548905735202},{"_id":"public/2015/04/15/MyFirstPost/index.html","hash":"6a6af8bd3d81e5616bdc49c2546537d729527294","modified":1548905735202},{"_id":"public/archives/index.html","hash":"696cd72ed178611d6eb34da6b06ec213e46cb0bb","modified":1548905735202},{"_id":"public/archives/page/2/index.html","hash":"391f7334d4fb16111168ef8958adcdb1f5f86855","modified":1548905735202},{"_id":"public/archives/page/3/index.html","hash":"6db1144ef126016b01a1203269124fc0b90b514f","modified":1548905735202},{"_id":"public/archives/page/4/index.html","hash":"7e69c5b90352ea5c96577cc1f02c6319774b6717","modified":1548905735202},{"_id":"public/archives/2015/index.html","hash":"ead9231e661f1b0ab9c823bcd73b5966c97bafe7","modified":1548905735203},{"_id":"public/archives/2015/page/2/index.html","hash":"90b12557985236c7588c2ae4784302dd4dca680f","modified":1548905735203},{"_id":"public/archives/2015/04/index.html","hash":"289e00ababc0129ea473dfea00d7fe40604a4dc7","modified":1548905735203},{"_id":"public/archives/2015/05/index.html","hash":"d1e5d32a2ddb646b768c4e28b612234e67ecf531","modified":1548905735203},{"_id":"public/archives/2015/07/index.html","hash":"a39e9850e714ed56344d9d45331ccd9b0eb159d2","modified":1548905735203},{"_id":"public/archives/2015/08/index.html","hash":"cd606074f419f7765ee855a48ac23bdcc26b7a27","modified":1548905735203},{"_id":"public/archives/2015/09/index.html","hash":"1fb73aea953a947dfa74b9db55d2a9eca31e7674","modified":1548905735203},{"_id":"public/archives/2015/12/index.html","hash":"56b7f6604d96b7e00fe9747e3680d885d3b9ae93","modified":1548905735204},{"_id":"public/archives/2017/index.html","hash":"c5628822a8ab4fbcef3861c9bfe5e4a8a83a18b3","modified":1548905735204},{"_id":"public/archives/2017/page/2/index.html","hash":"2bd1ce60c5456234e8572ac2517bf52c645eeb09","modified":1548905735204},{"_id":"public/archives/2017/02/index.html","hash":"445992b00c6a1e9a0528be57a765691dfe5632af","modified":1548905735205},{"_id":"public/archives/2017/05/index.html","hash":"6af3a0474c51287d9e807498396f9ac5b2297b36","modified":1548905735205},{"_id":"public/archives/2017/10/index.html","hash":"bfac80777146c03455716ed8d6d51b88256741c1","modified":1548905735205},{"_id":"public/archives/2017/11/index.html","hash":"5b9bf9178c1f956793e4478bb712daa1e55253a7","modified":1548905735205},{"_id":"public/archives/2018/index.html","hash":"58e2efbdd8870b1f037bed7e4cca36a45bd63b78","modified":1548905735205},{"_id":"public/archives/2018/05/index.html","hash":"4ef91a55cf07f8b535763b354e35435374d6e124","modified":1548905735205},{"_id":"public/archives/2018/07/index.html","hash":"3186d650523ad4260b2a60eee509bdab80fb6cba","modified":1548905735205},{"_id":"public/archives/2018/10/index.html","hash":"a5856896a8f0409791802113fbb3a82cb54bf7f2","modified":1548905735206},{"_id":"public/archives/2018/11/index.html","hash":"45668a17995bed148e1a171ae3159586a261b85c","modified":1548905735206},{"_id":"public/archives/2018/12/index.html","hash":"0ddef61de215bda99e61c2ae0348e28b30f2da38","modified":1548905735206},{"_id":"public/archives/2019/index.html","hash":"fa4edc582a4e480b7d77bbfd1bc1100187961c3a","modified":1548905735206},{"_id":"public/archives/2019/01/index.html","hash":"40ff0bffeb970c922f09bccc9f103b9ff383e7b1","modified":1548905735206},{"_id":"public/categories/Swift/index.html","hash":"dd62de4fa58d2e03a32c23b0ef4bd7620e60ad8b","modified":1548905735207},{"_id":"public/categories/Reading/index.html","hash":"fb94d6bfae38e7185d9789d66748063e8460fafe","modified":1548905735207},{"_id":"public/categories/拆轮子/index.html","hash":"547240f5f6f54a887799950bf8e3bd91b9688526","modified":1548905735207},{"_id":"public/categories/读书/index.html","hash":"636efbaceeee767a468c7dcde6e9a335a0ed9b29","modified":1548905735207},{"_id":"public/categories/Productivity/index.html","hash":"bfcdb38d379929c98214233ea8d5d0cac9f4e400","modified":1548905735207},{"_id":"public/categories/翻译/index.html","hash":"c9d2936ddfe58db3b46aca598cc58fcdaaa765c1","modified":1548905735207},{"_id":"public/categories/翻译/page/2/index.html","hash":"96d81ada20c489ff7fcb525720a3367993957a55","modified":1548905735207},{"_id":"public/categories/Apple-Documentation/index.html","hash":"7e34a5c437db9f22d502540c8745a8a62e2cffac","modified":1548905735207},{"_id":"public/categories/iOS/index.html","hash":"51e1c5a48629f531f0349b916b0dc970ef80fdc1","modified":1548905735207},{"_id":"public/categories/LeetCode/index.html","hash":"cd03f1f741ee781451a8af597fb06ea8893e100f","modified":1548905735208},{"_id":"public/categories/Mac/index.html","hash":"b045606347ce0ef8bdc03433ebc39d3de717d29d","modified":1548905735208},{"_id":"public/categories/Data-Structure/index.html","hash":"3062e3cf5c97a9204375c27a6989a0e502d942af","modified":1548905735208},{"_id":"public/categories/C/index.html","hash":"767854b8c0834350b2cd3e9b1791c9382f5b57df","modified":1548905735208},{"_id":"public/categories/Application/index.html","hash":"09d9ed2efc621d2499a323f80028dad7d3c9af31","modified":1548905735208},{"_id":"public/categories/七周七语言/index.html","hash":"79c22fc630e07bf9dd6cf58d27cecf823b78efc8","modified":1548905735208},{"_id":"public/index.html","hash":"a85071bc11b4bd1dfe2724758789641478404732","modified":1548905735208},{"_id":"public/page/2/index.html","hash":"41bd177eaa6aad1ada1dd3b811e34ed943a141e3","modified":1548905735208},{"_id":"public/page/3/index.html","hash":"bf811393b6cabd5cdd63030d46faa2ea7a7a94ed","modified":1548905735208},{"_id":"public/page/4/index.html","hash":"004cdc8efa75dfea62432626de4705c8e7019aaf","modified":1548905735208},{"_id":"public/tags/iOS/page/2/index.html","hash":"0d9de0bc8d6375e13d8cd7e7807e45c9efc109f3","modified":1548905735209},{"_id":"public/tags/iOS/index.html","hash":"566e55d2c85fd15bbf010fc4ce1c868de58ecae9","modified":1548905735209},{"_id":"public/tags/Swift/index.html","hash":"4c46df1eeca86b8748c2cac4ccbcf5a6fb3d5bca","modified":1548905735209},{"_id":"public/tags/Initializer/index.html","hash":"4fa4eba11590b4b1c4a842c27f2e04594e70a361","modified":1548905735209},{"_id":"public/tags/Convenience-Initializers/index.html","hash":"d770bf977d6c739e6e0db131f4e7a730b6089ca0","modified":1548905735209},{"_id":"public/tags/Designated-Initializer/index.html","hash":"2c8971fe262960e72a2d39b4d11f772e33a0b1fc","modified":1548905735209},{"_id":"public/tags/感悟/index.html","hash":"5c2b47d4f6b8d5a7f95f56c8369b7abd6f04178e","modified":1548905735209},{"_id":"public/tags/DEVONThink-MarginNote-PDFExpert/index.html","hash":"b439455e65544fd0b9212bf070635cbc940c7bd7","modified":1548905735209},{"_id":"public/tags/Github/index.html","hash":"2026eae9598e76772a78f60a2451c4a47c7d2066","modified":1548905735209},{"_id":"public/tags/Objective-C/index.html","hash":"54c94d31f188703adf0556508d88d47d119253e8","modified":1548905735209},{"_id":"public/tags/Garbage-Collection/index.html","hash":"d31fe90319cbc923c3d8f9abd09222e5bea780b8","modified":1548905735210},{"_id":"public/tags/Python/index.html","hash":"307bf7bb5d3b61b0b0eea002c98855498d281989","modified":1548905735210},{"_id":"public/tags/Book/index.html","hash":"4daa26e3114b61ff3d6ce5ae3fc491ecda9e9379","modified":1548905735210},{"_id":"public/tags/Bookmark-2Do-Productivity-Things/index.html","hash":"fed769e95c0196662aa3263626dc8bee0db2ff54","modified":1548905735210},{"_id":"public/tags/XCode/index.html","hash":"d82842d16951c56410e1718d4c2fbf3ff39657ea","modified":1548905735210},{"_id":"public/tags/Singleton/index.html","hash":"f322a87c3a5a7927f278bcc4ff500a86f5978ca7","modified":1548905735210},{"_id":"public/tags/Thread/index.html","hash":"b5b80406f074ebada8ec5b30b65cba25a212e815","modified":1548905735210},{"_id":"public/tags/UIResponder/index.html","hash":"ab84ca570d1e3fc6f6aa9bce049de1e0004b7d11","modified":1548905735210},{"_id":"public/tags/UIGestureRecognizer/index.html","hash":"76d8ee82f076becb6adc644dd851411755f59ec1","modified":1548905735210},{"_id":"public/tags/UserDefaults-Keychain/index.html","hash":"867fca22826b4ccf9f2583c5e22887164c73c879","modified":1548905735210},{"_id":"public/tags/Algorithm/index.html","hash":"4a3a52afb8450028279e3c3b3480b38531da586a","modified":1548905735211},{"_id":"public/tags/Array/index.html","hash":"17bc32100e37757cd6cfee4211e7c763f02b3c24","modified":1548905735211},{"_id":"public/tags/String/index.html","hash":"3bdf17d01e2782ebfee007fe2478b59d31121f36","modified":1548905735211},{"_id":"public/tags/Linked-list/index.html","hash":"23b86e3829bac66d8f873342888a6b0464b4348c","modified":1548905735212},{"_id":"public/tags/Traffic/index.html","hash":"5e2378dc615ac0e481964a201e7f33dde0929cc6","modified":1548905735213},{"_id":"public/tags/Safari/index.html","hash":"37fc69f4f945e0d312bdf7d3d246a1355fbcb84e","modified":1548905735212},{"_id":"public/tags/Data-Structure/index.html","hash":"4d2d8649de610b6d4565727c27b028169caa186a","modified":1548905735213},{"_id":"public/tags/C-11/index.html","hash":"7683e7ad51f1ed59e90e6a0b4b3e9c336a8859ca","modified":1548905735213},{"_id":"public/tags/Lambda/index.html","hash":"8a79350de26c30a6fd53e3c378fdc8ec9754d87d","modified":1548905735213},{"_id":"public/tags/Closure/index.html","hash":"974bca23775a733a7dc7dc3164db89bbd9f18251","modified":1548905735215},{"_id":"public/tags/Optional/index.html","hash":"7421b73c40d13413139311957f2da5a95ea39dc2","modified":1548905735215},{"_id":"public/tags/Animation/index.html","hash":"d3a6334778a962f40beb50e76beb216f2f9a52d7","modified":1548905735215},{"_id":"public/tags/IAP/index.html","hash":"8b8e4f226259212660cd3fcfd8cad005245e0a8b","modified":1548905735215},{"_id":"public/tags/Receipt/index.html","hash":"862bba549472a96fae7a04ab66458129c3e764b4","modified":1548905735215},{"_id":"public/tags/App/index.html","hash":"789085fe982b9a3003fc593f9ad387fa5b921f89","modified":1548905735215},{"_id":"public/tags/Mac/index.html","hash":"24867792bd0f30f007ccc326406eacc9d356cb75","modified":1548905735215},{"_id":"public/tags/Category/index.html","hash":"781213e4406826b11682fc58240d625f81d52689","modified":1548905735216},{"_id":"public/tags/LLVM/index.html","hash":"e2b03e4da1373f491e292ccdd26d386fc431041f","modified":1548905735216},{"_id":"public/tags/Compiler/index.html","hash":"98df6810f7cf94b6c7236f28f5230e4a6c889309","modified":1548905735216},{"_id":"public/tags/Swfit/index.html","hash":"cee18f641052fcaf2acf6de0735b6a87e9693ea0","modified":1548905735216},{"_id":"public/tags/IR/index.html","hash":"498a20ea427c4e3666174224ca3a77338790ea00","modified":1548905735216},{"_id":"public/tags/scala/index.html","hash":"3bbc28371e0c79667003fd5640a687663a100d86","modified":1548905735216},{"_id":"public/tags/CocoaPods/index.html","hash":"696ffd5377e58a52fd5aadfff7629ffe0fe19082","modified":1548905735216},{"_id":"public/tags/Carthage/index.html","hash":"9286983c70fb6fa18bedc6cd2f5560fc6091921c","modified":1548905735216},{"_id":"public/tags/Swift-Module-CocoaPods/index.html","hash":"f487e0817508e9ecb69d71a8a77ef3a885854974","modified":1548905735216},{"_id":"public/tags/Push-Notification/index.html","hash":"145bee6d5af3533568132a4d0048477d51970503","modified":1548905735216},{"_id":"public/tags/Notification/index.html","hash":"d6db6d32c94d3592edbbe7582a70133bc982d640","modified":1548905735216},{"_id":"public/tags/Runtime/index.html","hash":"87b589b6ec0b299efe72761132857c001289e115","modified":1548905735217},{"_id":"public/CNAME","hash":"134939cefd1f0f6033f31cdb2ecaa7b6963e6348","modified":1548905665702},{"_id":"public/favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1548905735237},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"d3d461f371069b9f4359f9bdf6dcd101e66f6441","modified":1548905665702},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"6febeb9611ee470daa2d789ee955ce040e5384fd","modified":1548905666324},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"4eea0e8bf9e56cbe9a56e5cefa1b7636078097ce","modified":1548905666453},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548905736276},{"_id":"public/css/index.css","hash":"abb0b8f136b8fd5ab3e7b9b79b0ff5cefb46b854","modified":1548905736277},{"_id":"public/assets/algolia/algoliasearch.js","hash":"8a77cf53e1bd88ff80103687ce191c3f5e90578e","modified":1548905666674},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548905736902},{"_id":"public/js/copy.js","hash":"5e5e496e5c9a78f8f1a79f62a20aa7e7f8303b3b","modified":1548905737682},{"_id":"public/js/fireworks.js","hash":"a5130dc16fb47fec50b8df20910812702abd757b","modified":1548905737683},{"_id":"public/js/head.js","hash":"4086835e4a87f2b03a2a69e5cf14232c2b27783c","modified":1548905737683},{"_id":"public/js/fancybox.js","hash":"67660473498a265d4e49cb62d545d95f17e72858","modified":1548905737682},{"_id":"public/js/scroll.js","hash":"5c81c69e933143b6268eb79e4d8f2b12db5a6d5c","modified":1548905737683},{"_id":"public/js/sidebar.js","hash":"a655db22d6388d1378d886f9ef08956391316ee8","modified":1548905737684},{"_id":"public/js/transition.js","hash":"5bde3a6598bc29fccd34090f9535178a709ee909","modified":1548905737684},{"_id":"public/js/utils.js","hash":"857fdcb66045cebef4e184156d93b0d525fad3c3","modified":1548905737684},{"_id":"public/js/search/algolia.js","hash":"ea2548071c569d25400d6fab113b553f9d36bf3a","modified":1548905737684},{"_id":"public/js/search/local-search.js","hash":"90335a4ed577db7329dbea2fd2e034df4c144a57","modified":1548905737684},{"_id":"public/js/third-party/reveal/markdown.min.js","hash":"1fca00ce95f8d9da8da36715d870c0fcc815dad2","modified":1548905737684},{"_id":"public/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1548905737684},{"_id":"public/js/third-party/reveal/notes.min.js","hash":"53f7dd810f778ef84c9c25a2e8dcece74d848c4a","modified":1548905737684},{"_id":"public/js/third-party/reveal/zoom.min.js","hash":"15747056bebc00e3585a482005508fa6ad23f6d6","modified":1548905737684},{"_id":"public/js/third-party/anime.min.js","hash":"fc7d4ac3a9d56f7a0f47d2b816c7e1c255265e1b","modified":1548905738027},{"_id":"public/js/third-party/reveal/head.min.js","hash":"dc76bea65d1a790ac3863f700c15ccdf08107df7","modified":1548905738029},{"_id":"public/js/third-party/reveal/marked.min.js","hash":"5bbbe26dc53e60834c96072e776ecd28ca4bfab6","modified":1548905738031},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"7700e816ea21dc4e9c3842ec6b0da927b620bce0","modified":1548905738028},{"_id":"public/js/third-party/velocity.min.js","hash":"347ab4741645f70f7f43d6778920788e2c6dea02","modified":1548905739595},{"_id":"public/js/third-party/reveal/reveal.min.js","hash":"8088e91272a2532b29ec3e6dbbf4be0a937c39b8","modified":1548905739598},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"42ede39d4ae5dce6212ace1ab1eb74af3ecf0a53","modified":1548905739598},{"_id":"public/js/third-party/jquery.min.js","hash":"a87d0283d5dbf93638a8bf99d5634b4be0811e27","modified":1548905740727},{"_id":"public/js/third-party/reveal/highlight.min.js","hash":"dc7e7959460dcbaa97a5273a9ecbd53829096511","modified":1548905741351}],"Category":[{"name":"Swift","_id":"cjrk2frw5000579pozc49wox2"},{"name":"Reading","_id":"cjrk2frwj000c79podb9wcsjc"},{"name":"拆轮子","_id":"cjrk2frwo000h79pojbtcmgyb"},{"name":"读书","_id":"cjrk2frws000m79po9rz6ecl3"},{"name":"Productivity","_id":"cjrk2frww000r79po7tcpb5br"},{"name":"翻译","_id":"cjrk2frx1000z79po1my5gt66"},{"name":"Apple Documentation","_id":"cjrk2frx5001779poqpaa1ygn"},{"name":"iOS","_id":"cjrk2frxa001e79pobgi0jc45"},{"name":"LeetCode","_id":"cjrk2frxi001p79pokq56q9kx"},{"name":"Mac","_id":"cjrk2frxs002e79powrrh7du0"},{"name":"Data Structure","_id":"cjrk2frxu002m79pot6j5f5az"},{"name":"C++","_id":"cjrk2frxw002t79pomcngpw8m"},{"name":"Application","_id":"cjrk2ftbs004r79po2ccza15r"},{"name":"七周七语言","_id":"cjrk2ftc2005379pocczo25t4"}],"Data":[{"_id":"melody","data":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}],"Page":[{"layout":"false","_content":"\n\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>404</title>\n<style>\n*{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;}\n.center{margin:0 auto;}\n.whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;}\n.whole img{width:100%;height:100%;}\n.mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);}\n.b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px}\np{color:#fff;margin-top:40px;font-size:24px;}\n#num{margin:0 5px;font-weight:bold;}\n</style>\n<script type=\"text/javascript\">\n\tvar num=4;\n\tfunction redirect(){\n\t\tnum--;\n\t\tdocument.getElementById(\"num\").innerHTML=num;\n\t\tif(num<0){\n\t\t\tdocument.getElementById(\"num\").innerHTML=0;\n\t\t\tlocation.href=\"http://hechen.info\";\n\t\t\t}\n\t\t}\n\tsetInterval(\"redirect()\", 1000);\n</script>\n</head>\n\n<body onLoad=\"redirect();\">\n<div class=\"whole\">\n\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/back.jpg\" />\n    <div class=\"mask\"></div>\n</div>\n<div class=\"b\">\n\t\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/404.png\" class=\"center\"/>\n\t\t<p>\n\t\t\t暂时未能找到您查找的页面<br>\n\t\t\t可能输入的网址错误或此页面不存在<br>\n            <span id=\"num\"></span>秒后自动跳转到主页\n\t\t</p>\n\t</div>\n\n</body>\n</html>\n","source":"404.html","raw":"---\nlayout: false\n---\n\n\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>404</title>\n<style>\n*{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;}\n.center{margin:0 auto;}\n.whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;}\n.whole img{width:100%;height:100%;}\n.mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);}\n.b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px}\np{color:#fff;margin-top:40px;font-size:24px;}\n#num{margin:0 5px;font-weight:bold;}\n</style>\n<script type=\"text/javascript\">\n\tvar num=4;\n\tfunction redirect(){\n\t\tnum--;\n\t\tdocument.getElementById(\"num\").innerHTML=num;\n\t\tif(num<0){\n\t\t\tdocument.getElementById(\"num\").innerHTML=0;\n\t\t\tlocation.href=\"http://hechen.info\";\n\t\t\t}\n\t\t}\n\tsetInterval(\"redirect()\", 1000);\n</script>\n</head>\n\n<body onLoad=\"redirect();\">\n<div class=\"whole\">\n\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/back.jpg\" />\n    <div class=\"mask\"></div>\n</div>\n<div class=\"b\">\n\t\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/404.png\" class=\"center\"/>\n\t\t<p>\n\t\t\t暂时未能找到您查找的页面<br>\n\t\t\t可能输入的网址错误或此页面不存在<br>\n            <span id=\"num\"></span>秒后自动跳转到主页\n\t\t</p>\n\t</div>\n\n</body>\n</html>\n","date":"2019-01-03T13:21:10.343Z","updated":"2017-12-04T12:17:20.000Z","path":"404.html","title":"","comments":1,"_id":"cjrk2frtf000079pofu67mfrs","content":"\n\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>404</title>\n<style>\n*{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;}\n.center{margin:0 auto;}\n.whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;}\n.whole img{width:100%;height:100%;}\n.mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);}\n.b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px}\np{color:#fff;margin-top:40px;font-size:24px;}\n#num{margin:0 5px;font-weight:bold;}\n</style>\n<script type=\"text/javascript\">\n\tvar num=4;\n\tfunction redirect(){\n\t\tnum--;\n\t\tdocument.getElementById(\"num\").innerHTML=num;\n\t\tif(num<0){\n\t\t\tdocument.getElementById(\"num\").innerHTML=0;\n\t\t\tlocation.href=\"http://hechen.info\";\n\t\t\t}\n\t\t}\n\tsetInterval(\"redirect()\", 1000);\n</script>\n</head>\n\n<body onload=\"redirect();\">\n<div class=\"whole\">\n\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/back.jpg\">\n    <div class=\"mask\"></div>\n</div>\n<div class=\"b\">\n\t\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/404.png\" class=\"center\">\n\t\t<p>\n\t\t\t暂时未能找到您查找的页面<br>\n\t\t\t可能输入的网址错误或此页面不存在<br>\n            <span id=\"num\"></span>秒后自动跳转到主页\n\t\t</p>\n\t</div>\n\n</body>\n</html>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"\n\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>404</title>\n<style>\n*{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;}\n.center{margin:0 auto;}\n.whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;}\n.whole img{width:100%;height:100%;}\n.mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);}\n.b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px}\np{color:#fff;margin-top:40px;font-size:24px;}\n#num{margin:0 5px;font-weight:bold;}\n</style>\n<script type=\"text/javascript\">\n\tvar num=4;\n\tfunction redirect(){\n\t\tnum--;\n\t\tdocument.getElementById(\"num\").innerHTML=num;\n\t\tif(num<0){\n\t\t\tdocument.getElementById(\"num\").innerHTML=0;\n\t\t\tlocation.href=\"http://hechen.info\";\n\t\t\t}\n\t\t}\n\tsetInterval(\"redirect()\", 1000);\n</script>\n</head>\n\n<body onload=\"redirect();\">\n<div class=\"whole\">\n\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/back.jpg\">\n    <div class=\"mask\"></div>\n</div>\n<div class=\"b\">\n\t\t<img src=\"http://7xowaa.com1.z0.glb.clouddn.com/404.png\" class=\"center\">\n\t\t<p>\n\t\t\t暂时未能找到您查找的页面<br>\n\t\t\t可能输入的网址错误或此页面不存在<br>\n            <span id=\"num\"></span>秒后自动跳转到主页\n\t\t</p>\n\t</div>\n\n</body>\n</html>\n"},{"date":"2017-02-13T13:21:08.000Z","comments":1,"_content":"","source":"about/index.md","raw":"---\ndate: 2017-02-13 21:21:08\ncomments: true\n---\n","updated":"2017-05-21T12:19:29.000Z","path":"about/index.html","title":"","layout":"page","_id":"cjrk2frvy000279po0yepqkr5","content":"","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":""},{"title":"Categories","date":"2017-12-04T12:08:54.000Z","type":"categories","comments":1,"_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ndate: 2017-12-04 20:08:54\ntype: \"categories\"\ncomments: true\n---\n","updated":"2018-05-02T10:37:54.000Z","path":"categories/index.html","layout":"page","_id":"cjrk2frw3000479pokoa6bwpn","content":"","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":""},{"title":"Gallery","date":"2018-01-04T16:00:00.000Z","type":"gallery","_content":"\n{% gallery https://ws1.sinaimg.cn/large/8700af19gy1fp5i6o2vghj20ea0eajse melody %}\n{% gallery https://user-images.githubusercontent.com/12621342/37325500-23e8f77c-26c9-11e8-8e24-eb4346f1fff5.png background %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19gy1fp5i64zaxqj20b40b474b demo1 %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19ly1fn2h26q32uj21120kudqq demo2 %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic demo3 %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19ly1fn2i5kjh2pj21120kuncd %}","source":"gallery/index.md","raw":"---\ntitle: Gallery \ndate: 2018-01-05 00:00:00\ntype: \"gallery\"\n---\n\n{% gallery https://ws1.sinaimg.cn/large/8700af19gy1fp5i6o2vghj20ea0eajse melody %}\n{% gallery https://user-images.githubusercontent.com/12621342/37325500-23e8f77c-26c9-11e8-8e24-eb4346f1fff5.png background %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19gy1fp5i64zaxqj20b40b474b demo1 %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19ly1fn2h26q32uj21120kudqq demo2 %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic demo3 %}\n{% gallery https://ws1.sinaimg.cn/large/8700af19ly1fn2i5kjh2pj21120kuncd %}","updated":"2018-05-02T07:36:33.000Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"cjrk2frwa000879poedhc2o4s","content":"\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19gy1fp5i6o2vghj20ea0eajse')\" data-title=\"melody\" data-url=\"https://ws1.sinaimg.cn/large/8700af19gy1fp5i6o2vghj20ea0eajse\">\n      <div class=\"gallery-item__title\">\n        melody\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://user-images.githubusercontent.com/12621342/37325500-23e8f77c-26c9-11e8-8e24-eb4346f1fff5.png')\" data-title=\"background\" data-url=\"https://user-images.githubusercontent.com/12621342/37325500-23e8f77c-26c9-11e8-8e24-eb4346f1fff5.png\">\n      <div class=\"gallery-item__title\">\n        background\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19gy1fp5i64zaxqj20b40b474b')\" data-title=\"demo1\" data-url=\"https://ws1.sinaimg.cn/large/8700af19gy1fp5i64zaxqj20b40b474b\">\n      <div class=\"gallery-item__title\">\n        demo1\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19ly1fn2h26q32uj21120kudqq')\" data-title=\"demo2\" data-url=\"https://ws1.sinaimg.cn/large/8700af19ly1fn2h26q32uj21120kudqq\">\n      <div class=\"gallery-item__title\">\n        demo2\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic')\" data-title=\"demo3\" data-url=\"https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic\">\n      <div class=\"gallery-item__title\">\n        demo3\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19ly1fn2i5kjh2pj21120kuncd')\" data-title=\"No title\" data-url=\"https://ws1.sinaimg.cn/large/8700af19ly1fn2i5kjh2pj21120kuncd\">\n      <div class=\"gallery-item__title\">\n        No title\n      </div>\n    </div>\n  ","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19gy1fp5i6o2vghj20ea0eajse')\" data-title=\"melody\" data-url=\"https://ws1.sinaimg.cn/large/8700af19gy1fp5i6o2vghj20ea0eajse\">\n      <div class=\"gallery-item__title\">\n        melody\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://user-images.githubusercontent.com/12621342/37325500-23e8f77c-26c9-11e8-8e24-eb4346f1fff5.png')\" data-title=\"background\" data-url=\"https://user-images.githubusercontent.com/12621342/37325500-23e8f77c-26c9-11e8-8e24-eb4346f1fff5.png\">\n      <div class=\"gallery-item__title\">\n        background\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19gy1fp5i64zaxqj20b40b474b')\" data-title=\"demo1\" data-url=\"https://ws1.sinaimg.cn/large/8700af19gy1fp5i64zaxqj20b40b474b\">\n      <div class=\"gallery-item__title\">\n        demo1\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19ly1fn2h26q32uj21120kudqq')\" data-title=\"demo2\" data-url=\"https://ws1.sinaimg.cn/large/8700af19ly1fn2h26q32uj21120kudqq\">\n      <div class=\"gallery-item__title\">\n        demo2\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic')\" data-title=\"demo3\" data-url=\"https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic\">\n      <div class=\"gallery-item__title\">\n        demo3\n      </div>\n    </div>\n  \n\n    <div class=\"gallery-item\" style=\"background-image: url('https://ws1.sinaimg.cn/large/8700af19ly1fn2i5kjh2pj21120kuncd')\" data-title=\"No title\" data-url=\"https://ws1.sinaimg.cn/large/8700af19ly1fn2i5kjh2pj21120kuncd\">\n      <div class=\"gallery-item__title\">\n        No title\n      </div>\n    </div>\n  "},{"title":"Tags","date":"2017-05-21T12:12:00.000Z","type":"tags","comments":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2017-05-21 20:12:00\ntype: \"tags\"\ncomments: true\n---\n","updated":"2018-05-02T10:31:36.000Z","path":"tags/index.html","layout":"page","_id":"cjrk2frwd000a79polqhqetxm","content":"","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":""}],"Post":[{"title":"Initializer in Swift","date":"2017-11-15T05:09:27.000Z","_content":"\n\n我想 `[[xxx alloc] init]` 应该是自己接触 iOS 开发以来写的最多的语句了吧。一个对象初始化是其得以存在的前提，无论你是使用 new 关键字与否，根本上都会执行到 init 方法。\n\n转入 swift 语言之后，在刚接触的时候经常会因为自建初始化方法不合适，编译器报一堆错误，很是痛苦，但是当理解 Swift 语言为了保障安全的初始化行为所做的工作之后，你就会明白，Swift 初始化方法是有一定的规范要求的。 \n\n这篇文章是想做个记录。\n\n### 初始化方法\n\n\n顺序很重要！\n\n与 `Objective-C` 中不同，Swift 语言会保证某个类的所有属性均被初始化才行。因此初始化方法会非常严格，那第一点需要保障的就是**顺序**。\n\n首先，祭出这张官方镇宅图：\n\n![initializerDelegation02_2x](media/initializerDelegation02_2x.png)\n\n\n\n\n\n\n在某个类的子类中，初始化方法语句的顺序并不是随意的，我们需要保证在当前子类实例的成员初始化完成后才能调用父类的初始化方法。\n\n\n\n","source":"_posts/Initializer-in-Swift.md","raw":"---\ntitle: Initializer in Swift\ndate: 2017-11-15 13:09:27\ncategories: Swift\ntags: [iOS,Swift,Initializer,Designated Initializer,Convenience Initializers]\n---\n\n\n我想 `[[xxx alloc] init]` 应该是自己接触 iOS 开发以来写的最多的语句了吧。一个对象初始化是其得以存在的前提，无论你是使用 new 关键字与否，根本上都会执行到 init 方法。\n\n转入 swift 语言之后，在刚接触的时候经常会因为自建初始化方法不合适，编译器报一堆错误，很是痛苦，但是当理解 Swift 语言为了保障安全的初始化行为所做的工作之后，你就会明白，Swift 初始化方法是有一定的规范要求的。 \n\n这篇文章是想做个记录。\n\n### 初始化方法\n\n\n顺序很重要！\n\n与 `Objective-C` 中不同，Swift 语言会保证某个类的所有属性均被初始化才行。因此初始化方法会非常严格，那第一点需要保障的就是**顺序**。\n\n首先，祭出这张官方镇宅图：\n\n![initializerDelegation02_2x](media/initializerDelegation02_2x.png)\n\n\n\n\n\n\n在某个类的子类中，初始化方法语句的顺序并不是随意的，我们需要保证在当前子类实例的成员初始化完成后才能调用父类的初始化方法。\n\n\n\n","slug":"Initializer-in-Swift","published":1,"updated":"2018-10-07T11:36:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frvs000179pozajyi0qb","content":"<p>我想 <code>[[xxx alloc] init]</code> 应该是自己接触 iOS 开发以来写的最多的语句了吧。一个对象初始化是其得以存在的前提，无论你是使用 new 关键字与否，根本上都会执行到 init 方法。</p>\n<p>转入 swift 语言之后，在刚接触的时候经常会因为自建初始化方法不合适，编译器报一堆错误，很是痛苦，但是当理解 Swift 语言为了保障安全的初始化行为所做的工作之后，你就会明白，Swift 初始化方法是有一定的规范要求的。 </p>\n<p>这篇文章是想做个记录。</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p>顺序很重要！</p>\n<p>与 <code>Objective-C</code> 中不同，Swift 语言会保证某个类的所有属性均被初始化才行。因此初始化方法会非常严格，那第一点需要保障的就是<strong>顺序</strong>。</p>\n<p>首先，祭出这张官方镇宅图：</p>\n<p><img src=\"media/initializerDelegation02_2x.png\" alt=\"initializerDelegation02_2x\"></p>\n<p>在某个类的子类中，初始化方法语句的顺序并不是随意的，我们需要保证在当前子类实例的成员初始化完成后才能调用父类的初始化方法。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>我想 <code>[[xxx alloc] init]</code> 应该是自己接触 iOS 开发以来写的最多的语句了吧。一个对象初始化是其得以存在的前提，无论你是使用 new 关键字与否，根本上都会执行到 init 方法。</p>\n<p>转入 swift 语言之后，在刚接触的时候经常会因为自建初始化方法不合适，编译器报一堆错误，很是痛苦，但是当理解 Swift 语言为了保障安全的初始化行为所做的工作之后，你就会明白，Swift 初始化方法是有一定的规范要求的。 </p>\n<p>这篇文章是想做个记录。</p>\n<h3 id=\"初始化方法\"><a href=\"#初始化方法\" class=\"headerlink\" title=\"初始化方法\"></a>初始化方法</h3><p>顺序很重要！</p>\n<p>与 <code>Objective-C</code> 中不同，Swift 语言会保证某个类的所有属性均被初始化才行。因此初始化方法会非常严格，那第一点需要保障的就是<strong>顺序</strong>。</p>\n<p>首先，祭出这张官方镇宅图：</p>\n<p><img src=\"media/initializerDelegation02_2x.png\" alt=\"initializerDelegation02_2x\"></p>\n<p>在某个类的子类中，初始化方法语句的顺序并不是随意的，我们需要保证在当前子类实例的成员初始化完成后才能调用父类的初始化方法。</p>\n"},{"title":"博客之旅","date":"2015-04-15T08:14:00.000Z","photos":["http://7xilk1.com1.z0.glb.clouddn.com/cat-aojiao.jpg"],"_content":"\n> 如果你不给自己烦恼，别人也永远不可能给你烦恼，因为你自己的内心，你放不下\n\n其实写博客一直在我的ToDoList上，不过放的时间有点久。我就是这样一个人，想干的太多，做到的却相当少。因此写这个博客的目的也是想督促自己前行，记录生活点滴的同时也能够让自己对生活有一些感悟。告诉自己，世界很大，千万不要局限在自己的小圈圈里无法自拔！\n\n\n","source":"_posts/MyFirstPost.md","raw":"title: \"博客之旅\" \ndate: 2015-04-15 16:14:00\nphotos: http://7xilk1.com1.z0.glb.clouddn.com/cat-aojiao.jpg\ntags: 感悟\n---\n\n> 如果你不给自己烦恼，别人也永远不可能给你烦恼，因为你自己的内心，你放不下\n\n其实写博客一直在我的ToDoList上，不过放的时间有点久。我就是这样一个人，想干的太多，做到的却相当少。因此写这个博客的目的也是想督促自己前行，记录生活点滴的同时也能够让自己对生活有一些感悟。告诉自己，世界很大，千万不要局限在自己的小圈圈里无法自拔！\n\n\n","slug":"MyFirstPost","published":1,"updated":"2017-05-21T12:35:10.000Z","comments":1,"layout":"post","link":"","_id":"cjrk2frw0000379podqu03cf3","content":"<blockquote>\n<p>如果你不给自己烦恼，别人也永远不可能给你烦恼，因为你自己的内心，你放不下</p>\n</blockquote>\n<p>其实写博客一直在我的ToDoList上，不过放的时间有点久。我就是这样一个人，想干的太多，做到的却相当少。因此写这个博客的目的也是想督促自己前行，记录生活点滴的同时也能够让自己对生活有一些感悟。告诉自己，世界很大，千万不要局限在自己的小圈圈里无法自拔！</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>如果你不给自己烦恼，别人也永远不可能给你烦恼，因为你自己的内心，你放不下</p>\n</blockquote>\n<p>其实写博客一直在我的ToDoList上，不过放的时间有点久。我就是这样一个人，想干的太多，做到的却相当少。因此写这个博客的目的也是想督促自己前行，记录生活点滴的同时也能够让自己对生活有一些感悟。告诉自己，世界很大，千万不要局限在自己的小圈圈里无法自拔！</p>\n"},{"title":"阅读流程","date":"2018-10-16T09:01:44.000Z","_content":"\n最近统一了一下自己的阅读流程，更新一下，具体用到的工具有\n\n1. DEVONThink Pro\n2. PDFExpert\n3. MarginNote\n\n\n其中 1 是输入和归档源，3 是输出源。 大概就是如下所示：\n\n![Reading Process](https://i.imgur.com/SrcVtP1.png)\n\n\n## 采集素材\n\n在平时浏览网页的时候，看到自己喜欢的文章之后，想进行一些标记或者做笔记，大概有几个选择：\n\n1. 印象笔记直接 clip 当前网页，之后在印象笔记里进行阅读或者标记\n2. 放进稍后读服务中，比如 Pocket 或者 Instapaper 等；\n3. 用 Safari 自带的 Save as PDF 之后再用单独的 PDF 工具查看；\n\n而最近几个月，因为 MarginNote 3 的发布，由于其提供的大纲脑图的自动生成，给我提供了一种便利的拆书功能，因此会把平时看到的文章都归集到一处来看。\n\n借助 DEVONthink 的 Clip To DEVONthink 的插件可以很方便的把文章归集到 DEONThink 中，最主要的是因为它能保存 WebArchive，即使后续文章被删除也没关系。\n\n![Clip To DEVONthink](https://i.imgur.com/Kw7CoBl.png)\n\n\n当按下 Cmmd + S 进行归档之后，DEVONThink 对应 Group 里就会把该原始页面保存起来。\n\n![DEVONthink](https://i.imgur.com/m3jM9kx.png)\n\n由于 WebArchive 无法做 Highlight 标记，这时候就用到了 DEVONthink 提供的 OCR 功能，将 WebArchive 提取为 PDF 文件。\n\n![WebArchive To PDF](https://i.imgur.com/YxEsN2G.png)\n\n\n## 二次加工处理\n\n当你使用 DEVONthink 生成 PDF 之后，就可以直接用其自带的 PDF 阅读工具进行阅读了，它默认提供工具已经完全满足，不过我想利用 MarginNote 来阅读，因此这时候你可以选择直接发送到 MarginNote 来阅读。\n\n其实更多时候，我会选择先使用 PDF Expert 进行 PDF 文件的裁剪，因为大多数时候网页正文内容两侧留白太多，想裁剪掉。\n\n![PDF With Margin](https://i.imgur.com/8I8UcFY.png)\n\n裁剪掉多余的部分之后，pdf 文件就可读性也会极大提高。\n![Final PDF](https://i.imgur.com/1CwG33x.png)\n\n\n## 阅读输出\n\n到了这一步，我们就可以把文档导入到 MarginNote 中，如图所示：\n![MarginNote Import](https://i.imgur.com/DmADrxk.png)\n\n使用 **Add to Study**，将自己的标记和笔记生成笔记本，MarginNote 强大就在于能够很好的自动帮你把重点归集到一起，生成脑图关联，你还可以针对某个部分做笔记。\n\n![MarginNote Add To Study](https://i.imgur.com/9uvu95H.png)\n\n而且很多时候，我们看一篇文章很大可能会展开这个主题，比如看下该文章下给的参考链接，这些往往都是同样主题的内容，我们希望相关的文章能够整体归集到一个笔记本下。MarginNote 可以很方便做到，比如下图，我在阅读 Apple 官方 URL Session Programming Guide 的时候会查看很多相关文章，也都是相关内容，我会把笔记整理在一起。\n\n![MarginNote Note Group](https://i.imgur.com/kIvn6v8.png)\n\n\n\n我单独在 MarginNote 里建了一个 Folder ，叫 Article。专门阅读我从 DEVONthink 中采集到的文章。阅读完毕，还可以将阅读笔记归档，MarginNote 支持分享到 印象笔记，Word 或者 DEVONthink 进行归档。\n\n\n![Export](https://i.imgur.com/yyQ3pOr.png)\n\n\n到了这里，基本上对我来讲一个 输入 ── 处理 ── 阅读 ── 输出 的整个流程就结束了。\n\n上面提到的三个工具，均有 iOS 版本，也就意味着即使拿着手机也能够不破坏整个阅读环节，不过其中 DEVONthink 提供的 iOS 版本是没办法进行 WebArchive 向 PDF 的转换的，处理这一步最后还是得放在 Mac 端处理，不过解决了输入和输出也就意味着随时随地可以捕获想看的内容放到稍后读列表，然后自动同步到 Mac 端进行处理，然后在 MarginNote 对应的 iOS 版本，平时在家的时候还是习惯用 iPad Pro 查看，体验也不错。\n\n![iPad MarginNote](https://i.imgur.com/ZJsdxyS.jpg)\n\n","source":"_posts/MyReadingProcess.md","raw":"---\ntitle: 阅读流程\ndate: 2018-10-16 17:01:44\ncategory: Reading\ntags: DEVONThink, MarginNote, PDFExpert\n---\n\n最近统一了一下自己的阅读流程，更新一下，具体用到的工具有\n\n1. DEVONThink Pro\n2. PDFExpert\n3. MarginNote\n\n\n其中 1 是输入和归档源，3 是输出源。 大概就是如下所示：\n\n![Reading Process](https://i.imgur.com/SrcVtP1.png)\n\n\n## 采集素材\n\n在平时浏览网页的时候，看到自己喜欢的文章之后，想进行一些标记或者做笔记，大概有几个选择：\n\n1. 印象笔记直接 clip 当前网页，之后在印象笔记里进行阅读或者标记\n2. 放进稍后读服务中，比如 Pocket 或者 Instapaper 等；\n3. 用 Safari 自带的 Save as PDF 之后再用单独的 PDF 工具查看；\n\n而最近几个月，因为 MarginNote 3 的发布，由于其提供的大纲脑图的自动生成，给我提供了一种便利的拆书功能，因此会把平时看到的文章都归集到一处来看。\n\n借助 DEVONthink 的 Clip To DEVONthink 的插件可以很方便的把文章归集到 DEONThink 中，最主要的是因为它能保存 WebArchive，即使后续文章被删除也没关系。\n\n![Clip To DEVONthink](https://i.imgur.com/Kw7CoBl.png)\n\n\n当按下 Cmmd + S 进行归档之后，DEVONThink 对应 Group 里就会把该原始页面保存起来。\n\n![DEVONthink](https://i.imgur.com/m3jM9kx.png)\n\n由于 WebArchive 无法做 Highlight 标记，这时候就用到了 DEVONthink 提供的 OCR 功能，将 WebArchive 提取为 PDF 文件。\n\n![WebArchive To PDF](https://i.imgur.com/YxEsN2G.png)\n\n\n## 二次加工处理\n\n当你使用 DEVONthink 生成 PDF 之后，就可以直接用其自带的 PDF 阅读工具进行阅读了，它默认提供工具已经完全满足，不过我想利用 MarginNote 来阅读，因此这时候你可以选择直接发送到 MarginNote 来阅读。\n\n其实更多时候，我会选择先使用 PDF Expert 进行 PDF 文件的裁剪，因为大多数时候网页正文内容两侧留白太多，想裁剪掉。\n\n![PDF With Margin](https://i.imgur.com/8I8UcFY.png)\n\n裁剪掉多余的部分之后，pdf 文件就可读性也会极大提高。\n![Final PDF](https://i.imgur.com/1CwG33x.png)\n\n\n## 阅读输出\n\n到了这一步，我们就可以把文档导入到 MarginNote 中，如图所示：\n![MarginNote Import](https://i.imgur.com/DmADrxk.png)\n\n使用 **Add to Study**，将自己的标记和笔记生成笔记本，MarginNote 强大就在于能够很好的自动帮你把重点归集到一起，生成脑图关联，你还可以针对某个部分做笔记。\n\n![MarginNote Add To Study](https://i.imgur.com/9uvu95H.png)\n\n而且很多时候，我们看一篇文章很大可能会展开这个主题，比如看下该文章下给的参考链接，这些往往都是同样主题的内容，我们希望相关的文章能够整体归集到一个笔记本下。MarginNote 可以很方便做到，比如下图，我在阅读 Apple 官方 URL Session Programming Guide 的时候会查看很多相关文章，也都是相关内容，我会把笔记整理在一起。\n\n![MarginNote Note Group](https://i.imgur.com/kIvn6v8.png)\n\n\n\n我单独在 MarginNote 里建了一个 Folder ，叫 Article。专门阅读我从 DEVONthink 中采集到的文章。阅读完毕，还可以将阅读笔记归档，MarginNote 支持分享到 印象笔记，Word 或者 DEVONthink 进行归档。\n\n\n![Export](https://i.imgur.com/yyQ3pOr.png)\n\n\n到了这里，基本上对我来讲一个 输入 ── 处理 ── 阅读 ── 输出 的整个流程就结束了。\n\n上面提到的三个工具，均有 iOS 版本，也就意味着即使拿着手机也能够不破坏整个阅读环节，不过其中 DEVONthink 提供的 iOS 版本是没办法进行 WebArchive 向 PDF 的转换的，处理这一步最后还是得放在 Mac 端处理，不过解决了输入和输出也就意味着随时随地可以捕获想看的内容放到稍后读列表，然后自动同步到 Mac 端进行处理，然后在 MarginNote 对应的 iOS 版本，平时在家的时候还是习惯用 iPad Pro 查看，体验也不错。\n\n![iPad MarginNote](https://i.imgur.com/ZJsdxyS.jpg)\n\n","slug":"MyReadingProcess","published":1,"updated":"2018-10-21T06:07:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frw8000779pofbwiovgx","content":"<p>最近统一了一下自己的阅读流程，更新一下，具体用到的工具有</p>\n<ol>\n<li>DEVONThink Pro</li>\n<li>PDFExpert</li>\n<li>MarginNote</li>\n</ol>\n<p>其中 1 是输入和归档源，3 是输出源。 大概就是如下所示：</p>\n<p><img src=\"https://i.imgur.com/SrcVtP1.png\" alt=\"Reading Process\"></p>\n<h2 id=\"采集素材\"><a href=\"#采集素材\" class=\"headerlink\" title=\"采集素材\"></a>采集素材</h2><p>在平时浏览网页的时候，看到自己喜欢的文章之后，想进行一些标记或者做笔记，大概有几个选择：</p>\n<ol>\n<li>印象笔记直接 clip 当前网页，之后在印象笔记里进行阅读或者标记</li>\n<li>放进稍后读服务中，比如 Pocket 或者 Instapaper 等；</li>\n<li>用 Safari 自带的 Save as PDF 之后再用单独的 PDF 工具查看；</li>\n</ol>\n<p>而最近几个月，因为 MarginNote 3 的发布，由于其提供的大纲脑图的自动生成，给我提供了一种便利的拆书功能，因此会把平时看到的文章都归集到一处来看。</p>\n<p>借助 DEVONthink 的 Clip To DEVONthink 的插件可以很方便的把文章归集到 DEONThink 中，最主要的是因为它能保存 WebArchive，即使后续文章被删除也没关系。</p>\n<p><img src=\"https://i.imgur.com/Kw7CoBl.png\" alt=\"Clip To DEVONthink\"></p>\n<p>当按下 Cmmd + S 进行归档之后，DEVONThink 对应 Group 里就会把该原始页面保存起来。</p>\n<p><img src=\"https://i.imgur.com/m3jM9kx.png\" alt=\"DEVONthink\"></p>\n<p>由于 WebArchive 无法做 Highlight 标记，这时候就用到了 DEVONthink 提供的 OCR 功能，将 WebArchive 提取为 PDF 文件。</p>\n<p><img src=\"https://i.imgur.com/YxEsN2G.png\" alt=\"WebArchive To PDF\"></p>\n<h2 id=\"二次加工处理\"><a href=\"#二次加工处理\" class=\"headerlink\" title=\"二次加工处理\"></a>二次加工处理</h2><p>当你使用 DEVONthink 生成 PDF 之后，就可以直接用其自带的 PDF 阅读工具进行阅读了，它默认提供工具已经完全满足，不过我想利用 MarginNote 来阅读，因此这时候你可以选择直接发送到 MarginNote 来阅读。</p>\n<p>其实更多时候，我会选择先使用 PDF Expert 进行 PDF 文件的裁剪，因为大多数时候网页正文内容两侧留白太多，想裁剪掉。</p>\n<p><img src=\"https://i.imgur.com/8I8UcFY.png\" alt=\"PDF With Margin\"></p>\n<p>裁剪掉多余的部分之后，pdf 文件就可读性也会极大提高。<br><img src=\"https://i.imgur.com/1CwG33x.png\" alt=\"Final PDF\"></p>\n<h2 id=\"阅读输出\"><a href=\"#阅读输出\" class=\"headerlink\" title=\"阅读输出\"></a>阅读输出</h2><p>到了这一步，我们就可以把文档导入到 MarginNote 中，如图所示：<br><img src=\"https://i.imgur.com/DmADrxk.png\" alt=\"MarginNote Import\"></p>\n<p>使用 <strong>Add to Study</strong>，将自己的标记和笔记生成笔记本，MarginNote 强大就在于能够很好的自动帮你把重点归集到一起，生成脑图关联，你还可以针对某个部分做笔记。</p>\n<p><img src=\"https://i.imgur.com/9uvu95H.png\" alt=\"MarginNote Add To Study\"></p>\n<p>而且很多时候，我们看一篇文章很大可能会展开这个主题，比如看下该文章下给的参考链接，这些往往都是同样主题的内容，我们希望相关的文章能够整体归集到一个笔记本下。MarginNote 可以很方便做到，比如下图，我在阅读 Apple 官方 URL Session Programming Guide 的时候会查看很多相关文章，也都是相关内容，我会把笔记整理在一起。</p>\n<p><img src=\"https://i.imgur.com/kIvn6v8.png\" alt=\"MarginNote Note Group\"></p>\n<p>我单独在 MarginNote 里建了一个 Folder ，叫 Article。专门阅读我从 DEVONthink 中采集到的文章。阅读完毕，还可以将阅读笔记归档，MarginNote 支持分享到 印象笔记，Word 或者 DEVONthink 进行归档。</p>\n<p><img src=\"https://i.imgur.com/yyQ3pOr.png\" alt=\"Export\"></p>\n<p>到了这里，基本上对我来讲一个 输入 ── 处理 ── 阅读 ── 输出 的整个流程就结束了。</p>\n<p>上面提到的三个工具，均有 iOS 版本，也就意味着即使拿着手机也能够不破坏整个阅读环节，不过其中 DEVONthink 提供的 iOS 版本是没办法进行 WebArchive 向 PDF 的转换的，处理这一步最后还是得放在 Mac 端处理，不过解决了输入和输出也就意味着随时随地可以捕获想看的内容放到稍后读列表，然后自动同步到 Mac 端进行处理，然后在 MarginNote 对应的 iOS 版本，平时在家的时候还是习惯用 iPad Pro 查看，体验也不错。</p>\n<p><img src=\"https://i.imgur.com/ZJsdxyS.jpg\" alt=\"iPad MarginNote\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>最近统一了一下自己的阅读流程，更新一下，具体用到的工具有</p>\n<ol>\n<li>DEVONThink Pro</li>\n<li>PDFExpert</li>\n<li>MarginNote</li>\n</ol>\n<p>其中 1 是输入和归档源，3 是输出源。 大概就是如下所示：</p>\n<p><img src=\"https://i.imgur.com/SrcVtP1.png\" alt=\"Reading Process\"></p>\n<h2 id=\"采集素材\"><a href=\"#采集素材\" class=\"headerlink\" title=\"采集素材\"></a>采集素材</h2><p>在平时浏览网页的时候，看到自己喜欢的文章之后，想进行一些标记或者做笔记，大概有几个选择：</p>\n<ol>\n<li>印象笔记直接 clip 当前网页，之后在印象笔记里进行阅读或者标记</li>\n<li>放进稍后读服务中，比如 Pocket 或者 Instapaper 等；</li>\n<li>用 Safari 自带的 Save as PDF 之后再用单独的 PDF 工具查看；</li>\n</ol>\n<p>而最近几个月，因为 MarginNote 3 的发布，由于其提供的大纲脑图的自动生成，给我提供了一种便利的拆书功能，因此会把平时看到的文章都归集到一处来看。</p>\n<p>借助 DEVONthink 的 Clip To DEVONthink 的插件可以很方便的把文章归集到 DEONThink 中，最主要的是因为它能保存 WebArchive，即使后续文章被删除也没关系。</p>\n<p><img src=\"https://i.imgur.com/Kw7CoBl.png\" alt=\"Clip To DEVONthink\"></p>\n<p>当按下 Cmmd + S 进行归档之后，DEVONThink 对应 Group 里就会把该原始页面保存起来。</p>\n<p><img src=\"https://i.imgur.com/m3jM9kx.png\" alt=\"DEVONthink\"></p>\n<p>由于 WebArchive 无法做 Highlight 标记，这时候就用到了 DEVONthink 提供的 OCR 功能，将 WebArchive 提取为 PDF 文件。</p>\n<p><img src=\"https://i.imgur.com/YxEsN2G.png\" alt=\"WebArchive To PDF\"></p>\n<h2 id=\"二次加工处理\"><a href=\"#二次加工处理\" class=\"headerlink\" title=\"二次加工处理\"></a>二次加工处理</h2><p>当你使用 DEVONthink 生成 PDF 之后，就可以直接用其自带的 PDF 阅读工具进行阅读了，它默认提供工具已经完全满足，不过我想利用 MarginNote 来阅读，因此这时候你可以选择直接发送到 MarginNote 来阅读。</p>\n<p>其实更多时候，我会选择先使用 PDF Expert 进行 PDF 文件的裁剪，因为大多数时候网页正文内容两侧留白太多，想裁剪掉。</p>\n<p><img src=\"https://i.imgur.com/8I8UcFY.png\" alt=\"PDF With Margin\"></p>\n<p>裁剪掉多余的部分之后，pdf 文件就可读性也会极大提高。<br><img src=\"https://i.imgur.com/1CwG33x.png\" alt=\"Final PDF\"></p>\n<h2 id=\"阅读输出\"><a href=\"#阅读输出\" class=\"headerlink\" title=\"阅读输出\"></a>阅读输出</h2><p>到了这一步，我们就可以把文档导入到 MarginNote 中，如图所示：<br><img src=\"https://i.imgur.com/DmADrxk.png\" alt=\"MarginNote Import\"></p>\n<p>使用 <strong>Add to Study</strong>，将自己的标记和笔记生成笔记本，MarginNote 强大就在于能够很好的自动帮你把重点归集到一起，生成脑图关联，你还可以针对某个部分做笔记。</p>\n<p><img src=\"https://i.imgur.com/9uvu95H.png\" alt=\"MarginNote Add To Study\"></p>\n<p>而且很多时候，我们看一篇文章很大可能会展开这个主题，比如看下该文章下给的参考链接，这些往往都是同样主题的内容，我们希望相关的文章能够整体归集到一个笔记本下。MarginNote 可以很方便做到，比如下图，我在阅读 Apple 官方 URL Session Programming Guide 的时候会查看很多相关文章，也都是相关内容，我会把笔记整理在一起。</p>\n<p><img src=\"https://i.imgur.com/kIvn6v8.png\" alt=\"MarginNote Note Group\"></p>\n<p>我单独在 MarginNote 里建了一个 Folder ，叫 Article。专门阅读我从 DEVONthink 中采集到的文章。阅读完毕，还可以将阅读笔记归档，MarginNote 支持分享到 印象笔记，Word 或者 DEVONthink 进行归档。</p>\n<p><img src=\"https://i.imgur.com/yyQ3pOr.png\" alt=\"Export\"></p>\n<p>到了这里，基本上对我来讲一个 输入 ── 处理 ── 阅读 ── 输出 的整个流程就结束了。</p>\n<p>上面提到的三个工具，均有 iOS 版本，也就意味着即使拿着手机也能够不破坏整个阅读环节，不过其中 DEVONthink 提供的 iOS 版本是没办法进行 WebArchive 向 PDF 的转换的，处理这一步最后还是得放在 Mac 端处理，不过解决了输入和输出也就意味着随时随地可以捕获想看的内容放到稍后读列表，然后自动同步到 Mac 端进行处理，然后在 MarginNote 对应的 iOS 版本，平时在家的时候还是习惯用 iPad Pro 查看，体验也不错。</p>\n<p><img src=\"https://i.imgur.com/ZJsdxyS.jpg\" alt=\"iPad MarginNote\"></p>\n"},{"title":"解析 PNChart 第三方库","date":"2017-02-12T08:36:54.000Z","_content":"\n### 学习 PNChart \n\n本篇文章写作时，**PChart** 版本号为 `0.8.9`.\n\n<!-- more -->\n\n#### 代码结构\n\n##### 可视化展示类型\n\n首先，目前 PNChart 提供多达六种图的可视化展示。分别是：\n\n1. PNLineChart\n![PNLineChart-w621](http://7xilk1.com1.z0.glb.clouddn.com/PNLineChart.png)\n\n2. PNScatterChart\n![PNScatterChart-w621](http://7xilk1.com1.z0.glb.clouddn.com/PNScatterChart.png)\n\n3. PNRadarChart\n![PNRadarChart](http://7xilk1.com1.z0.glb.clouddn.com/PNRadarChart.png)\n\n4. PNPieChart\n![PNPieChart](http://7xilk1.com1.z0.glb.clouddn.com/PNPieChart.png)\n\n5. PNBarChart\n![PNBarChart](http://7xilk1.com1.z0.glb.clouddn.com/PNBarChart.png)\n\n\n6. PNCircleChart\n![PNCircleChart](http://7xilk1.com1.z0.glb.clouddn.com/PNCircleChart.png)\n\n##### 类图\n\n首先来看最主要的集中图片的类，如下所示：\n![](http://7xilk1.com1.z0.glb.clouddn.com/14867986596626.jpg)\n\n其中除了 `PNCircleChart` 以外，其余均继承了 `PNGenericChart`类。 \n\n其中图片和外界的交互回调是通过 PNChartDelegate 来进行的，要包含这么多种类型图片的回调，接口自然无法写的更加优雅，看这个协议定义的方法就能看出来。\n![](http://7xilk1.com1.z0.glb.clouddn.com/14867993267852.jpg)\n\n\n同时，针对每一种图形类别，也有相对应的 Model 类型，如下所示：\n![](http://7xilk1.com1.z0.glb.clouddn.com/14868010321036.jpg)\n\n目前设计来看并不是很统一，其中和外界进行对接的数据类型定义为 `PNxxChartData`，而该具体的每一个节点数据类型就用`PNxxChartDataItem` 类型来标识，因为具体的图形化业务不同，并不是所有的`PNChart`都会使用者两者，比如 `PNBarChart` 目前就完全不使用类似的设计，而是直接指定Y轴的值，还有`PNCircleChart`也如此，只需指定 Total 和 current 即可。\n\n还有剩余几个辅助类：\n![](http://7xilk1.com1.z0.glb.clouddn.com/14868112330724.jpg)\n\n1. PNColor 类只有一个方法：` imageFromColor: ` ，生成某种颜色的图片，而在其所定义的文件 PNColor.h 中定义了很多常用颜色的宏；\n2. PNLineChartColorRange 类型是定义在 PNLineChartData.h 文件中一个类型，主要是指定折线图上，命中指定的数值区域时显示特定的颜色；如下所示代码，当 Y 轴元素是 10 ~ 30 之间，显示红色折线，当 Y 轴元素是 100 ~ 200 之间，显示紫色折线。\n\n``` Objective-C\n\n PNLineChartData *data01 = [PNLineChartData new];\n data01.rangeColors = @[\n    [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(10, 30) color:[UIColor redColor]],\n    [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(100, 200) color:[UIColor purpleColor]]\n        ];\n```\n\n3. PNChartLabel类定义 UILabel，库中所用到的 Label 均为该类型，主要是做了一些通用的配置罢了。\n\n\n\n\n","source":"_posts/Read-SourceCode-of-PNChart.md","raw":"title: \"解析 PNChart 第三方库\"\ndate: 2017-02-12 16:36:54\ncategories: 拆轮子\ntags: [iOS,Github,Objective-C]\n---\n\n### 学习 PNChart \n\n本篇文章写作时，**PChart** 版本号为 `0.8.9`.\n\n<!-- more -->\n\n#### 代码结构\n\n##### 可视化展示类型\n\n首先，目前 PNChart 提供多达六种图的可视化展示。分别是：\n\n1. PNLineChart\n![PNLineChart-w621](http://7xilk1.com1.z0.glb.clouddn.com/PNLineChart.png)\n\n2. PNScatterChart\n![PNScatterChart-w621](http://7xilk1.com1.z0.glb.clouddn.com/PNScatterChart.png)\n\n3. PNRadarChart\n![PNRadarChart](http://7xilk1.com1.z0.glb.clouddn.com/PNRadarChart.png)\n\n4. PNPieChart\n![PNPieChart](http://7xilk1.com1.z0.glb.clouddn.com/PNPieChart.png)\n\n5. PNBarChart\n![PNBarChart](http://7xilk1.com1.z0.glb.clouddn.com/PNBarChart.png)\n\n\n6. PNCircleChart\n![PNCircleChart](http://7xilk1.com1.z0.glb.clouddn.com/PNCircleChart.png)\n\n##### 类图\n\n首先来看最主要的集中图片的类，如下所示：\n![](http://7xilk1.com1.z0.glb.clouddn.com/14867986596626.jpg)\n\n其中除了 `PNCircleChart` 以外，其余均继承了 `PNGenericChart`类。 \n\n其中图片和外界的交互回调是通过 PNChartDelegate 来进行的，要包含这么多种类型图片的回调，接口自然无法写的更加优雅，看这个协议定义的方法就能看出来。\n![](http://7xilk1.com1.z0.glb.clouddn.com/14867993267852.jpg)\n\n\n同时，针对每一种图形类别，也有相对应的 Model 类型，如下所示：\n![](http://7xilk1.com1.z0.glb.clouddn.com/14868010321036.jpg)\n\n目前设计来看并不是很统一，其中和外界进行对接的数据类型定义为 `PNxxChartData`，而该具体的每一个节点数据类型就用`PNxxChartDataItem` 类型来标识，因为具体的图形化业务不同，并不是所有的`PNChart`都会使用者两者，比如 `PNBarChart` 目前就完全不使用类似的设计，而是直接指定Y轴的值，还有`PNCircleChart`也如此，只需指定 Total 和 current 即可。\n\n还有剩余几个辅助类：\n![](http://7xilk1.com1.z0.glb.clouddn.com/14868112330724.jpg)\n\n1. PNColor 类只有一个方法：` imageFromColor: ` ，生成某种颜色的图片，而在其所定义的文件 PNColor.h 中定义了很多常用颜色的宏；\n2. PNLineChartColorRange 类型是定义在 PNLineChartData.h 文件中一个类型，主要是指定折线图上，命中指定的数值区域时显示特定的颜色；如下所示代码，当 Y 轴元素是 10 ~ 30 之间，显示红色折线，当 Y 轴元素是 100 ~ 200 之间，显示紫色折线。\n\n``` Objective-C\n\n PNLineChartData *data01 = [PNLineChartData new];\n data01.rangeColors = @[\n    [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(10, 30) color:[UIColor redColor]],\n    [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(100, 200) color:[UIColor purpleColor]]\n        ];\n```\n\n3. PNChartLabel类定义 UILabel，库中所用到的 Label 均为该类型，主要是做了一些通用的配置罢了。\n\n\n\n\n","slug":"Read-SourceCode-of-PNChart","published":1,"updated":"2017-10-17T12:20:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwb000979pohnbykp94","content":"<h3 id=\"学习-PNChart\"><a href=\"#学习-PNChart\" class=\"headerlink\" title=\"学习 PNChart\"></a>学习 PNChart</h3><p>本篇文章写作时，<strong>PChart</strong> 版本号为 <code>0.8.9</code>.</p>\n<a id=\"more\"></a>\n<h4 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h4><h5 id=\"可视化展示类型\"><a href=\"#可视化展示类型\" class=\"headerlink\" title=\"可视化展示类型\"></a>可视化展示类型</h5><p>首先，目前 PNChart 提供多达六种图的可视化展示。分别是：</p>\n<ol>\n<li><p>PNLineChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNLineChart.png\" alt=\"PNLineChart-w621\"></p>\n</li>\n<li><p>PNScatterChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNScatterChart.png\" alt=\"PNScatterChart-w621\"></p>\n</li>\n<li><p>PNRadarChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNRadarChart.png\" alt=\"PNRadarChart\"></p>\n</li>\n<li><p>PNPieChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNPieChart.png\" alt=\"PNPieChart\"></p>\n</li>\n<li><p>PNBarChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNBarChart.png\" alt=\"PNBarChart\"></p>\n</li>\n</ol>\n<ol start=\"6\">\n<li>PNCircleChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNCircleChart.png\" alt=\"PNCircleChart\"></li>\n</ol>\n<h5 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h5><p>首先来看最主要的集中图片的类，如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14867986596626.jpg\" alt=\"\"></p>\n<p>其中除了 <code>PNCircleChart</code> 以外，其余均继承了 <code>PNGenericChart</code>类。 </p>\n<p>其中图片和外界的交互回调是通过 PNChartDelegate 来进行的，要包含这么多种类型图片的回调，接口自然无法写的更加优雅，看这个协议定义的方法就能看出来。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14867993267852.jpg\" alt=\"\"></p>\n<p>同时，针对每一种图形类别，也有相对应的 Model 类型，如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14868010321036.jpg\" alt=\"\"></p>\n<p>目前设计来看并不是很统一，其中和外界进行对接的数据类型定义为 <code>PNxxChartData</code>，而该具体的每一个节点数据类型就用<code>PNxxChartDataItem</code> 类型来标识，因为具体的图形化业务不同，并不是所有的<code>PNChart</code>都会使用者两者，比如 <code>PNBarChart</code> 目前就完全不使用类似的设计，而是直接指定Y轴的值，还有<code>PNCircleChart</code>也如此，只需指定 Total 和 current 即可。</p>\n<p>还有剩余几个辅助类：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14868112330724.jpg\" alt=\"\"></p>\n<ol>\n<li>PNColor 类只有一个方法：<code>imageFromColor:</code> ，生成某种颜色的图片，而在其所定义的文件 PNColor.h 中定义了很多常用颜色的宏；</li>\n<li>PNLineChartColorRange 类型是定义在 PNLineChartData.h 文件中一个类型，主要是指定折线图上，命中指定的数值区域时显示特定的颜色；如下所示代码，当 Y 轴元素是 10 ~ 30 之间，显示红色折线，当 Y 轴元素是 100 ~ 200 之间，显示紫色折线。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">PNLineChartData *data01 = [PNLineChartData new];</span><br><span class=\"line\">data01.rangeColors = @[</span><br><span class=\"line\">   [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(10, 30) color:[UIColor redColor]],</span><br><span class=\"line\">   [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(100, 200) color:[UIColor purpleColor]]</span><br><span class=\"line\">       ];</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>PNChartLabel类定义 UILabel，库中所用到的 Label 均为该类型，主要是做了一些通用的配置罢了。</li>\n</ol>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"学习-PNChart\"><a href=\"#学习-PNChart\" class=\"headerlink\" title=\"学习 PNChart\"></a>学习 PNChart</h3><p>本篇文章写作时，<strong>PChart</strong> 版本号为 <code>0.8.9</code>.</p>","more":"<h4 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h4><h5 id=\"可视化展示类型\"><a href=\"#可视化展示类型\" class=\"headerlink\" title=\"可视化展示类型\"></a>可视化展示类型</h5><p>首先，目前 PNChart 提供多达六种图的可视化展示。分别是：</p>\n<ol>\n<li><p>PNLineChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNLineChart.png\" alt=\"PNLineChart-w621\"></p>\n</li>\n<li><p>PNScatterChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNScatterChart.png\" alt=\"PNScatterChart-w621\"></p>\n</li>\n<li><p>PNRadarChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNRadarChart.png\" alt=\"PNRadarChart\"></p>\n</li>\n<li><p>PNPieChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNPieChart.png\" alt=\"PNPieChart\"></p>\n</li>\n<li><p>PNBarChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNBarChart.png\" alt=\"PNBarChart\"></p>\n</li>\n</ol>\n<ol start=\"6\">\n<li>PNCircleChart<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/PNCircleChart.png\" alt=\"PNCircleChart\"></li>\n</ol>\n<h5 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h5><p>首先来看最主要的集中图片的类，如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14867986596626.jpg\" alt=\"\"></p>\n<p>其中除了 <code>PNCircleChart</code> 以外，其余均继承了 <code>PNGenericChart</code>类。 </p>\n<p>其中图片和外界的交互回调是通过 PNChartDelegate 来进行的，要包含这么多种类型图片的回调，接口自然无法写的更加优雅，看这个协议定义的方法就能看出来。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14867993267852.jpg\" alt=\"\"></p>\n<p>同时，针对每一种图形类别，也有相对应的 Model 类型，如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14868010321036.jpg\" alt=\"\"></p>\n<p>目前设计来看并不是很统一，其中和外界进行对接的数据类型定义为 <code>PNxxChartData</code>，而该具体的每一个节点数据类型就用<code>PNxxChartDataItem</code> 类型来标识，因为具体的图形化业务不同，并不是所有的<code>PNChart</code>都会使用者两者，比如 <code>PNBarChart</code> 目前就完全不使用类似的设计，而是直接指定Y轴的值，还有<code>PNCircleChart</code>也如此，只需指定 Total 和 current 即可。</p>\n<p>还有剩余几个辅助类：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14868112330724.jpg\" alt=\"\"></p>\n<ol>\n<li>PNColor 类只有一个方法：<code>imageFromColor:</code> ，生成某种颜色的图片，而在其所定义的文件 PNColor.h 中定义了很多常用颜色的宏；</li>\n<li>PNLineChartColorRange 类型是定义在 PNLineChartData.h 文件中一个类型，主要是指定折线图上，命中指定的数值区域时显示特定的颜色；如下所示代码，当 Y 轴元素是 10 ~ 30 之间，显示红色折线，当 Y 轴元素是 100 ~ 200 之间，显示紫色折线。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">PNLineChartData *data01 = [PNLineChartData new];</span><br><span class=\"line\">data01.rangeColors = @[</span><br><span class=\"line\">   [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(10, 30) color:[UIColor redColor]],</span><br><span class=\"line\">   [[PNLineChartColorRange alloc] initWithRange:NSMakeRange(100, 200) color:[UIColor purpleColor]]</span><br><span class=\"line\">       ];</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>PNChartLabel类定义 UILabel，库中所用到的 Label 均为该类型，主要是做了一些通用的配置罢了。</li>\n</ol>"},{"title":"阅读《垃圾回收的算法与实现》","date":"2017-02-12T08:38:24.000Z","photos":["http://7xilk1.com1.z0.glb.clouddn.com/s28830934.jpg"],"_content":"\n前一阵子 《垃圾回收的算法与实现》 这本书比较火，正好本人也对垃圾回收这个概念挺感兴趣的，就耐着性子一点一点啃，到今天只能说磕磕绊绊的看了大部分，实现篇只看了 Python 的部分，剩余的关于 Dalvik VM、Rubinius 以及 V8 的垃圾回收并未多看，主要还是自己对 Javascript，Ruby 等语言未有深入学习，我深以为只有结合这种语言本身的语言特性来看对应的垃圾回收实现才有意义。这篇文章主要是总结下学习到的一些主要的知识点。\n\n<!-- more -->\n\n### 知识点总结\n\n对于实现篇思维导图里也未有展开，之后等把 Ruby、Javascript 等语言熟悉之后再做深入的阅读吧。。。\n\n![GC算法](http://7xilk1.com1.z0.glb.clouddn.com/GC算法.png)\n\n\n","source":"_posts/Reading-Garbage-Collection.md","raw":"---\ntitle: 阅读《垃圾回收的算法与实现》\ndate: 2017-02-12 16:38:24\ncategories: 读书\nphotos: http://7xilk1.com1.z0.glb.clouddn.com/s28830934.jpg\ntags: [Garbage Collection,Python,Book]\n---\n\n前一阵子 《垃圾回收的算法与实现》 这本书比较火，正好本人也对垃圾回收这个概念挺感兴趣的，就耐着性子一点一点啃，到今天只能说磕磕绊绊的看了大部分，实现篇只看了 Python 的部分，剩余的关于 Dalvik VM、Rubinius 以及 V8 的垃圾回收并未多看，主要还是自己对 Javascript，Ruby 等语言未有深入学习，我深以为只有结合这种语言本身的语言特性来看对应的垃圾回收实现才有意义。这篇文章主要是总结下学习到的一些主要的知识点。\n\n<!-- more -->\n\n### 知识点总结\n\n对于实现篇思维导图里也未有展开，之后等把 Ruby、Javascript 等语言熟悉之后再做深入的阅读吧。。。\n\n![GC算法](http://7xilk1.com1.z0.glb.clouddn.com/GC算法.png)\n\n\n","slug":"Reading-Garbage-Collection","published":1,"updated":"2017-11-12T12:38:12.000Z","comments":1,"layout":"post","link":"","_id":"cjrk2frwg000b79po1flp3481","content":"<p>前一阵子 《垃圾回收的算法与实现》 这本书比较火，正好本人也对垃圾回收这个概念挺感兴趣的，就耐着性子一点一点啃，到今天只能说磕磕绊绊的看了大部分，实现篇只看了 Python 的部分，剩余的关于 Dalvik VM、Rubinius 以及 V8 的垃圾回收并未多看，主要还是自己对 Javascript，Ruby 等语言未有深入学习，我深以为只有结合这种语言本身的语言特性来看对应的垃圾回收实现才有意义。这篇文章主要是总结下学习到的一些主要的知识点。</p>\n<a id=\"more\"></a>\n<h3 id=\"知识点总结\"><a href=\"#知识点总结\" class=\"headerlink\" title=\"知识点总结\"></a>知识点总结</h3><p>对于实现篇思维导图里也未有展开，之后等把 Ruby、Javascript 等语言熟悉之后再做深入的阅读吧。。。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/GC算法.png\" alt=\"GC算法\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>前一阵子 《垃圾回收的算法与实现》 这本书比较火，正好本人也对垃圾回收这个概念挺感兴趣的，就耐着性子一点一点啃，到今天只能说磕磕绊绊的看了大部分，实现篇只看了 Python 的部分，剩余的关于 Dalvik VM、Rubinius 以及 V8 的垃圾回收并未多看，主要还是自己对 Javascript，Ruby 等语言未有深入学习，我深以为只有结合这种语言本身的语言特性来看对应的垃圾回收实现才有意义。这篇文章主要是总结下学习到的一些主要的知识点。</p>","more":"<h3 id=\"知识点总结\"><a href=\"#知识点总结\" class=\"headerlink\" title=\"知识点总结\"></a>知识点总结</h3><p>对于实现篇思维导图里也未有展开，之后等把 Ruby、Javascript 等语言熟悉之后再做深入的阅读吧。。。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/GC算法.png\" alt=\"GC算法\"></p>"},{"title":"如何做 Send to 2Do 的书签","date":"2018-11-26T06:59:50.000Z","_content":"\n\n使用鼠标拖拽下面这个链接到你的 Favorites Bar 上，\n\n[Send to 2Do](javascript:window.location='')\n\n然后编辑地址，将其替换为如下：\n\n```\njavascript:window.location='twodo://x-callback-url/add?task='+encodeURIComponent(document.title)+'&note='+encodeURIComponent(window.location)+'&action=url:'+encodeURIComponent(window.location)\n```\n\n![Change Value](https://i.imgur.com/7M0xN1g.jpg)\n\n\n所以，其实还是在触发调用 URL Scheme，其中 \n\n1. `document.title` 为标题\n2. `window.location` 为当前页面链接\n\n我们知道 Things 的 URL Scheme 为 \n\n`things:///add?title=iamtitle&notes=iamnotes&when=tomorrow`\n\n比如你可以把链接内容改为支持 Send To Things：\n\n```\njavascript:window.location='things:///add?title='+encodeURIComponent(document.title)+'&notes='+encodeURIComponent(window.location)+'&when=today'\n```\n\n以及 Send To OmniFocus ，如下：\n\n```\njavascript:window.location='omnifocus:///add?note='+encodeURIComponent(window.location)+'&name='+encodeURIComponent(document.title)\n```\n\n或者直接去 [OmniFocus 页面](http://people.omnigroup.com/kc/OmniFocus/SendToOmniFocusBookmarklet.html) 用相同方式把起已经设置好正确 Value 的链接拖到上方工具条上即可。\n\n\n如果你找不到 Favorites Bar，点击 Safari 菜单栏上的 View 菜单就能看到（中文系统叫视图）\n\n![Favorites Bar](https://i.imgur.com/ZBqkn4Z.jpg)\n\n","source":"_posts/Send-to-2Do.md","raw":"---\ntitle: 如何做 Send to 2Do 的书签\ndate: 2018-11-26 14:59:50\ncategory: Productivity\ntags: Bookmark,2Do,Productivity,Things\n---\n\n\n使用鼠标拖拽下面这个链接到你的 Favorites Bar 上，\n\n[Send to 2Do](javascript:window.location='')\n\n然后编辑地址，将其替换为如下：\n\n```\njavascript:window.location='twodo://x-callback-url/add?task='+encodeURIComponent(document.title)+'&note='+encodeURIComponent(window.location)+'&action=url:'+encodeURIComponent(window.location)\n```\n\n![Change Value](https://i.imgur.com/7M0xN1g.jpg)\n\n\n所以，其实还是在触发调用 URL Scheme，其中 \n\n1. `document.title` 为标题\n2. `window.location` 为当前页面链接\n\n我们知道 Things 的 URL Scheme 为 \n\n`things:///add?title=iamtitle&notes=iamnotes&when=tomorrow`\n\n比如你可以把链接内容改为支持 Send To Things：\n\n```\njavascript:window.location='things:///add?title='+encodeURIComponent(document.title)+'&notes='+encodeURIComponent(window.location)+'&when=today'\n```\n\n以及 Send To OmniFocus ，如下：\n\n```\njavascript:window.location='omnifocus:///add?note='+encodeURIComponent(window.location)+'&name='+encodeURIComponent(document.title)\n```\n\n或者直接去 [OmniFocus 页面](http://people.omnigroup.com/kc/OmniFocus/SendToOmniFocusBookmarklet.html) 用相同方式把起已经设置好正确 Value 的链接拖到上方工具条上即可。\n\n\n如果你找不到 Favorites Bar，点击 Safari 菜单栏上的 View 菜单就能看到（中文系统叫视图）\n\n![Favorites Bar](https://i.imgur.com/ZBqkn4Z.jpg)\n\n","slug":"Send-to-2Do","published":1,"updated":"2018-12-02T11:52:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwk000e79poc6x2wkuu","content":"<p>使用鼠标拖拽下面这个链接到你的 Favorites Bar 上，</p>\n<p><a href=\"javascript:window.location=&#39;&#39;\" target=\"_blank\" rel=\"noopener\">Send to 2Do</a></p>\n<p>然后编辑地址，将其替换为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">javascript:window.location=&apos;twodo://x-callback-url/add?task=&apos;+encodeURIComponent(document.title)+&apos;&amp;note=&apos;+encodeURIComponent(window.location)+&apos;&amp;action=url:&apos;+encodeURIComponent(window.location)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.imgur.com/7M0xN1g.jpg\" alt=\"Change Value\"></p>\n<p>所以，其实还是在触发调用 URL Scheme，其中 </p>\n<ol>\n<li><code>document.title</code> 为标题</li>\n<li><code>window.location</code> 为当前页面链接</li>\n</ol>\n<p>我们知道 Things 的 URL Scheme 为 </p>\n<p><code>things:///add?title=iamtitle&amp;notes=iamnotes&amp;when=tomorrow</code></p>\n<p>比如你可以把链接内容改为支持 Send To Things：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">javascript:window.location=&apos;things:///add?title=&apos;+encodeURIComponent(document.title)+&apos;&amp;notes=&apos;+encodeURIComponent(window.location)+&apos;&amp;when=today&apos;</span><br></pre></td></tr></table></figure>\n<p>以及 Send To OmniFocus ，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">javascript:window.location=&apos;omnifocus:///add?note=&apos;+encodeURIComponent(window.location)+&apos;&amp;name=&apos;+encodeURIComponent(document.title)</span><br></pre></td></tr></table></figure>\n<p>或者直接去 <a href=\"http://people.omnigroup.com/kc/OmniFocus/SendToOmniFocusBookmarklet.html\" target=\"_blank\" rel=\"noopener\">OmniFocus 页面</a> 用相同方式把起已经设置好正确 Value 的链接拖到上方工具条上即可。</p>\n<p>如果你找不到 Favorites Bar，点击 Safari 菜单栏上的 View 菜单就能看到（中文系统叫视图）</p>\n<p><img src=\"https://i.imgur.com/ZBqkn4Z.jpg\" alt=\"Favorites Bar\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>使用鼠标拖拽下面这个链接到你的 Favorites Bar 上，</p>\n<p><a href=\"javascript:window.location=&#39;&#39;\" target=\"_blank\" rel=\"noopener\">Send to 2Do</a></p>\n<p>然后编辑地址，将其替换为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">javascript:window.location=&apos;twodo://x-callback-url/add?task=&apos;+encodeURIComponent(document.title)+&apos;&amp;note=&apos;+encodeURIComponent(window.location)+&apos;&amp;action=url:&apos;+encodeURIComponent(window.location)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.imgur.com/7M0xN1g.jpg\" alt=\"Change Value\"></p>\n<p>所以，其实还是在触发调用 URL Scheme，其中 </p>\n<ol>\n<li><code>document.title</code> 为标题</li>\n<li><code>window.location</code> 为当前页面链接</li>\n</ol>\n<p>我们知道 Things 的 URL Scheme 为 </p>\n<p><code>things:///add?title=iamtitle&amp;notes=iamnotes&amp;when=tomorrow</code></p>\n<p>比如你可以把链接内容改为支持 Send To Things：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">javascript:window.location=&apos;things:///add?title=&apos;+encodeURIComponent(document.title)+&apos;&amp;notes=&apos;+encodeURIComponent(window.location)+&apos;&amp;when=today&apos;</span><br></pre></td></tr></table></figure>\n<p>以及 Send To OmniFocus ，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">javascript:window.location=&apos;omnifocus:///add?note=&apos;+encodeURIComponent(window.location)+&apos;&amp;name=&apos;+encodeURIComponent(document.title)</span><br></pre></td></tr></table></figure>\n<p>或者直接去 <a href=\"http://people.omnigroup.com/kc/OmniFocus/SendToOmniFocusBookmarklet.html\" target=\"_blank\" rel=\"noopener\">OmniFocus 页面</a> 用相同方式把起已经设置好正确 Value 的链接拖到上方工具条上即可。</p>\n<p>如果你找不到 Favorites Bar，点击 Safari 菜单栏上的 View 菜单就能看到（中文系统叫视图）</p>\n<p><img src=\"https://i.imgur.com/ZBqkn4Z.jpg\" alt=\"Favorites Bar\"></p>\n"},{"title":"三个简单步骤让你测试使用系统单例的代码","date":"2018-07-17T09:09:57.000Z","_content":"\n\n> 原文：[Testing Swift code that uses system singletons in 3 easy steps](https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps)\n> 原作者 & Copyright [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n大部分在 Apple 平台开发的 App 都会依赖基于单例的 API。从 UIScreen 到 UIApplication，再到 NSBundle，而 Foundation，UIKit 以及 AppKit 里到处充斥着静态的 API。\n\n尽管单例非常方便，并且随时随地都可以很轻易的获取到特定的 API，但是当它们一旦要面临代码解耦和测试的时候就会出现挑战。单例同时也是平时遇到 Bug 里最常见的一种，在单例中状态会以共享的方式终结，那些针对状态做的变更并不能很好的广播到整个系统层面。\n\n然而，尽管我们能够重构自己的代码，让它们只在真正需求的地方使用单例，我们针对系统 API 也做不了太多。但是，好消息是，这里有一些技巧让你使用系统单例的代码依然变得容易管理和测试。\n\n让我们看一些使用了 URLSession.shared 单例的代码：\n\n\n``` Swift\n\nclass DataLoader {\n    enum Result {\n        case data(Data)\n        case error(Error)\n    }\n\n    func load(from url: URL, completionHandler: @escaping (Result) -> Void) {\n        let task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n            if let error = error {\n                return completionHandler(.error(error))\n            }\n\n            completionHandler(.data(data ?? Data()))\n        }\n\n        task.resume()\n    }\n}\n\n```\n\n上面这个 **DataLoader** 现在就变得很难测试，因为它内部会自主调用共享的 URL Session 来执行一个网络调用。这就需要我们为测试代码中增加一些等待和超时代码，然后很快这部分代码就会变得糟糕和不稳定。\n\n### 抽象成一个协议\n\n我们第一个任务就是把我们需要的 URLSession 的部分移到一个协议里，这样我们在测试中也能够很容易的进行 mock。在作者的[一次 talk](http://www.ustream.tv/recorded/101118612)中作者建议尽可能的避免 mock，尽管它是一种很好的策略。但是当你和系统的单例打交道的时候，mock 就是一个增加可预测性的重要工具。\n\n让我们创建一个 **NetworkEngine** 协议，然后让 URLSession 符合它:\n\n``` Swift\n\nprotocol NetworkEngine {\n    typealias Handler = (Data?, URLResponse?, Error?) -> Void\n\n    func performRequest(for url: URL, completionHandler: @escaping Handler)\n}\n\nextension URLSession: NetworkEngine {\n    typealias Handler = NetworkEngine.Handler\n\n    func performRequest(for url: URL, completionHandler: @escaping Handler) {\n        let task = dataTask(with: url, completionHandler: completionHandler)\n        task.resume()\n    }\n}\n\n```\n\n如上所见，我们使得 **URLSessionDataTask** 成了 **URLSession** 的一个实现细节。这样，我们就避免了在测试代码中不得不创建不同的 mock ，而只需要关注 NetworkEngine 就行。\n\n### 协议中把单例作为默认值\n\n现在，让我们更新我们的 **DataLoader** 来使用新的 NetworkEngine 协议，把它作为依赖项注入。我们把 URLSession.shared 作为默认参数传递，以此做到了向后兼容并且和之前一样方便。\n\n``` Swift\n\nclass DataLoader {\n    enum Result {\n        case data(Data)\n        case error(Error)\n    }\n\n    private let engine: NetworkEngine\n\n    init(engine: NetworkEngine = URLSession.shared) {\n        self.engine = engine\n    }\n\n    func load(from url: URL, completionHandler: @escaping (Result) -> Void) {\n        engine.performRequest(for: url) { (data, response, error) in\n            if let error = error {\n                return completionHandler(.error(error))\n            }\n\n            completionHandler(.data(data ?? Data()))\n        }\n    }\n}\n\n```\n\n通过使用默认参数，我们依然可以像之前一样很容易的生成 **DataLoader**，而不需要提供一个 **NetworkEngine**。\n\n### 在你的测试中 Mock 协议\n\n最后，让我们写个测试，在这里我们通过 mock **NetworkEngine** 使得我们的测试快速，可预测并且容易维护。\n\n``` Swift\n\nfunc testLoadingData() {\n    class NetworkEngineMock: NetworkEngine {\n        typealias Handler = NetworkEngine.Handler \n\n        var requestedURL: URL?\n\n        func performRequest(for url: URL, completionHandler: @escaping Handler) {\n            requestedURL = url\n\n            let data = “Hello world”.data(using: .utf8)\n            completionHandler(data, nil, nil)\n        }\n    }\n\n    let engine = NetworkEngineMock()\n    let loader = DataLoader(engine: engine)\n\n    var result: DataLoader.Result?\n    let url = URL(string: “my/API”)!\n    loader.load(from: url) { result = $0 }\n\n    XCTAssertEqual(engine.requestedURL, url)\n    XCTAssertEqual(result, .data(“Hello world”.data(using: .utf8)!))\n}\n\n```\n\n如上所见，作者试图让 mock 尽可能的简单。不需要创建包含大量逻辑的复杂 mock，你只需要让自己的代码返回一些 hardcode 的值通常是一个好主意，这样，你能够在自己的测试中进行断言。然而，风险就是你可能最后测试的是自己的 mock 而不是生产环境的代码。\n\n\n## 最后\n\n我们现在通过以下三个步骤让这些依然方便的使用了系统的单例可被测试：\n\n1. 抽象协议\n2. 协议中把单例作为默认值\n3. 在你的测试中 Mock 该协议\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Testing-Swift-code-that-uses-system-singletons-in-3-easy-steps.md","raw":"---\ntitle: 三个简单步骤让你测试使用系统单例的代码\ndate: 2018-07-17 17:09:57\ncategories: 翻译\ntags: [iOS,XCode,Swift,Singleton]\n---\n\n\n> 原文：[Testing Swift code that uses system singletons in 3 easy steps](https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps)\n> 原作者 & Copyright [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n大部分在 Apple 平台开发的 App 都会依赖基于单例的 API。从 UIScreen 到 UIApplication，再到 NSBundle，而 Foundation，UIKit 以及 AppKit 里到处充斥着静态的 API。\n\n尽管单例非常方便，并且随时随地都可以很轻易的获取到特定的 API，但是当它们一旦要面临代码解耦和测试的时候就会出现挑战。单例同时也是平时遇到 Bug 里最常见的一种，在单例中状态会以共享的方式终结，那些针对状态做的变更并不能很好的广播到整个系统层面。\n\n然而，尽管我们能够重构自己的代码，让它们只在真正需求的地方使用单例，我们针对系统 API 也做不了太多。但是，好消息是，这里有一些技巧让你使用系统单例的代码依然变得容易管理和测试。\n\n让我们看一些使用了 URLSession.shared 单例的代码：\n\n\n``` Swift\n\nclass DataLoader {\n    enum Result {\n        case data(Data)\n        case error(Error)\n    }\n\n    func load(from url: URL, completionHandler: @escaping (Result) -> Void) {\n        let task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n            if let error = error {\n                return completionHandler(.error(error))\n            }\n\n            completionHandler(.data(data ?? Data()))\n        }\n\n        task.resume()\n    }\n}\n\n```\n\n上面这个 **DataLoader** 现在就变得很难测试，因为它内部会自主调用共享的 URL Session 来执行一个网络调用。这就需要我们为测试代码中增加一些等待和超时代码，然后很快这部分代码就会变得糟糕和不稳定。\n\n### 抽象成一个协议\n\n我们第一个任务就是把我们需要的 URLSession 的部分移到一个协议里，这样我们在测试中也能够很容易的进行 mock。在作者的[一次 talk](http://www.ustream.tv/recorded/101118612)中作者建议尽可能的避免 mock，尽管它是一种很好的策略。但是当你和系统的单例打交道的时候，mock 就是一个增加可预测性的重要工具。\n\n让我们创建一个 **NetworkEngine** 协议，然后让 URLSession 符合它:\n\n``` Swift\n\nprotocol NetworkEngine {\n    typealias Handler = (Data?, URLResponse?, Error?) -> Void\n\n    func performRequest(for url: URL, completionHandler: @escaping Handler)\n}\n\nextension URLSession: NetworkEngine {\n    typealias Handler = NetworkEngine.Handler\n\n    func performRequest(for url: URL, completionHandler: @escaping Handler) {\n        let task = dataTask(with: url, completionHandler: completionHandler)\n        task.resume()\n    }\n}\n\n```\n\n如上所见，我们使得 **URLSessionDataTask** 成了 **URLSession** 的一个实现细节。这样，我们就避免了在测试代码中不得不创建不同的 mock ，而只需要关注 NetworkEngine 就行。\n\n### 协议中把单例作为默认值\n\n现在，让我们更新我们的 **DataLoader** 来使用新的 NetworkEngine 协议，把它作为依赖项注入。我们把 URLSession.shared 作为默认参数传递，以此做到了向后兼容并且和之前一样方便。\n\n``` Swift\n\nclass DataLoader {\n    enum Result {\n        case data(Data)\n        case error(Error)\n    }\n\n    private let engine: NetworkEngine\n\n    init(engine: NetworkEngine = URLSession.shared) {\n        self.engine = engine\n    }\n\n    func load(from url: URL, completionHandler: @escaping (Result) -> Void) {\n        engine.performRequest(for: url) { (data, response, error) in\n            if let error = error {\n                return completionHandler(.error(error))\n            }\n\n            completionHandler(.data(data ?? Data()))\n        }\n    }\n}\n\n```\n\n通过使用默认参数，我们依然可以像之前一样很容易的生成 **DataLoader**，而不需要提供一个 **NetworkEngine**。\n\n### 在你的测试中 Mock 协议\n\n最后，让我们写个测试，在这里我们通过 mock **NetworkEngine** 使得我们的测试快速，可预测并且容易维护。\n\n``` Swift\n\nfunc testLoadingData() {\n    class NetworkEngineMock: NetworkEngine {\n        typealias Handler = NetworkEngine.Handler \n\n        var requestedURL: URL?\n\n        func performRequest(for url: URL, completionHandler: @escaping Handler) {\n            requestedURL = url\n\n            let data = “Hello world”.data(using: .utf8)\n            completionHandler(data, nil, nil)\n        }\n    }\n\n    let engine = NetworkEngineMock()\n    let loader = DataLoader(engine: engine)\n\n    var result: DataLoader.Result?\n    let url = URL(string: “my/API”)!\n    loader.load(from: url) { result = $0 }\n\n    XCTAssertEqual(engine.requestedURL, url)\n    XCTAssertEqual(result, .data(“Hello world”.data(using: .utf8)!))\n}\n\n```\n\n如上所见，作者试图让 mock 尽可能的简单。不需要创建包含大量逻辑的复杂 mock，你只需要让自己的代码返回一些 hardcode 的值通常是一个好主意，这样，你能够在自己的测试中进行断言。然而，风险就是你可能最后测试的是自己的 mock 而不是生产环境的代码。\n\n\n## 最后\n\n我们现在通过以下三个步骤让这些依然方便的使用了系统的单例可被测试：\n\n1. 抽象协议\n2. 协议中把单例作为默认值\n3. 在你的测试中 Mock 该协议\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Testing-Swift-code-that-uses-system-singletons-in-3-easy-steps","published":1,"updated":"2018-07-17T09:54:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwn000f79polub0f8ul","content":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps\" target=\"_blank\" rel=\"noopener\">Testing Swift code that uses system singletons in 3 easy steps</a><br>原作者 &amp; Copyright <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>大部分在 Apple 平台开发的 App 都会依赖基于单例的 API。从 UIScreen 到 UIApplication，再到 NSBundle，而 Foundation，UIKit 以及 AppKit 里到处充斥着静态的 API。</p>\n<p>尽管单例非常方便，并且随时随地都可以很轻易的获取到特定的 API，但是当它们一旦要面临代码解耦和测试的时候就会出现挑战。单例同时也是平时遇到 Bug 里最常见的一种，在单例中状态会以共享的方式终结，那些针对状态做的变更并不能很好的广播到整个系统层面。</p>\n<p>然而，尽管我们能够重构自己的代码，让它们只在真正需求的地方使用单例，我们针对系统 API 也做不了太多。但是，好消息是，这里有一些技巧让你使用系统单例的代码依然变得容易管理和测试。</p>\n<p>让我们看一些使用了 URLSession.shared 单例的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Result</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> data(<span class=\"type\">Data</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> error(<span class=\"type\">Error</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">load</span><span class=\"params\">(from url: URL, completionHandler: @escaping <span class=\"params\">(Result)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> task = <span class=\"type\">URLSession</span>.shared.dataTask(with: url) &#123; (data, response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> completionHandler(.error(error))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(.data(data ?? <span class=\"type\">Data</span>()))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个 <strong>DataLoader</strong> 现在就变得很难测试，因为它内部会自主调用共享的 URL Session 来执行一个网络调用。这就需要我们为测试代码中增加一些等待和超时代码，然后很快这部分代码就会变得糟糕和不稳定。</p>\n<h3 id=\"抽象成一个协议\"><a href=\"#抽象成一个协议\" class=\"headerlink\" title=\"抽象成一个协议\"></a>抽象成一个协议</h3><p>我们第一个任务就是把我们需要的 URLSession 的部分移到一个协议里，这样我们在测试中也能够很容易的进行 mock。在作者的<a href=\"http://www.ustream.tv/recorded/101118612\" target=\"_blank\" rel=\"noopener\">一次 talk</a>中作者建议尽可能的避免 mock，尽管它是一种很好的策略。但是当你和系统的单例打交道的时候，mock 就是一个增加可预测性的重要工具。</p>\n<p>让我们创建一个 <strong>NetworkEngine</strong> 协议，然后让 URLSession 符合它:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">NetworkEngine</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typealias</span> <span class=\"type\">Handler</span> = (<span class=\"type\">Data</span>?, <span class=\"type\">URLResponse</span>?, <span class=\"type\">Error</span>?) -&gt; <span class=\"type\">Void</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performRequest</span><span class=\"params\">(<span class=\"keyword\">for</span> url: URL, completionHandler: @escaping Handler)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">URLSession</span>: <span class=\"title\">NetworkEngine</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typealias</span> <span class=\"type\">Handler</span> = <span class=\"type\">NetworkEngine</span>.<span class=\"type\">Handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performRequest</span><span class=\"params\">(<span class=\"keyword\">for</span> url: URL, completionHandler: @escaping Handler)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> task = dataTask(with: url, completionHandler: completionHandler)</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所见，我们使得 <strong>URLSessionDataTask</strong> 成了 <strong>URLSession</strong> 的一个实现细节。这样，我们就避免了在测试代码中不得不创建不同的 mock ，而只需要关注 NetworkEngine 就行。</p>\n<h3 id=\"协议中把单例作为默认值\"><a href=\"#协议中把单例作为默认值\" class=\"headerlink\" title=\"协议中把单例作为默认值\"></a>协议中把单例作为默认值</h3><p>现在，让我们更新我们的 <strong>DataLoader</strong> 来使用新的 NetworkEngine 协议，把它作为依赖项注入。我们把 URLSession.shared 作为默认参数传递，以此做到了向后兼容并且和之前一样方便。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Result</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> data(<span class=\"type\">Data</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> error(<span class=\"type\">Error</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> engine: <span class=\"type\">NetworkEngine</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(engine: <span class=\"type\">NetworkEngine</span> = <span class=\"type\">URLSession</span>.shared) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.engine = engine</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">load</span><span class=\"params\">(from url: URL, completionHandler: @escaping <span class=\"params\">(Result)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        engine.performRequest(<span class=\"keyword\">for</span>: url) &#123; (data, response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> completionHandler(.error(error))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(.data(data ?? <span class=\"type\">Data</span>()))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过使用默认参数，我们依然可以像之前一样很容易的生成 <strong>DataLoader</strong>，而不需要提供一个 <strong>NetworkEngine</strong>。</p>\n<h3 id=\"在你的测试中-Mock-协议\"><a href=\"#在你的测试中-Mock-协议\" class=\"headerlink\" title=\"在你的测试中 Mock 协议\"></a>在你的测试中 Mock 协议</h3><p>最后，让我们写个测试，在这里我们通过 mock <strong>NetworkEngine</strong> 使得我们的测试快速，可预测并且容易维护。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testLoadingData</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NetworkEngineMock</span>: <span class=\"title\">NetworkEngine</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">typealias</span> <span class=\"type\">Handler</span> = <span class=\"type\">NetworkEngine</span>.<span class=\"type\">Handler</span> </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> requestedURL: <span class=\"type\">URL</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performRequest</span><span class=\"params\">(<span class=\"keyword\">for</span> url: URL, completionHandler: @escaping Handler)</span></span> &#123;</span><br><span class=\"line\">            requestedURL = url</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> data = “<span class=\"type\">Hello</span> world”.data(using: .utf8)</span><br><span class=\"line\">            completionHandler(data, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> engine = <span class=\"type\">NetworkEngineMock</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> loader = <span class=\"type\">DataLoader</span>(engine: engine)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result: <span class=\"type\">DataLoader</span>.<span class=\"type\">Result</span>?</span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = <span class=\"type\">URL</span>(string: “my/<span class=\"type\">API</span>”)!</span><br><span class=\"line\">    loader.load(from: url) &#123; result = $<span class=\"number\">0</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(engine.requestedURL, url)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(result, .data(“<span class=\"type\">Hello</span> world”.data(using: .utf8)!))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所见，作者试图让 mock 尽可能的简单。不需要创建包含大量逻辑的复杂 mock，你只需要让自己的代码返回一些 hardcode 的值通常是一个好主意，这样，你能够在自己的测试中进行断言。然而，风险就是你可能最后测试的是自己的 mock 而不是生产环境的代码。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>我们现在通过以下三个步骤让这些依然方便的使用了系统的单例可被测试：</p>\n<ol>\n<li>抽象协议</li>\n<li>协议中把单例作为默认值</li>\n<li>在你的测试中 Mock 该协议</li>\n</ol>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps\" target=\"_blank\" rel=\"noopener\">Testing Swift code that uses system singletons in 3 easy steps</a><br>原作者 &amp; Copyright <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>大部分在 Apple 平台开发的 App 都会依赖基于单例的 API。从 UIScreen 到 UIApplication，再到 NSBundle，而 Foundation，UIKit 以及 AppKit 里到处充斥着静态的 API。</p>\n<p>尽管单例非常方便，并且随时随地都可以很轻易的获取到特定的 API，但是当它们一旦要面临代码解耦和测试的时候就会出现挑战。单例同时也是平时遇到 Bug 里最常见的一种，在单例中状态会以共享的方式终结，那些针对状态做的变更并不能很好的广播到整个系统层面。</p>\n<p>然而，尽管我们能够重构自己的代码，让它们只在真正需求的地方使用单例，我们针对系统 API 也做不了太多。但是，好消息是，这里有一些技巧让你使用系统单例的代码依然变得容易管理和测试。</p>\n<p>让我们看一些使用了 URLSession.shared 单例的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Result</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> data(<span class=\"type\">Data</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> error(<span class=\"type\">Error</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">load</span><span class=\"params\">(from url: URL, completionHandler: @escaping <span class=\"params\">(Result)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> task = <span class=\"type\">URLSession</span>.shared.dataTask(with: url) &#123; (data, response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> completionHandler(.error(error))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(.data(data ?? <span class=\"type\">Data</span>()))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个 <strong>DataLoader</strong> 现在就变得很难测试，因为它内部会自主调用共享的 URL Session 来执行一个网络调用。这就需要我们为测试代码中增加一些等待和超时代码，然后很快这部分代码就会变得糟糕和不稳定。</p>\n<h3 id=\"抽象成一个协议\"><a href=\"#抽象成一个协议\" class=\"headerlink\" title=\"抽象成一个协议\"></a>抽象成一个协议</h3><p>我们第一个任务就是把我们需要的 URLSession 的部分移到一个协议里，这样我们在测试中也能够很容易的进行 mock。在作者的<a href=\"http://www.ustream.tv/recorded/101118612\" target=\"_blank\" rel=\"noopener\">一次 talk</a>中作者建议尽可能的避免 mock，尽管它是一种很好的策略。但是当你和系统的单例打交道的时候，mock 就是一个增加可预测性的重要工具。</p>\n<p>让我们创建一个 <strong>NetworkEngine</strong> 协议，然后让 URLSession 符合它:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">NetworkEngine</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typealias</span> <span class=\"type\">Handler</span> = (<span class=\"type\">Data</span>?, <span class=\"type\">URLResponse</span>?, <span class=\"type\">Error</span>?) -&gt; <span class=\"type\">Void</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performRequest</span><span class=\"params\">(<span class=\"keyword\">for</span> url: URL, completionHandler: @escaping Handler)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">URLSession</span>: <span class=\"title\">NetworkEngine</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typealias</span> <span class=\"type\">Handler</span> = <span class=\"type\">NetworkEngine</span>.<span class=\"type\">Handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performRequest</span><span class=\"params\">(<span class=\"keyword\">for</span> url: URL, completionHandler: @escaping Handler)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> task = dataTask(with: url, completionHandler: completionHandler)</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所见，我们使得 <strong>URLSessionDataTask</strong> 成了 <strong>URLSession</strong> 的一个实现细节。这样，我们就避免了在测试代码中不得不创建不同的 mock ，而只需要关注 NetworkEngine 就行。</p>\n<h3 id=\"协议中把单例作为默认值\"><a href=\"#协议中把单例作为默认值\" class=\"headerlink\" title=\"协议中把单例作为默认值\"></a>协议中把单例作为默认值</h3><p>现在，让我们更新我们的 <strong>DataLoader</strong> 来使用新的 NetworkEngine 协议，把它作为依赖项注入。我们把 URLSession.shared 作为默认参数传递，以此做到了向后兼容并且和之前一样方便。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Result</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> data(<span class=\"type\">Data</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> error(<span class=\"type\">Error</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> engine: <span class=\"type\">NetworkEngine</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(engine: <span class=\"type\">NetworkEngine</span> = <span class=\"type\">URLSession</span>.shared) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.engine = engine</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">load</span><span class=\"params\">(from url: URL, completionHandler: @escaping <span class=\"params\">(Result)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        engine.performRequest(<span class=\"keyword\">for</span>: url) &#123; (data, response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> completionHandler(.error(error))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(.data(data ?? <span class=\"type\">Data</span>()))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过使用默认参数，我们依然可以像之前一样很容易的生成 <strong>DataLoader</strong>，而不需要提供一个 <strong>NetworkEngine</strong>。</p>\n<h3 id=\"在你的测试中-Mock-协议\"><a href=\"#在你的测试中-Mock-协议\" class=\"headerlink\" title=\"在你的测试中 Mock 协议\"></a>在你的测试中 Mock 协议</h3><p>最后，让我们写个测试，在这里我们通过 mock <strong>NetworkEngine</strong> 使得我们的测试快速，可预测并且容易维护。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testLoadingData</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NetworkEngineMock</span>: <span class=\"title\">NetworkEngine</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">typealias</span> <span class=\"type\">Handler</span> = <span class=\"type\">NetworkEngine</span>.<span class=\"type\">Handler</span> </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> requestedURL: <span class=\"type\">URL</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">performRequest</span><span class=\"params\">(<span class=\"keyword\">for</span> url: URL, completionHandler: @escaping Handler)</span></span> &#123;</span><br><span class=\"line\">            requestedURL = url</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> data = “<span class=\"type\">Hello</span> world”.data(using: .utf8)</span><br><span class=\"line\">            completionHandler(data, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> engine = <span class=\"type\">NetworkEngineMock</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> loader = <span class=\"type\">DataLoader</span>(engine: engine)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result: <span class=\"type\">DataLoader</span>.<span class=\"type\">Result</span>?</span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = <span class=\"type\">URL</span>(string: “my/<span class=\"type\">API</span>”)!</span><br><span class=\"line\">    loader.load(from: url) &#123; result = $<span class=\"number\">0</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(engine.requestedURL, url)</span><br><span class=\"line\">    <span class=\"type\">XCTAssertEqual</span>(result, .data(“<span class=\"type\">Hello</span> world”.data(using: .utf8)!))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上所见，作者试图让 mock 尽可能的简单。不需要创建包含大量逻辑的复杂 mock，你只需要让自己的代码返回一些 hardcode 的值通常是一个好主意，这样，你能够在自己的测试中进行断言。然而，风险就是你可能最后测试的是自己的 mock 而不是生产环境的代码。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>我们现在通过以下三个步骤让这些依然方便的使用了系统的单例可被测试：</p>\n<ol>\n<li>抽象协议</li>\n<li>协议中把单例作为默认值</li>\n<li>在你的测试中 Mock 该协议</li>\n</ol>\n"},{"title":"阅读 《Thread Programming Guide》","date":"2017-10-17T12:06:46.000Z","_content":"\n\n花了两天时间阅读了官方的 Thread Programming Guide，下面是该文档的脑图。\n\n\n![Thread Programming Guide](http://7xilk1.com1.z0.glb.clouddn.com/Thread Programming Guide-1.png)\n\n\n\n","source":"_posts/Thread-Programming-Guide.md","raw":"---\ntitle: 阅读 《Thread Programming Guide》\ndate: 2017-10-17 20:06:46\ncategories: Apple Documentation\ntags: [Thread, iOS]\n---\n\n\n花了两天时间阅读了官方的 Thread Programming Guide，下面是该文档的脑图。\n\n\n![Thread Programming Guide](http://7xilk1.com1.z0.glb.clouddn.com/Thread Programming Guide-1.png)\n\n\n\n","slug":"Thread-Programming-Guide","published":1,"updated":"2017-10-17T12:18:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwp000j79poiqpo48wx","content":"<p>花了两天时间阅读了官方的 Thread Programming Guide，下面是该文档的脑图。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Thread Programming Guide-1.png\" alt=\"Thread Programming Guide\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>花了两天时间阅读了官方的 Thread Programming Guide，下面是该文档的脑图。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Thread Programming Guide-1.png\" alt=\"Thread Programming Guide\"></p>\n"},{"title":"理解响应者和响应链","date":"2017-11-13T13:22:44.000Z","_content":"\nApps 是通过响应者（responder）对象来接收和处理事件的。一个响应者对象是 UIResponder 类的一个实例，我们常见的 UIView，UIViewController 以及 UIApplication 都是 UIResponder 的子类。 UIKit 自动帮你管理着这些 responder 相关的行为，包括事件是如何从一个 responder 传递给另一个 responder 的等等。当然，你也可以修改你的 app 中事件传递的默认行为。\n\nUIKit 会把大部分的事件都传递给最适合的 responder 对象来处理。如果该 responder 无法处理该事件，UIKit 就会继续把该事件沿着当前的响应者链传递到下一个 responder。响应者链就是你的 App 中所有响应者的动态配置，也因为其是动态的，你的 App 中不可能只存在单一的响应者链。由于事件总是从特定的响应者那里流转到更通用的响应者那里，因此很容易确定某响应者链中下一个响应者是谁。举个例子，一个 view 的下一个响应者是其 superview 或者负责管理它的 view controller。事件就是这样在响应者链中传递直到其被处理掉。\n\n下图1 表明一个界面中包含了 一个 Label，一个 text field，一个 button 以及两个 background view 的 App 中响应链是什么样子的。如果 text field 不处理某个事件，UIKit 就会把该事件发送给 text field 的父级 UIView 对象，同样的，如果该对象依然处理不了，就会传递给该 view 对象的 window。如果 window 对象也依然无法处理该事件，UIKit 最终会把该事件传递给 UIApplication 对象，一般上该 UIApplication 对象是 App 的 delegate 对象并且是 UIResponder 实例，当然这个时候已经脱离了响应者链了。\n\n![图1 - 一个响应者链的例子](https://ws4.sinaimg.cn/large/006tKfTcly1flgs9djns2j30zp0lyac6.jpg)\n\n针对每一个事件，UIKit 都会指定一个第一响应者（first responder），然后把该事件首先发送给对象处理。这个第一响应者基于事件类型而不同。\n\n1. **Touch events.** 第一响应者是 Touch 发生所在的 view。\n2. **Press events.** 第一响应者是当前焦点所在的响应者。\n3. **Motion event.** 第一响应者是你显式指定用以处理事件的对象。 Core Motion 处理所有的和加速器、气压仪以及磁力计相关的事件。Motion events 不随响应者链流动。\n4. **Shake-motion events.** 第一响应者是你或者 UIKit 框架指定的对象。\n5. **Remote-control events.** 第一响应者是你或者 UIKit 框架指定的对象。\n6. **Editing-menu messages.** 第一响应者是你或者 UIKit 框架指定的对象。\n\n\nControls 向其关联的对象发送动作消息本身不是事件，但是依然能够享受到响应者链的好处。当一个 Control 的 target object 是 nil 的时候，UIKit 就会在该 target object 的响应者链上寻找合适的对象用以妥善处理动作消息。例如，UIKit 编辑按钮使用这种行为来寻找响应者对象来执行`cut:`, `copy:` 或者 `paste:` 等方法。\n\n如果一个 view 自身还有附加的手势识别器的话，该手势识别器会延迟针对该 view 的 touch 和 press 事件的传递。`delaysTouchesBegan`, `delaysTouchesEnded` 以及 `UIGestureRecognizer` 的 `cancelsTouchesInView` 属性都是用来决定这些 touches 什么时间以及以什么方式被延迟处理。\n\n\n### 识别包含 Touch 事件的响应者\n\nUIKit 使用基于视图的碰撞检测（hit-testing）来决定 touch 事件发生的地点。具体而言，UIKit  拿该 touch 的位置和视图层级中所有的视图对象的 bounds 进行比较。UIView 的 `hitTest:withEvent:` 方法会游历整个视图层级，找到该 touch 事件发生所在的视图树最底端的视图，其也就是处理该 touch 事件的第一响应者。\n\n> 如果一个 touch 的位置发生在某个视图的外围，`hitTest:withEvent:`方法就会忽略该视图和其所有子视图。所以，如果你将 view 的`clipsToBounds`属性设置为 NO 的化，即使其子视图将该 touch 包含在自己领域也是无效的。\n\n就这样，UIKit 持续不断的把每个 touch 指派给包含该 touch 的视图。当 touch 发生的时候，UIKit 创建一个 `UITouch` 对象，直到 touch 结束该对象才会被释放。当 touch 位置或者其他参数发生变化的时候，UIKit 就更新这个 UITouch 对象的信息。当然，其中有的属性当然是不会变化的，比如该 touch 附属的 view，甚至当 touch 位置已经超出原始 view 的外围的时候，UITouch 对象中的 view 属性依然保持和之前一样。\n\n### 变更响应者链\n\n你可以通过覆写响应者的 nextResponder 属性来改变响应者链。许多 UIKit 的类已经覆写了该方法并且返回了特定的对象。\n\n1. 如果你覆写了任意类的 `nextResponder` 属性，那该对象的下一个响应者就是你返回的那个；\n2. `UIView`\n\t2.1 如果该视图是某个视图控制器的根视图（root view），其下一个响应者就是该视图控制器；\n\t2.2 如果该视图不是某个视图控制器的根视图，其下一个响应者就是该视图的父视图；\n3. `UIViewController`\n\t3.1 如果该视图控制器的视图是某个 window 的根视图（root view），其下一个响应者就是 window；\n\t3.2 如果该视图控制器是由另一个视图控制器展示出来的，其下一个响应者就是那个视图控制器（presenting view controller）；\n4. `UIWindow`  window 的下一个响应者就是 `UIApplication` 对象\n5. `UIApplication`  UIApplication 对象的下一个响应者是 App delegate，而且要求该 delegate 必须是 `UIRepsponder` 的实例并且不能是一个视图、视图控制器或者 `UIApplication` 对象自己。\n\n\n\n\n\n\n[image-1]:\thttp://7xilk1.com1.z0.glb.clouddn.com/responder_chain_overview_2x.png\n\n","source":"_posts/Understanding-Responders-and-the-Responder-Chain.md","raw":"---\ntitle: 理解响应者和响应链\ndate: 2017-11-13 21:22:44\ncategories: iOS\ntags: [UIResponder,UIGestureRecognizer]\n---\n\nApps 是通过响应者（responder）对象来接收和处理事件的。一个响应者对象是 UIResponder 类的一个实例，我们常见的 UIView，UIViewController 以及 UIApplication 都是 UIResponder 的子类。 UIKit 自动帮你管理着这些 responder 相关的行为，包括事件是如何从一个 responder 传递给另一个 responder 的等等。当然，你也可以修改你的 app 中事件传递的默认行为。\n\nUIKit 会把大部分的事件都传递给最适合的 responder 对象来处理。如果该 responder 无法处理该事件，UIKit 就会继续把该事件沿着当前的响应者链传递到下一个 responder。响应者链就是你的 App 中所有响应者的动态配置，也因为其是动态的，你的 App 中不可能只存在单一的响应者链。由于事件总是从特定的响应者那里流转到更通用的响应者那里，因此很容易确定某响应者链中下一个响应者是谁。举个例子，一个 view 的下一个响应者是其 superview 或者负责管理它的 view controller。事件就是这样在响应者链中传递直到其被处理掉。\n\n下图1 表明一个界面中包含了 一个 Label，一个 text field，一个 button 以及两个 background view 的 App 中响应链是什么样子的。如果 text field 不处理某个事件，UIKit 就会把该事件发送给 text field 的父级 UIView 对象，同样的，如果该对象依然处理不了，就会传递给该 view 对象的 window。如果 window 对象也依然无法处理该事件，UIKit 最终会把该事件传递给 UIApplication 对象，一般上该 UIApplication 对象是 App 的 delegate 对象并且是 UIResponder 实例，当然这个时候已经脱离了响应者链了。\n\n![图1 - 一个响应者链的例子](https://ws4.sinaimg.cn/large/006tKfTcly1flgs9djns2j30zp0lyac6.jpg)\n\n针对每一个事件，UIKit 都会指定一个第一响应者（first responder），然后把该事件首先发送给对象处理。这个第一响应者基于事件类型而不同。\n\n1. **Touch events.** 第一响应者是 Touch 发生所在的 view。\n2. **Press events.** 第一响应者是当前焦点所在的响应者。\n3. **Motion event.** 第一响应者是你显式指定用以处理事件的对象。 Core Motion 处理所有的和加速器、气压仪以及磁力计相关的事件。Motion events 不随响应者链流动。\n4. **Shake-motion events.** 第一响应者是你或者 UIKit 框架指定的对象。\n5. **Remote-control events.** 第一响应者是你或者 UIKit 框架指定的对象。\n6. **Editing-menu messages.** 第一响应者是你或者 UIKit 框架指定的对象。\n\n\nControls 向其关联的对象发送动作消息本身不是事件，但是依然能够享受到响应者链的好处。当一个 Control 的 target object 是 nil 的时候，UIKit 就会在该 target object 的响应者链上寻找合适的对象用以妥善处理动作消息。例如，UIKit 编辑按钮使用这种行为来寻找响应者对象来执行`cut:`, `copy:` 或者 `paste:` 等方法。\n\n如果一个 view 自身还有附加的手势识别器的话，该手势识别器会延迟针对该 view 的 touch 和 press 事件的传递。`delaysTouchesBegan`, `delaysTouchesEnded` 以及 `UIGestureRecognizer` 的 `cancelsTouchesInView` 属性都是用来决定这些 touches 什么时间以及以什么方式被延迟处理。\n\n\n### 识别包含 Touch 事件的响应者\n\nUIKit 使用基于视图的碰撞检测（hit-testing）来决定 touch 事件发生的地点。具体而言，UIKit  拿该 touch 的位置和视图层级中所有的视图对象的 bounds 进行比较。UIView 的 `hitTest:withEvent:` 方法会游历整个视图层级，找到该 touch 事件发生所在的视图树最底端的视图，其也就是处理该 touch 事件的第一响应者。\n\n> 如果一个 touch 的位置发生在某个视图的外围，`hitTest:withEvent:`方法就会忽略该视图和其所有子视图。所以，如果你将 view 的`clipsToBounds`属性设置为 NO 的化，即使其子视图将该 touch 包含在自己领域也是无效的。\n\n就这样，UIKit 持续不断的把每个 touch 指派给包含该 touch 的视图。当 touch 发生的时候，UIKit 创建一个 `UITouch` 对象，直到 touch 结束该对象才会被释放。当 touch 位置或者其他参数发生变化的时候，UIKit 就更新这个 UITouch 对象的信息。当然，其中有的属性当然是不会变化的，比如该 touch 附属的 view，甚至当 touch 位置已经超出原始 view 的外围的时候，UITouch 对象中的 view 属性依然保持和之前一样。\n\n### 变更响应者链\n\n你可以通过覆写响应者的 nextResponder 属性来改变响应者链。许多 UIKit 的类已经覆写了该方法并且返回了特定的对象。\n\n1. 如果你覆写了任意类的 `nextResponder` 属性，那该对象的下一个响应者就是你返回的那个；\n2. `UIView`\n\t2.1 如果该视图是某个视图控制器的根视图（root view），其下一个响应者就是该视图控制器；\n\t2.2 如果该视图不是某个视图控制器的根视图，其下一个响应者就是该视图的父视图；\n3. `UIViewController`\n\t3.1 如果该视图控制器的视图是某个 window 的根视图（root view），其下一个响应者就是 window；\n\t3.2 如果该视图控制器是由另一个视图控制器展示出来的，其下一个响应者就是那个视图控制器（presenting view controller）；\n4. `UIWindow`  window 的下一个响应者就是 `UIApplication` 对象\n5. `UIApplication`  UIApplication 对象的下一个响应者是 App delegate，而且要求该 delegate 必须是 `UIRepsponder` 的实例并且不能是一个视图、视图控制器或者 `UIApplication` 对象自己。\n\n\n\n\n\n\n[image-1]:\thttp://7xilk1.com1.z0.glb.clouddn.com/responder_chain_overview_2x.png\n\n","slug":"Understanding-Responders-and-the-Responder-Chain","published":1,"updated":"2018-05-02T10:46:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwr000k79polfyz297w","content":"<p>Apps 是通过响应者（responder）对象来接收和处理事件的。一个响应者对象是 UIResponder 类的一个实例，我们常见的 UIView，UIViewController 以及 UIApplication 都是 UIResponder 的子类。 UIKit 自动帮你管理着这些 responder 相关的行为，包括事件是如何从一个 responder 传递给另一个 responder 的等等。当然，你也可以修改你的 app 中事件传递的默认行为。</p>\n<p>UIKit 会把大部分的事件都传递给最适合的 responder 对象来处理。如果该 responder 无法处理该事件，UIKit 就会继续把该事件沿着当前的响应者链传递到下一个 responder。响应者链就是你的 App 中所有响应者的动态配置，也因为其是动态的，你的 App 中不可能只存在单一的响应者链。由于事件总是从特定的响应者那里流转到更通用的响应者那里，因此很容易确定某响应者链中下一个响应者是谁。举个例子，一个 view 的下一个响应者是其 superview 或者负责管理它的 view controller。事件就是这样在响应者链中传递直到其被处理掉。</p>\n<p>下图1 表明一个界面中包含了 一个 Label，一个 text field，一个 button 以及两个 background view 的 App 中响应链是什么样子的。如果 text field 不处理某个事件，UIKit 就会把该事件发送给 text field 的父级 UIView 对象，同样的，如果该对象依然处理不了，就会传递给该 view 对象的 window。如果 window 对象也依然无法处理该事件，UIKit 最终会把该事件传递给 UIApplication 对象，一般上该 UIApplication 对象是 App 的 delegate 对象并且是 UIResponder 实例，当然这个时候已经脱离了响应者链了。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1flgs9djns2j30zp0lyac6.jpg\" alt=\"图1 - 一个响应者链的例子\"></p>\n<p>针对每一个事件，UIKit 都会指定一个第一响应者（first responder），然后把该事件首先发送给对象处理。这个第一响应者基于事件类型而不同。</p>\n<ol>\n<li><strong>Touch events.</strong> 第一响应者是 Touch 发生所在的 view。</li>\n<li><strong>Press events.</strong> 第一响应者是当前焦点所在的响应者。</li>\n<li><strong>Motion event.</strong> 第一响应者是你显式指定用以处理事件的对象。 Core Motion 处理所有的和加速器、气压仪以及磁力计相关的事件。Motion events 不随响应者链流动。</li>\n<li><strong>Shake-motion events.</strong> 第一响应者是你或者 UIKit 框架指定的对象。</li>\n<li><strong>Remote-control events.</strong> 第一响应者是你或者 UIKit 框架指定的对象。</li>\n<li><strong>Editing-menu messages.</strong> 第一响应者是你或者 UIKit 框架指定的对象。</li>\n</ol>\n<p>Controls 向其关联的对象发送动作消息本身不是事件，但是依然能够享受到响应者链的好处。当一个 Control 的 target object 是 nil 的时候，UIKit 就会在该 target object 的响应者链上寻找合适的对象用以妥善处理动作消息。例如，UIKit 编辑按钮使用这种行为来寻找响应者对象来执行<code>cut:</code>, <code>copy:</code> 或者 <code>paste:</code> 等方法。</p>\n<p>如果一个 view 自身还有附加的手势识别器的话，该手势识别器会延迟针对该 view 的 touch 和 press 事件的传递。<code>delaysTouchesBegan</code>, <code>delaysTouchesEnded</code> 以及 <code>UIGestureRecognizer</code> 的 <code>cancelsTouchesInView</code> 属性都是用来决定这些 touches 什么时间以及以什么方式被延迟处理。</p>\n<h3 id=\"识别包含-Touch-事件的响应者\"><a href=\"#识别包含-Touch-事件的响应者\" class=\"headerlink\" title=\"识别包含 Touch 事件的响应者\"></a>识别包含 Touch 事件的响应者</h3><p>UIKit 使用基于视图的碰撞检测（hit-testing）来决定 touch 事件发生的地点。具体而言，UIKit  拿该 touch 的位置和视图层级中所有的视图对象的 bounds 进行比较。UIView 的 <code>hitTest:withEvent:</code> 方法会游历整个视图层级，找到该 touch 事件发生所在的视图树最底端的视图，其也就是处理该 touch 事件的第一响应者。</p>\n<blockquote>\n<p>如果一个 touch 的位置发生在某个视图的外围，<code>hitTest:withEvent:</code>方法就会忽略该视图和其所有子视图。所以，如果你将 view 的<code>clipsToBounds</code>属性设置为 NO 的化，即使其子视图将该 touch 包含在自己领域也是无效的。</p>\n</blockquote>\n<p>就这样，UIKit 持续不断的把每个 touch 指派给包含该 touch 的视图。当 touch 发生的时候，UIKit 创建一个 <code>UITouch</code> 对象，直到 touch 结束该对象才会被释放。当 touch 位置或者其他参数发生变化的时候，UIKit 就更新这个 UITouch 对象的信息。当然，其中有的属性当然是不会变化的，比如该 touch 附属的 view，甚至当 touch 位置已经超出原始 view 的外围的时候，UITouch 对象中的 view 属性依然保持和之前一样。</p>\n<h3 id=\"变更响应者链\"><a href=\"#变更响应者链\" class=\"headerlink\" title=\"变更响应者链\"></a>变更响应者链</h3><p>你可以通过覆写响应者的 nextResponder 属性来改变响应者链。许多 UIKit 的类已经覆写了该方法并且返回了特定的对象。</p>\n<ol>\n<li>如果你覆写了任意类的 <code>nextResponder</code> 属性，那该对象的下一个响应者就是你返回的那个；</li>\n<li><code>UIView</code><br> 2.1 如果该视图是某个视图控制器的根视图（root view），其下一个响应者就是该视图控制器；<br> 2.2 如果该视图不是某个视图控制器的根视图，其下一个响应者就是该视图的父视图；</li>\n<li><code>UIViewController</code><br> 3.1 如果该视图控制器的视图是某个 window 的根视图（root view），其下一个响应者就是 window；<br> 3.2 如果该视图控制器是由另一个视图控制器展示出来的，其下一个响应者就是那个视图控制器（presenting view controller）；</li>\n<li><code>UIWindow</code>  window 的下一个响应者就是 <code>UIApplication</code> 对象</li>\n<li><code>UIApplication</code>  UIApplication 对象的下一个响应者是 App delegate，而且要求该 delegate 必须是 <code>UIRepsponder</code> 的实例并且不能是一个视图、视图控制器或者 <code>UIApplication</code> 对象自己。</li>\n</ol>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>Apps 是通过响应者（responder）对象来接收和处理事件的。一个响应者对象是 UIResponder 类的一个实例，我们常见的 UIView，UIViewController 以及 UIApplication 都是 UIResponder 的子类。 UIKit 自动帮你管理着这些 responder 相关的行为，包括事件是如何从一个 responder 传递给另一个 responder 的等等。当然，你也可以修改你的 app 中事件传递的默认行为。</p>\n<p>UIKit 会把大部分的事件都传递给最适合的 responder 对象来处理。如果该 responder 无法处理该事件，UIKit 就会继续把该事件沿着当前的响应者链传递到下一个 responder。响应者链就是你的 App 中所有响应者的动态配置，也因为其是动态的，你的 App 中不可能只存在单一的响应者链。由于事件总是从特定的响应者那里流转到更通用的响应者那里，因此很容易确定某响应者链中下一个响应者是谁。举个例子，一个 view 的下一个响应者是其 superview 或者负责管理它的 view controller。事件就是这样在响应者链中传递直到其被处理掉。</p>\n<p>下图1 表明一个界面中包含了 一个 Label，一个 text field，一个 button 以及两个 background view 的 App 中响应链是什么样子的。如果 text field 不处理某个事件，UIKit 就会把该事件发送给 text field 的父级 UIView 对象，同样的，如果该对象依然处理不了，就会传递给该 view 对象的 window。如果 window 对象也依然无法处理该事件，UIKit 最终会把该事件传递给 UIApplication 对象，一般上该 UIApplication 对象是 App 的 delegate 对象并且是 UIResponder 实例，当然这个时候已经脱离了响应者链了。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1flgs9djns2j30zp0lyac6.jpg\" alt=\"图1 - 一个响应者链的例子\"></p>\n<p>针对每一个事件，UIKit 都会指定一个第一响应者（first responder），然后把该事件首先发送给对象处理。这个第一响应者基于事件类型而不同。</p>\n<ol>\n<li><strong>Touch events.</strong> 第一响应者是 Touch 发生所在的 view。</li>\n<li><strong>Press events.</strong> 第一响应者是当前焦点所在的响应者。</li>\n<li><strong>Motion event.</strong> 第一响应者是你显式指定用以处理事件的对象。 Core Motion 处理所有的和加速器、气压仪以及磁力计相关的事件。Motion events 不随响应者链流动。</li>\n<li><strong>Shake-motion events.</strong> 第一响应者是你或者 UIKit 框架指定的对象。</li>\n<li><strong>Remote-control events.</strong> 第一响应者是你或者 UIKit 框架指定的对象。</li>\n<li><strong>Editing-menu messages.</strong> 第一响应者是你或者 UIKit 框架指定的对象。</li>\n</ol>\n<p>Controls 向其关联的对象发送动作消息本身不是事件，但是依然能够享受到响应者链的好处。当一个 Control 的 target object 是 nil 的时候，UIKit 就会在该 target object 的响应者链上寻找合适的对象用以妥善处理动作消息。例如，UIKit 编辑按钮使用这种行为来寻找响应者对象来执行<code>cut:</code>, <code>copy:</code> 或者 <code>paste:</code> 等方法。</p>\n<p>如果一个 view 自身还有附加的手势识别器的话，该手势识别器会延迟针对该 view 的 touch 和 press 事件的传递。<code>delaysTouchesBegan</code>, <code>delaysTouchesEnded</code> 以及 <code>UIGestureRecognizer</code> 的 <code>cancelsTouchesInView</code> 属性都是用来决定这些 touches 什么时间以及以什么方式被延迟处理。</p>\n<h3 id=\"识别包含-Touch-事件的响应者\"><a href=\"#识别包含-Touch-事件的响应者\" class=\"headerlink\" title=\"识别包含 Touch 事件的响应者\"></a>识别包含 Touch 事件的响应者</h3><p>UIKit 使用基于视图的碰撞检测（hit-testing）来决定 touch 事件发生的地点。具体而言，UIKit  拿该 touch 的位置和视图层级中所有的视图对象的 bounds 进行比较。UIView 的 <code>hitTest:withEvent:</code> 方法会游历整个视图层级，找到该 touch 事件发生所在的视图树最底端的视图，其也就是处理该 touch 事件的第一响应者。</p>\n<blockquote>\n<p>如果一个 touch 的位置发生在某个视图的外围，<code>hitTest:withEvent:</code>方法就会忽略该视图和其所有子视图。所以，如果你将 view 的<code>clipsToBounds</code>属性设置为 NO 的化，即使其子视图将该 touch 包含在自己领域也是无效的。</p>\n</blockquote>\n<p>就这样，UIKit 持续不断的把每个 touch 指派给包含该 touch 的视图。当 touch 发生的时候，UIKit 创建一个 <code>UITouch</code> 对象，直到 touch 结束该对象才会被释放。当 touch 位置或者其他参数发生变化的时候，UIKit 就更新这个 UITouch 对象的信息。当然，其中有的属性当然是不会变化的，比如该 touch 附属的 view，甚至当 touch 位置已经超出原始 view 的外围的时候，UITouch 对象中的 view 属性依然保持和之前一样。</p>\n<h3 id=\"变更响应者链\"><a href=\"#变更响应者链\" class=\"headerlink\" title=\"变更响应者链\"></a>变更响应者链</h3><p>你可以通过覆写响应者的 nextResponder 属性来改变响应者链。许多 UIKit 的类已经覆写了该方法并且返回了特定的对象。</p>\n<ol>\n<li>如果你覆写了任意类的 <code>nextResponder</code> 属性，那该对象的下一个响应者就是你返回的那个；</li>\n<li><code>UIView</code><br> 2.1 如果该视图是某个视图控制器的根视图（root view），其下一个响应者就是该视图控制器；<br> 2.2 如果该视图不是某个视图控制器的根视图，其下一个响应者就是该视图的父视图；</li>\n<li><code>UIViewController</code><br> 3.1 如果该视图控制器的视图是某个 window 的根视图（root view），其下一个响应者就是 window；<br> 3.2 如果该视图控制器是由另一个视图控制器展示出来的，其下一个响应者就是那个视图控制器（presenting view controller）；</li>\n<li><code>UIWindow</code>  window 的下一个响应者就是 <code>UIApplication</code> 对象</li>\n<li><code>UIApplication</code>  UIApplication 对象的下一个响应者是 App delegate，而且要求该 delegate 必须是 <code>UIRepsponder</code> 的实例并且不能是一个视图、视图控制器或者 <code>UIApplication</code> 对象自己。</li>\n</ol>\n"},{"title":"UserDefaults and Keychain","date":"2018-12-21T06:30:50.000Z","_content":"\nApple 提供了几种持久化方案，其中 UserDefaults 和 Keychain 是 App 开发过程中使用频率最高的方案，而且从以往和同事的探讨过程中发现对这两个概念中有一些细节还是理解不太透彻，因此本文会针对这二者展开讲一讲。\n\n## UserDefaults\n\n首先，阅读完 Apple 关于 UserDefaults 一节的文档描述之后，我觉得有两个需要注意的点：\n\n1. UserDefaults 的构成\n2. UserDefaults 的目的\n\n\n### UserDefaults 构成\n\n我们可以看看具体 UserDefaults 存储的地方，如下图，我们在应用中写入 Demo 数据：\n\n![Write Key-Value to UserDefaults](https://i.imgur.com/wq9onOa.png)\n\n打印 Library 路径，在 Finder 中打开路径:\n\n![Library](https://i.imgur.com/65ybYX6.png)\n\n如下展示内容，可以看到在 Preferences 目录中存在某个文件，例如该 App Library 目录下存放的文件为 `app.chen.ios.PersistenceDemo.plist`\n\n![Cache](https://i.imgur.com/ChqnDJa.png)\n![Preferences](https://i.imgur.com/cPvlFdR.png)\n\n该 plist 内容如图所示，即为我们之前在 App 中写入的 Key-Value。\n\n![plist](https://i.imgur.com/shdXoZN.png)\n\n\n所以这也证明了，我们针对 UserDefaults 的读写实质上是针对 plist 文件的读写。\n\niOS 系统会自动帮你做 `plist` 文件的读入以及 Cache，根据情况会把你在内存中所做的操作同步到 `plist` 文件（UserDefaults 同步到内存是同步的，同步到 Database 是异步的， iOS 8 开始，会有一个常驻进程 `cfprefsd` 来负责同步）。\n\n所以你会看有iOS 面试题目会问题： 系统的 `UserDefaults` 的本质以及和 plist 文件的直接读写的区别？（这题目太 TM 偏了。。。）\n\n> UserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value. When you set a default value, it’s changed synchronously within your process, and asynchronously to persistent storage and other processes.\n\n所以，实质上，你是可以直接针对 UserDefaults 的最终产物 plist 文件进行操作的，当然，这是有风险的，而且无法保障正常使用的。官方在文档中也提醒了开发者。\n\n> Don’t try to access the preferences subsystem directly. Modifying preference property list files may result in loss of changes, delay of reflecting changes, and app crashes. To configure preferences, use the defaults command-line utility in macOS instead.\n\n那既然本质上 UserDefaults 是使用 plist 文件进行存储，那也要求了我们能存储的 Value 只能支持 `plist` 所支持的格式，例如 `String`，`Number`，`Array`，`Data`，`Date` 等，当然如果你要存储自定义的类，其需要遵守 `Codable` 协议（实质也是要归档为 `Data`）\n\n![plist](https://i.imgur.com/cxWHfvS.png)\n\n### UserDefaults 目的\n\n> The defaults system allows an app to customize its behavior to match a user’s preferences. For example, you can allow users to specify their preferred units of measurement or media playback speed. Apps store these preferences by assigning values to a set of parameters in a user’s defaults database. \n\n一般我们在 `UserDefaults` 存储的数据都是用户的某些配置项，不因为用户使用过程中出现意外而丢失，比如是否开启了日夜间模式了，是否开启了大图模式了等等。或者存储一些对安全方面不敏感的数据\n\n不建议往 `UserDefaults` 里存储较大的数据，例如直接存储一张图片。而对于这种需要存储较大文件的需求，你可以将文件本身存储到本地，而 `UserDefaults` 里只存储该文件的路径。\n\n毕竟在 App 启动之后，UserDefaults 会进行 IO ，读取本地 plist 文件，因此一定程度上，也会较少 App 启动之后 UserDefaults API 针对 `plist` 文件 IO 的时间，纯属个人揣测，没有经过实验验证。\n\n### 关于 Extension 中 UserDefaults 的应用\n\n\niOS 上 Extension 和 Host App 之间做数据共享也是通过 UserDefaults，开启 App Group 之后，这二者就可以修改同一份配置。具体 Extension 和 Host App 之间的内在关系可以先看下 Apple 文档。本质上如下所示，\n\n\n![app_extensions_container_restrictions](https://i.imgur.com/cZFlz6o.png)\n\n\nExtension 和 Host App 之间通过 Shared Container 来做数据共享，该 SharedContainer 私有，因此不存在于单一 App 的沙盒内。应该是系统会单独开辟一块空间用以做共享数据的存储。\n\n> After you enable app groups, an app extension and its containing app can both use the NSUserDefaults API to share access to user preferences. To enable this sharing, use the initWithSuiteName: method to instantiate a new NSUserDefaults object, passing in the identifier of the shared group.\n\n因为 UserDefaults 既然是暴露在本地能够访问的文件当中的，因此不要在 UserDefaults 里存储任何 Security-Sensitive 的数据。 如果要存储保密级别较高的数据，就要用到另外一种持久化方案 ── Keychain\n\n\n## Keychain\n\n关于 Keychain，是 Apple 提供给开发者用来存储 Security-Sensitive 的数据了，比如登录密码，用户标识，加密数据等等。 官方示意图如下，其实中间 Keychain 的 API 还进行了 Decrypt 和 Encrypt 的动作。\n\n![Keychain services API](https://i.imgur.com/tvA4lV3.png)\n\n\nApple 提供的 Keychain API 大部分都是 C 语言写成，使用起来相对不便，因此基本上我们都会使用二次加工过的库，比如知乎用的就是 SMKeychain。\n\nKeychain 中的数据完全交由系统保管并加密过( AES 128 in GCM (Galois/Counter Mode))的，因此能够保证安全性。\n\n如果对加密这一块感兴趣，可以看下[苹果的白皮书](https://www.apple.com/business/site/docs/iOS_Security_Guide.pdf)中 Keychain data protection 这一节。\n\n另外，Keychain 的数据并不存放在 App 的 Sanbox 中，即使删除了 App，资料依然保存在 keychain 中。如果重新安装了app，还可以从 keychain 获取数据。\n\n\n\n### 同一个 App 内部共享\n\n类似 UserDefaults ，Keychain 也支持 Extension 和 host app 之间的共享，需要在每个 Target 的 Capability 下开启 Keychain Sharing 功能，并且设置为同一个 Group。\n\n\n### 不同 App 之间共享\n\n和 UserDefaults 不同的是，Keychain 的数据是可以跨 App 获取的，但是限于一个开发者的 App，也就是需要确保这些 App 所属的 Team ID 是相同的。\n\n这个也是App 进行 SSO 登录的基础，比如知乎日报使用知乎主 App 登录也是基于此原理。\n\n![shared items](https://i.imgur.com/0L2MA23.png)\n\n在需要进行 Keychain 共享的 App 内开启 Keychain Sharing 的能力，所属同一个 Team ID 下的 App 本身都可以读取该 Keychain 的内容，类似于 AppGroup，这里也会产生 Keychain Group。\n\n> Allows this application to share passwords from its keychain with other applications made by your team.\n\n![Keychain Sharing](https://i.imgur.com/DJsInJb.png)\n\n\n## 参考文档\n\n1. https://developer.apple.com/documentation/foundation/userdefaults\n2. https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/\n3. http://iphonedevwiki.net/index.php/PreferenceBundles\n4. https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\n5. https://developer.apple.com/documentation/security/keychain_services\n6. https://github.com/soffes/SAMKeychain\n7. https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps","source":"_posts/UserDefaults-and-Keychain.md","raw":"---\ntitle: UserDefaults and Keychain\ndate: 2018-12-21 14:30:50\ncategory: iOS\ntags: UserDefaults,Keychain\n---\n\nApple 提供了几种持久化方案，其中 UserDefaults 和 Keychain 是 App 开发过程中使用频率最高的方案，而且从以往和同事的探讨过程中发现对这两个概念中有一些细节还是理解不太透彻，因此本文会针对这二者展开讲一讲。\n\n## UserDefaults\n\n首先，阅读完 Apple 关于 UserDefaults 一节的文档描述之后，我觉得有两个需要注意的点：\n\n1. UserDefaults 的构成\n2. UserDefaults 的目的\n\n\n### UserDefaults 构成\n\n我们可以看看具体 UserDefaults 存储的地方，如下图，我们在应用中写入 Demo 数据：\n\n![Write Key-Value to UserDefaults](https://i.imgur.com/wq9onOa.png)\n\n打印 Library 路径，在 Finder 中打开路径:\n\n![Library](https://i.imgur.com/65ybYX6.png)\n\n如下展示内容，可以看到在 Preferences 目录中存在某个文件，例如该 App Library 目录下存放的文件为 `app.chen.ios.PersistenceDemo.plist`\n\n![Cache](https://i.imgur.com/ChqnDJa.png)\n![Preferences](https://i.imgur.com/cPvlFdR.png)\n\n该 plist 内容如图所示，即为我们之前在 App 中写入的 Key-Value。\n\n![plist](https://i.imgur.com/shdXoZN.png)\n\n\n所以这也证明了，我们针对 UserDefaults 的读写实质上是针对 plist 文件的读写。\n\niOS 系统会自动帮你做 `plist` 文件的读入以及 Cache，根据情况会把你在内存中所做的操作同步到 `plist` 文件（UserDefaults 同步到内存是同步的，同步到 Database 是异步的， iOS 8 开始，会有一个常驻进程 `cfprefsd` 来负责同步）。\n\n所以你会看有iOS 面试题目会问题： 系统的 `UserDefaults` 的本质以及和 plist 文件的直接读写的区别？（这题目太 TM 偏了。。。）\n\n> UserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value. When you set a default value, it’s changed synchronously within your process, and asynchronously to persistent storage and other processes.\n\n所以，实质上，你是可以直接针对 UserDefaults 的最终产物 plist 文件进行操作的，当然，这是有风险的，而且无法保障正常使用的。官方在文档中也提醒了开发者。\n\n> Don’t try to access the preferences subsystem directly. Modifying preference property list files may result in loss of changes, delay of reflecting changes, and app crashes. To configure preferences, use the defaults command-line utility in macOS instead.\n\n那既然本质上 UserDefaults 是使用 plist 文件进行存储，那也要求了我们能存储的 Value 只能支持 `plist` 所支持的格式，例如 `String`，`Number`，`Array`，`Data`，`Date` 等，当然如果你要存储自定义的类，其需要遵守 `Codable` 协议（实质也是要归档为 `Data`）\n\n![plist](https://i.imgur.com/cxWHfvS.png)\n\n### UserDefaults 目的\n\n> The defaults system allows an app to customize its behavior to match a user’s preferences. For example, you can allow users to specify their preferred units of measurement or media playback speed. Apps store these preferences by assigning values to a set of parameters in a user’s defaults database. \n\n一般我们在 `UserDefaults` 存储的数据都是用户的某些配置项，不因为用户使用过程中出现意外而丢失，比如是否开启了日夜间模式了，是否开启了大图模式了等等。或者存储一些对安全方面不敏感的数据\n\n不建议往 `UserDefaults` 里存储较大的数据，例如直接存储一张图片。而对于这种需要存储较大文件的需求，你可以将文件本身存储到本地，而 `UserDefaults` 里只存储该文件的路径。\n\n毕竟在 App 启动之后，UserDefaults 会进行 IO ，读取本地 plist 文件，因此一定程度上，也会较少 App 启动之后 UserDefaults API 针对 `plist` 文件 IO 的时间，纯属个人揣测，没有经过实验验证。\n\n### 关于 Extension 中 UserDefaults 的应用\n\n\niOS 上 Extension 和 Host App 之间做数据共享也是通过 UserDefaults，开启 App Group 之后，这二者就可以修改同一份配置。具体 Extension 和 Host App 之间的内在关系可以先看下 Apple 文档。本质上如下所示，\n\n\n![app_extensions_container_restrictions](https://i.imgur.com/cZFlz6o.png)\n\n\nExtension 和 Host App 之间通过 Shared Container 来做数据共享，该 SharedContainer 私有，因此不存在于单一 App 的沙盒内。应该是系统会单独开辟一块空间用以做共享数据的存储。\n\n> After you enable app groups, an app extension and its containing app can both use the NSUserDefaults API to share access to user preferences. To enable this sharing, use the initWithSuiteName: method to instantiate a new NSUserDefaults object, passing in the identifier of the shared group.\n\n因为 UserDefaults 既然是暴露在本地能够访问的文件当中的，因此不要在 UserDefaults 里存储任何 Security-Sensitive 的数据。 如果要存储保密级别较高的数据，就要用到另外一种持久化方案 ── Keychain\n\n\n## Keychain\n\n关于 Keychain，是 Apple 提供给开发者用来存储 Security-Sensitive 的数据了，比如登录密码，用户标识，加密数据等等。 官方示意图如下，其实中间 Keychain 的 API 还进行了 Decrypt 和 Encrypt 的动作。\n\n![Keychain services API](https://i.imgur.com/tvA4lV3.png)\n\n\nApple 提供的 Keychain API 大部分都是 C 语言写成，使用起来相对不便，因此基本上我们都会使用二次加工过的库，比如知乎用的就是 SMKeychain。\n\nKeychain 中的数据完全交由系统保管并加密过( AES 128 in GCM (Galois/Counter Mode))的，因此能够保证安全性。\n\n如果对加密这一块感兴趣，可以看下[苹果的白皮书](https://www.apple.com/business/site/docs/iOS_Security_Guide.pdf)中 Keychain data protection 这一节。\n\n另外，Keychain 的数据并不存放在 App 的 Sanbox 中，即使删除了 App，资料依然保存在 keychain 中。如果重新安装了app，还可以从 keychain 获取数据。\n\n\n\n### 同一个 App 内部共享\n\n类似 UserDefaults ，Keychain 也支持 Extension 和 host app 之间的共享，需要在每个 Target 的 Capability 下开启 Keychain Sharing 功能，并且设置为同一个 Group。\n\n\n### 不同 App 之间共享\n\n和 UserDefaults 不同的是，Keychain 的数据是可以跨 App 获取的，但是限于一个开发者的 App，也就是需要确保这些 App 所属的 Team ID 是相同的。\n\n这个也是App 进行 SSO 登录的基础，比如知乎日报使用知乎主 App 登录也是基于此原理。\n\n![shared items](https://i.imgur.com/0L2MA23.png)\n\n在需要进行 Keychain 共享的 App 内开启 Keychain Sharing 的能力，所属同一个 Team ID 下的 App 本身都可以读取该 Keychain 的内容，类似于 AppGroup，这里也会产生 Keychain Group。\n\n> Allows this application to share passwords from its keychain with other applications made by your team.\n\n![Keychain Sharing](https://i.imgur.com/DJsInJb.png)\n\n\n## 参考文档\n\n1. https://developer.apple.com/documentation/foundation/userdefaults\n2. https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/\n3. http://iphonedevwiki.net/index.php/PreferenceBundles\n4. https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\n5. https://developer.apple.com/documentation/security/keychain_services\n6. https://github.com/soffes/SAMKeychain\n7. https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps","slug":"UserDefaults-and-Keychain","published":1,"updated":"2019-01-03T14:26:07.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwt000o79po9dgsvja1","content":"<p>Apple 提供了几种持久化方案，其中 UserDefaults 和 Keychain 是 App 开发过程中使用频率最高的方案，而且从以往和同事的探讨过程中发现对这两个概念中有一些细节还是理解不太透彻，因此本文会针对这二者展开讲一讲。</p>\n<h2 id=\"UserDefaults\"><a href=\"#UserDefaults\" class=\"headerlink\" title=\"UserDefaults\"></a>UserDefaults</h2><p>首先，阅读完 Apple 关于 UserDefaults 一节的文档描述之后，我觉得有两个需要注意的点：</p>\n<ol>\n<li>UserDefaults 的构成</li>\n<li>UserDefaults 的目的</li>\n</ol>\n<h3 id=\"UserDefaults-构成\"><a href=\"#UserDefaults-构成\" class=\"headerlink\" title=\"UserDefaults 构成\"></a>UserDefaults 构成</h3><p>我们可以看看具体 UserDefaults 存储的地方，如下图，我们在应用中写入 Demo 数据：</p>\n<p><img src=\"https://i.imgur.com/wq9onOa.png\" alt=\"Write Key-Value to UserDefaults\"></p>\n<p>打印 Library 路径，在 Finder 中打开路径:</p>\n<p><img src=\"https://i.imgur.com/65ybYX6.png\" alt=\"Library\"></p>\n<p>如下展示内容，可以看到在 Preferences 目录中存在某个文件，例如该 App Library 目录下存放的文件为 <code>app.chen.ios.PersistenceDemo.plist</code></p>\n<p><img src=\"https://i.imgur.com/ChqnDJa.png\" alt=\"Cache\"><br><img src=\"https://i.imgur.com/cPvlFdR.png\" alt=\"Preferences\"></p>\n<p>该 plist 内容如图所示，即为我们之前在 App 中写入的 Key-Value。</p>\n<p><img src=\"https://i.imgur.com/shdXoZN.png\" alt=\"plist\"></p>\n<p>所以这也证明了，我们针对 UserDefaults 的读写实质上是针对 plist 文件的读写。</p>\n<p>iOS 系统会自动帮你做 <code>plist</code> 文件的读入以及 Cache，根据情况会把你在内存中所做的操作同步到 <code>plist</code> 文件（UserDefaults 同步到内存是同步的，同步到 Database 是异步的， iOS 8 开始，会有一个常驻进程 <code>cfprefsd</code> 来负责同步）。</p>\n<p>所以你会看有iOS 面试题目会问题： 系统的 <code>UserDefaults</code> 的本质以及和 plist 文件的直接读写的区别？（这题目太 TM 偏了。。。）</p>\n<blockquote>\n<p>UserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value. When you set a default value, it’s changed synchronously within your process, and asynchronously to persistent storage and other processes.</p>\n</blockquote>\n<p>所以，实质上，你是可以直接针对 UserDefaults 的最终产物 plist 文件进行操作的，当然，这是有风险的，而且无法保障正常使用的。官方在文档中也提醒了开发者。</p>\n<blockquote>\n<p>Don’t try to access the preferences subsystem directly. Modifying preference property list files may result in loss of changes, delay of reflecting changes, and app crashes. To configure preferences, use the defaults command-line utility in macOS instead.</p>\n</blockquote>\n<p>那既然本质上 UserDefaults 是使用 plist 文件进行存储，那也要求了我们能存储的 Value 只能支持 <code>plist</code> 所支持的格式，例如 <code>String</code>，<code>Number</code>，<code>Array</code>，<code>Data</code>，<code>Date</code> 等，当然如果你要存储自定义的类，其需要遵守 <code>Codable</code> 协议（实质也是要归档为 <code>Data</code>）</p>\n<p><img src=\"https://i.imgur.com/cxWHfvS.png\" alt=\"plist\"></p>\n<h3 id=\"UserDefaults-目的\"><a href=\"#UserDefaults-目的\" class=\"headerlink\" title=\"UserDefaults 目的\"></a>UserDefaults 目的</h3><blockquote>\n<p>The defaults system allows an app to customize its behavior to match a user’s preferences. For example, you can allow users to specify their preferred units of measurement or media playback speed. Apps store these preferences by assigning values to a set of parameters in a user’s defaults database. </p>\n</blockquote>\n<p>一般我们在 <code>UserDefaults</code> 存储的数据都是用户的某些配置项，不因为用户使用过程中出现意外而丢失，比如是否开启了日夜间模式了，是否开启了大图模式了等等。或者存储一些对安全方面不敏感的数据</p>\n<p>不建议往 <code>UserDefaults</code> 里存储较大的数据，例如直接存储一张图片。而对于这种需要存储较大文件的需求，你可以将文件本身存储到本地，而 <code>UserDefaults</code> 里只存储该文件的路径。</p>\n<p>毕竟在 App 启动之后，UserDefaults 会进行 IO ，读取本地 plist 文件，因此一定程度上，也会较少 App 启动之后 UserDefaults API 针对 <code>plist</code> 文件 IO 的时间，纯属个人揣测，没有经过实验验证。</p>\n<h3 id=\"关于-Extension-中-UserDefaults-的应用\"><a href=\"#关于-Extension-中-UserDefaults-的应用\" class=\"headerlink\" title=\"关于 Extension 中 UserDefaults 的应用\"></a>关于 Extension 中 UserDefaults 的应用</h3><p>iOS 上 Extension 和 Host App 之间做数据共享也是通过 UserDefaults，开启 App Group 之后，这二者就可以修改同一份配置。具体 Extension 和 Host App 之间的内在关系可以先看下 Apple 文档。本质上如下所示，</p>\n<p><img src=\"https://i.imgur.com/cZFlz6o.png\" alt=\"app_extensions_container_restrictions\"></p>\n<p>Extension 和 Host App 之间通过 Shared Container 来做数据共享，该 SharedContainer 私有，因此不存在于单一 App 的沙盒内。应该是系统会单独开辟一块空间用以做共享数据的存储。</p>\n<blockquote>\n<p>After you enable app groups, an app extension and its containing app can both use the NSUserDefaults API to share access to user preferences. To enable this sharing, use the initWithSuiteName: method to instantiate a new NSUserDefaults object, passing in the identifier of the shared group.</p>\n</blockquote>\n<p>因为 UserDefaults 既然是暴露在本地能够访问的文件当中的，因此不要在 UserDefaults 里存储任何 Security-Sensitive 的数据。 如果要存储保密级别较高的数据，就要用到另外一种持久化方案 ── Keychain</p>\n<h2 id=\"Keychain\"><a href=\"#Keychain\" class=\"headerlink\" title=\"Keychain\"></a>Keychain</h2><p>关于 Keychain，是 Apple 提供给开发者用来存储 Security-Sensitive 的数据了，比如登录密码，用户标识，加密数据等等。 官方示意图如下，其实中间 Keychain 的 API 还进行了 Decrypt 和 Encrypt 的动作。</p>\n<p><img src=\"https://i.imgur.com/tvA4lV3.png\" alt=\"Keychain services API\"></p>\n<p>Apple 提供的 Keychain API 大部分都是 C 语言写成，使用起来相对不便，因此基本上我们都会使用二次加工过的库，比如知乎用的就是 SMKeychain。</p>\n<p>Keychain 中的数据完全交由系统保管并加密过( AES 128 in GCM (Galois/Counter Mode))的，因此能够保证安全性。</p>\n<p>如果对加密这一块感兴趣，可以看下<a href=\"https://www.apple.com/business/site/docs/iOS_Security_Guide.pdf\" target=\"_blank\" rel=\"noopener\">苹果的白皮书</a>中 Keychain data protection 这一节。</p>\n<p>另外，Keychain 的数据并不存放在 App 的 Sanbox 中，即使删除了 App，资料依然保存在 keychain 中。如果重新安装了app，还可以从 keychain 获取数据。</p>\n<h3 id=\"同一个-App-内部共享\"><a href=\"#同一个-App-内部共享\" class=\"headerlink\" title=\"同一个 App 内部共享\"></a>同一个 App 内部共享</h3><p>类似 UserDefaults ，Keychain 也支持 Extension 和 host app 之间的共享，需要在每个 Target 的 Capability 下开启 Keychain Sharing 功能，并且设置为同一个 Group。</p>\n<h3 id=\"不同-App-之间共享\"><a href=\"#不同-App-之间共享\" class=\"headerlink\" title=\"不同 App 之间共享\"></a>不同 App 之间共享</h3><p>和 UserDefaults 不同的是，Keychain 的数据是可以跨 App 获取的，但是限于一个开发者的 App，也就是需要确保这些 App 所属的 Team ID 是相同的。</p>\n<p>这个也是App 进行 SSO 登录的基础，比如知乎日报使用知乎主 App 登录也是基于此原理。</p>\n<p><img src=\"https://i.imgur.com/0L2MA23.png\" alt=\"shared items\"></p>\n<p>在需要进行 Keychain 共享的 App 内开启 Keychain Sharing 的能力，所属同一个 Team ID 下的 App 本身都可以读取该 Keychain 的内容，类似于 AppGroup，这里也会产生 Keychain Group。</p>\n<blockquote>\n<p>Allows this application to share passwords from its keychain with other applications made by your team.</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/DJsInJb.png\" alt=\"Keychain Sharing\"></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"https://developer.apple.com/documentation/foundation/userdefaults\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/foundation/userdefaults</a></li>\n<li><a href=\"https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/\" target=\"_blank\" rel=\"noopener\">https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/</a></li>\n<li><a href=\"http://iphonedevwiki.net/index.php/PreferenceBundles\" target=\"_blank\" rel=\"noopener\">http://iphonedevwiki.net/index.php/PreferenceBundles</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html</a></li>\n<li><a href=\"https://developer.apple.com/documentation/security/keychain_services\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/security/keychain_services</a></li>\n<li><a href=\"https://github.com/soffes/SAMKeychain\" target=\"_blank\" rel=\"noopener\">https://github.com/soffes/SAMKeychain</a></li>\n<li><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps</a></li>\n</ol>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>Apple 提供了几种持久化方案，其中 UserDefaults 和 Keychain 是 App 开发过程中使用频率最高的方案，而且从以往和同事的探讨过程中发现对这两个概念中有一些细节还是理解不太透彻，因此本文会针对这二者展开讲一讲。</p>\n<h2 id=\"UserDefaults\"><a href=\"#UserDefaults\" class=\"headerlink\" title=\"UserDefaults\"></a>UserDefaults</h2><p>首先，阅读完 Apple 关于 UserDefaults 一节的文档描述之后，我觉得有两个需要注意的点：</p>\n<ol>\n<li>UserDefaults 的构成</li>\n<li>UserDefaults 的目的</li>\n</ol>\n<h3 id=\"UserDefaults-构成\"><a href=\"#UserDefaults-构成\" class=\"headerlink\" title=\"UserDefaults 构成\"></a>UserDefaults 构成</h3><p>我们可以看看具体 UserDefaults 存储的地方，如下图，我们在应用中写入 Demo 数据：</p>\n<p><img src=\"https://i.imgur.com/wq9onOa.png\" alt=\"Write Key-Value to UserDefaults\"></p>\n<p>打印 Library 路径，在 Finder 中打开路径:</p>\n<p><img src=\"https://i.imgur.com/65ybYX6.png\" alt=\"Library\"></p>\n<p>如下展示内容，可以看到在 Preferences 目录中存在某个文件，例如该 App Library 目录下存放的文件为 <code>app.chen.ios.PersistenceDemo.plist</code></p>\n<p><img src=\"https://i.imgur.com/ChqnDJa.png\" alt=\"Cache\"><br><img src=\"https://i.imgur.com/cPvlFdR.png\" alt=\"Preferences\"></p>\n<p>该 plist 内容如图所示，即为我们之前在 App 中写入的 Key-Value。</p>\n<p><img src=\"https://i.imgur.com/shdXoZN.png\" alt=\"plist\"></p>\n<p>所以这也证明了，我们针对 UserDefaults 的读写实质上是针对 plist 文件的读写。</p>\n<p>iOS 系统会自动帮你做 <code>plist</code> 文件的读入以及 Cache，根据情况会把你在内存中所做的操作同步到 <code>plist</code> 文件（UserDefaults 同步到内存是同步的，同步到 Database 是异步的， iOS 8 开始，会有一个常驻进程 <code>cfprefsd</code> 来负责同步）。</p>\n<p>所以你会看有iOS 面试题目会问题： 系统的 <code>UserDefaults</code> 的本质以及和 plist 文件的直接读写的区别？（这题目太 TM 偏了。。。）</p>\n<blockquote>\n<p>UserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value. When you set a default value, it’s changed synchronously within your process, and asynchronously to persistent storage and other processes.</p>\n</blockquote>\n<p>所以，实质上，你是可以直接针对 UserDefaults 的最终产物 plist 文件进行操作的，当然，这是有风险的，而且无法保障正常使用的。官方在文档中也提醒了开发者。</p>\n<blockquote>\n<p>Don’t try to access the preferences subsystem directly. Modifying preference property list files may result in loss of changes, delay of reflecting changes, and app crashes. To configure preferences, use the defaults command-line utility in macOS instead.</p>\n</blockquote>\n<p>那既然本质上 UserDefaults 是使用 plist 文件进行存储，那也要求了我们能存储的 Value 只能支持 <code>plist</code> 所支持的格式，例如 <code>String</code>，<code>Number</code>，<code>Array</code>，<code>Data</code>，<code>Date</code> 等，当然如果你要存储自定义的类，其需要遵守 <code>Codable</code> 协议（实质也是要归档为 <code>Data</code>）</p>\n<p><img src=\"https://i.imgur.com/cxWHfvS.png\" alt=\"plist\"></p>\n<h3 id=\"UserDefaults-目的\"><a href=\"#UserDefaults-目的\" class=\"headerlink\" title=\"UserDefaults 目的\"></a>UserDefaults 目的</h3><blockquote>\n<p>The defaults system allows an app to customize its behavior to match a user’s preferences. For example, you can allow users to specify their preferred units of measurement or media playback speed. Apps store these preferences by assigning values to a set of parameters in a user’s defaults database. </p>\n</blockquote>\n<p>一般我们在 <code>UserDefaults</code> 存储的数据都是用户的某些配置项，不因为用户使用过程中出现意外而丢失，比如是否开启了日夜间模式了，是否开启了大图模式了等等。或者存储一些对安全方面不敏感的数据</p>\n<p>不建议往 <code>UserDefaults</code> 里存储较大的数据，例如直接存储一张图片。而对于这种需要存储较大文件的需求，你可以将文件本身存储到本地，而 <code>UserDefaults</code> 里只存储该文件的路径。</p>\n<p>毕竟在 App 启动之后，UserDefaults 会进行 IO ，读取本地 plist 文件，因此一定程度上，也会较少 App 启动之后 UserDefaults API 针对 <code>plist</code> 文件 IO 的时间，纯属个人揣测，没有经过实验验证。</p>\n<h3 id=\"关于-Extension-中-UserDefaults-的应用\"><a href=\"#关于-Extension-中-UserDefaults-的应用\" class=\"headerlink\" title=\"关于 Extension 中 UserDefaults 的应用\"></a>关于 Extension 中 UserDefaults 的应用</h3><p>iOS 上 Extension 和 Host App 之间做数据共享也是通过 UserDefaults，开启 App Group 之后，这二者就可以修改同一份配置。具体 Extension 和 Host App 之间的内在关系可以先看下 Apple 文档。本质上如下所示，</p>\n<p><img src=\"https://i.imgur.com/cZFlz6o.png\" alt=\"app_extensions_container_restrictions\"></p>\n<p>Extension 和 Host App 之间通过 Shared Container 来做数据共享，该 SharedContainer 私有，因此不存在于单一 App 的沙盒内。应该是系统会单独开辟一块空间用以做共享数据的存储。</p>\n<blockquote>\n<p>After you enable app groups, an app extension and its containing app can both use the NSUserDefaults API to share access to user preferences. To enable this sharing, use the initWithSuiteName: method to instantiate a new NSUserDefaults object, passing in the identifier of the shared group.</p>\n</blockquote>\n<p>因为 UserDefaults 既然是暴露在本地能够访问的文件当中的，因此不要在 UserDefaults 里存储任何 Security-Sensitive 的数据。 如果要存储保密级别较高的数据，就要用到另外一种持久化方案 ── Keychain</p>\n<h2 id=\"Keychain\"><a href=\"#Keychain\" class=\"headerlink\" title=\"Keychain\"></a>Keychain</h2><p>关于 Keychain，是 Apple 提供给开发者用来存储 Security-Sensitive 的数据了，比如登录密码，用户标识，加密数据等等。 官方示意图如下，其实中间 Keychain 的 API 还进行了 Decrypt 和 Encrypt 的动作。</p>\n<p><img src=\"https://i.imgur.com/tvA4lV3.png\" alt=\"Keychain services API\"></p>\n<p>Apple 提供的 Keychain API 大部分都是 C 语言写成，使用起来相对不便，因此基本上我们都会使用二次加工过的库，比如知乎用的就是 SMKeychain。</p>\n<p>Keychain 中的数据完全交由系统保管并加密过( AES 128 in GCM (Galois/Counter Mode))的，因此能够保证安全性。</p>\n<p>如果对加密这一块感兴趣，可以看下<a href=\"https://www.apple.com/business/site/docs/iOS_Security_Guide.pdf\" target=\"_blank\" rel=\"noopener\">苹果的白皮书</a>中 Keychain data protection 这一节。</p>\n<p>另外，Keychain 的数据并不存放在 App 的 Sanbox 中，即使删除了 App，资料依然保存在 keychain 中。如果重新安装了app，还可以从 keychain 获取数据。</p>\n<h3 id=\"同一个-App-内部共享\"><a href=\"#同一个-App-内部共享\" class=\"headerlink\" title=\"同一个 App 内部共享\"></a>同一个 App 内部共享</h3><p>类似 UserDefaults ，Keychain 也支持 Extension 和 host app 之间的共享，需要在每个 Target 的 Capability 下开启 Keychain Sharing 功能，并且设置为同一个 Group。</p>\n<h3 id=\"不同-App-之间共享\"><a href=\"#不同-App-之间共享\" class=\"headerlink\" title=\"不同 App 之间共享\"></a>不同 App 之间共享</h3><p>和 UserDefaults 不同的是，Keychain 的数据是可以跨 App 获取的，但是限于一个开发者的 App，也就是需要确保这些 App 所属的 Team ID 是相同的。</p>\n<p>这个也是App 进行 SSO 登录的基础，比如知乎日报使用知乎主 App 登录也是基于此原理。</p>\n<p><img src=\"https://i.imgur.com/0L2MA23.png\" alt=\"shared items\"></p>\n<p>在需要进行 Keychain 共享的 App 内开启 Keychain Sharing 的能力，所属同一个 Team ID 下的 App 本身都可以读取该 Keychain 的内容，类似于 AppGroup，这里也会产生 Keychain Group。</p>\n<blockquote>\n<p>Allows this application to share passwords from its keychain with other applications made by your team.</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/DJsInJb.png\" alt=\"Keychain Sharing\"></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"https://developer.apple.com/documentation/foundation/userdefaults\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/foundation/userdefaults</a></li>\n<li><a href=\"https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/\" target=\"_blank\" rel=\"noopener\">https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/</a></li>\n<li><a href=\"http://iphonedevwiki.net/index.php/PreferenceBundles\" target=\"_blank\" rel=\"noopener\">http://iphonedevwiki.net/index.php/PreferenceBundles</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html</a></li>\n<li><a href=\"https://developer.apple.com/documentation/security/keychain_services\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/security/keychain_services</a></li>\n<li><a href=\"https://github.com/soffes/SAMKeychain\" target=\"_blank\" rel=\"noopener\">https://github.com/soffes/SAMKeychain</a></li>\n<li><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps</a></li>\n</ol>\n"},{"title":"@autoclosure && @escape","date":"2017-11-12T12:01:54.000Z","_content":"\n我们知道在 `swift` 中，闭包（closure）是一等公民，因此可以被当作参数传递，在学习 swift 的过程中经常会看到某些关键字修饰该闭包，`@autoclosure`， `@escape` 就是其中比较常见的两种关键字。\n\n\n### @escape 和 @nonescape\n\n当一个闭包被当作参数传递给一个函数，但是当该函数内容执行完毕返回之后，该闭包才会被执行，我们就称该闭包要 escape 某个函数，那 `@escape` 关键字就是用来表示该闭包是允许在函数返回之后被调用的。\n\n我们用 swift 官方文档的例子来看，如下所示\n\n```\nvar completionHandlers: [() -> Void] = []\n\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n```\n\n`someFunctionWithEscapingClosure(_:)` 的参数是一个闭包，函数内部会把传入的闭包存到之前声明的数组里以便之后进行调用，可以看到，在函数参数的声明部分添加了 `@escaping` 关键字，如果这里不添加的话，就会在编译的时候报错：\n\n```\nerror: passing non-escaping parameter 'completionHandler' to function expecting an @escaping closure\n    completionHandlers.append(completionHandler)    \n```\n\n针对标记了 @escaping 关键字含义代表你必须在该闭包内部显式的使用 self 关键字，官方文档中又列举了另外一个例子，如下所示：\n\n```\nfunc someFunctionWithNonescapingClosure(closure: () -> Void) {\n    closure()\n}\n \nclass SomeClass {\n    var x = 10\n    func doSomething() {\n        someFunctionWithEscapingClosure { self.x = 100 }\n        someFunctionWithNonescapingClosure { x = 200 }\n    }\n}\n \nlet instance = SomeClass()\ninstance.doSomething()\nprint(instance.x)\n// Prints \"200\"\n \ncompletionHandlers.first?()\nprint(instance.x)\n// Prints \"100”\n```\n\n`someFunctionWithEscapingClosure(_:)` 是一个可逃逸的闭包，意味着你需要显示的调用 self 关键字， 而 `someFunctionWithNonescapingClosure(_:)` 是非逃逸的闭包，意味着你可以隐式的调用 self。\n\n\n### @autoclosure\n\n\n#### 例子讲解\n\n通过一个🌰来说明 `@autoclosure` 关键字到底起到什么作用。\n\n考虑下面这个函数 f，其需传入一个参数，类型是 `()-> Bool` 的闭包。\n\n```\nfunc f(predicate: () -> Bool) {\n    if predicate() {\n        print(\"It's true\")\n    }\n}\n```\n\n然后通过传入符合此类型的闭包进行调用\n\n```\nf(predicate: {2 > 1})\n// \"It's true\"\n```\n\n但是，如果我们忽略传入闭包的 `{` 和 `}` ，编译就会错误。\n\n```\nf(predicate: 2 > 1)\n// error: '>' produces 'Bool', not the expected contextual result type '() -> Bool'\n```\n\n如文档中所说，一个 autoclosure (自主闭包？)是这样一种闭包: 当某个表达式被当做参数传递给一个函数的时候会被 wrap 成一个闭包，该闭包没有任何参数，其被调用的时候，返回的是其 wrap 的表达式的值。swift 提供这种语法糖就能够让你省略 {} 而直接写一个表达式。\n\n结合上面的例子来看，当你写个表达式类似 2 > 1 传给函数 f 的时候，该表达式会被自动包裹到一个闭包中，会自动处理为 { 2 > 1 } 而传递给函数 f。\n\n```\nfunc f(predicate: @autoclosure () -> Bool) {\n    if predicate() {\n        print(\"It's true\")\n    }\n}\n\nf(predicate: 2 > 1)\n// It's true\n```\n\n⚠️ @autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -> T 的参数才能简化\n\n\n#### Delay Evaluation\n\nswift 提供了 ?? 操作符，如下所示：\n\n```\nlet nickName: String? = nil\nlet fullName: String = \"John Appleseed\"\nlet informalGreeting = \"Hi \\(nickName ?? fullName)\n```\n\n如果某 Optional 存在就会返回其值，如果没有就会返回后面的默认值，当我们去看 ?? 的实现的时候能看到如下定义：\n\n```\nfunc ??<T>(optional: T?, defaultValue: @autoclosure () -> T?) -> T?\n\nfunc ??<T>(optional: T?, defaultValue: @autoclosure () -> T) -> T\n```\n\n看得出来 `??` 是一个二元操作符，optional 指代 ?? 前面的输入，defaultValue 指代 `??` 后面的参数，那我们就会想，我们上面的例子中 `fullName` 只是一个 `String`，怎么变成 `() -> T` 类型的呢？ 这个就看前面的 `@autoclosure` 的威力了，前面讲过了，该关键字把表达式的值封装成闭包并且返回该表达式的值了。 其实传入该方法的第二个参数是 `{ fullName }`。\n\n所以可以想到该方法的实现应该如下所示，（当然 fullName 为 String 类型，应该会重载第二个函数实现）\n\n```\nfunc ??<T>(optional: T?, defaultValue: @autoclosure () -> T) -> T {\n    switch optional {\n        case .Some(let value):\n            return value\n        case .None:\n            return defaultValue()\n        }\n}\n```\n\n这里我们还需要注意一点的是，使用 `@autoclosure ` 来修饰的表达式可以实现延迟计算，也就是说直到该闭包被调用之前，闭包里所被包裹的表达式都不会进行取值计算，也就避免了一定的开销，尤其是上面默认值是复杂计算得到的话。\n\n\n","source":"_posts/autoclosure-escape.md","raw":"---\ntitle: '@autoclosure && @escape'\ndate: 2017-11-12 20:01:54\ncategories: Swift\ntags: [iOS,Swift]\n---\n\n我们知道在 `swift` 中，闭包（closure）是一等公民，因此可以被当作参数传递，在学习 swift 的过程中经常会看到某些关键字修饰该闭包，`@autoclosure`， `@escape` 就是其中比较常见的两种关键字。\n\n\n### @escape 和 @nonescape\n\n当一个闭包被当作参数传递给一个函数，但是当该函数内容执行完毕返回之后，该闭包才会被执行，我们就称该闭包要 escape 某个函数，那 `@escape` 关键字就是用来表示该闭包是允许在函数返回之后被调用的。\n\n我们用 swift 官方文档的例子来看，如下所示\n\n```\nvar completionHandlers: [() -> Void] = []\n\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n```\n\n`someFunctionWithEscapingClosure(_:)` 的参数是一个闭包，函数内部会把传入的闭包存到之前声明的数组里以便之后进行调用，可以看到，在函数参数的声明部分添加了 `@escaping` 关键字，如果这里不添加的话，就会在编译的时候报错：\n\n```\nerror: passing non-escaping parameter 'completionHandler' to function expecting an @escaping closure\n    completionHandlers.append(completionHandler)    \n```\n\n针对标记了 @escaping 关键字含义代表你必须在该闭包内部显式的使用 self 关键字，官方文档中又列举了另外一个例子，如下所示：\n\n```\nfunc someFunctionWithNonescapingClosure(closure: () -> Void) {\n    closure()\n}\n \nclass SomeClass {\n    var x = 10\n    func doSomething() {\n        someFunctionWithEscapingClosure { self.x = 100 }\n        someFunctionWithNonescapingClosure { x = 200 }\n    }\n}\n \nlet instance = SomeClass()\ninstance.doSomething()\nprint(instance.x)\n// Prints \"200\"\n \ncompletionHandlers.first?()\nprint(instance.x)\n// Prints \"100”\n```\n\n`someFunctionWithEscapingClosure(_:)` 是一个可逃逸的闭包，意味着你需要显示的调用 self 关键字， 而 `someFunctionWithNonescapingClosure(_:)` 是非逃逸的闭包，意味着你可以隐式的调用 self。\n\n\n### @autoclosure\n\n\n#### 例子讲解\n\n通过一个🌰来说明 `@autoclosure` 关键字到底起到什么作用。\n\n考虑下面这个函数 f，其需传入一个参数，类型是 `()-> Bool` 的闭包。\n\n```\nfunc f(predicate: () -> Bool) {\n    if predicate() {\n        print(\"It's true\")\n    }\n}\n```\n\n然后通过传入符合此类型的闭包进行调用\n\n```\nf(predicate: {2 > 1})\n// \"It's true\"\n```\n\n但是，如果我们忽略传入闭包的 `{` 和 `}` ，编译就会错误。\n\n```\nf(predicate: 2 > 1)\n// error: '>' produces 'Bool', not the expected contextual result type '() -> Bool'\n```\n\n如文档中所说，一个 autoclosure (自主闭包？)是这样一种闭包: 当某个表达式被当做参数传递给一个函数的时候会被 wrap 成一个闭包，该闭包没有任何参数，其被调用的时候，返回的是其 wrap 的表达式的值。swift 提供这种语法糖就能够让你省略 {} 而直接写一个表达式。\n\n结合上面的例子来看，当你写个表达式类似 2 > 1 传给函数 f 的时候，该表达式会被自动包裹到一个闭包中，会自动处理为 { 2 > 1 } 而传递给函数 f。\n\n```\nfunc f(predicate: @autoclosure () -> Bool) {\n    if predicate() {\n        print(\"It's true\")\n    }\n}\n\nf(predicate: 2 > 1)\n// It's true\n```\n\n⚠️ @autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -> T 的参数才能简化\n\n\n#### Delay Evaluation\n\nswift 提供了 ?? 操作符，如下所示：\n\n```\nlet nickName: String? = nil\nlet fullName: String = \"John Appleseed\"\nlet informalGreeting = \"Hi \\(nickName ?? fullName)\n```\n\n如果某 Optional 存在就会返回其值，如果没有就会返回后面的默认值，当我们去看 ?? 的实现的时候能看到如下定义：\n\n```\nfunc ??<T>(optional: T?, defaultValue: @autoclosure () -> T?) -> T?\n\nfunc ??<T>(optional: T?, defaultValue: @autoclosure () -> T) -> T\n```\n\n看得出来 `??` 是一个二元操作符，optional 指代 ?? 前面的输入，defaultValue 指代 `??` 后面的参数，那我们就会想，我们上面的例子中 `fullName` 只是一个 `String`，怎么变成 `() -> T` 类型的呢？ 这个就看前面的 `@autoclosure` 的威力了，前面讲过了，该关键字把表达式的值封装成闭包并且返回该表达式的值了。 其实传入该方法的第二个参数是 `{ fullName }`。\n\n所以可以想到该方法的实现应该如下所示，（当然 fullName 为 String 类型，应该会重载第二个函数实现）\n\n```\nfunc ??<T>(optional: T?, defaultValue: @autoclosure () -> T) -> T {\n    switch optional {\n        case .Some(let value):\n            return value\n        case .None:\n            return defaultValue()\n        }\n}\n```\n\n这里我们还需要注意一点的是，使用 `@autoclosure ` 来修饰的表达式可以实现延迟计算，也就是说直到该闭包被调用之前，闭包里所被包裹的表达式都不会进行取值计算，也就避免了一定的开销，尤其是上面默认值是复杂计算得到的话。\n\n\n","slug":"autoclosure-escape","published":1,"updated":"2019-01-23T04:16:40.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwu000p79poubxwooz6","content":"<p>我们知道在 <code>swift</code> 中，闭包（closure）是一等公民，因此可以被当作参数传递，在学习 swift 的过程中经常会看到某些关键字修饰该闭包，<code>@autoclosure</code>， <code>@escape</code> 就是其中比较常见的两种关键字。</p>\n<h3 id=\"escape-和-nonescape\"><a href=\"#escape-和-nonescape\" class=\"headerlink\" title=\"@escape 和 @nonescape\"></a>@escape 和 @nonescape</h3><p>当一个闭包被当作参数传递给一个函数，但是当该函数内容执行完毕返回之后，该闭包才会被执行，我们就称该闭包要 escape 某个函数，那 <code>@escape</code> 关键字就是用来表示该闭包是允许在函数返回之后被调用的。</p>\n<p>我们用 swift 官方文档的例子来看，如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var completionHandlers: [() -&gt; Void] = []</span><br><span class=\"line\"></span><br><span class=\"line\">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class=\"line\">    completionHandlers.append(completionHandler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>someFunctionWithEscapingClosure(_:)</code> 的参数是一个闭包，函数内部会把传入的闭包存到之前声明的数组里以便之后进行调用，可以看到，在函数参数的声明部分添加了 <code>@escaping</code> 关键字，如果这里不添加的话，就会在编译的时候报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: passing non-escaping parameter &apos;completionHandler&apos; to function expecting an @escaping closure</span><br><span class=\"line\">    completionHandlers.append(completionHandler)</span><br></pre></td></tr></table></figure>\n<p>针对标记了 @escaping 关键字含义代表你必须在该闭包内部显式的使用 self 关键字，官方文档中又列举了另外一个例子，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123;</span><br><span class=\"line\">    closure()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">class SomeClass &#123;</span><br><span class=\"line\">    var x = 10</span><br><span class=\"line\">    func doSomething() &#123;</span><br><span class=\"line\">        someFunctionWithEscapingClosure &#123; self.x = 100 &#125;</span><br><span class=\"line\">        someFunctionWithNonescapingClosure &#123; x = 200 &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">let instance = SomeClass()</span><br><span class=\"line\">instance.doSomething()</span><br><span class=\"line\">print(instance.x)</span><br><span class=\"line\">// Prints &quot;200&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">completionHandlers.first?()</span><br><span class=\"line\">print(instance.x)</span><br><span class=\"line\">// Prints &quot;100”</span><br></pre></td></tr></table></figure>\n<p><code>someFunctionWithEscapingClosure(_:)</code> 是一个可逃逸的闭包，意味着你需要显示的调用 self 关键字， 而 <code>someFunctionWithNonescapingClosure(_:)</code> 是非逃逸的闭包，意味着你可以隐式的调用 self。</p>\n<h3 id=\"autoclosure\"><a href=\"#autoclosure\" class=\"headerlink\" title=\"@autoclosure\"></a>@autoclosure</h3><h4 id=\"例子讲解\"><a href=\"#例子讲解\" class=\"headerlink\" title=\"例子讲解\"></a>例子讲解</h4><p>通过一个🌰来说明 <code>@autoclosure</code> 关键字到底起到什么作用。</p>\n<p>考虑下面这个函数 f，其需传入一个参数，类型是 <code>()-&gt; Bool</code> 的闭包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func f(predicate: () -&gt; Bool) &#123;</span><br><span class=\"line\">    if predicate() &#123;</span><br><span class=\"line\">        print(&quot;It&apos;s true&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后通过传入符合此类型的闭包进行调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(predicate: &#123;2 &gt; 1&#125;)</span><br><span class=\"line\">// &quot;It&apos;s true&quot;</span><br></pre></td></tr></table></figure>\n<p>但是，如果我们忽略传入闭包的 <code>{</code> 和 <code>}</code> ，编译就会错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(predicate: 2 &gt; 1)</span><br><span class=\"line\">// error: &apos;&gt;&apos; produces &apos;Bool&apos;, not the expected contextual result type &apos;() -&gt; Bool&apos;</span><br></pre></td></tr></table></figure>\n<p>如文档中所说，一个 autoclosure (自主闭包？)是这样一种闭包: 当某个表达式被当做参数传递给一个函数的时候会被 wrap 成一个闭包，该闭包没有任何参数，其被调用的时候，返回的是其 wrap 的表达式的值。swift 提供这种语法糖就能够让你省略 {} 而直接写一个表达式。</p>\n<p>结合上面的例子来看，当你写个表达式类似 2 &gt; 1 传给函数 f 的时候，该表达式会被自动包裹到一个闭包中，会自动处理为 { 2 &gt; 1 } 而传递给函数 f。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func f(predicate: @autoclosure () -&gt; Bool) &#123;</span><br><span class=\"line\">    if predicate() &#123;</span><br><span class=\"line\">        print(&quot;It&apos;s true&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(predicate: 2 &gt; 1)</span><br><span class=\"line\">// It&apos;s true</span><br></pre></td></tr></table></figure>\n<p>⚠️ @autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -&gt; T 的参数才能简化</p>\n<h4 id=\"Delay-Evaluation\"><a href=\"#Delay-Evaluation\" class=\"headerlink\" title=\"Delay Evaluation\"></a>Delay Evaluation</h4><p>swift 提供了 ?? 操作符，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let nickName: String? = nil</span><br><span class=\"line\">let fullName: String = &quot;John Appleseed&quot;</span><br><span class=\"line\">let informalGreeting = &quot;Hi \\(nickName ?? fullName)</span><br></pre></td></tr></table></figure>\n<p>如果某 Optional 存在就会返回其值，如果没有就会返回后面的默认值，当我们去看 ?? 的实现的时候能看到如下定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T?) -&gt; T?</span><br><span class=\"line\"></span><br><span class=\"line\">func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T) -&gt; T</span><br></pre></td></tr></table></figure>\n<p>看得出来 <code>??</code> 是一个二元操作符，optional 指代 ?? 前面的输入，defaultValue 指代 <code>??</code> 后面的参数，那我们就会想，我们上面的例子中 <code>fullName</code> 只是一个 <code>String</code>，怎么变成 <code>() -&gt; T</code> 类型的呢？ 这个就看前面的 <code>@autoclosure</code> 的威力了，前面讲过了，该关键字把表达式的值封装成闭包并且返回该表达式的值了。 其实传入该方法的第二个参数是 <code>{ fullName }</code>。</p>\n<p>所以可以想到该方法的实现应该如下所示，（当然 fullName 为 String 类型，应该会重载第二个函数实现）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T) -&gt; T &#123;</span><br><span class=\"line\">    switch optional &#123;</span><br><span class=\"line\">        case .Some(let value):</span><br><span class=\"line\">            return value</span><br><span class=\"line\">        case .None:</span><br><span class=\"line\">            return defaultValue()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们还需要注意一点的是，使用 <code>@autoclosure</code> 来修饰的表达式可以实现延迟计算，也就是说直到该闭包被调用之前，闭包里所被包裹的表达式都不会进行取值计算，也就避免了一定的开销，尤其是上面默认值是复杂计算得到的话。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>我们知道在 <code>swift</code> 中，闭包（closure）是一等公民，因此可以被当作参数传递，在学习 swift 的过程中经常会看到某些关键字修饰该闭包，<code>@autoclosure</code>， <code>@escape</code> 就是其中比较常见的两种关键字。</p>\n<h3 id=\"escape-和-nonescape\"><a href=\"#escape-和-nonescape\" class=\"headerlink\" title=\"@escape 和 @nonescape\"></a>@escape 和 @nonescape</h3><p>当一个闭包被当作参数传递给一个函数，但是当该函数内容执行完毕返回之后，该闭包才会被执行，我们就称该闭包要 escape 某个函数，那 <code>@escape</code> 关键字就是用来表示该闭包是允许在函数返回之后被调用的。</p>\n<p>我们用 swift 官方文档的例子来看，如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var completionHandlers: [() -&gt; Void] = []</span><br><span class=\"line\"></span><br><span class=\"line\">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class=\"line\">    completionHandlers.append(completionHandler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>someFunctionWithEscapingClosure(_:)</code> 的参数是一个闭包，函数内部会把传入的闭包存到之前声明的数组里以便之后进行调用，可以看到，在函数参数的声明部分添加了 <code>@escaping</code> 关键字，如果这里不添加的话，就会在编译的时候报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: passing non-escaping parameter &apos;completionHandler&apos; to function expecting an @escaping closure</span><br><span class=\"line\">    completionHandlers.append(completionHandler)</span><br></pre></td></tr></table></figure>\n<p>针对标记了 @escaping 关键字含义代表你必须在该闭包内部显式的使用 self 关键字，官方文档中又列举了另外一个例子，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123;</span><br><span class=\"line\">    closure()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">class SomeClass &#123;</span><br><span class=\"line\">    var x = 10</span><br><span class=\"line\">    func doSomething() &#123;</span><br><span class=\"line\">        someFunctionWithEscapingClosure &#123; self.x = 100 &#125;</span><br><span class=\"line\">        someFunctionWithNonescapingClosure &#123; x = 200 &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">let instance = SomeClass()</span><br><span class=\"line\">instance.doSomething()</span><br><span class=\"line\">print(instance.x)</span><br><span class=\"line\">// Prints &quot;200&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">completionHandlers.first?()</span><br><span class=\"line\">print(instance.x)</span><br><span class=\"line\">// Prints &quot;100”</span><br></pre></td></tr></table></figure>\n<p><code>someFunctionWithEscapingClosure(_:)</code> 是一个可逃逸的闭包，意味着你需要显示的调用 self 关键字， 而 <code>someFunctionWithNonescapingClosure(_:)</code> 是非逃逸的闭包，意味着你可以隐式的调用 self。</p>\n<h3 id=\"autoclosure\"><a href=\"#autoclosure\" class=\"headerlink\" title=\"@autoclosure\"></a>@autoclosure</h3><h4 id=\"例子讲解\"><a href=\"#例子讲解\" class=\"headerlink\" title=\"例子讲解\"></a>例子讲解</h4><p>通过一个🌰来说明 <code>@autoclosure</code> 关键字到底起到什么作用。</p>\n<p>考虑下面这个函数 f，其需传入一个参数，类型是 <code>()-&gt; Bool</code> 的闭包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func f(predicate: () -&gt; Bool) &#123;</span><br><span class=\"line\">    if predicate() &#123;</span><br><span class=\"line\">        print(&quot;It&apos;s true&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后通过传入符合此类型的闭包进行调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(predicate: &#123;2 &gt; 1&#125;)</span><br><span class=\"line\">// &quot;It&apos;s true&quot;</span><br></pre></td></tr></table></figure>\n<p>但是，如果我们忽略传入闭包的 <code>{</code> 和 <code>}</code> ，编译就会错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(predicate: 2 &gt; 1)</span><br><span class=\"line\">// error: &apos;&gt;&apos; produces &apos;Bool&apos;, not the expected contextual result type &apos;() -&gt; Bool&apos;</span><br></pre></td></tr></table></figure>\n<p>如文档中所说，一个 autoclosure (自主闭包？)是这样一种闭包: 当某个表达式被当做参数传递给一个函数的时候会被 wrap 成一个闭包，该闭包没有任何参数，其被调用的时候，返回的是其 wrap 的表达式的值。swift 提供这种语法糖就能够让你省略 {} 而直接写一个表达式。</p>\n<p>结合上面的例子来看，当你写个表达式类似 2 &gt; 1 传给函数 f 的时候，该表达式会被自动包裹到一个闭包中，会自动处理为 { 2 &gt; 1 } 而传递给函数 f。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func f(predicate: @autoclosure () -&gt; Bool) &#123;</span><br><span class=\"line\">    if predicate() &#123;</span><br><span class=\"line\">        print(&quot;It&apos;s true&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(predicate: 2 &gt; 1)</span><br><span class=\"line\">// It&apos;s true</span><br></pre></td></tr></table></figure>\n<p>⚠️ @autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -&gt; T 的参数才能简化</p>\n<h4 id=\"Delay-Evaluation\"><a href=\"#Delay-Evaluation\" class=\"headerlink\" title=\"Delay Evaluation\"></a>Delay Evaluation</h4><p>swift 提供了 ?? 操作符，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let nickName: String? = nil</span><br><span class=\"line\">let fullName: String = &quot;John Appleseed&quot;</span><br><span class=\"line\">let informalGreeting = &quot;Hi \\(nickName ?? fullName)</span><br></pre></td></tr></table></figure>\n<p>如果某 Optional 存在就会返回其值，如果没有就会返回后面的默认值，当我们去看 ?? 的实现的时候能看到如下定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T?) -&gt; T?</span><br><span class=\"line\"></span><br><span class=\"line\">func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T) -&gt; T</span><br></pre></td></tr></table></figure>\n<p>看得出来 <code>??</code> 是一个二元操作符，optional 指代 ?? 前面的输入，defaultValue 指代 <code>??</code> 后面的参数，那我们就会想，我们上面的例子中 <code>fullName</code> 只是一个 <code>String</code>，怎么变成 <code>() -&gt; T</code> 类型的呢？ 这个就看前面的 <code>@autoclosure</code> 的威力了，前面讲过了，该关键字把表达式的值封装成闭包并且返回该表达式的值了。 其实传入该方法的第二个参数是 <code>{ fullName }</code>。</p>\n<p>所以可以想到该方法的实现应该如下所示，（当然 fullName 为 String 类型，应该会重载第二个函数实现）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T) -&gt; T &#123;</span><br><span class=\"line\">    switch optional &#123;</span><br><span class=\"line\">        case .Some(let value):</span><br><span class=\"line\">            return value</span><br><span class=\"line\">        case .None:</span><br><span class=\"line\">            return defaultValue()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们还需要注意一点的是，使用 <code>@autoclosure</code> 来修饰的表达式可以实现延迟计算，也就是说直到该闭包被调用之前，闭包里所被包裹的表达式都不会进行取值计算，也就避免了一定的开销，尤其是上面默认值是复杂计算得到的话。</p>\n"},{"title":"leetCode[001]Maximum Product Subarray","date":"2015-04-29T03:30:00.000Z","_content":"\n### 题目：\n Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n\t\t For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.\n\n<!-- more -->\n\n### 题意：\n\n题目中给出一个（至少包含一个元素）整形数组，求一个子数组（元素连续），使得其元素之积最大。最直接了当的方法，当然是暴力穷举，但是其O(n^2)是无法通过LeetCode的OJ的，而且从自己平时接触到得面试题而言，直截了当的暴力解法往往不是真正的解决思路。\n\nC语言实现如下：\n\n    int maxProduct(int* nums, int numsSize) {\n            int nMaxPro = nums[0];\n            int max_tmp = nums[0];\n            int min_tmp = nums[0];\n\n            for(int i = 1; i< numsSize; ++i){\n                int a = nums[i] * max_tmp;\n                int b = nums[i] * min_tmp;\n\n                max_tmp = (( a > b ? a : b ) > nums[i]) ? ( a > b ? a : b ) : nums[i];\n                min_tmp = (( a < b ? a : b ) < nums[i]) ? ( a < b ? a : b ) : nums[i];\n\n                nMaxPro = (nMaxPro > max_tmp) ? nMaxPro : max_tmp;\n            }\n\n            return nMaxPro;\n\t}\n\nleetCode Oj系统评判结果如下图所示：\n\n![leetCode C](http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C.png)\n\nC++实现如下：\n\n    class Solution {\n\t\tpublic:\n\t\t    int maxProduct(vector<int>& nums) {\n\t            int nMaxPro = nums[0];\n\t            int max_tmp = nums[0];\n\t            int min_tmp = nums[0];\n\n\t            for(int i = 1; i< nums.size(); ++i){\n\t                int a = nums[i] * max_tmp;\n\t                int b = nums[i] * min_tmp;\n\n\t                max_tmp = (( a > b ? a : b ) > nums[i]) ? ( a > b ? a : b ) : nums[i];\n\t                min_tmp = (( a < b ? a : b ) < nums[i]) ? ( a < b ? a : b ) : nums[i];\n\n\t                nMaxPro = (nMaxPro > max_tmp) ? nMaxPro : max_tmp;\n\t            }\n\n\t            return nMaxPro;\n\t\t    }\n\t};\n\nleetCode的OJ系统评判结果如下图所示：\n\n![leetCode C++](http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C++.png)\n\n\nJava实现如下：\n\n\tpublic class Solution {\n\t\t public int maxProduct(int[] nums) {\n            int nMaxPro = nums[0];\n            int max_tmp = nums[0];\n            int min_tmp = nums[0];\n\n            for(int i = 1; i< nums.length; ++i){\n                int a = nums[i] * max_tmp;\n                int b = nums[i] * min_tmp;\n\n                max_tmp = (( a > b ? a : b ) > nums[i]) ? ( a > b ? a : b ) : nums[i];\n                min_tmp = (( a < b ? a : b ) < nums[i]) ? ( a < b ? a : b ) : nums[i];\n\n                nMaxPro = (nMaxPro > max_tmp) ? nMaxPro : max_tmp;\n            }\n\n            return nMaxPro;\n\t    }\n\t}\n\nleetCode的OJ系统评判结果如下所示：\n\n![leetCode Java](http://7xilk1.com1.z0.glb.clouddn.com/leetCode001Java.png)\n\n","source":"_posts/leetCode-001-Maximum-Product-Subarray.md","raw":"title: \"leetCode[001]Maximum Product Subarray\"\ndate: 2015-04-29 11:30:00\ncategories: LeetCode\ntags: [Algorithm,Array]\n---\n\n### 题目：\n Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n\t\t For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.\n\n<!-- more -->\n\n### 题意：\n\n题目中给出一个（至少包含一个元素）整形数组，求一个子数组（元素连续），使得其元素之积最大。最直接了当的方法，当然是暴力穷举，但是其O(n^2)是无法通过LeetCode的OJ的，而且从自己平时接触到得面试题而言，直截了当的暴力解法往往不是真正的解决思路。\n\nC语言实现如下：\n\n    int maxProduct(int* nums, int numsSize) {\n            int nMaxPro = nums[0];\n            int max_tmp = nums[0];\n            int min_tmp = nums[0];\n\n            for(int i = 1; i< numsSize; ++i){\n                int a = nums[i] * max_tmp;\n                int b = nums[i] * min_tmp;\n\n                max_tmp = (( a > b ? a : b ) > nums[i]) ? ( a > b ? a : b ) : nums[i];\n                min_tmp = (( a < b ? a : b ) < nums[i]) ? ( a < b ? a : b ) : nums[i];\n\n                nMaxPro = (nMaxPro > max_tmp) ? nMaxPro : max_tmp;\n            }\n\n            return nMaxPro;\n\t}\n\nleetCode Oj系统评判结果如下图所示：\n\n![leetCode C](http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C.png)\n\nC++实现如下：\n\n    class Solution {\n\t\tpublic:\n\t\t    int maxProduct(vector<int>& nums) {\n\t            int nMaxPro = nums[0];\n\t            int max_tmp = nums[0];\n\t            int min_tmp = nums[0];\n\n\t            for(int i = 1; i< nums.size(); ++i){\n\t                int a = nums[i] * max_tmp;\n\t                int b = nums[i] * min_tmp;\n\n\t                max_tmp = (( a > b ? a : b ) > nums[i]) ? ( a > b ? a : b ) : nums[i];\n\t                min_tmp = (( a < b ? a : b ) < nums[i]) ? ( a < b ? a : b ) : nums[i];\n\n\t                nMaxPro = (nMaxPro > max_tmp) ? nMaxPro : max_tmp;\n\t            }\n\n\t            return nMaxPro;\n\t\t    }\n\t};\n\nleetCode的OJ系统评判结果如下图所示：\n\n![leetCode C++](http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C++.png)\n\n\nJava实现如下：\n\n\tpublic class Solution {\n\t\t public int maxProduct(int[] nums) {\n            int nMaxPro = nums[0];\n            int max_tmp = nums[0];\n            int min_tmp = nums[0];\n\n            for(int i = 1; i< nums.length; ++i){\n                int a = nums[i] * max_tmp;\n                int b = nums[i] * min_tmp;\n\n                max_tmp = (( a > b ? a : b ) > nums[i]) ? ( a > b ? a : b ) : nums[i];\n                min_tmp = (( a < b ? a : b ) < nums[i]) ? ( a < b ? a : b ) : nums[i];\n\n                nMaxPro = (nMaxPro > max_tmp) ? nMaxPro : max_tmp;\n            }\n\n            return nMaxPro;\n\t    }\n\t}\n\nleetCode的OJ系统评判结果如下所示：\n\n![leetCode Java](http://7xilk1.com1.z0.glb.clouddn.com/leetCode001Java.png)\n\n","slug":"leetCode-001-Maximum-Product-Subarray","published":1,"updated":"2018-05-02T10:43:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frww000t79powqopfvoq","content":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p> Find the contiguous subarray within an array (containing at least one number) which has the largest product.<br>         For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.</p>\n<a id=\"more\"></a>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>题目中给出一个（至少包含一个元素）整形数组，求一个子数组（元素连续），使得其元素之积最大。最直接了当的方法，当然是暴力穷举，但是其O(n^2)是无法通过LeetCode的OJ的，而且从自己平时接触到得面试题而言，直截了当的暴力解法往往不是真正的解决思路。</p>\n<p>C语言实现如下：</p>\n<pre><code>int maxProduct(int* nums, int numsSize) {\n        int nMaxPro = nums[0];\n        int max_tmp = nums[0];\n        int min_tmp = nums[0];\n\n        for(int i = 1; i&lt; numsSize; ++i){\n            int a = nums[i] * max_tmp;\n            int b = nums[i] * min_tmp;\n\n            max_tmp = (( a &gt; b ? a : b ) &gt; nums[i]) ? ( a &gt; b ? a : b ) : nums[i];\n            min_tmp = (( a &lt; b ? a : b ) &lt; nums[i]) ? ( a &lt; b ? a : b ) : nums[i];\n\n            nMaxPro = (nMaxPro &gt; max_tmp) ? nMaxPro : max_tmp;\n        }\n\n        return nMaxPro;\n}\n</code></pre><p>leetCode Oj系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C.png\" alt=\"leetCode C\"></p>\n<p>C++实现如下：</p>\n<pre><code>class Solution {\n    public:\n        int maxProduct(vector&lt;int&gt;&amp; nums) {\n            int nMaxPro = nums[0];\n            int max_tmp = nums[0];\n            int min_tmp = nums[0];\n\n            for(int i = 1; i&lt; nums.size(); ++i){\n                int a = nums[i] * max_tmp;\n                int b = nums[i] * min_tmp;\n\n                max_tmp = (( a &gt; b ? a : b ) &gt; nums[i]) ? ( a &gt; b ? a : b ) : nums[i];\n                min_tmp = (( a &lt; b ? a : b ) &lt; nums[i]) ? ( a &lt; b ? a : b ) : nums[i];\n\n                nMaxPro = (nMaxPro &gt; max_tmp) ? nMaxPro : max_tmp;\n            }\n\n            return nMaxPro;\n        }\n};\n</code></pre><p>leetCode的OJ系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C++.png\" alt=\"leetCode C++\"></p>\n<p>Java实现如下：</p>\n<pre><code>public class Solution {\n     public int maxProduct(int[] nums) {\n        int nMaxPro = nums[0];\n        int max_tmp = nums[0];\n        int min_tmp = nums[0];\n\n        for(int i = 1; i&lt; nums.length; ++i){\n            int a = nums[i] * max_tmp;\n            int b = nums[i] * min_tmp;\n\n            max_tmp = (( a &gt; b ? a : b ) &gt; nums[i]) ? ( a &gt; b ? a : b ) : nums[i];\n            min_tmp = (( a &lt; b ? a : b ) &lt; nums[i]) ? ( a &lt; b ? a : b ) : nums[i];\n\n            nMaxPro = (nMaxPro &gt; max_tmp) ? nMaxPro : max_tmp;\n        }\n\n        return nMaxPro;\n    }\n}\n</code></pre><p>leetCode的OJ系统评判结果如下所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode001Java.png\" alt=\"leetCode Java\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p> Find the contiguous subarray within an array (containing at least one number) which has the largest product.<br>         For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.</p>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>题目中给出一个（至少包含一个元素）整形数组，求一个子数组（元素连续），使得其元素之积最大。最直接了当的方法，当然是暴力穷举，但是其O(n^2)是无法通过LeetCode的OJ的，而且从自己平时接触到得面试题而言，直截了当的暴力解法往往不是真正的解决思路。</p>\n<p>C语言实现如下：</p>\n<pre><code>int maxProduct(int* nums, int numsSize) {\n        int nMaxPro = nums[0];\n        int max_tmp = nums[0];\n        int min_tmp = nums[0];\n\n        for(int i = 1; i&lt; numsSize; ++i){\n            int a = nums[i] * max_tmp;\n            int b = nums[i] * min_tmp;\n\n            max_tmp = (( a &gt; b ? a : b ) &gt; nums[i]) ? ( a &gt; b ? a : b ) : nums[i];\n            min_tmp = (( a &lt; b ? a : b ) &lt; nums[i]) ? ( a &lt; b ? a : b ) : nums[i];\n\n            nMaxPro = (nMaxPro &gt; max_tmp) ? nMaxPro : max_tmp;\n        }\n\n        return nMaxPro;\n}\n</code></pre><p>leetCode Oj系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C.png\" alt=\"leetCode C\"></p>\n<p>C++实现如下：</p>\n<pre><code>class Solution {\n    public:\n        int maxProduct(vector&lt;int&gt;&amp; nums) {\n            int nMaxPro = nums[0];\n            int max_tmp = nums[0];\n            int min_tmp = nums[0];\n\n            for(int i = 1; i&lt; nums.size(); ++i){\n                int a = nums[i] * max_tmp;\n                int b = nums[i] * min_tmp;\n\n                max_tmp = (( a &gt; b ? a : b ) &gt; nums[i]) ? ( a &gt; b ? a : b ) : nums[i];\n                min_tmp = (( a &lt; b ? a : b ) &lt; nums[i]) ? ( a &lt; b ? a : b ) : nums[i];\n\n                nMaxPro = (nMaxPro &gt; max_tmp) ? nMaxPro : max_tmp;\n            }\n\n            return nMaxPro;\n        }\n};\n</code></pre><p>leetCode的OJ系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode001C++.png\" alt=\"leetCode C++\"></p>\n<p>Java实现如下：</p>\n<pre><code>public class Solution {\n     public int maxProduct(int[] nums) {\n        int nMaxPro = nums[0];\n        int max_tmp = nums[0];\n        int min_tmp = nums[0];\n\n        for(int i = 1; i&lt; nums.length; ++i){\n            int a = nums[i] * max_tmp;\n            int b = nums[i] * min_tmp;\n\n            max_tmp = (( a &gt; b ? a : b ) &gt; nums[i]) ? ( a &gt; b ? a : b ) : nums[i];\n            min_tmp = (( a &lt; b ? a : b ) &lt; nums[i]) ? ( a &lt; b ? a : b ) : nums[i];\n\n            nMaxPro = (nMaxPro &gt; max_tmp) ? nMaxPro : max_tmp;\n        }\n\n        return nMaxPro;\n    }\n}\n</code></pre><p>leetCode的OJ系统评判结果如下所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode001Java.png\" alt=\"leetCode Java\"></p>"},{"title":"leetCode[002]Reverse Words in a String","date":"2015-05-01T01:29:09.000Z","_content":"\n### 题目：Reverse Words in a String\n\nGiven an input string s, reverse the string word by word.\nFor example, given s = \"the sky is blue\", return \"blue is sky the\".\n\n<!-- more -->\n\n### 题意：\n题意很明确，将字符串中的单词进行翻转，形成新的字符串。但是这其中有几个问题我们需要思考（参考leetCode官方CleanCodeBook）：\n\nQ: What constitutes a word?\nA: A sequence of non-space characters constitutes a word.\n\nQ: Does tab or newline character count as space characters?\nA: Assume the input does not contain any tabs or newline characters.\n\nQ: Could the input string contain leading or trailing spaces?\nA: Yes. However, your reversed string should not contain leading or trailing spaces.\n\nQ: How about multiple spaces between two words?\nA: Reduce them to a single space in the reversed string.\n\n#### 解法：\n\n``` C++\nclass Solution {\npublic:\n\tvoid reverseWords(std::string &s) {\t\t\n\t    std::string reversed(\"\");\n\t\tint j = s.length();\n\n\t\tfor (int i = s.length() - 1; i >= 0; --i) {\n\t\t\tif(s.at(i) == ' ') j = i;\n\t\t\telse if (i == 0 || s.at(i - 1) == ' '){\n\t\t\t\tif (reversed.length() != 0) reversed += ' ';\n\t\t\t\treversed += s.substr(i, j - i);\n\t\t\t}\n\t\t}\n\t\ts = reversed;\n\t}\n};\n```\n\n\nleetCode的OJ系统评判结果：\n![leetCode C++  Solution3](http://7xilk1.com1.z0.glb.clouddn.com/leetCode_ReverseWordsInAString_C++.png)\n\n","source":"_posts/leetCode-002-Reverse-Words-in-a-String.md","raw":"title: \"leetCode[002]Reverse Words in a String\"\ndate: 2015-05-01 09:29:09\ncategories: LeetCode\ntags: [Algorithm,String]\n---\n\n### 题目：Reverse Words in a String\n\nGiven an input string s, reverse the string word by word.\nFor example, given s = \"the sky is blue\", return \"blue is sky the\".\n\n<!-- more -->\n\n### 题意：\n题意很明确，将字符串中的单词进行翻转，形成新的字符串。但是这其中有几个问题我们需要思考（参考leetCode官方CleanCodeBook）：\n\nQ: What constitutes a word?\nA: A sequence of non-space characters constitutes a word.\n\nQ: Does tab or newline character count as space characters?\nA: Assume the input does not contain any tabs or newline characters.\n\nQ: Could the input string contain leading or trailing spaces?\nA: Yes. However, your reversed string should not contain leading or trailing spaces.\n\nQ: How about multiple spaces between two words?\nA: Reduce them to a single space in the reversed string.\n\n#### 解法：\n\n``` C++\nclass Solution {\npublic:\n\tvoid reverseWords(std::string &s) {\t\t\n\t    std::string reversed(\"\");\n\t\tint j = s.length();\n\n\t\tfor (int i = s.length() - 1; i >= 0; --i) {\n\t\t\tif(s.at(i) == ' ') j = i;\n\t\t\telse if (i == 0 || s.at(i - 1) == ' '){\n\t\t\t\tif (reversed.length() != 0) reversed += ' ';\n\t\t\t\treversed += s.substr(i, j - i);\n\t\t\t}\n\t\t}\n\t\ts = reversed;\n\t}\n};\n```\n\n\nleetCode的OJ系统评判结果：\n![leetCode C++  Solution3](http://7xilk1.com1.z0.glb.clouddn.com/leetCode_ReverseWordsInAString_C++.png)\n\n","slug":"leetCode-002-Reverse-Words-in-a-String","published":1,"updated":"2018-05-02T10:50:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frwy000v79po4kz32kdu","content":"<h3 id=\"题目：Reverse-Words-in-a-String\"><a href=\"#题目：Reverse-Words-in-a-String\" class=\"headerlink\" title=\"题目：Reverse Words in a String\"></a>题目：Reverse Words in a String</h3><p>Given an input string s, reverse the string word by word.<br>For example, given s = “the sky is blue”, return “blue is sky the”.</p>\n<a id=\"more\"></a>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>题意很明确，将字符串中的单词进行翻转，形成新的字符串。但是这其中有几个问题我们需要思考（参考leetCode官方CleanCodeBook）：</p>\n<p>Q: What constitutes a word?<br>A: A sequence of non-space characters constitutes a word.</p>\n<p>Q: Does tab or newline character count as space characters?<br>A: Assume the input does not contain any tabs or newline characters.</p>\n<p>Q: Could the input string contain leading or trailing spaces?<br>A: Yes. However, your reversed string should not contain leading or trailing spaces.</p>\n<p>Q: How about multiple spaces between two words?<br>A: Reduce them to a single space in the reversed string.</p>\n<h4 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverseWords</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;\t\t</span><br><span class=\"line\">\t    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reversed</span><span class=\"params\">(<span class=\"string\">\"\"</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> j = s.length();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = s.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(s.at(i) == <span class=\"string\">' '</span>) j = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || s.at(i - <span class=\"number\">1</span>) == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (reversed.length() != <span class=\"number\">0</span>) reversed += <span class=\"string\">' '</span>;</span><br><span class=\"line\">\t\t\t\treversed += s.substr(i, j - i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ts = reversed;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>leetCode的OJ系统评判结果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode_ReverseWordsInAString_C++.png\" alt=\"leetCode C++  Solution3\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"题目：Reverse-Words-in-a-String\"><a href=\"#题目：Reverse-Words-in-a-String\" class=\"headerlink\" title=\"题目：Reverse Words in a String\"></a>题目：Reverse Words in a String</h3><p>Given an input string s, reverse the string word by word.<br>For example, given s = “the sky is blue”, return “blue is sky the”.</p>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>题意很明确，将字符串中的单词进行翻转，形成新的字符串。但是这其中有几个问题我们需要思考（参考leetCode官方CleanCodeBook）：</p>\n<p>Q: What constitutes a word?<br>A: A sequence of non-space characters constitutes a word.</p>\n<p>Q: Does tab or newline character count as space characters?<br>A: Assume the input does not contain any tabs or newline characters.</p>\n<p>Q: Could the input string contain leading or trailing spaces?<br>A: Yes. However, your reversed string should not contain leading or trailing spaces.</p>\n<p>Q: How about multiple spaces between two words?<br>A: Reduce them to a single space in the reversed string.</p>\n<h4 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverseWords</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;s)</span> </span>&#123;\t\t</span><br><span class=\"line\">\t    <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">reversed</span><span class=\"params\">(<span class=\"string\">\"\"</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> j = s.length();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = s.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(s.at(i) == <span class=\"string\">' '</span>) j = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || s.at(i - <span class=\"number\">1</span>) == <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (reversed.length() != <span class=\"number\">0</span>) reversed += <span class=\"string\">' '</span>;</span><br><span class=\"line\">\t\t\t\treversed += s.substr(i, j - i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ts = reversed;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>leetCode的OJ系统评判结果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode_ReverseWordsInAString_C++.png\" alt=\"leetCode C++  Solution3\"></p>"},{"title":"leetCode[002]Intersection of Two Linked lists","date":"2015-04-29T04:28:00.000Z","_content":"\n### 题目：Intersection of Two Linked lists\n\nWrite a program to find the node at which the intersection of two\nsingly linked lists begins.\n\n　　　　For example, the following two linked lists:\n\n　　　　　　A: a1 → a2\n　　　　　　　　　　　　↘\n　　　　　　　　　　　　   c1 → c2 → c3\n　　　　　　　　　　   ↗ 　　　\n\t  B: b1 → b2 → b3 　　\n\t　begin to intersect at node c1.\n\n　　Notes:\n　　　　1. If the two linked lists have no intersection at all, return null.\n　　　　2. The linked lists must retain their original structure after the function returns.\n　　　　3. You may assume there are no cycles anywhere in the entire linked structure.\n　　　　4. Your code should preferably run in O(n) time and use only O(1) memory\n\n<!-- more -->\n\n### 题意：\n\n输入两个单链表，判断这两个单链表是否相交，返回相交点。这里有几种方法供大家参考。 本文中所有代码均为C++实现，其他语言代码稍后我会补上。\n\n#### 解法1：\n《编程之美》一书中有讲到该问题，如何判断这两个链表相交，可以讲其中一个链表的头尾相连，然后从另一个链表的角度来判断时候有环状链表存在即可。相当于将问题转换成如何求有环单链表的环状入口点？详细方案见我的另一篇专门讲环状单链表的文章 《关于有环单链表的那些事儿》。需要注意的是，不能改变原有链表的结构，因此方法返回的时候需要恢复原状。\n\n　　1. 将链表B的尾节点指向其头节点HeadB，因此链表B形成环状，链表A成为有环单链表；\n　　2. 此时问题转换成求链表A上环状入口点；\n　　3. 恢复链表B的结构；\n\n　　代码如下：\n\n```\n    /**\n\t\t *\t Definition for singly-linked list.\n\t\t * struct ListNode {\n\t\t *     int val;\n\t\t *     ListNode *next;\n\t\t *     ListNode(int x) : val(x), next(NULL) {}\n\t\t * };\n\t\t */\n\t\tclass Solution {\n\t\t\tpublic:\n\t\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\t\t\t        if (nullptr == headA || nullptr == headB){\n\t\t\t\t\t            return nullptr;\n\t\t\t\t        }\n\n\t\t\t\t        ListNode *pNode = headB;\n\t\t\t\t        while (pNode->next){\n\t\t\t\t            pNode = pNode->next;\n\t\t\t\t        }\n\t\t        \n\t\t\t\t        ListNode *pRear = pNode;\n\t\t\t\t        pNode->next = headB;\n\n\t\t\t\t        ListNode *pJoint = loopJoint(headA);\n\t\t\t\t        pRear->next = nullptr;   // 恢复\n\n\t\t\t\t        return pJoint;\n\t\t\t    }\n\t    \n\t\tprivate:    \n\t\t\t    ListNode *loopJoint(ListNode *pHead){\n\t\t        if (nullptr == pHead || nullptr == pHead->next){\n\t\t            return nullptr;\n\t\t        }\n\n\t\t        ListNode *pSlow = pHead;\n\t\t        ListNode *pFast = pHead;\n\t\t        while (pFast && pFast->next){\n\t\t            pFast = pFast->next->next;\n\t\t            pSlow = pSlow->next;\n\n\t\t            if (pFast == pSlow){\n\t\t                break;\n\t\t            }\n\t\t        }\n\n\t\t        if (nullptr == pFast || nullptr == pFast->next){\n\t\t            return nullptr;\n\t\t        }\n\n\t\t        pSlow = pHead;\n\t\t\t    while (pFast != pSlow){\n\t\t            pFast = pFast->next;\n\t\t            pSlow = pSlow->next;\n\t\t        }\n\n\t\t        return pSlow;\n\t\t    }\n\t};\n\n```\n\nleetCode的OJ系统评判结果如下：\n![leetCode C++ Solution1](http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++1.png)\n\n#### 解法2：\n　　《剑指Offer》一书中提到的这个方法，如果两个没有环的链表相交于某个节点，那么在这个节点之后的所有节点都是两个链表所共有的。因此两个链表从交织点之前的部分长度差即为整条链表的长度差，我们只要让两条链表从离交织点相同距离的位置开始前进，经过O（n）步，一定能够找到交织点。\n　　\n　　1. 遍历链表A，记录其长度len1，遍历链表B，记录其长度len2。\n　　\n　　2.  按尾部对齐，如果两个链表的长度不相同，让长度更长的那个链表从头节点先遍历abs(len1-en2),这样两个链表指针指向对齐的位置。\n\n　　3. 然后两个链表齐头并进，当它们相等时，就是交集的节点。\n\n　　时间复杂度O(n+m)，空间复杂度O(1)\n\n　　代码如下：\n\n\t   /**\n\t\t\t\t * Definition for singly-linked list.\n\t\t\t\t * struct ListNode {\n\t\t\t\t *     int val;\n\t\t\t\t *     ListNode *next;\n\t\t\t\t *     ListNode(int x) : val(x), next(NULL) {}\n\t\t\t\t * };\n\t\t  */\n\tclass Solution {\n\t\tpublic:\n\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\t        if (nullptr == headA || nullptr == headB){\n\t            return nullptr;\n\t        }\n\n\t        int nLongLength = 0;\n\t        int nShortLength = 0;\n\t        ListNode *pLongList = headA;\n\t        ListNode *pShortList = headB;\n\n\t        while (pLongList){\n\t            ++nLongLength;\n\t            pLongList = pLongList->next;\n\t        }\n\n\t        while (pShortList){\n\t            ++nShortLength;\n\t            pShortList = pShortList->next;\n\t        }\n\n\t        if (nShortLength > nLongLength){\n\t            pLongList = headB;\n\t            pShortList = headA;\n\n\t            // 校正\n\t            nLongLength ^= nShortLength;\n\t            nShortLength ^= nLongLength;\n\t            nLongLength ^= nShortLength;\n\t        }\n\t        else{\n\t            pLongList = headA;\n\t            pShortList = headB;\n\t        }\n\t\n\t        int offset = nLongLength - nShortLength;\n\t        while (offset> 0){\n\t            pLongList = pLongList->next;\n\t            --offset;\n\t        }\n\t\n\t        while (pLongList != pShortList){\n\t            pLongList = pLongList->next;\n\t            pShortList = pShortList->next;\n\t        }\n\t\n\t        return pLongList;\n\t    }\n\t};\nleetCode的OJ系统评判结果如下所示：\n![leetCode C++ Solution 2](http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++2.png)\n\n#### 解法3：\n　还有一种解法，实际上还是利用步差来实现的，具体证明还米有搞懂，思考中。具体如下：\n\n　　1. 维护两个指针pA和pB，初始分别指向链表A和链表B。然后让它们分别遍历整个链表，每步一个节点。\n\n　　2. 当pA到达链表末尾时，让它指向B的头节点；类似的当pB到达链表末尾时，重新指向A的头节点。\n\n　　3. 当pA和pB相遇时也即为交织点。\n\n　　该算法的时间复杂度依然为O（m + n）,时间复杂度为O(1)。\n\n实现如下：\n\n    /**\n\t\t * Definition for singly-linked list.\n\t\t * struct ListNode {\n\t\t *     int val;\n\t\t *     ListNode *next;\n\t\t *     ListNode(int x) : val(x), next(NULL) {}\n\t\t * };\n\t */\n\tclass Solution {\n\t\tpublic:\n\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\t        if (nullptr == headA || nullptr == headB){\n\t\t            return nullptr;\n\t\t        }\n\t\n\t        ListNode *nodeA = headA;\n\t        ListNode *nodeB = headB;\n\t        while (nodeA && nodeB && nodeA != nodeB){\n\t            nodeA = nodeA->next;\n\t            nodeB = nodeB->next;\n\t\n\t            if (nodeA == nodeB){\n\t                break;\n\t            }\n\t\n\t            if (nullptr == nodeA){\n\t                nodeA = headB;\n\t            }\n\t\n\t            if (nullptr == nodeB){\n\t                nodeB = headA;\n\t            }\n\t        }\n\t\n\t        return nodeA;\n\t    }\n\t};\n\nleetCode的OJ系统评判结果：\n![leetCode C++  Solution3](http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++3.png)\n\n","source":"_posts/leetCode-003-Intersection-of-Two-Linked-lists.md","raw":"title: \"leetCode[002]Intersection of Two Linked lists\"\ndate: 2015-04-29 12:28:00\ncategories: LeetCode\ntags: [Algorithm,Linked list]\n---\n\n### 题目：Intersection of Two Linked lists\n\nWrite a program to find the node at which the intersection of two\nsingly linked lists begins.\n\n　　　　For example, the following two linked lists:\n\n　　　　　　A: a1 → a2\n　　　　　　　　　　　　↘\n　　　　　　　　　　　　   c1 → c2 → c3\n　　　　　　　　　　   ↗ 　　　\n\t  B: b1 → b2 → b3 　　\n\t　begin to intersect at node c1.\n\n　　Notes:\n　　　　1. If the two linked lists have no intersection at all, return null.\n　　　　2. The linked lists must retain their original structure after the function returns.\n　　　　3. You may assume there are no cycles anywhere in the entire linked structure.\n　　　　4. Your code should preferably run in O(n) time and use only O(1) memory\n\n<!-- more -->\n\n### 题意：\n\n输入两个单链表，判断这两个单链表是否相交，返回相交点。这里有几种方法供大家参考。 本文中所有代码均为C++实现，其他语言代码稍后我会补上。\n\n#### 解法1：\n《编程之美》一书中有讲到该问题，如何判断这两个链表相交，可以讲其中一个链表的头尾相连，然后从另一个链表的角度来判断时候有环状链表存在即可。相当于将问题转换成如何求有环单链表的环状入口点？详细方案见我的另一篇专门讲环状单链表的文章 《关于有环单链表的那些事儿》。需要注意的是，不能改变原有链表的结构，因此方法返回的时候需要恢复原状。\n\n　　1. 将链表B的尾节点指向其头节点HeadB，因此链表B形成环状，链表A成为有环单链表；\n　　2. 此时问题转换成求链表A上环状入口点；\n　　3. 恢复链表B的结构；\n\n　　代码如下：\n\n```\n    /**\n\t\t *\t Definition for singly-linked list.\n\t\t * struct ListNode {\n\t\t *     int val;\n\t\t *     ListNode *next;\n\t\t *     ListNode(int x) : val(x), next(NULL) {}\n\t\t * };\n\t\t */\n\t\tclass Solution {\n\t\t\tpublic:\n\t\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\t\t\t        if (nullptr == headA || nullptr == headB){\n\t\t\t\t\t            return nullptr;\n\t\t\t\t        }\n\n\t\t\t\t        ListNode *pNode = headB;\n\t\t\t\t        while (pNode->next){\n\t\t\t\t            pNode = pNode->next;\n\t\t\t\t        }\n\t\t        \n\t\t\t\t        ListNode *pRear = pNode;\n\t\t\t\t        pNode->next = headB;\n\n\t\t\t\t        ListNode *pJoint = loopJoint(headA);\n\t\t\t\t        pRear->next = nullptr;   // 恢复\n\n\t\t\t\t        return pJoint;\n\t\t\t    }\n\t    \n\t\tprivate:    \n\t\t\t    ListNode *loopJoint(ListNode *pHead){\n\t\t        if (nullptr == pHead || nullptr == pHead->next){\n\t\t            return nullptr;\n\t\t        }\n\n\t\t        ListNode *pSlow = pHead;\n\t\t        ListNode *pFast = pHead;\n\t\t        while (pFast && pFast->next){\n\t\t            pFast = pFast->next->next;\n\t\t            pSlow = pSlow->next;\n\n\t\t            if (pFast == pSlow){\n\t\t                break;\n\t\t            }\n\t\t        }\n\n\t\t        if (nullptr == pFast || nullptr == pFast->next){\n\t\t            return nullptr;\n\t\t        }\n\n\t\t        pSlow = pHead;\n\t\t\t    while (pFast != pSlow){\n\t\t            pFast = pFast->next;\n\t\t            pSlow = pSlow->next;\n\t\t        }\n\n\t\t        return pSlow;\n\t\t    }\n\t};\n\n```\n\nleetCode的OJ系统评判结果如下：\n![leetCode C++ Solution1](http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++1.png)\n\n#### 解法2：\n　　《剑指Offer》一书中提到的这个方法，如果两个没有环的链表相交于某个节点，那么在这个节点之后的所有节点都是两个链表所共有的。因此两个链表从交织点之前的部分长度差即为整条链表的长度差，我们只要让两条链表从离交织点相同距离的位置开始前进，经过O（n）步，一定能够找到交织点。\n　　\n　　1. 遍历链表A，记录其长度len1，遍历链表B，记录其长度len2。\n　　\n　　2.  按尾部对齐，如果两个链表的长度不相同，让长度更长的那个链表从头节点先遍历abs(len1-en2),这样两个链表指针指向对齐的位置。\n\n　　3. 然后两个链表齐头并进，当它们相等时，就是交集的节点。\n\n　　时间复杂度O(n+m)，空间复杂度O(1)\n\n　　代码如下：\n\n\t   /**\n\t\t\t\t * Definition for singly-linked list.\n\t\t\t\t * struct ListNode {\n\t\t\t\t *     int val;\n\t\t\t\t *     ListNode *next;\n\t\t\t\t *     ListNode(int x) : val(x), next(NULL) {}\n\t\t\t\t * };\n\t\t  */\n\tclass Solution {\n\t\tpublic:\n\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\t        if (nullptr == headA || nullptr == headB){\n\t            return nullptr;\n\t        }\n\n\t        int nLongLength = 0;\n\t        int nShortLength = 0;\n\t        ListNode *pLongList = headA;\n\t        ListNode *pShortList = headB;\n\n\t        while (pLongList){\n\t            ++nLongLength;\n\t            pLongList = pLongList->next;\n\t        }\n\n\t        while (pShortList){\n\t            ++nShortLength;\n\t            pShortList = pShortList->next;\n\t        }\n\n\t        if (nShortLength > nLongLength){\n\t            pLongList = headB;\n\t            pShortList = headA;\n\n\t            // 校正\n\t            nLongLength ^= nShortLength;\n\t            nShortLength ^= nLongLength;\n\t            nLongLength ^= nShortLength;\n\t        }\n\t        else{\n\t            pLongList = headA;\n\t            pShortList = headB;\n\t        }\n\t\n\t        int offset = nLongLength - nShortLength;\n\t        while (offset> 0){\n\t            pLongList = pLongList->next;\n\t            --offset;\n\t        }\n\t\n\t        while (pLongList != pShortList){\n\t            pLongList = pLongList->next;\n\t            pShortList = pShortList->next;\n\t        }\n\t\n\t        return pLongList;\n\t    }\n\t};\nleetCode的OJ系统评判结果如下所示：\n![leetCode C++ Solution 2](http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++2.png)\n\n#### 解法3：\n　还有一种解法，实际上还是利用步差来实现的，具体证明还米有搞懂，思考中。具体如下：\n\n　　1. 维护两个指针pA和pB，初始分别指向链表A和链表B。然后让它们分别遍历整个链表，每步一个节点。\n\n　　2. 当pA到达链表末尾时，让它指向B的头节点；类似的当pB到达链表末尾时，重新指向A的头节点。\n\n　　3. 当pA和pB相遇时也即为交织点。\n\n　　该算法的时间复杂度依然为O（m + n）,时间复杂度为O(1)。\n\n实现如下：\n\n    /**\n\t\t * Definition for singly-linked list.\n\t\t * struct ListNode {\n\t\t *     int val;\n\t\t *     ListNode *next;\n\t\t *     ListNode(int x) : val(x), next(NULL) {}\n\t\t * };\n\t */\n\tclass Solution {\n\t\tpublic:\n\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\t        if (nullptr == headA || nullptr == headB){\n\t\t            return nullptr;\n\t\t        }\n\t\n\t        ListNode *nodeA = headA;\n\t        ListNode *nodeB = headB;\n\t        while (nodeA && nodeB && nodeA != nodeB){\n\t            nodeA = nodeA->next;\n\t            nodeB = nodeB->next;\n\t\n\t            if (nodeA == nodeB){\n\t                break;\n\t            }\n\t\n\t            if (nullptr == nodeA){\n\t                nodeA = headB;\n\t            }\n\t\n\t            if (nullptr == nodeB){\n\t                nodeB = headA;\n\t            }\n\t        }\n\t\n\t        return nodeA;\n\t    }\n\t};\n\nleetCode的OJ系统评判结果：\n![leetCode C++  Solution3](http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++3.png)\n\n","slug":"leetCode-003-Intersection-of-Two-Linked-lists","published":1,"updated":"2018-05-02T10:51:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frx0000y79pod614pi6w","content":"<h3 id=\"题目：Intersection-of-Two-Linked-lists\"><a href=\"#题目：Intersection-of-Two-Linked-lists\" class=\"headerlink\" title=\"题目：Intersection of Two Linked lists\"></a>题目：Intersection of Two Linked lists</h3><p>Write a program to find the node at which the intersection of two<br>singly linked lists begins.</p>\n<p>　　　　For example, the following two linked lists:</p>\n<p>　　　　　　A: a1 → a2<br>　　　　　　　　　　　　↘<br>　　　　　　　　　　　　   c1 → c2 → c3<br>　　　　　　　　　　   ↗ 　　　<br>      B: b1 → b2 → b3 　　<br>    　begin to intersect at node c1.</p>\n<p>　　Notes:<br>　　　　1. If the two linked lists have no intersection at all, return null.<br>　　　　2. The linked lists must retain their original structure after the function returns.<br>　　　　3. You may assume there are no cycles anywhere in the entire linked structure.<br>　　　　4. Your code should preferably run in O(n) time and use only O(1) memory</p>\n<a id=\"more\"></a>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>输入两个单链表，判断这两个单链表是否相交，返回相交点。这里有几种方法供大家参考。 本文中所有代码均为C++实现，其他语言代码稍后我会补上。</p>\n<h4 id=\"解法1：\"><a href=\"#解法1：\" class=\"headerlink\" title=\"解法1：\"></a>解法1：</h4><p>《编程之美》一书中有讲到该问题，如何判断这两个链表相交，可以讲其中一个链表的头尾相连，然后从另一个链表的角度来判断时候有环状链表存在即可。相当于将问题转换成如何求有环单链表的环状入口点？详细方案见我的另一篇专门讲环状单链表的文章 《关于有环单链表的那些事儿》。需要注意的是，不能改变原有链表的结构，因此方法返回的时候需要恢复原状。</p>\n<p>　　1. 将链表B的尾节点指向其头节点HeadB，因此链表B形成环状，链表A成为有环单链表；<br>　　2. 此时问题转换成求链表A上环状入口点；<br>　　3. 恢复链表B的结构；</p>\n<p>　　代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">   /**</span><br><span class=\"line\">\t *\t Definition for singly-linked list.</span><br><span class=\"line\">\t * struct ListNode &#123;</span><br><span class=\"line\">\t *     int val;</span><br><span class=\"line\">\t *     ListNode *next;</span><br><span class=\"line\">\t *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\">\t * &#125;;</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tclass Solution &#123;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class=\"line\">\t\t\t        if (nullptr == headA || nullptr == headB)&#123;</span><br><span class=\"line\">\t\t\t\t            return nullptr;</span><br><span class=\"line\">\t\t\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t        ListNode *pNode = headB;</span><br><span class=\"line\">\t\t\t        while (pNode-&gt;next)&#123;</span><br><span class=\"line\">\t\t\t            pNode = pNode-&gt;next;</span><br><span class=\"line\">\t\t\t        &#125;</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t\t\t        ListNode *pRear = pNode;</span><br><span class=\"line\">\t\t\t        pNode-&gt;next = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t        ListNode *pJoint = loopJoint(headA);</span><br><span class=\"line\">\t\t\t        pRear-&gt;next = nullptr;   // 恢复</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t        return pJoint;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tprivate:    </span><br><span class=\"line\">\t\t    ListNode *loopJoint(ListNode *pHead)&#123;</span><br><span class=\"line\">\t        if (nullptr == pHead || nullptr == pHead-&gt;next)&#123;</span><br><span class=\"line\">\t            return nullptr;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        ListNode *pSlow = pHead;</span><br><span class=\"line\">\t        ListNode *pFast = pHead;</span><br><span class=\"line\">\t        while (pFast &amp;&amp; pFast-&gt;next)&#123;</span><br><span class=\"line\">\t            pFast = pFast-&gt;next-&gt;next;</span><br><span class=\"line\">\t            pSlow = pSlow-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t            if (pFast == pSlow)&#123;</span><br><span class=\"line\">\t                break;</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        if (nullptr == pFast || nullptr == pFast-&gt;next)&#123;</span><br><span class=\"line\">\t            return nullptr;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        pSlow = pHead;</span><br><span class=\"line\">\t\t    while (pFast != pSlow)&#123;</span><br><span class=\"line\">\t            pFast = pFast-&gt;next;</span><br><span class=\"line\">\t            pSlow = pSlow-&gt;next;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        return pSlow;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>leetCode的OJ系统评判结果如下：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++1.png\" alt=\"leetCode C++ Solution1\"></p>\n<h4 id=\"解法2：\"><a href=\"#解法2：\" class=\"headerlink\" title=\"解法2：\"></a>解法2：</h4><p>　　《剑指Offer》一书中提到的这个方法，如果两个没有环的链表相交于某个节点，那么在这个节点之后的所有节点都是两个链表所共有的。因此两个链表从交织点之前的部分长度差即为整条链表的长度差，我们只要让两条链表从离交织点相同距离的位置开始前进，经过O（n）步，一定能够找到交织点。<br>　　<br>　　1. 遍历链表A，记录其长度len1，遍历链表B，记录其长度len2。<br>　　<br>　　2.  按尾部对齐，如果两个链表的长度不相同，让长度更长的那个链表从头节点先遍历abs(len1-en2),这样两个链表指针指向对齐的位置。</p>\n<p>　　3. 然后两个链表齐头并进，当它们相等时，就是交集的节点。</p>\n<p>　　时间复杂度O(n+m)，空间复杂度O(1)</p>\n<p>　　代码如下：</p>\n<pre><code>   /**\n             * Definition for singly-linked list.\n             * struct ListNode {\n             *     int val;\n             *     ListNode *next;\n             *     ListNode(int x) : val(x), next(NULL) {}\n             * };\n      */\nclass Solution {\n    public:\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n            if (nullptr == headA || nullptr == headB){\n            return nullptr;\n        }\n\n        int nLongLength = 0;\n        int nShortLength = 0;\n        ListNode *pLongList = headA;\n        ListNode *pShortList = headB;\n\n        while (pLongList){\n            ++nLongLength;\n            pLongList = pLongList-&gt;next;\n        }\n\n        while (pShortList){\n            ++nShortLength;\n            pShortList = pShortList-&gt;next;\n        }\n\n        if (nShortLength &gt; nLongLength){\n            pLongList = headB;\n            pShortList = headA;\n\n            // 校正\n            nLongLength ^= nShortLength;\n            nShortLength ^= nLongLength;\n            nLongLength ^= nShortLength;\n        }\n        else{\n            pLongList = headA;\n            pShortList = headB;\n        }\n\n        int offset = nLongLength - nShortLength;\n        while (offset&gt; 0){\n            pLongList = pLongList-&gt;next;\n            --offset;\n        }\n\n        while (pLongList != pShortList){\n            pLongList = pLongList-&gt;next;\n            pShortList = pShortList-&gt;next;\n        }\n\n        return pLongList;\n    }\n};\n</code></pre><p>leetCode的OJ系统评判结果如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++2.png\" alt=\"leetCode C++ Solution 2\"></p>\n<h4 id=\"解法3：\"><a href=\"#解法3：\" class=\"headerlink\" title=\"解法3：\"></a>解法3：</h4><p>　还有一种解法，实际上还是利用步差来实现的，具体证明还米有搞懂，思考中。具体如下：</p>\n<p>　　1. 维护两个指针pA和pB，初始分别指向链表A和链表B。然后让它们分别遍历整个链表，每步一个节点。</p>\n<p>　　2. 当pA到达链表末尾时，让它指向B的头节点；类似的当pB到达链表末尾时，重新指向A的头节点。</p>\n<p>　　3. 当pA和pB相遇时也即为交织点。</p>\n<p>　　该算法的时间复杂度依然为O（m + n）,时间复杂度为O(1)。</p>\n<p>实现如下：</p>\n<pre><code>/**\n     * Definition for singly-linked list.\n     * struct ListNode {\n     *     int val;\n     *     ListNode *next;\n     *     ListNode(int x) : val(x), next(NULL) {}\n     * };\n */\nclass Solution {\n    public:\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n            if (nullptr == headA || nullptr == headB){\n                return nullptr;\n            }\n\n        ListNode *nodeA = headA;\n        ListNode *nodeB = headB;\n        while (nodeA &amp;&amp; nodeB &amp;&amp; nodeA != nodeB){\n            nodeA = nodeA-&gt;next;\n            nodeB = nodeB-&gt;next;\n\n            if (nodeA == nodeB){\n                break;\n            }\n\n            if (nullptr == nodeA){\n                nodeA = headB;\n            }\n\n            if (nullptr == nodeB){\n                nodeB = headA;\n            }\n        }\n\n        return nodeA;\n    }\n};\n</code></pre><p>leetCode的OJ系统评判结果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++3.png\" alt=\"leetCode C++  Solution3\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"题目：Intersection-of-Two-Linked-lists\"><a href=\"#题目：Intersection-of-Two-Linked-lists\" class=\"headerlink\" title=\"题目：Intersection of Two Linked lists\"></a>题目：Intersection of Two Linked lists</h3><p>Write a program to find the node at which the intersection of two<br>singly linked lists begins.</p>\n<p>　　　　For example, the following two linked lists:</p>\n<p>　　　　　　A: a1 → a2<br>　　　　　　　　　　　　↘<br>　　　　　　　　　　　　   c1 → c2 → c3<br>　　　　　　　　　　   ↗ 　　　<br>      B: b1 → b2 → b3 　　<br>    　begin to intersect at node c1.</p>\n<p>　　Notes:<br>　　　　1. If the two linked lists have no intersection at all, return null.<br>　　　　2. The linked lists must retain their original structure after the function returns.<br>　　　　3. You may assume there are no cycles anywhere in the entire linked structure.<br>　　　　4. Your code should preferably run in O(n) time and use only O(1) memory</p>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>输入两个单链表，判断这两个单链表是否相交，返回相交点。这里有几种方法供大家参考。 本文中所有代码均为C++实现，其他语言代码稍后我会补上。</p>\n<h4 id=\"解法1：\"><a href=\"#解法1：\" class=\"headerlink\" title=\"解法1：\"></a>解法1：</h4><p>《编程之美》一书中有讲到该问题，如何判断这两个链表相交，可以讲其中一个链表的头尾相连，然后从另一个链表的角度来判断时候有环状链表存在即可。相当于将问题转换成如何求有环单链表的环状入口点？详细方案见我的另一篇专门讲环状单链表的文章 《关于有环单链表的那些事儿》。需要注意的是，不能改变原有链表的结构，因此方法返回的时候需要恢复原状。</p>\n<p>　　1. 将链表B的尾节点指向其头节点HeadB，因此链表B形成环状，链表A成为有环单链表；<br>　　2. 此时问题转换成求链表A上环状入口点；<br>　　3. 恢复链表B的结构；</p>\n<p>　　代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">   /**</span><br><span class=\"line\">\t *\t Definition for singly-linked list.</span><br><span class=\"line\">\t * struct ListNode &#123;</span><br><span class=\"line\">\t *     int val;</span><br><span class=\"line\">\t *     ListNode *next;</span><br><span class=\"line\">\t *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"line\">\t * &#125;;</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tclass Solution &#123;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t\t    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class=\"line\">\t\t\t        if (nullptr == headA || nullptr == headB)&#123;</span><br><span class=\"line\">\t\t\t\t            return nullptr;</span><br><span class=\"line\">\t\t\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t        ListNode *pNode = headB;</span><br><span class=\"line\">\t\t\t        while (pNode-&gt;next)&#123;</span><br><span class=\"line\">\t\t\t            pNode = pNode-&gt;next;</span><br><span class=\"line\">\t\t\t        &#125;</span><br><span class=\"line\">\t        </span><br><span class=\"line\">\t\t\t        ListNode *pRear = pNode;</span><br><span class=\"line\">\t\t\t        pNode-&gt;next = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t        ListNode *pJoint = loopJoint(headA);</span><br><span class=\"line\">\t\t\t        pRear-&gt;next = nullptr;   // 恢复</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t        return pJoint;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tprivate:    </span><br><span class=\"line\">\t\t    ListNode *loopJoint(ListNode *pHead)&#123;</span><br><span class=\"line\">\t        if (nullptr == pHead || nullptr == pHead-&gt;next)&#123;</span><br><span class=\"line\">\t            return nullptr;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        ListNode *pSlow = pHead;</span><br><span class=\"line\">\t        ListNode *pFast = pHead;</span><br><span class=\"line\">\t        while (pFast &amp;&amp; pFast-&gt;next)&#123;</span><br><span class=\"line\">\t            pFast = pFast-&gt;next-&gt;next;</span><br><span class=\"line\">\t            pSlow = pSlow-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t            if (pFast == pSlow)&#123;</span><br><span class=\"line\">\t                break;</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        if (nullptr == pFast || nullptr == pFast-&gt;next)&#123;</span><br><span class=\"line\">\t            return nullptr;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        pSlow = pHead;</span><br><span class=\"line\">\t\t    while (pFast != pSlow)&#123;</span><br><span class=\"line\">\t            pFast = pFast-&gt;next;</span><br><span class=\"line\">\t            pSlow = pSlow-&gt;next;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t        return pSlow;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>leetCode的OJ系统评判结果如下：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++1.png\" alt=\"leetCode C++ Solution1\"></p>\n<h4 id=\"解法2：\"><a href=\"#解法2：\" class=\"headerlink\" title=\"解法2：\"></a>解法2：</h4><p>　　《剑指Offer》一书中提到的这个方法，如果两个没有环的链表相交于某个节点，那么在这个节点之后的所有节点都是两个链表所共有的。因此两个链表从交织点之前的部分长度差即为整条链表的长度差，我们只要让两条链表从离交织点相同距离的位置开始前进，经过O（n）步，一定能够找到交织点。<br>　　<br>　　1. 遍历链表A，记录其长度len1，遍历链表B，记录其长度len2。<br>　　<br>　　2.  按尾部对齐，如果两个链表的长度不相同，让长度更长的那个链表从头节点先遍历abs(len1-en2),这样两个链表指针指向对齐的位置。</p>\n<p>　　3. 然后两个链表齐头并进，当它们相等时，就是交集的节点。</p>\n<p>　　时间复杂度O(n+m)，空间复杂度O(1)</p>\n<p>　　代码如下：</p>\n<pre><code>   /**\n             * Definition for singly-linked list.\n             * struct ListNode {\n             *     int val;\n             *     ListNode *next;\n             *     ListNode(int x) : val(x), next(NULL) {}\n             * };\n      */\nclass Solution {\n    public:\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n            if (nullptr == headA || nullptr == headB){\n            return nullptr;\n        }\n\n        int nLongLength = 0;\n        int nShortLength = 0;\n        ListNode *pLongList = headA;\n        ListNode *pShortList = headB;\n\n        while (pLongList){\n            ++nLongLength;\n            pLongList = pLongList-&gt;next;\n        }\n\n        while (pShortList){\n            ++nShortLength;\n            pShortList = pShortList-&gt;next;\n        }\n\n        if (nShortLength &gt; nLongLength){\n            pLongList = headB;\n            pShortList = headA;\n\n            // 校正\n            nLongLength ^= nShortLength;\n            nShortLength ^= nLongLength;\n            nLongLength ^= nShortLength;\n        }\n        else{\n            pLongList = headA;\n            pShortList = headB;\n        }\n\n        int offset = nLongLength - nShortLength;\n        while (offset&gt; 0){\n            pLongList = pLongList-&gt;next;\n            --offset;\n        }\n\n        while (pLongList != pShortList){\n            pLongList = pLongList-&gt;next;\n            pShortList = pShortList-&gt;next;\n        }\n\n        return pLongList;\n    }\n};\n</code></pre><p>leetCode的OJ系统评判结果如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++2.png\" alt=\"leetCode C++ Solution 2\"></p>\n<h4 id=\"解法3：\"><a href=\"#解法3：\" class=\"headerlink\" title=\"解法3：\"></a>解法3：</h4><p>　还有一种解法，实际上还是利用步差来实现的，具体证明还米有搞懂，思考中。具体如下：</p>\n<p>　　1. 维护两个指针pA和pB，初始分别指向链表A和链表B。然后让它们分别遍历整个链表，每步一个节点。</p>\n<p>　　2. 当pA到达链表末尾时，让它指向B的头节点；类似的当pB到达链表末尾时，重新指向A的头节点。</p>\n<p>　　3. 当pA和pB相遇时也即为交织点。</p>\n<p>　　该算法的时间复杂度依然为O（m + n）,时间复杂度为O(1)。</p>\n<p>实现如下：</p>\n<pre><code>/**\n     * Definition for singly-linked list.\n     * struct ListNode {\n     *     int val;\n     *     ListNode *next;\n     *     ListNode(int x) : val(x), next(NULL) {}\n     * };\n */\nclass Solution {\n    public:\n        ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n            if (nullptr == headA || nullptr == headB){\n                return nullptr;\n            }\n\n        ListNode *nodeA = headA;\n        ListNode *nodeB = headB;\n        while (nodeA &amp;&amp; nodeB &amp;&amp; nodeA != nodeB){\n            nodeA = nodeA-&gt;next;\n            nodeB = nodeB-&gt;next;\n\n            if (nodeA == nodeB){\n                break;\n            }\n\n            if (nullptr == nodeA){\n                nodeA = headB;\n            }\n\n            if (nullptr == nodeB){\n                nodeB = headA;\n            }\n        }\n\n        return nodeA;\n    }\n};\n</code></pre><p>leetCode的OJ系统评判结果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode002C++3.png\" alt=\"leetCode C++  Solution3\"></p>"},{"title":"leetCode[003]Two Sum","date":"2015-04-29T05:15:00.000Z","_content":"\n本文主要包括leetCode题集里的两个题目，Two Sum1 和 Two Sum2\n\n<!-- more -->\n\n### 题目1： Two Sum 1\n\nGiven an array of integers, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target, \nwhere index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\n\nYou may assume that each input would have exactly one solution.\n\n　　　　Input: numbers={2, 7, 11, 15}, target=9\n　　　　Output: index1=1, index2=2\n\n####题意：\n\n题目中要求输入一个整形数组以及一个target，找出该整型数组中这样两个元素，使得这两个元素之和等于指定target的值。 题目中假设该两个元素必然存在，并且是只有一组（所以相对简单），返回的是这两个元素的index值（数组Index从1开始）。\n\n####关键点：\n\n我们经常会使用空间换取时间的方法来获取较小的时间复杂度。因此增加必要的数据结构来减少时间复杂度。这道题目一样，我们增加一个map结构，key为数组元素值，value为其在数组中对应的index。每次遍历到数组元素便去map结构中查找对应的补数，如果存在，那就说明找到了。如果没存在就记录当前元素以及其index，直到结束。\n\n代码实现如下：\n\n   \n``` \nclass Solution{\n\t\tpublic:\n\t     // O(n) runtime, O(n) space\n\t     // We could reduce the runtime complexity of looking up a value to O(1) using a hash map that maps a value to its index.\n\t    std::vector<int> twoSum(std::vector<int>& numbers, int target){\n\t        std::vector<int> vecRet;\n\t        std::map<int, int> mapIndex;\n\t        for (size_t i = 0; i < numbers.size(); ++i){\n\t            if (0 != mapIndex.count(target - numbers[i])){\n\t                int nIndex = mapIndex[target - numbers[i]];\n\t                // 当前存储的Index肯定比i要小，注意要排除i\n\t                if (nIndex < i){\n\t                    vecRet.push_back(nIndex + 1);\n\t                    vecRet.push_back(i + 1);\n\t                    return vecRet;\n\t                }\n\t            } else {\n\t                mapIndex[numbers[i]] = i;\n\t            }\n\t        }\n\t        return vecRet;\n\t    } // twoSum\n\t};\n```\nleetCode的OJ系统评判结果如下所示：\n![leetCode Two Sum 1 C++](http://7xilk1.com1.z0.glb.clouddn.com/leetCode003C++.png)\n\n本地运行结果如下所示：\n![leetCode Two Sum 1 C++  Run](http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run1.jpg)\n\n### 题目2：Two Sum 2\nGiven an array of integers, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\n\nYou may assume that each input would have exactly one solution.\n\n**Input**: numbers={2, 7, 11, 15}, target=9\n**Output**: index1=1, index2=2\n\n\n#### 题意：\n和上题中Two Sum1 比较，大家发现什么异同了没（没发现的童鞋面壁去），这道题目仅仅更改了输入条件，Input的数组为已经排序的数组，并且呈现升序。输入条件变严格，我们依然可以使用前一篇问丈夫中的方法进行。那这里既然为升序，我们能不能不使用前一种方法而又能够达到O（n）时间复杂度呢？ 答案是必然的。\n\n#### 关键点：\n1. 数组既然排序，元素之前的大小关系相对确定，存在的这一对元素必然处于相对固定的位置，我们可以使用两个游标，一个从头部遍历，一个从尾部遍历，两者所指元素之和如果偏大，调整后面的游标，相反则调整前面的游标。\n2.  由于两个int之和有可能出现INT_MAX的情况，所以如果输入类型给定int，则我们需要使用long long类型来表示才能避免出现溢出的情况。\n\n实现代码如下：\n\n    class Solution{\n\t\tpublic:\n\t        std::vector<int> twoSum(std::vector<int> &numbers, int target){\n\t        std::vector<int> vecRet;\n\t        int nLeft = 0;\n\t        int nRight = numbers.size() - 1;\n\t\n\t        while (nLeft < nRight){\n\t            // 小心两个int之和溢出，使用long long类型\n\t            long long int nAdd = numbers[nLeft] + numbers[nRight];\n\t            if (nAdd == target){\n\t                vecRet.push_back(nLeft + 1);\n\t                vecRet.push_back(nRight + 1);\n\t\n\t                return vecRet;\n\t            }\n\t            else if (nAdd > target){\n\t                nRight--;\n\t            }\n\t            else if (nAdd < target){\n\t                nLeft++;\n\t            }\n\t        }\n\t\n\t        return vecRet;\n\t    } \n\t};\n\t\n由于Two Sum2 题目是收费的，因此木有进行leetCode的OJ评判，直接上本地运行截图吧，sign~\n\n![leetCode Two Sum 2  Run](http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run2.jpg)\n\t\n\n\n","source":"_posts/leetCode-003-Two-Sum.md","raw":"title: \"leetCode[003]Two Sum\"\ndate: 2015-04-29 13:15:00\ncategories: LeetCode\ntags: [Algorithm,Array]\n---\n\n本文主要包括leetCode题集里的两个题目，Two Sum1 和 Two Sum2\n\n<!-- more -->\n\n### 题目1： Two Sum 1\n\nGiven an array of integers, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target, \nwhere index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\n\nYou may assume that each input would have exactly one solution.\n\n　　　　Input: numbers={2, 7, 11, 15}, target=9\n　　　　Output: index1=1, index2=2\n\n####题意：\n\n题目中要求输入一个整形数组以及一个target，找出该整型数组中这样两个元素，使得这两个元素之和等于指定target的值。 题目中假设该两个元素必然存在，并且是只有一组（所以相对简单），返回的是这两个元素的index值（数组Index从1开始）。\n\n####关键点：\n\n我们经常会使用空间换取时间的方法来获取较小的时间复杂度。因此增加必要的数据结构来减少时间复杂度。这道题目一样，我们增加一个map结构，key为数组元素值，value为其在数组中对应的index。每次遍历到数组元素便去map结构中查找对应的补数，如果存在，那就说明找到了。如果没存在就记录当前元素以及其index，直到结束。\n\n代码实现如下：\n\n   \n``` \nclass Solution{\n\t\tpublic:\n\t     // O(n) runtime, O(n) space\n\t     // We could reduce the runtime complexity of looking up a value to O(1) using a hash map that maps a value to its index.\n\t    std::vector<int> twoSum(std::vector<int>& numbers, int target){\n\t        std::vector<int> vecRet;\n\t        std::map<int, int> mapIndex;\n\t        for (size_t i = 0; i < numbers.size(); ++i){\n\t            if (0 != mapIndex.count(target - numbers[i])){\n\t                int nIndex = mapIndex[target - numbers[i]];\n\t                // 当前存储的Index肯定比i要小，注意要排除i\n\t                if (nIndex < i){\n\t                    vecRet.push_back(nIndex + 1);\n\t                    vecRet.push_back(i + 1);\n\t                    return vecRet;\n\t                }\n\t            } else {\n\t                mapIndex[numbers[i]] = i;\n\t            }\n\t        }\n\t        return vecRet;\n\t    } // twoSum\n\t};\n```\nleetCode的OJ系统评判结果如下所示：\n![leetCode Two Sum 1 C++](http://7xilk1.com1.z0.glb.clouddn.com/leetCode003C++.png)\n\n本地运行结果如下所示：\n![leetCode Two Sum 1 C++  Run](http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run1.jpg)\n\n### 题目2：Two Sum 2\nGiven an array of integers, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\n\nYou may assume that each input would have exactly one solution.\n\n**Input**: numbers={2, 7, 11, 15}, target=9\n**Output**: index1=1, index2=2\n\n\n#### 题意：\n和上题中Two Sum1 比较，大家发现什么异同了没（没发现的童鞋面壁去），这道题目仅仅更改了输入条件，Input的数组为已经排序的数组，并且呈现升序。输入条件变严格，我们依然可以使用前一篇问丈夫中的方法进行。那这里既然为升序，我们能不能不使用前一种方法而又能够达到O（n）时间复杂度呢？ 答案是必然的。\n\n#### 关键点：\n1. 数组既然排序，元素之前的大小关系相对确定，存在的这一对元素必然处于相对固定的位置，我们可以使用两个游标，一个从头部遍历，一个从尾部遍历，两者所指元素之和如果偏大，调整后面的游标，相反则调整前面的游标。\n2.  由于两个int之和有可能出现INT_MAX的情况，所以如果输入类型给定int，则我们需要使用long long类型来表示才能避免出现溢出的情况。\n\n实现代码如下：\n\n    class Solution{\n\t\tpublic:\n\t        std::vector<int> twoSum(std::vector<int> &numbers, int target){\n\t        std::vector<int> vecRet;\n\t        int nLeft = 0;\n\t        int nRight = numbers.size() - 1;\n\t\n\t        while (nLeft < nRight){\n\t            // 小心两个int之和溢出，使用long long类型\n\t            long long int nAdd = numbers[nLeft] + numbers[nRight];\n\t            if (nAdd == target){\n\t                vecRet.push_back(nLeft + 1);\n\t                vecRet.push_back(nRight + 1);\n\t\n\t                return vecRet;\n\t            }\n\t            else if (nAdd > target){\n\t                nRight--;\n\t            }\n\t            else if (nAdd < target){\n\t                nLeft++;\n\t            }\n\t        }\n\t\n\t        return vecRet;\n\t    } \n\t};\n\t\n由于Two Sum2 题目是收费的，因此木有进行leetCode的OJ评判，直接上本地运行截图吧，sign~\n\n![leetCode Two Sum 2  Run](http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run2.jpg)\n\t\n\n\n","slug":"leetCode-003-Two-Sum","published":1,"updated":"2018-05-02T10:47:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frx3001379po1qwwmx56","content":"<p>本文主要包括leetCode题集里的两个题目，Two Sum1 和 Two Sum2</p>\n<a id=\"more\"></a>\n<h3 id=\"题目1：-Two-Sum-1\"><a href=\"#题目1：-Two-Sum-1\" class=\"headerlink\" title=\"题目1： Two Sum 1\"></a>题目1： Two Sum 1</h3><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>\n<p>The function twoSum should return indices of the two numbers such that they add up to the target,<br>where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n<p>You may assume that each input would have exactly one solution.</p>\n<p>　　　　Input: numbers={2, 7, 11, 15}, target=9<br>　　　　Output: index1=1, index2=2</p>\n<p>####题意：</p>\n<p>题目中要求输入一个整形数组以及一个target，找出该整型数组中这样两个元素，使得这两个元素之和等于指定target的值。 题目中假设该两个元素必然存在，并且是只有一组（所以相对简单），返回的是这两个元素的index值（数组Index从1开始）。</p>\n<p>####关键点：</p>\n<p>我们经常会使用空间换取时间的方法来获取较小的时间复杂度。因此增加必要的数据结构来减少时间复杂度。这道题目一样，我们增加一个map结构，key为数组元素值，value为其在数组中对应的index。每次遍历到数组元素便去map结构中查找对应的补数，如果存在，那就说明找到了。如果没存在就记录当前元素以及其index，直到结束。</p>\n<p>代码实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution&#123;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t     // O(n) runtime, O(n) space</span><br><span class=\"line\">\t     // We could reduce the runtime complexity of looking up a value to O(1) using a hash map that maps a value to its index.</span><br><span class=\"line\">\t    std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt;&amp; numbers, int target)&#123;</span><br><span class=\"line\">\t        std::vector&lt;int&gt; vecRet;</span><br><span class=\"line\">\t        std::map&lt;int, int&gt; mapIndex;</span><br><span class=\"line\">\t        for (size_t i = 0; i &lt; numbers.size(); ++i)&#123;</span><br><span class=\"line\">\t            if (0 != mapIndex.count(target - numbers[i]))&#123;</span><br><span class=\"line\">\t                int nIndex = mapIndex[target - numbers[i]];</span><br><span class=\"line\">\t                // 当前存储的Index肯定比i要小，注意要排除i</span><br><span class=\"line\">\t                if (nIndex &lt; i)&#123;</span><br><span class=\"line\">\t                    vecRet.push_back(nIndex + 1);</span><br><span class=\"line\">\t                    vecRet.push_back(i + 1);</span><br><span class=\"line\">\t                    return vecRet;</span><br><span class=\"line\">\t                &#125;</span><br><span class=\"line\">\t            &#125; else &#123;</span><br><span class=\"line\">\t                mapIndex[numbers[i]] = i;</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t        return vecRet;</span><br><span class=\"line\">\t    &#125; // twoSum</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n<p>leetCode的OJ系统评判结果如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode003C++.png\" alt=\"leetCode Two Sum 1 C++\"></p>\n<p>本地运行结果如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run1.jpg\" alt=\"leetCode Two Sum 1 C++  Run\"></p>\n<h3 id=\"题目2：Two-Sum-2\"><a href=\"#题目2：Two-Sum-2\" class=\"headerlink\" title=\"题目2：Two Sum 2\"></a>题目2：Two Sum 2</h3><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>\n<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n<p>You may assume that each input would have exactly one solution.</p>\n<p><strong>Input</strong>: numbers={2, 7, 11, 15}, target=9<br><strong>Output</strong>: index1=1, index2=2</p>\n<h4 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h4><p>和上题中Two Sum1 比较，大家发现什么异同了没（没发现的童鞋面壁去），这道题目仅仅更改了输入条件，Input的数组为已经排序的数组，并且呈现升序。输入条件变严格，我们依然可以使用前一篇问丈夫中的方法进行。那这里既然为升序，我们能不能不使用前一种方法而又能够达到O（n）时间复杂度呢？ 答案是必然的。</p>\n<h4 id=\"关键点：\"><a href=\"#关键点：\" class=\"headerlink\" title=\"关键点：\"></a>关键点：</h4><ol>\n<li>数组既然排序，元素之前的大小关系相对确定，存在的这一对元素必然处于相对固定的位置，我们可以使用两个游标，一个从头部遍历，一个从尾部遍历，两者所指元素之和如果偏大，调整后面的游标，相反则调整前面的游标。</li>\n<li>由于两个int之和有可能出现INT_MAX的情况，所以如果输入类型给定int，则我们需要使用long long类型来表示才能避免出现溢出的情况。</li>\n</ol>\n<p>实现代码如下：</p>\n<pre><code>class Solution{\n    public:\n        std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt; &amp;numbers, int target){\n        std::vector&lt;int&gt; vecRet;\n        int nLeft = 0;\n        int nRight = numbers.size() - 1;\n\n        while (nLeft &lt; nRight){\n            // 小心两个int之和溢出，使用long long类型\n            long long int nAdd = numbers[nLeft] + numbers[nRight];\n            if (nAdd == target){\n                vecRet.push_back(nLeft + 1);\n                vecRet.push_back(nRight + 1);\n\n                return vecRet;\n            }\n            else if (nAdd &gt; target){\n                nRight--;\n            }\n            else if (nAdd &lt; target){\n                nLeft++;\n            }\n        }\n\n        return vecRet;\n    } \n};\n</code></pre><p>由于Two Sum2 题目是收费的，因此木有进行leetCode的OJ评判，直接上本地运行截图吧，sign~</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run2.jpg\" alt=\"leetCode Two Sum 2  Run\"></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>本文主要包括leetCode题集里的两个题目，Two Sum1 和 Two Sum2</p>","more":"<h3 id=\"题目1：-Two-Sum-1\"><a href=\"#题目1：-Two-Sum-1\" class=\"headerlink\" title=\"题目1： Two Sum 1\"></a>题目1： Two Sum 1</h3><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>\n<p>The function twoSum should return indices of the two numbers such that they add up to the target,<br>where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n<p>You may assume that each input would have exactly one solution.</p>\n<p>　　　　Input: numbers={2, 7, 11, 15}, target=9<br>　　　　Output: index1=1, index2=2</p>\n<p>####题意：</p>\n<p>题目中要求输入一个整形数组以及一个target，找出该整型数组中这样两个元素，使得这两个元素之和等于指定target的值。 题目中假设该两个元素必然存在，并且是只有一组（所以相对简单），返回的是这两个元素的index值（数组Index从1开始）。</p>\n<p>####关键点：</p>\n<p>我们经常会使用空间换取时间的方法来获取较小的时间复杂度。因此增加必要的数据结构来减少时间复杂度。这道题目一样，我们增加一个map结构，key为数组元素值，value为其在数组中对应的index。每次遍历到数组元素便去map结构中查找对应的补数，如果存在，那就说明找到了。如果没存在就记录当前元素以及其index，直到结束。</p>\n<p>代码实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution&#123;</span><br><span class=\"line\">\t\tpublic:</span><br><span class=\"line\">\t     // O(n) runtime, O(n) space</span><br><span class=\"line\">\t     // We could reduce the runtime complexity of looking up a value to O(1) using a hash map that maps a value to its index.</span><br><span class=\"line\">\t    std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt;&amp; numbers, int target)&#123;</span><br><span class=\"line\">\t        std::vector&lt;int&gt; vecRet;</span><br><span class=\"line\">\t        std::map&lt;int, int&gt; mapIndex;</span><br><span class=\"line\">\t        for (size_t i = 0; i &lt; numbers.size(); ++i)&#123;</span><br><span class=\"line\">\t            if (0 != mapIndex.count(target - numbers[i]))&#123;</span><br><span class=\"line\">\t                int nIndex = mapIndex[target - numbers[i]];</span><br><span class=\"line\">\t                // 当前存储的Index肯定比i要小，注意要排除i</span><br><span class=\"line\">\t                if (nIndex &lt; i)&#123;</span><br><span class=\"line\">\t                    vecRet.push_back(nIndex + 1);</span><br><span class=\"line\">\t                    vecRet.push_back(i + 1);</span><br><span class=\"line\">\t                    return vecRet;</span><br><span class=\"line\">\t                &#125;</span><br><span class=\"line\">\t            &#125; else &#123;</span><br><span class=\"line\">\t                mapIndex[numbers[i]] = i;</span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t        return vecRet;</span><br><span class=\"line\">\t    &#125; // twoSum</span><br><span class=\"line\">\t&#125;;</span><br></pre></td></tr></table></figure>\n<p>leetCode的OJ系统评判结果如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode003C++.png\" alt=\"leetCode Two Sum 1 C++\"></p>\n<p>本地运行结果如下所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run1.jpg\" alt=\"leetCode Two Sum 1 C++  Run\"></p>\n<h3 id=\"题目2：Two-Sum-2\"><a href=\"#题目2：Two-Sum-2\" class=\"headerlink\" title=\"题目2：Two Sum 2\"></a>题目2：Two Sum 2</h3><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>\n<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n<p>You may assume that each input would have exactly one solution.</p>\n<p><strong>Input</strong>: numbers={2, 7, 11, 15}, target=9<br><strong>Output</strong>: index1=1, index2=2</p>\n<h4 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h4><p>和上题中Two Sum1 比较，大家发现什么异同了没（没发现的童鞋面壁去），这道题目仅仅更改了输入条件，Input的数组为已经排序的数组，并且呈现升序。输入条件变严格，我们依然可以使用前一篇问丈夫中的方法进行。那这里既然为升序，我们能不能不使用前一种方法而又能够达到O（n）时间复杂度呢？ 答案是必然的。</p>\n<h4 id=\"关键点：\"><a href=\"#关键点：\" class=\"headerlink\" title=\"关键点：\"></a>关键点：</h4><ol>\n<li>数组既然排序，元素之前的大小关系相对确定，存在的这一对元素必然处于相对固定的位置，我们可以使用两个游标，一个从头部遍历，一个从尾部遍历，两者所指元素之和如果偏大，调整后面的游标，相反则调整前面的游标。</li>\n<li>由于两个int之和有可能出现INT_MAX的情况，所以如果输入类型给定int，则我们需要使用long long类型来表示才能避免出现溢出的情况。</li>\n</ol>\n<p>实现代码如下：</p>\n<pre><code>class Solution{\n    public:\n        std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt; &amp;numbers, int target){\n        std::vector&lt;int&gt; vecRet;\n        int nLeft = 0;\n        int nRight = numbers.size() - 1;\n\n        while (nLeft &lt; nRight){\n            // 小心两个int之和溢出，使用long long类型\n            long long int nAdd = numbers[nLeft] + numbers[nRight];\n            if (nAdd == target){\n                vecRet.push_back(nLeft + 1);\n                vecRet.push_back(nRight + 1);\n\n                return vecRet;\n            }\n            else if (nAdd &gt; target){\n                nRight--;\n            }\n            else if (nAdd &lt; target){\n                nLeft++;\n            }\n        }\n\n        return vecRet;\n    } \n};\n</code></pre><p>由于Two Sum2 题目是收费的，因此木有进行leetCode的OJ评判，直接上本地运行截图吧，sign~</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode003Run2.jpg\" alt=\"leetCode Two Sum 2  Run\"></p>"},{"title":"leetCode[018]Length Of Last Word","date":"2015-08-18T08:13:44.000Z","_content":"\n### 题目：\n  Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length\n  of last word in the string.\n  If the last word does not exist, return 0.\n  Note: A word is defined as a character sequence consists of non-space characters only.\n\t\t\tFor example, Given s = \"Hello World\", return 5.\n\t\t\t\n\t\t\t\n<!-- more -->\n\n### 题意：\n难度不大，考虑所有边界情况即可。\n\n### 解法：\nC++版本实现方法1：\n\t\t\n\t// 从右往左依次遍历即可\t\n\n``` C++\n  class Solution {\n\tpublic:\n\t\tint lengthOfLastWord(string s) {\n\t\t\tint length = 0;\n\t\t\tfor (int index = s.length() - 1; index >= 0; index--){\n\t\t\t\tchar c = s.at(index);\n\t\t\t\tif (c != ' '){\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' && length != 0){\n\t\t\t\t\treturn length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn length;\n\t\t}\n\t}\n```\nleetCode Oj系统评判结果如下图所示：\n\n![leetCode C++1](http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++1.png);\n\nC++版本实现方法2：\n\n``` C++\n\t// 直接利用现有轮子STL \nclass Solution {\n\tpublic:\n\t\tint lengthOfLastWord(string s) {\n\t\t\tauto left = find_if(s.rbegin(), s.rend(), ::isalpha);\n\t\t\tauto right = find_if_not(left, s.rend(), ::isalpha);\n\t\t\treturn distance(left, right);\n\t\t}\n\t}\n```\n\nleetCode Oj系统评判结果如下图所示：\n\n![leetCode C++2](http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++2.png);\n\n","source":"_posts/leetCode-018-LengthOfLastWord.md","raw":"title: \"leetCode[018]Length Of Last Word\"\ndate: 2015-08-18 16:13:44\ncategories: LeetCode\ntags: [Algorithm,String]\n---\n\n### 题目：\n  Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length\n  of last word in the string.\n  If the last word does not exist, return 0.\n  Note: A word is defined as a character sequence consists of non-space characters only.\n\t\t\tFor example, Given s = \"Hello World\", return 5.\n\t\t\t\n\t\t\t\n<!-- more -->\n\n### 题意：\n难度不大，考虑所有边界情况即可。\n\n### 解法：\nC++版本实现方法1：\n\t\t\n\t// 从右往左依次遍历即可\t\n\n``` C++\n  class Solution {\n\tpublic:\n\t\tint lengthOfLastWord(string s) {\n\t\t\tint length = 0;\n\t\t\tfor (int index = s.length() - 1; index >= 0; index--){\n\t\t\t\tchar c = s.at(index);\n\t\t\t\tif (c != ' '){\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' && length != 0){\n\t\t\t\t\treturn length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn length;\n\t\t}\n\t}\n```\nleetCode Oj系统评判结果如下图所示：\n\n![leetCode C++1](http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++1.png);\n\nC++版本实现方法2：\n\n``` C++\n\t// 直接利用现有轮子STL \nclass Solution {\n\tpublic:\n\t\tint lengthOfLastWord(string s) {\n\t\t\tauto left = find_if(s.rbegin(), s.rend(), ::isalpha);\n\t\t\tauto right = find_if_not(left, s.rend(), ::isalpha);\n\t\t\treturn distance(left, right);\n\t\t}\n\t}\n```\n\nleetCode Oj系统评判结果如下图所示：\n\n![leetCode C++2](http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++2.png);\n\n","slug":"leetCode-018-LengthOfLastWord","published":1,"updated":"2018-05-02T10:43:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frx4001579povrnpzvf1","content":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>  Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length<br>  of last word in the string.<br>  If the last word does not exist, return 0.<br>  Note: A word is defined as a character sequence consists of non-space characters only.<br>            For example, Given s = “Hello World”, return 5.</p>\n<a id=\"more\"></a>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>难度不大，考虑所有边界情况即可。</p>\n<h3 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h3><p>C++版本实现方法1：</p>\n<pre><code>// 从右往左依次遍历即可    \n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = s.length() - <span class=\"number\">1</span>; index &gt;= <span class=\"number\">0</span>; index--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">char</span> c = s.at(index);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c != <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">\t\t\t\tlength++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">' '</span> &amp;&amp; length != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> length;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> length;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>leetCode Oj系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++1.png\" alt=\"leetCode C++1\">;</p>\n<p>C++版本实现方法2：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">// 直接利用现有轮子STL </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">auto</span> left = find_if(s.rbegin(), s.rend(), ::<span class=\"built_in\">isalpha</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">auto</span> right = find_if_not(left, s.rend(), ::<span class=\"built_in\">isalpha</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> distance(left, right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>leetCode Oj系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++2.png\" alt=\"leetCode C++2\">;</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>  Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length<br>  of last word in the string.<br>  If the last word does not exist, return 0.<br>  Note: A word is defined as a character sequence consists of non-space characters only.<br>            For example, Given s = “Hello World”, return 5.</p>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>难度不大，考虑所有边界情况即可。</p>\n<h3 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h3><p>C++版本实现方法1：</p>\n<pre><code>// 从右往左依次遍历即可    \n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = s.length() - <span class=\"number\">1</span>; index &gt;= <span class=\"number\">0</span>; index--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">char</span> c = s.at(index);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c != <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">\t\t\t\tlength++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c == <span class=\"string\">' '</span> &amp;&amp; length != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> length;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> length;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>leetCode Oj系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++1.png\" alt=\"leetCode C++1\">;</p>\n<p>C++版本实现方法2：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">// 直接利用现有轮子STL </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">auto</span> left = find_if(s.rbegin(), s.rend(), ::<span class=\"built_in\">isalpha</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">auto</span> right = find_if_not(left, s.rend(), ::<span class=\"built_in\">isalpha</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> distance(left, right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>leetCode Oj系统评判结果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode018C++2.png\" alt=\"leetCode C++2\">;</p>"},{"title":"leetCode[021]Implement Strstr","date":"2015-08-21T01:14:17.000Z","_content":"\n### 题目：Implement strStr()\nImplement strStr().\n\nReturns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\n<!-- more -->\n\n### 题意：\n\n该题目就是实现strstr()函数，该函数C语言原型如下：返回字符串str1在str2中的位置。\n\n```\nextern char *strstr(char *str1, const char *str2);\n```\n\n\n### 解法：\n\n#### 暴力求解法\n\n最直接的实现方式就是暴力求解法，如下代码所示，\n\n``` C++\n  class Solution {\n\tpublic:\n\t\tint strStr(string haystack, string needle) {\n\t\t\treturn bruth(haystack, needle);\n\t\t}\n\n\tprivate:\n\t\tint bruth(string text, string pattern) {\n\t\t\tint M = pattern.length();\n\t\t\tint N = text.length();\n\t\t\tif (M == 0) return 0;\n\t\t\tif (N == 0) return -1;\n\t\t\tfor (int i = 0; i <= N - M; ++i) {\n\t\t\t\tint j = 0;\n\t\t\t\tfor (; j < M; ++j) {\n\t\t\t\t\tif (text.at(i + j) != pattern.at(j))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == M) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t};\n```\n在最坏的情况下，暴力子字符串查找算法在长度为N的文本中查找长度为M的模式字符串需要O(NM)次字符串比较。\n\n我们可以将上面的实现方法进行一定的修改，让大家能看到i指针的回退，如下代码所示，当i指针指向字符和j指向字符发生失配，i便会回退j个位置（此时j是失配前模式串的匹配项个数），同时j指向模式串的第一个位置。该段代码和上面代码其实是等效的。\n```\nclass Solution {\npublic:\n\tint strStr(string haystack, string needle) {\n\t\treturn bruth(haystack, needle);\n\t}\n\nprivate:\n\tint bruth(string text, string pattern) {\n\t\tint M = pattern.length();\n\t\tint N = text.length();\n\t\tif (M == 0) return 0;\n\t\tif (N == 0) return -1;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (; i < N && j < M; ++i) {\n\t\t\tif (text.at(i) == pattern.at(j)) j++;\n\t\t\telse {\ti -= j; j = 0; }\n\t\t}\n\t\tif (j == M) return i - M;\n\t\telse return -1;\n\t}\n};\n```\n那我们就可以很明显的看到，当模式串中j指向位置字符不匹配的时候，其实前面通过匹配我们已经获知了一部分文本的情况，因此如果能够利用这一部分已知的情况来加大模式串移动的有效性。KMP算法就是利用字符串匹配失效之前部分匹配的这个有用信息，通过保持文本指针不回退，仅有效移动模式字符串的位置来进行有效查找的。\n\n#### KMP算法\n[KMP算法](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人同时独立发现，后取这3人的姓氏命名此算法.\n大家可以参看[july的Blog](http://blog.csdn.net/tukangzheng/article/details/38438481)，讲解的是我目前看到最详细的了。\n\nKMP算法实现：\n\n```\n class Solution {\n\tpublic:\n\t\tint strStr(string haystack, string needle) {\n\t\t\treturn kmp(haystack, needle);\n\t\t}\n\tprivate:\n\t\t// KMP\n\t\tint kmp(string text, string pattern) {\n\t\t\tint M = pattern.length();\n\t\t\tint N = text.length();\n\t\t\tif (M == 0) return 0;\n\t\t\tif (N == 0) return -1;\n\t\t\tint i = 0;\n\t\t\tint j = 0;\n\t\n\t\t\tint* next = new int[M];\n\t\t\tcalculateNext(pattern, next);\n\t\t\tfor (; i < N && j < M; ++i) {\n\t\t\t\tif ( j == -1 || text.at(i) == pattern.at(j) ) j++;\n\t\t\t\telse { i--; j = next[j]; }\t// i维持不变，j跳转位置由next数组决定\n\t\t\t}\n\t\t\tdelete[] next;\n\t\n\t\t\tif (j == M) return i - M;\n\t\t\telse return -1;\n\t\t}\n\t\tvoid calculateNext(string pattern, int* next) {\n\t\t\tif (pattern.length() == 0 || next == nullptr) return;\n\t\t\tnext[0] = -1;\n\t\t\tint i = 0;\n\t\t\tint k = -1;\n\t\t\twhile (i < pattern.length() - 1) {\n\t\t\t\tif (k == -1 || pattern.at(k) == pattern.at(i)) {\n\t\t\t\t\t++i;\n\t\t\t\t\t++k;\n\t\t\t\t\tnext[i] = k;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk = next[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n```\n\n","source":"_posts/leetCode-021-ImplementStrstr.md","raw":"title: \"leetCode[021]Implement Strstr\"\ndate: 2015-08-21 09:14:17\ncategories: LeetCode\ntags: [Algorithm,String]\n---\n\n### 题目：Implement strStr()\nImplement strStr().\n\nReturns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\n<!-- more -->\n\n### 题意：\n\n该题目就是实现strstr()函数，该函数C语言原型如下：返回字符串str1在str2中的位置。\n\n```\nextern char *strstr(char *str1, const char *str2);\n```\n\n\n### 解法：\n\n#### 暴力求解法\n\n最直接的实现方式就是暴力求解法，如下代码所示，\n\n``` C++\n  class Solution {\n\tpublic:\n\t\tint strStr(string haystack, string needle) {\n\t\t\treturn bruth(haystack, needle);\n\t\t}\n\n\tprivate:\n\t\tint bruth(string text, string pattern) {\n\t\t\tint M = pattern.length();\n\t\t\tint N = text.length();\n\t\t\tif (M == 0) return 0;\n\t\t\tif (N == 0) return -1;\n\t\t\tfor (int i = 0; i <= N - M; ++i) {\n\t\t\t\tint j = 0;\n\t\t\t\tfor (; j < M; ++j) {\n\t\t\t\t\tif (text.at(i + j) != pattern.at(j))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j == M) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t};\n```\n在最坏的情况下，暴力子字符串查找算法在长度为N的文本中查找长度为M的模式字符串需要O(NM)次字符串比较。\n\n我们可以将上面的实现方法进行一定的修改，让大家能看到i指针的回退，如下代码所示，当i指针指向字符和j指向字符发生失配，i便会回退j个位置（此时j是失配前模式串的匹配项个数），同时j指向模式串的第一个位置。该段代码和上面代码其实是等效的。\n```\nclass Solution {\npublic:\n\tint strStr(string haystack, string needle) {\n\t\treturn bruth(haystack, needle);\n\t}\n\nprivate:\n\tint bruth(string text, string pattern) {\n\t\tint M = pattern.length();\n\t\tint N = text.length();\n\t\tif (M == 0) return 0;\n\t\tif (N == 0) return -1;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (; i < N && j < M; ++i) {\n\t\t\tif (text.at(i) == pattern.at(j)) j++;\n\t\t\telse {\ti -= j; j = 0; }\n\t\t}\n\t\tif (j == M) return i - M;\n\t\telse return -1;\n\t}\n};\n```\n那我们就可以很明显的看到，当模式串中j指向位置字符不匹配的时候，其实前面通过匹配我们已经获知了一部分文本的情况，因此如果能够利用这一部分已知的情况来加大模式串移动的有效性。KMP算法就是利用字符串匹配失效之前部分匹配的这个有用信息，通过保持文本指针不回退，仅有效移动模式字符串的位置来进行有效查找的。\n\n#### KMP算法\n[KMP算法](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人同时独立发现，后取这3人的姓氏命名此算法.\n大家可以参看[july的Blog](http://blog.csdn.net/tukangzheng/article/details/38438481)，讲解的是我目前看到最详细的了。\n\nKMP算法实现：\n\n```\n class Solution {\n\tpublic:\n\t\tint strStr(string haystack, string needle) {\n\t\t\treturn kmp(haystack, needle);\n\t\t}\n\tprivate:\n\t\t// KMP\n\t\tint kmp(string text, string pattern) {\n\t\t\tint M = pattern.length();\n\t\t\tint N = text.length();\n\t\t\tif (M == 0) return 0;\n\t\t\tif (N == 0) return -1;\n\t\t\tint i = 0;\n\t\t\tint j = 0;\n\t\n\t\t\tint* next = new int[M];\n\t\t\tcalculateNext(pattern, next);\n\t\t\tfor (; i < N && j < M; ++i) {\n\t\t\t\tif ( j == -1 || text.at(i) == pattern.at(j) ) j++;\n\t\t\t\telse { i--; j = next[j]; }\t// i维持不变，j跳转位置由next数组决定\n\t\t\t}\n\t\t\tdelete[] next;\n\t\n\t\t\tif (j == M) return i - M;\n\t\t\telse return -1;\n\t\t}\n\t\tvoid calculateNext(string pattern, int* next) {\n\t\t\tif (pattern.length() == 0 || next == nullptr) return;\n\t\t\tnext[0] = -1;\n\t\t\tint i = 0;\n\t\t\tint k = -1;\n\t\t\twhile (i < pattern.length() - 1) {\n\t\t\t\tif (k == -1 || pattern.at(k) == pattern.at(i)) {\n\t\t\t\t\t++i;\n\t\t\t\t\t++k;\n\t\t\t\t\tnext[i] = k;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk = next[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n```\n\n","slug":"leetCode-021-ImplementStrstr","published":1,"updated":"2018-05-02T10:45:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frx6001a79podbyv2b75","content":"<h3 id=\"题目：Implement-strStr\"><a href=\"#题目：Implement-strStr\" class=\"headerlink\" title=\"题目：Implement strStr()\"></a>题目：Implement strStr()</h3><p>Implement strStr().</p>\n<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>\n<a id=\"more\"></a>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>该题目就是实现strstr()函数，该函数C语言原型如下：返回字符串str1在str2中的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extern char *strstr(char *str1, const char *str2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h3><h4 id=\"暴力求解法\"><a href=\"#暴力求解法\" class=\"headerlink\" title=\"暴力求解法\"></a>暴力求解法</h4><p>最直接的实现方式就是暴力求解法，如下代码所示，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(<span class=\"built_in\">string</span> haystack, <span class=\"built_in\">string</span> needle)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bruth(haystack, needle);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bruth</span><span class=\"params\">(<span class=\"built_in\">string</span> text, <span class=\"built_in\">string</span> pattern)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> M = pattern.length();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> N = text.length();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (M == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (N == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N - M; ++i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (; j &lt; M; ++j) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (text.at(i + j) != pattern.at(j))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (j == M) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在最坏的情况下，暴力子字符串查找算法在长度为N的文本中查找长度为M的模式字符串需要O(NM)次字符串比较。</p>\n<p>我们可以将上面的实现方法进行一定的修改，让大家能看到i指针的回退，如下代码所示，当i指针指向字符和j指向字符发生失配，i便会回退j个位置（此时j是失配前模式串的匹配项个数），同时j指向模式串的第一个位置。该段代码和上面代码其实是等效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint strStr(string haystack, string needle) &#123;</span><br><span class=\"line\">\t\treturn bruth(haystack, needle);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint bruth(string text, string pattern) &#123;</span><br><span class=\"line\">\t\tint M = pattern.length();</span><br><span class=\"line\">\t\tint N = text.length();</span><br><span class=\"line\">\t\tif (M == 0) return 0;</span><br><span class=\"line\">\t\tif (N == 0) return -1;</span><br><span class=\"line\">\t\tint i = 0;</span><br><span class=\"line\">\t\tint j = 0;</span><br><span class=\"line\">\t\tfor (; i &lt; N &amp;&amp; j &lt; M; ++i) &#123;</span><br><span class=\"line\">\t\t\tif (text.at(i) == pattern.at(j)) j++;</span><br><span class=\"line\">\t\t\telse &#123;\ti -= j; j = 0; &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (j == M) return i - M;</span><br><span class=\"line\">\t\telse return -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>那我们就可以很明显的看到，当模式串中j指向位置字符不匹配的时候，其实前面通过匹配我们已经获知了一部分文本的情况，因此如果能够利用这一部分已知的情况来加大模式串移动的有效性。KMP算法就是利用字符串匹配失效之前部分匹配的这个有用信息，通过保持文本指针不回退，仅有效移动模式字符串的位置来进行有效查找的。</p>\n<h4 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h4><p><a href=\"https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\" target=\"_blank\" rel=\"noopener\">KMP算法</a>常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人同时独立发现，后取这3人的姓氏命名此算法.<br>大家可以参看<a href=\"http://blog.csdn.net/tukangzheng/article/details/38438481\" target=\"_blank\" rel=\"noopener\">july的Blog</a>，讲解的是我目前看到最详细的了。</p>\n<p>KMP算法实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint strStr(string haystack, string needle) &#123;</span><br><span class=\"line\">\t\treturn kmp(haystack, needle);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\t// KMP</span><br><span class=\"line\">\tint kmp(string text, string pattern) &#123;</span><br><span class=\"line\">\t\tint M = pattern.length();</span><br><span class=\"line\">\t\tint N = text.length();</span><br><span class=\"line\">\t\tif (M == 0) return 0;</span><br><span class=\"line\">\t\tif (N == 0) return -1;</span><br><span class=\"line\">\t\tint i = 0;</span><br><span class=\"line\">\t\tint j = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint* next = new int[M];</span><br><span class=\"line\">\t\tcalculateNext(pattern, next);</span><br><span class=\"line\">\t\tfor (; i &lt; N &amp;&amp; j &lt; M; ++i) &#123;</span><br><span class=\"line\">\t\t\tif ( j == -1 || text.at(i) == pattern.at(j) ) j++;</span><br><span class=\"line\">\t\t\telse &#123; i--; j = next[j]; &#125;\t// i维持不变，j跳转位置由next数组决定</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tdelete[] next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (j == M) return i - M;</span><br><span class=\"line\">\t\telse return -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid calculateNext(string pattern, int* next) &#123;</span><br><span class=\"line\">\t\tif (pattern.length() == 0 || next == nullptr) return;</span><br><span class=\"line\">\t\tnext[0] = -1;</span><br><span class=\"line\">\t\tint i = 0;</span><br><span class=\"line\">\t\tint k = -1;</span><br><span class=\"line\">\t\twhile (i &lt; pattern.length() - 1) &#123;</span><br><span class=\"line\">\t\t\tif (k == -1 || pattern.at(k) == pattern.at(i)) &#123;</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t\t++k;</span><br><span class=\"line\">\t\t\t\tnext[i] = k;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\tk = next[k];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"题目：Implement-strStr\"><a href=\"#题目：Implement-strStr\" class=\"headerlink\" title=\"题目：Implement strStr()\"></a>题目：Implement strStr()</h3><p>Implement strStr().</p>\n<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>该题目就是实现strstr()函数，该函数C语言原型如下：返回字符串str1在str2中的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extern char *strstr(char *str1, const char *str2);</span><br></pre></td></tr></table></figure>\n<h3 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h3><h4 id=\"暴力求解法\"><a href=\"#暴力求解法\" class=\"headerlink\" title=\"暴力求解法\"></a>暴力求解法</h4><p>最直接的实现方式就是暴力求解法，如下代码所示，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(<span class=\"built_in\">string</span> haystack, <span class=\"built_in\">string</span> needle)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> bruth(haystack, needle);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bruth</span><span class=\"params\">(<span class=\"built_in\">string</span> text, <span class=\"built_in\">string</span> pattern)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> M = pattern.length();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> N = text.length();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (M == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (N == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N - M; ++i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (; j &lt; M; ++j) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (text.at(i + j) != pattern.at(j))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (j == M) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在最坏的情况下，暴力子字符串查找算法在长度为N的文本中查找长度为M的模式字符串需要O(NM)次字符串比较。</p>\n<p>我们可以将上面的实现方法进行一定的修改，让大家能看到i指针的回退，如下代码所示，当i指针指向字符和j指向字符发生失配，i便会回退j个位置（此时j是失配前模式串的匹配项个数），同时j指向模式串的第一个位置。该段代码和上面代码其实是等效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint strStr(string haystack, string needle) &#123;</span><br><span class=\"line\">\t\treturn bruth(haystack, needle);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint bruth(string text, string pattern) &#123;</span><br><span class=\"line\">\t\tint M = pattern.length();</span><br><span class=\"line\">\t\tint N = text.length();</span><br><span class=\"line\">\t\tif (M == 0) return 0;</span><br><span class=\"line\">\t\tif (N == 0) return -1;</span><br><span class=\"line\">\t\tint i = 0;</span><br><span class=\"line\">\t\tint j = 0;</span><br><span class=\"line\">\t\tfor (; i &lt; N &amp;&amp; j &lt; M; ++i) &#123;</span><br><span class=\"line\">\t\t\tif (text.at(i) == pattern.at(j)) j++;</span><br><span class=\"line\">\t\t\telse &#123;\ti -= j; j = 0; &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (j == M) return i - M;</span><br><span class=\"line\">\t\telse return -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>那我们就可以很明显的看到，当模式串中j指向位置字符不匹配的时候，其实前面通过匹配我们已经获知了一部分文本的情况，因此如果能够利用这一部分已知的情况来加大模式串移动的有效性。KMP算法就是利用字符串匹配失效之前部分匹配的这个有用信息，通过保持文本指针不回退，仅有效移动模式字符串的位置来进行有效查找的。</p>\n<h4 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h4><p><a href=\"https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\" target=\"_blank\" rel=\"noopener\">KMP算法</a>常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人同时独立发现，后取这3人的姓氏命名此算法.<br>大家可以参看<a href=\"http://blog.csdn.net/tukangzheng/article/details/38438481\" target=\"_blank\" rel=\"noopener\">july的Blog</a>，讲解的是我目前看到最详细的了。</p>\n<p>KMP算法实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint strStr(string haystack, string needle) &#123;</span><br><span class=\"line\">\t\treturn kmp(haystack, needle);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\t// KMP</span><br><span class=\"line\">\tint kmp(string text, string pattern) &#123;</span><br><span class=\"line\">\t\tint M = pattern.length();</span><br><span class=\"line\">\t\tint N = text.length();</span><br><span class=\"line\">\t\tif (M == 0) return 0;</span><br><span class=\"line\">\t\tif (N == 0) return -1;</span><br><span class=\"line\">\t\tint i = 0;</span><br><span class=\"line\">\t\tint j = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint* next = new int[M];</span><br><span class=\"line\">\t\tcalculateNext(pattern, next);</span><br><span class=\"line\">\t\tfor (; i &lt; N &amp;&amp; j &lt; M; ++i) &#123;</span><br><span class=\"line\">\t\t\tif ( j == -1 || text.at(i) == pattern.at(j) ) j++;</span><br><span class=\"line\">\t\t\telse &#123; i--; j = next[j]; &#125;\t// i维持不变，j跳转位置由next数组决定</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tdelete[] next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tif (j == M) return i - M;</span><br><span class=\"line\">\t\telse return -1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid calculateNext(string pattern, int* next) &#123;</span><br><span class=\"line\">\t\tif (pattern.length() == 0 || next == nullptr) return;</span><br><span class=\"line\">\t\tnext[0] = -1;</span><br><span class=\"line\">\t\tint i = 0;</span><br><span class=\"line\">\t\tint k = -1;</span><br><span class=\"line\">\t\twhile (i &lt; pattern.length() - 1) &#123;</span><br><span class=\"line\">\t\t\tif (k == -1 || pattern.at(k) == pattern.at(i)) &#123;</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t\t++k;</span><br><span class=\"line\">\t\t\t\tnext[i] = k;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse &#123;</span><br><span class=\"line\">\t\t\t\tk = next[k];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"关于 SS 流量丢失的原因探索","date":"2019-01-28T09:51:35.000Z","_content":"\n\n\n### 2019-01-29 更新\n\n早上一到办公室连接上公司网络，网速直接就飚到了 600KB/s，甚至一度有过 M 的趋势，果不其然，还是 com.apple.Safari.SafeBrowsing.Service 这个服务进程。这就尴尬了，看来并不是说你不用 Safari 就不会触发。\n\n![Surge Dashboard][image-1]\n\n直接把 Surge 规则中的 Rule 由 Direct 改成了 Reject。\n\n\n\n# 问题追踪\n\n在 2018 年 12 月底的时候，一大早打开电脑查询刚买的 SS 服务。\n\n刚刚在前几天购买的 SS 流量，每个月 150GB 的限额在短短的 4 天之内就耗了将近 95GB，就在 1 月 1 日元旦当天就耗了接近 75GB，要知道，我并不只有 AgentNEO 一家的流量服务，相对来说在 ping test 上其还不如 Shadowsocks 家的好，所以理论上规则命中也应该是后者的，而且就算我用 A 服务看小电影也不至于这么多流量消耗。\n\n![AgentNEO 流量面板][image-2]\n\n在最初看到这个统计数据之后，我一度怀疑是他们网站的流量统计有问题。\n\n后续几天，我实际上对流量耗损比较关注，有一天注意到，Surge 的流量监控速率一直持续不断的显示达 五六百 KB/s 的下载流量，但是我知道自己当时并没有下载任何东西。\n\n![Surge Menu Bar][image-3]\n\n打开 Surge Dashboard，看到如下的情形：\n\n![Surge Dashboard][image-4]\n\n可以看到当时在持续不断的进行下载动作的进程名称是 `com.apple.Safari.SafeBrowsing.Service`，看请求地址是 safebrowsing.googleapis.com。\n\n从进程名字来看应该是 Safari 和安全流量相关的服务，通过 Snitch 的数据库查到对其的说明：\n\n> Safari has built-in support for Google’s Safe Browsing service to identify fraudulent and unsafe websites. Right before Safari navigates to a certain website, the website gets checked for possible security concerns using Google’s Safe Browsing online database. Accessing the online database requires connections to Google servers.\n\n说明该服务是针对 Safari 浏览器启用的，我们在如下图所示的 Safari 的 Security 菜单中可以找到启用关于欺诈网站的检测功能的开关。\n\n> Safari uses Tencent Safe Browsing and Google Safe Browsing to identify fraudulent websites.\n\n大概意思就是 Safari 使用腾讯的安全浏览服务和 Google 的安全浏览服务来鉴别欺诈网站，\n\n![Little Snitch Network Monitor][image-5]\n\n通过针对该进程的出口请求 host 也可以验证这一点，该进程发起的网络请求会有如下两个 host 出口：\n1. safebrowsing.googleapis.com \n2. safebrowsing.urlsec.qq.com\n\n查了一下知道腾讯为 Apple 提供了本地化的欺诈网站特征库，而我们出问题的就是 1 的 google 提供的欺诈网站特征库。\n\n![Little Snitch Network Monitor][image-6]\n\n\n尝试关闭 Surge 作为系统流量代理之后，看到 Activity Monitor 中进程又开始了下载，如下图所示，只是连接请求主体从原来 Surge 切换到了独立进程而已（Surge 会接管网络流量，因此之前该任务的下载会算到 Surge 的头上），但是针对该 host 的下载任务一致持续不断。\n\n> 说起来，Little Snitch Network Monitor 这款软件也是当时为了查流量丢失问题，才买的。\n\n![Little Snitch Network Monitor][image-7]\n\n\n而在我关闭 Surge 作为代理之前，可以看到该进程大概在 7 个小时之内耗了 12.4 GB 的流量。\n\n![Little Snitch Network Monitor][image-8]\n\n而在网络上目前未看到针对 safebrowsing 进程的大量讨论，国内论坛 [V2EX][1] 里也看到有人遇到该问题。\n\n目前暂时不清楚是官方 Bug 还是我电脑安装了什么插件或者软件导致。暂时先停掉使用 Safari 了，用 Chrome 用上一段时间之后再用 Snitch 看下情况吧。\n\n另一方面，因为不放心，在 Surge 的自定义规则中加了一条：\n\tNAME,com.apple.Safari.SafeBrowsing.Service,DIRECT\n针对该进程的所有流量都直连，不用代理了。 后续有任何进展会更新到 Blog 中。\n\n\n\n\n\n[1]:\thttps://www.v2ex.com/t/404025\n\n[image-1]:\thttps://i.imgur.com/yifgIEZ.png\n[image-2]:\thttps://i.imgur.com/9tRs9vh.png\n[image-3]:\thttps://i.imgur.com/nWz8JAt.png\n[image-4]:\thttps://i.imgur.com/9kVX27V.png\n[image-5]:\thttps://i.imgur.com/wEhv8iu.png\n[image-6]:\thttps://i.imgur.com/BtfvMIV.png\n[image-7]:\thttps://i.imgur.com/SUT5qQC.png\n[image-8]:\thttps://i.imgur.com/Gnxc4bB.png","source":"_posts/关于-SS-流量丢失的原因探索.md","raw":"---\ntitle: 关于 SS 流量丢失的原因探索\ndate: 2019-01-28 17:51:35\ntags: [Safari, Traffic]\ncategories: Mac\n---\n\n\n\n### 2019-01-29 更新\n\n早上一到办公室连接上公司网络，网速直接就飚到了 600KB/s，甚至一度有过 M 的趋势，果不其然，还是 com.apple.Safari.SafeBrowsing.Service 这个服务进程。这就尴尬了，看来并不是说你不用 Safari 就不会触发。\n\n![Surge Dashboard][image-1]\n\n直接把 Surge 规则中的 Rule 由 Direct 改成了 Reject。\n\n\n\n# 问题追踪\n\n在 2018 年 12 月底的时候，一大早打开电脑查询刚买的 SS 服务。\n\n刚刚在前几天购买的 SS 流量，每个月 150GB 的限额在短短的 4 天之内就耗了将近 95GB，就在 1 月 1 日元旦当天就耗了接近 75GB，要知道，我并不只有 AgentNEO 一家的流量服务，相对来说在 ping test 上其还不如 Shadowsocks 家的好，所以理论上规则命中也应该是后者的，而且就算我用 A 服务看小电影也不至于这么多流量消耗。\n\n![AgentNEO 流量面板][image-2]\n\n在最初看到这个统计数据之后，我一度怀疑是他们网站的流量统计有问题。\n\n后续几天，我实际上对流量耗损比较关注，有一天注意到，Surge 的流量监控速率一直持续不断的显示达 五六百 KB/s 的下载流量，但是我知道自己当时并没有下载任何东西。\n\n![Surge Menu Bar][image-3]\n\n打开 Surge Dashboard，看到如下的情形：\n\n![Surge Dashboard][image-4]\n\n可以看到当时在持续不断的进行下载动作的进程名称是 `com.apple.Safari.SafeBrowsing.Service`，看请求地址是 safebrowsing.googleapis.com。\n\n从进程名字来看应该是 Safari 和安全流量相关的服务，通过 Snitch 的数据库查到对其的说明：\n\n> Safari has built-in support for Google’s Safe Browsing service to identify fraudulent and unsafe websites. Right before Safari navigates to a certain website, the website gets checked for possible security concerns using Google’s Safe Browsing online database. Accessing the online database requires connections to Google servers.\n\n说明该服务是针对 Safari 浏览器启用的，我们在如下图所示的 Safari 的 Security 菜单中可以找到启用关于欺诈网站的检测功能的开关。\n\n> Safari uses Tencent Safe Browsing and Google Safe Browsing to identify fraudulent websites.\n\n大概意思就是 Safari 使用腾讯的安全浏览服务和 Google 的安全浏览服务来鉴别欺诈网站，\n\n![Little Snitch Network Monitor][image-5]\n\n通过针对该进程的出口请求 host 也可以验证这一点，该进程发起的网络请求会有如下两个 host 出口：\n1. safebrowsing.googleapis.com \n2. safebrowsing.urlsec.qq.com\n\n查了一下知道腾讯为 Apple 提供了本地化的欺诈网站特征库，而我们出问题的就是 1 的 google 提供的欺诈网站特征库。\n\n![Little Snitch Network Monitor][image-6]\n\n\n尝试关闭 Surge 作为系统流量代理之后，看到 Activity Monitor 中进程又开始了下载，如下图所示，只是连接请求主体从原来 Surge 切换到了独立进程而已（Surge 会接管网络流量，因此之前该任务的下载会算到 Surge 的头上），但是针对该 host 的下载任务一致持续不断。\n\n> 说起来，Little Snitch Network Monitor 这款软件也是当时为了查流量丢失问题，才买的。\n\n![Little Snitch Network Monitor][image-7]\n\n\n而在我关闭 Surge 作为代理之前，可以看到该进程大概在 7 个小时之内耗了 12.4 GB 的流量。\n\n![Little Snitch Network Monitor][image-8]\n\n而在网络上目前未看到针对 safebrowsing 进程的大量讨论，国内论坛 [V2EX][1] 里也看到有人遇到该问题。\n\n目前暂时不清楚是官方 Bug 还是我电脑安装了什么插件或者软件导致。暂时先停掉使用 Safari 了，用 Chrome 用上一段时间之后再用 Snitch 看下情况吧。\n\n另一方面，因为不放心，在 Surge 的自定义规则中加了一条：\n\tNAME,com.apple.Safari.SafeBrowsing.Service,DIRECT\n针对该进程的所有流量都直连，不用代理了。 后续有任何进展会更新到 Blog 中。\n\n\n\n\n\n[1]:\thttps://www.v2ex.com/t/404025\n\n[image-1]:\thttps://i.imgur.com/yifgIEZ.png\n[image-2]:\thttps://i.imgur.com/9tRs9vh.png\n[image-3]:\thttps://i.imgur.com/nWz8JAt.png\n[image-4]:\thttps://i.imgur.com/9kVX27V.png\n[image-5]:\thttps://i.imgur.com/wEhv8iu.png\n[image-6]:\thttps://i.imgur.com/BtfvMIV.png\n[image-7]:\thttps://i.imgur.com/SUT5qQC.png\n[image-8]:\thttps://i.imgur.com/Gnxc4bB.png","slug":"关于-SS-流量丢失的原因探索","published":1,"updated":"2019-01-31T02:30:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frx8001c79poyolcnhis","content":"<h3 id=\"2019-01-29-更新\"><a href=\"#2019-01-29-更新\" class=\"headerlink\" title=\"2019-01-29 更新\"></a>2019-01-29 更新</h3><p>早上一到办公室连接上公司网络，网速直接就飚到了 600KB/s，甚至一度有过 M 的趋势，果不其然，还是 com.apple.Safari.SafeBrowsing.Service 这个服务进程。这就尴尬了，看来并不是说你不用 Safari 就不会触发。</p>\n<p><img src=\"https://i.imgur.com/yifgIEZ.png\" alt=\"Surge Dashboard\"></p>\n<p>直接把 Surge 规则中的 Rule 由 Direct 改成了 Reject。</p>\n<h1 id=\"问题追踪\"><a href=\"#问题追踪\" class=\"headerlink\" title=\"问题追踪\"></a>问题追踪</h1><p>在 2018 年 12 月底的时候，一大早打开电脑查询刚买的 SS 服务。</p>\n<p>刚刚在前几天购买的 SS 流量，每个月 150GB 的限额在短短的 4 天之内就耗了将近 95GB，就在 1 月 1 日元旦当天就耗了接近 75GB，要知道，我并不只有 AgentNEO 一家的流量服务，相对来说在 ping test 上其还不如 Shadowsocks 家的好，所以理论上规则命中也应该是后者的，而且就算我用 A 服务看小电影也不至于这么多流量消耗。</p>\n<p><img src=\"https://i.imgur.com/9tRs9vh.png\" alt=\"AgentNEO 流量面板\"></p>\n<p>在最初看到这个统计数据之后，我一度怀疑是他们网站的流量统计有问题。</p>\n<p>后续几天，我实际上对流量耗损比较关注，有一天注意到，Surge 的流量监控速率一直持续不断的显示达 五六百 KB/s 的下载流量，但是我知道自己当时并没有下载任何东西。</p>\n<p><img src=\"https://i.imgur.com/nWz8JAt.png\" alt=\"Surge Menu Bar\"></p>\n<p>打开 Surge Dashboard，看到如下的情形：</p>\n<p><img src=\"https://i.imgur.com/9kVX27V.png\" alt=\"Surge Dashboard\"></p>\n<p>可以看到当时在持续不断的进行下载动作的进程名称是 <code>com.apple.Safari.SafeBrowsing.Service</code>，看请求地址是 safebrowsing.googleapis.com。</p>\n<p>从进程名字来看应该是 Safari 和安全流量相关的服务，通过 Snitch 的数据库查到对其的说明：</p>\n<blockquote>\n<p>Safari has built-in support for Google’s Safe Browsing service to identify fraudulent and unsafe websites. Right before Safari navigates to a certain website, the website gets checked for possible security concerns using Google’s Safe Browsing online database. Accessing the online database requires connections to Google servers.</p>\n</blockquote>\n<p>说明该服务是针对 Safari 浏览器启用的，我们在如下图所示的 Safari 的 Security 菜单中可以找到启用关于欺诈网站的检测功能的开关。</p>\n<blockquote>\n<p>Safari uses Tencent Safe Browsing and Google Safe Browsing to identify fraudulent websites.</p>\n</blockquote>\n<p>大概意思就是 Safari 使用腾讯的安全浏览服务和 Google 的安全浏览服务来鉴别欺诈网站，</p>\n<p><img src=\"https://i.imgur.com/wEhv8iu.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>通过针对该进程的出口请求 host 也可以验证这一点，该进程发起的网络请求会有如下两个 host 出口：</p>\n<ol>\n<li>safebrowsing.googleapis.com </li>\n<li>safebrowsing.urlsec.qq.com</li>\n</ol>\n<p>查了一下知道腾讯为 Apple 提供了本地化的欺诈网站特征库，而我们出问题的就是 1 的 google 提供的欺诈网站特征库。</p>\n<p><img src=\"https://i.imgur.com/BtfvMIV.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>尝试关闭 Surge 作为系统流量代理之后，看到 Activity Monitor 中进程又开始了下载，如下图所示，只是连接请求主体从原来 Surge 切换到了独立进程而已（Surge 会接管网络流量，因此之前该任务的下载会算到 Surge 的头上），但是针对该 host 的下载任务一致持续不断。</p>\n<blockquote>\n<p>说起来，Little Snitch Network Monitor 这款软件也是当时为了查流量丢失问题，才买的。</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/SUT5qQC.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>而在我关闭 Surge 作为代理之前，可以看到该进程大概在 7 个小时之内耗了 12.4 GB 的流量。</p>\n<p><img src=\"https://i.imgur.com/Gnxc4bB.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>而在网络上目前未看到针对 safebrowsing 进程的大量讨论，国内论坛 <a href=\"https://www.v2ex.com/t/404025\" target=\"_blank\" rel=\"noopener\">V2EX</a> 里也看到有人遇到该问题。</p>\n<p>目前暂时不清楚是官方 Bug 还是我电脑安装了什么插件或者软件导致。暂时先停掉使用 Safari 了，用 Chrome 用上一段时间之后再用 Snitch 看下情况吧。</p>\n<p>另一方面，因为不放心，在 Surge 的自定义规则中加了一条：<br>    NAME,com.apple.Safari.SafeBrowsing.Service,DIRECT<br>针对该进程的所有流量都直连，不用代理了。 后续有任何进展会更新到 Blog 中。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<h3 id=\"2019-01-29-更新\"><a href=\"#2019-01-29-更新\" class=\"headerlink\" title=\"2019-01-29 更新\"></a>2019-01-29 更新</h3><p>早上一到办公室连接上公司网络，网速直接就飚到了 600KB/s，甚至一度有过 M 的趋势，果不其然，还是 com.apple.Safari.SafeBrowsing.Service 这个服务进程。这就尴尬了，看来并不是说你不用 Safari 就不会触发。</p>\n<p><img src=\"https://i.imgur.com/yifgIEZ.png\" alt=\"Surge Dashboard\"></p>\n<p>直接把 Surge 规则中的 Rule 由 Direct 改成了 Reject。</p>\n<h1 id=\"问题追踪\"><a href=\"#问题追踪\" class=\"headerlink\" title=\"问题追踪\"></a>问题追踪</h1><p>在 2018 年 12 月底的时候，一大早打开电脑查询刚买的 SS 服务。</p>\n<p>刚刚在前几天购买的 SS 流量，每个月 150GB 的限额在短短的 4 天之内就耗了将近 95GB，就在 1 月 1 日元旦当天就耗了接近 75GB，要知道，我并不只有 AgentNEO 一家的流量服务，相对来说在 ping test 上其还不如 Shadowsocks 家的好，所以理论上规则命中也应该是后者的，而且就算我用 A 服务看小电影也不至于这么多流量消耗。</p>\n<p><img src=\"https://i.imgur.com/9tRs9vh.png\" alt=\"AgentNEO 流量面板\"></p>\n<p>在最初看到这个统计数据之后，我一度怀疑是他们网站的流量统计有问题。</p>\n<p>后续几天，我实际上对流量耗损比较关注，有一天注意到，Surge 的流量监控速率一直持续不断的显示达 五六百 KB/s 的下载流量，但是我知道自己当时并没有下载任何东西。</p>\n<p><img src=\"https://i.imgur.com/nWz8JAt.png\" alt=\"Surge Menu Bar\"></p>\n<p>打开 Surge Dashboard，看到如下的情形：</p>\n<p><img src=\"https://i.imgur.com/9kVX27V.png\" alt=\"Surge Dashboard\"></p>\n<p>可以看到当时在持续不断的进行下载动作的进程名称是 <code>com.apple.Safari.SafeBrowsing.Service</code>，看请求地址是 safebrowsing.googleapis.com。</p>\n<p>从进程名字来看应该是 Safari 和安全流量相关的服务，通过 Snitch 的数据库查到对其的说明：</p>\n<blockquote>\n<p>Safari has built-in support for Google’s Safe Browsing service to identify fraudulent and unsafe websites. Right before Safari navigates to a certain website, the website gets checked for possible security concerns using Google’s Safe Browsing online database. Accessing the online database requires connections to Google servers.</p>\n</blockquote>\n<p>说明该服务是针对 Safari 浏览器启用的，我们在如下图所示的 Safari 的 Security 菜单中可以找到启用关于欺诈网站的检测功能的开关。</p>\n<blockquote>\n<p>Safari uses Tencent Safe Browsing and Google Safe Browsing to identify fraudulent websites.</p>\n</blockquote>\n<p>大概意思就是 Safari 使用腾讯的安全浏览服务和 Google 的安全浏览服务来鉴别欺诈网站，</p>\n<p><img src=\"https://i.imgur.com/wEhv8iu.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>通过针对该进程的出口请求 host 也可以验证这一点，该进程发起的网络请求会有如下两个 host 出口：</p>\n<ol>\n<li>safebrowsing.googleapis.com </li>\n<li>safebrowsing.urlsec.qq.com</li>\n</ol>\n<p>查了一下知道腾讯为 Apple 提供了本地化的欺诈网站特征库，而我们出问题的就是 1 的 google 提供的欺诈网站特征库。</p>\n<p><img src=\"https://i.imgur.com/BtfvMIV.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>尝试关闭 Surge 作为系统流量代理之后，看到 Activity Monitor 中进程又开始了下载，如下图所示，只是连接请求主体从原来 Surge 切换到了独立进程而已（Surge 会接管网络流量，因此之前该任务的下载会算到 Surge 的头上），但是针对该 host 的下载任务一致持续不断。</p>\n<blockquote>\n<p>说起来，Little Snitch Network Monitor 这款软件也是当时为了查流量丢失问题，才买的。</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/SUT5qQC.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>而在我关闭 Surge 作为代理之前，可以看到该进程大概在 7 个小时之内耗了 12.4 GB 的流量。</p>\n<p><img src=\"https://i.imgur.com/Gnxc4bB.png\" alt=\"Little Snitch Network Monitor\"></p>\n<p>而在网络上目前未看到针对 safebrowsing 进程的大量讨论，国内论坛 <a href=\"https://www.v2ex.com/t/404025\" target=\"_blank\" rel=\"noopener\">V2EX</a> 里也看到有人遇到该问题。</p>\n<p>目前暂时不清楚是官方 Bug 还是我电脑安装了什么插件或者软件导致。暂时先停掉使用 Safari 了，用 Chrome 用上一段时间之后再用 Snitch 看下情况吧。</p>\n<p>另一方面，因为不放心，在 Surge 的自定义规则中加了一条：<br>    NAME,com.apple.Safari.SafeBrowsing.Service,DIRECT<br>针对该进程的所有流量都直连，不用代理了。 后续有任何进展会更新到 Blog 中。</p>\n"},{"title":"leetCode[019]BinaryTreePaths","date":"2015-08-18T08:28:26.000Z","_content":"\n### 题目：\n  Given a binary tree, return all root-to-leaf paths.\n    For example, given the following binary tree:\n\t\t\t\t\t\t   1\n\t\t\t\t\t\t /   \\\n\t\t\t\t\t    2     3\n\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t    5\n\tAll root-to-leaf paths are:\n\t\t\t[\"1->2->5\", \"1->3\"]\n\t\t\t\n<!-- more -->\n\n### 题意：\n难度不大，考察树的遍历\n\n### 解法：\nC++版本实现方法：\n\t\t\n\t/**\n\t\t * Definition for a binary tree node.\n\t\t * struct TreeNode {\n\t\t *     int val;\n\t\t *     TreeNode *left;\n\t\t *     TreeNode *right;\n\t\t *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n\t\t * };\n\t\t */\n\tclass Solution {\n\t\tpublic:\n\t\t\tvector<string> binaryTreePaths(TreeNode* root) \n\t\t\t{\n\t\t\t\tvector<string> results;\n\t\t\t\tvisitTreeNode(root, \"\", results);\n\t\t\t\treturn results;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tvoid visitTreeNode(TreeNode* node, string path, vector<string>& result)\n\t\t\t{\n\t\t\t    if(node == nullptr) return;\n\t\t\t\tif (!path.empty())\n\t\t\t\t{\n\t\t\t\t\tpath += \"->\";\n\t\t\t\t}\n\t\t\t\tpath += int2Str(node->val);\n\n\t\t\t\tif (node->left == nullptr && node->right == nullptr)\n\t\t\t\t{\n\t\t\t\t\tresult.push_back(path);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (node->left != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tvisitTreeNode(node->left, path, result);\n\t\t\t\t\t}\n\t\t\t\t\tif (node->right != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tvisitTreeNode(node->right, path, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::string int2Str(int nValue)\n\t\t\t{\n\t\t\t\tostringstream ss;\n\t\t\t\tss << nValue;\n\t\t\t\treturn ss.str();\n\t\t\t}\n\t\t};\nleetCode Oj系统评判结果如下图所示：\n没有各种语言的柱状图，官方解释由于没有充足的提交导致，不知道是新题还是因为太简单大家直接略过了~\n\n![leetCode Binary Tree Paths C++](http://7xilk1.com1.z0.glb.clouddn.com/leetCode019C++.png);\n\n相关题目：[Path Sum 2]()\n\n","source":"_posts/leetCode-019-BinaryTreePaths.md","raw":"title: \"leetCode[019]BinaryTreePaths\"\ndate: 2015-08-18 16:28:26\ncategories: LeetCode\ntags: [Algorithm,String]\n---\n\n### 题目：\n  Given a binary tree, return all root-to-leaf paths.\n    For example, given the following binary tree:\n\t\t\t\t\t\t   1\n\t\t\t\t\t\t /   \\\n\t\t\t\t\t    2     3\n\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t    5\n\tAll root-to-leaf paths are:\n\t\t\t[\"1->2->5\", \"1->3\"]\n\t\t\t\n<!-- more -->\n\n### 题意：\n难度不大，考察树的遍历\n\n### 解法：\nC++版本实现方法：\n\t\t\n\t/**\n\t\t * Definition for a binary tree node.\n\t\t * struct TreeNode {\n\t\t *     int val;\n\t\t *     TreeNode *left;\n\t\t *     TreeNode *right;\n\t\t *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n\t\t * };\n\t\t */\n\tclass Solution {\n\t\tpublic:\n\t\t\tvector<string> binaryTreePaths(TreeNode* root) \n\t\t\t{\n\t\t\t\tvector<string> results;\n\t\t\t\tvisitTreeNode(root, \"\", results);\n\t\t\t\treturn results;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tvoid visitTreeNode(TreeNode* node, string path, vector<string>& result)\n\t\t\t{\n\t\t\t    if(node == nullptr) return;\n\t\t\t\tif (!path.empty())\n\t\t\t\t{\n\t\t\t\t\tpath += \"->\";\n\t\t\t\t}\n\t\t\t\tpath += int2Str(node->val);\n\n\t\t\t\tif (node->left == nullptr && node->right == nullptr)\n\t\t\t\t{\n\t\t\t\t\tresult.push_back(path);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (node->left != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tvisitTreeNode(node->left, path, result);\n\t\t\t\t\t}\n\t\t\t\t\tif (node->right != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tvisitTreeNode(node->right, path, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::string int2Str(int nValue)\n\t\t\t{\n\t\t\t\tostringstream ss;\n\t\t\t\tss << nValue;\n\t\t\t\treturn ss.str();\n\t\t\t}\n\t\t};\nleetCode Oj系统评判结果如下图所示：\n没有各种语言的柱状图，官方解释由于没有充足的提交导致，不知道是新题还是因为太简单大家直接略过了~\n\n![leetCode Binary Tree Paths C++](http://7xilk1.com1.z0.glb.clouddn.com/leetCode019C++.png);\n\n相关题目：[Path Sum 2]()\n\n","slug":"leetCode-019-BinaryTreePaths","published":1,"updated":"2018-05-02T10:46:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frxa001h79powf6zts7f","content":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>  Given a binary tree, return all root-to-leaf paths.<br>    For example, given the following binary tree:<br>                           1<br>                         /   \\<br>                        2     3<br>                               \\<br>                                5<br>    All root-to-leaf paths are:<br>            [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>\n<a id=\"more\"></a>\n<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>难度不大，考察树的遍历</p>\n<h3 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h3><p>C++版本实现方法：</p>\n<pre><code>/**\n     * Definition for a binary tree node.\n     * struct TreeNode {\n     *     int val;\n     *     TreeNode *left;\n     *     TreeNode *right;\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n     * };\n     */\nclass Solution {\n    public:\n        vector&lt;string&gt; binaryTreePaths(TreeNode* root) \n        {\n            vector&lt;string&gt; results;\n            visitTreeNode(root, &quot;&quot;, results);\n            return results;\n        }\n\n    private:\n        void visitTreeNode(TreeNode* node, string path, vector&lt;string&gt;&amp; result)\n        {\n            if(node == nullptr) return;\n            if (!path.empty())\n            {\n                path += &quot;-&gt;&quot;;\n            }\n            path += int2Str(node-&gt;val);\n\n            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr)\n            {\n                result.push_back(path);\n            }\n            else\n            {\n                if (node-&gt;left != nullptr)\n                {\n                    visitTreeNode(node-&gt;left, path, result);\n                }\n                if (node-&gt;right != nullptr)\n                {\n                    visitTreeNode(node-&gt;right, path, result);\n                }\n            }\n        }\n\n        std::string int2Str(int nValue)\n        {\n            ostringstream ss;\n            ss &lt;&lt; nValue;\n            return ss.str();\n        }\n    };\n</code></pre><p>leetCode Oj系统评判结果如下图所示：<br>没有各种语言的柱状图，官方解释由于没有充足的提交导致，不知道是新题还是因为太简单大家直接略过了~</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode019C++.png\" alt=\"leetCode Binary Tree Paths C++\">;</p>\n<p>相关题目：<a href=\"\">Path Sum 2</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>  Given a binary tree, return all root-to-leaf paths.<br>    For example, given the following binary tree:<br>                           1<br>                         /   \\<br>                        2     3<br>                               \\<br>                                5<br>    All root-to-leaf paths are:<br>            [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>","more":"<h3 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h3><p>难度不大，考察树的遍历</p>\n<h3 id=\"解法：\"><a href=\"#解法：\" class=\"headerlink\" title=\"解法：\"></a>解法：</h3><p>C++版本实现方法：</p>\n<pre><code>/**\n     * Definition for a binary tree node.\n     * struct TreeNode {\n     *     int val;\n     *     TreeNode *left;\n     *     TreeNode *right;\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n     * };\n     */\nclass Solution {\n    public:\n        vector&lt;string&gt; binaryTreePaths(TreeNode* root) \n        {\n            vector&lt;string&gt; results;\n            visitTreeNode(root, &quot;&quot;, results);\n            return results;\n        }\n\n    private:\n        void visitTreeNode(TreeNode* node, string path, vector&lt;string&gt;&amp; result)\n        {\n            if(node == nullptr) return;\n            if (!path.empty())\n            {\n                path += &quot;-&gt;&quot;;\n            }\n            path += int2Str(node-&gt;val);\n\n            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr)\n            {\n                result.push_back(path);\n            }\n            else\n            {\n                if (node-&gt;left != nullptr)\n                {\n                    visitTreeNode(node-&gt;left, path, result);\n                }\n                if (node-&gt;right != nullptr)\n                {\n                    visitTreeNode(node-&gt;right, path, result);\n                }\n            }\n        }\n\n        std::string int2Str(int nValue)\n        {\n            ostringstream ss;\n            ss &lt;&lt; nValue;\n            return ss.str();\n        }\n    };\n</code></pre><p>leetCode Oj系统评判结果如下图所示：<br>没有各种语言的柱状图，官方解释由于没有充足的提交导致，不知道是新题还是因为太简单大家直接略过了~</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/leetCode019C++.png\" alt=\"leetCode Binary Tree Paths C++\">;</p>\n<p>相关题目：<a href=\"\">Path Sum 2</a></p>"},{"title":"关于单链表的那些事儿","date":"2015-05-07T05:59:00.000Z","_content":"\n关于有环单链表，即单链表中存在环路，该问题衍生出很多面试题，特在此汇总，方便查阅也帮助自己梳理下思路。\n\n<!-- more -->\n\n如下图1所示为有环单链表，假设头结点为H， 环的入口点为A。\n\n![有环单链表示例](http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_1.jpg)\n\n##### 关于有环单链表相关的问题：\n\n1. 该单链表中是否真有环存在？\n2. 如何求出环状的入口点？\n3. 如何求出环状的长度？\n4. 求解整条链表的长度？\n\n下面我们分别针对这几个问题进行分析和解答。\n\n#### 判断一个单链表是否存在环\n\n　　首先，关于第一个问题，如何确定一条链表中确实存在环，关于环状的检测主要有三种方法，链表环状检测主要有三种方法：外部记录法，内部记录法以及追赶法。\n\n　　内部标记法和外部标记法其实是一个道理，不过就是辅助变量一个是在链表节点内，一个是借助辅助数组或者hash或者AVL，红黑树等 把已经访问过的节点地址存起来，每次访问下一个节点的时候进行查询看是否已经出现过。这里不再赘述。主要看追赶法，也称快满指针法，而追赶法大家一定都已经烂熟于心了。\n\n　　追赶法主要利用最大公倍数原理，用2个游标，对链表进行访问，例如:pSlow， pFast。 pSlow访问每步向前进1个节点，而pFast则每次向前前进2个节点，如果有环则pSlow和pFast必会相遇，如果pFast最终指向了NULL，则说明该链表不存在环路。因为两个指针步子迈的不一样，因为被称作快慢指针。\n\n    // Definition for singly - linked list.\n\tstruct ListNode {\n\t    int val;\n\t    ListNode *next;\n\t    ListNode(int x) : val(x), next(nullptr) {}\n\t};\n\n\tbool isLoopList(ListNode *pHead){\n\t    if (nullptr == pHead || nullptr == pHead->next){\n\t        return false;\n\t    }\n\n\t    ListNode *pSlow = pHead;\n\t    ListNode *pFast = pHead;\n\t    while (pFast && pFast->next){\n\t        pFast = pFast->next->next;\n\t        pSlow = pSlow->next;\n\t\n\t        if (pFast == pSlow){\n\t            break;\n\t        }\n\t    }\n\n\t    return !(nullptr == pFast || nullptr == pFast->next);\n\t}\n\n\n#### 确定该有环单链表的环的入口\n\n　　关于这个问题，首先我们需要证明当pSlow和pFast第一次相遇的时候，pSlow并未走完整个链表或者恰好到达环入口点。\n\n![有环单链表](http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_2.jpg)\n\n看上图（画的比较粗糙），假设pSlow到达环状入口点A的时候，pFast在环上某一点B，假设B逆时针方向离A点距离为y，并且整个环状的长度为R，我们知道y <= R。从A点开始，pSlow向前走y步，此时pFast从点B往前则走2 * y步 并与pSlow相遇于点D，此时pSlow还需R - y 才能到达链表尾端，也即A点。因为y <= R，因此R - y >= 0。得证。\n\n![有环单链表](http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_3.jpg)\n\n　　此时我们假设相遇的时候pSlow走了s步，那pFast走2 * s步，而pFast多走的肯定是在环内绕圈，很自然我们有 \n\n　　2 * s = s + n * R ;   (n >= 1)\n\n　　有： s = n * R (n >= 1).\n\n　　设整个链表的长度为L， HA的长度为a ，第一次相遇点B与A的距离为x，则有\n\n　　a + x = s = n * R;\n\n　　a + x = (n - 1 + 1 ) * R = (n - 1) * R + R =  (n - 1) * R + L - a;\n\n　　有 a = (n - 1) * R + (L - a - x);　　有前面我们证明知，L - a - x 为我们所设变量y。 因此a = (n - 1) * R + y; (n >= 1).\n\n　　这样，我们就可以这样，相遇点设置一个指针，链表头部设置一个指针，这两个指针同时按照一步一个节点前进，第一次相遇的时候必定是相遇点指针走y + (n - 1)*R的时候，也就是入口点A的位置。得证，因此获取入口点的实现如下。\n\n    ListNode *loopJoint(ListNode *pHead){\n        if (nullptr == pHead || nullptr == pHead->next){\n            return nullptr;\n        }\n\n        ListNode *pSlow = pHead;\n        ListNode *pFast = pHead;\n        while (pFast && pFast->next){\n            pFast = pFast->next->next;\n            pSlow = pSlow->next;\n\n            if (pFast == pSlow){\n                break;\n            }\n        }\n\n        if (nullptr == pFast || nullptr == pFast->next){\n            return nullptr;\n        }\n\n        // 此时调整两个指针为普通指针，一次一步，并且其中一个指针从头部开始，第一次相遇点一定是环的入口点\n        pSlow = pHead;\n        while (pFast != pSlow){\n            pFast = pFast->next;\n            pSlow = pSlow->next;\n        }\n\n        return pSlow;\n    }\n\n\n#### 求出该有环单链表中环的长度\n\n有了以上的基础，环状的长度就很明显了，入口点已知，沿着环状走一圈即得。\n\n\n#### 求出该有环单链表长度\n\n同理，当R已知，而问题2中其中指向头部的指针到达环状入口点的时候HA已知，因此单链表的长度等于 L =  R + a;\n\n\n","source":"_posts/关于单链表的那些事儿.md","raw":"title: \"关于单链表的那些事儿\"\ndate: 2015-05-07 13:59:00\ncategories: Data Structure\ntags: [Data Structure, Algorithm]\n---\n\n关于有环单链表，即单链表中存在环路，该问题衍生出很多面试题，特在此汇总，方便查阅也帮助自己梳理下思路。\n\n<!-- more -->\n\n如下图1所示为有环单链表，假设头结点为H， 环的入口点为A。\n\n![有环单链表示例](http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_1.jpg)\n\n##### 关于有环单链表相关的问题：\n\n1. 该单链表中是否真有环存在？\n2. 如何求出环状的入口点？\n3. 如何求出环状的长度？\n4. 求解整条链表的长度？\n\n下面我们分别针对这几个问题进行分析和解答。\n\n#### 判断一个单链表是否存在环\n\n　　首先，关于第一个问题，如何确定一条链表中确实存在环，关于环状的检测主要有三种方法，链表环状检测主要有三种方法：外部记录法，内部记录法以及追赶法。\n\n　　内部标记法和外部标记法其实是一个道理，不过就是辅助变量一个是在链表节点内，一个是借助辅助数组或者hash或者AVL，红黑树等 把已经访问过的节点地址存起来，每次访问下一个节点的时候进行查询看是否已经出现过。这里不再赘述。主要看追赶法，也称快满指针法，而追赶法大家一定都已经烂熟于心了。\n\n　　追赶法主要利用最大公倍数原理，用2个游标，对链表进行访问，例如:pSlow， pFast。 pSlow访问每步向前进1个节点，而pFast则每次向前前进2个节点，如果有环则pSlow和pFast必会相遇，如果pFast最终指向了NULL，则说明该链表不存在环路。因为两个指针步子迈的不一样，因为被称作快慢指针。\n\n    // Definition for singly - linked list.\n\tstruct ListNode {\n\t    int val;\n\t    ListNode *next;\n\t    ListNode(int x) : val(x), next(nullptr) {}\n\t};\n\n\tbool isLoopList(ListNode *pHead){\n\t    if (nullptr == pHead || nullptr == pHead->next){\n\t        return false;\n\t    }\n\n\t    ListNode *pSlow = pHead;\n\t    ListNode *pFast = pHead;\n\t    while (pFast && pFast->next){\n\t        pFast = pFast->next->next;\n\t        pSlow = pSlow->next;\n\t\n\t        if (pFast == pSlow){\n\t            break;\n\t        }\n\t    }\n\n\t    return !(nullptr == pFast || nullptr == pFast->next);\n\t}\n\n\n#### 确定该有环单链表的环的入口\n\n　　关于这个问题，首先我们需要证明当pSlow和pFast第一次相遇的时候，pSlow并未走完整个链表或者恰好到达环入口点。\n\n![有环单链表](http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_2.jpg)\n\n看上图（画的比较粗糙），假设pSlow到达环状入口点A的时候，pFast在环上某一点B，假设B逆时针方向离A点距离为y，并且整个环状的长度为R，我们知道y <= R。从A点开始，pSlow向前走y步，此时pFast从点B往前则走2 * y步 并与pSlow相遇于点D，此时pSlow还需R - y 才能到达链表尾端，也即A点。因为y <= R，因此R - y >= 0。得证。\n\n![有环单链表](http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_3.jpg)\n\n　　此时我们假设相遇的时候pSlow走了s步，那pFast走2 * s步，而pFast多走的肯定是在环内绕圈，很自然我们有 \n\n　　2 * s = s + n * R ;   (n >= 1)\n\n　　有： s = n * R (n >= 1).\n\n　　设整个链表的长度为L， HA的长度为a ，第一次相遇点B与A的距离为x，则有\n\n　　a + x = s = n * R;\n\n　　a + x = (n - 1 + 1 ) * R = (n - 1) * R + R =  (n - 1) * R + L - a;\n\n　　有 a = (n - 1) * R + (L - a - x);　　有前面我们证明知，L - a - x 为我们所设变量y。 因此a = (n - 1) * R + y; (n >= 1).\n\n　　这样，我们就可以这样，相遇点设置一个指针，链表头部设置一个指针，这两个指针同时按照一步一个节点前进，第一次相遇的时候必定是相遇点指针走y + (n - 1)*R的时候，也就是入口点A的位置。得证，因此获取入口点的实现如下。\n\n    ListNode *loopJoint(ListNode *pHead){\n        if (nullptr == pHead || nullptr == pHead->next){\n            return nullptr;\n        }\n\n        ListNode *pSlow = pHead;\n        ListNode *pFast = pHead;\n        while (pFast && pFast->next){\n            pFast = pFast->next->next;\n            pSlow = pSlow->next;\n\n            if (pFast == pSlow){\n                break;\n            }\n        }\n\n        if (nullptr == pFast || nullptr == pFast->next){\n            return nullptr;\n        }\n\n        // 此时调整两个指针为普通指针，一次一步，并且其中一个指针从头部开始，第一次相遇点一定是环的入口点\n        pSlow = pHead;\n        while (pFast != pSlow){\n            pFast = pFast->next;\n            pSlow = pSlow->next;\n        }\n\n        return pSlow;\n    }\n\n\n#### 求出该有环单链表中环的长度\n\n有了以上的基础，环状的长度就很明显了，入口点已知，沿着环状走一圈即得。\n\n\n#### 求出该有环单链表长度\n\n同理，当R已知，而问题2中其中指向头部的指针到达环状入口点的时候HA已知，因此单链表的长度等于 L =  R + a;\n\n\n","slug":"关于单链表的那些事儿","published":1,"updated":"2017-05-21T08:31:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frxc001j79poca5dmhd6","content":"<p>关于有环单链表，即单链表中存在环路，该问题衍生出很多面试题，特在此汇总，方便查阅也帮助自己梳理下思路。</p>\n<a id=\"more\"></a>\n<p>如下图1所示为有环单链表，假设头结点为H， 环的入口点为A。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_1.jpg\" alt=\"有环单链表示例\"></p>\n<h5 id=\"关于有环单链表相关的问题：\"><a href=\"#关于有环单链表相关的问题：\" class=\"headerlink\" title=\"关于有环单链表相关的问题：\"></a>关于有环单链表相关的问题：</h5><ol>\n<li>该单链表中是否真有环存在？</li>\n<li>如何求出环状的入口点？</li>\n<li>如何求出环状的长度？</li>\n<li>求解整条链表的长度？</li>\n</ol>\n<p>下面我们分别针对这几个问题进行分析和解答。</p>\n<h4 id=\"判断一个单链表是否存在环\"><a href=\"#判断一个单链表是否存在环\" class=\"headerlink\" title=\"判断一个单链表是否存在环\"></a>判断一个单链表是否存在环</h4><p>　　首先，关于第一个问题，如何确定一条链表中确实存在环，关于环状的检测主要有三种方法，链表环状检测主要有三种方法：外部记录法，内部记录法以及追赶法。</p>\n<p>　　内部标记法和外部标记法其实是一个道理，不过就是辅助变量一个是在链表节点内，一个是借助辅助数组或者hash或者AVL，红黑树等 把已经访问过的节点地址存起来，每次访问下一个节点的时候进行查询看是否已经出现过。这里不再赘述。主要看追赶法，也称快满指针法，而追赶法大家一定都已经烂熟于心了。</p>\n<p>　　追赶法主要利用最大公倍数原理，用2个游标，对链表进行访问，例如:pSlow， pFast。 pSlow访问每步向前进1个节点，而pFast则每次向前前进2个节点，如果有环则pSlow和pFast必会相遇，如果pFast最终指向了NULL，则说明该链表不存在环路。因为两个指针步子迈的不一样，因为被称作快慢指针。</p>\n<pre><code>// Definition for singly - linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nbool isLoopList(ListNode *pHead){\n    if (nullptr == pHead || nullptr == pHead-&gt;next){\n        return false;\n    }\n\n    ListNode *pSlow = pHead;\n    ListNode *pFast = pHead;\n    while (pFast &amp;&amp; pFast-&gt;next){\n        pFast = pFast-&gt;next-&gt;next;\n        pSlow = pSlow-&gt;next;\n\n        if (pFast == pSlow){\n            break;\n        }\n    }\n\n    return !(nullptr == pFast || nullptr == pFast-&gt;next);\n}\n</code></pre><h4 id=\"确定该有环单链表的环的入口\"><a href=\"#确定该有环单链表的环的入口\" class=\"headerlink\" title=\"确定该有环单链表的环的入口\"></a>确定该有环单链表的环的入口</h4><p>　　关于这个问题，首先我们需要证明当pSlow和pFast第一次相遇的时候，pSlow并未走完整个链表或者恰好到达环入口点。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_2.jpg\" alt=\"有环单链表\"></p>\n<p>看上图（画的比较粗糙），假设pSlow到达环状入口点A的时候，pFast在环上某一点B，假设B逆时针方向离A点距离为y，并且整个环状的长度为R，我们知道y &lt;= R。从A点开始，pSlow向前走y步，此时pFast从点B往前则走2 * y步 并与pSlow相遇于点D，此时pSlow还需R - y 才能到达链表尾端，也即A点。因为y &lt;= R，因此R - y &gt;= 0。得证。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_3.jpg\" alt=\"有环单链表\"></p>\n<p>　　此时我们假设相遇的时候pSlow走了s步，那pFast走2 * s步，而pFast多走的肯定是在环内绕圈，很自然我们有 </p>\n<p>　　2 <em> s = s + n </em> R ;   (n &gt;= 1)</p>\n<p>　　有： s = n * R (n &gt;= 1).</p>\n<p>　　设整个链表的长度为L， HA的长度为a ，第一次相遇点B与A的距离为x，则有</p>\n<p>　　a + x = s = n * R;</p>\n<p>　　a + x = (n - 1 + 1 ) <em> R = (n - 1) </em> R + R =  (n - 1) * R + L - a;</p>\n<p>　　有 a = (n - 1) <em> R + (L - a - x);　　有前面我们证明知，L - a - x 为我们所设变量y。 因此a = (n - 1) </em> R + y; (n &gt;= 1).</p>\n<p>　　这样，我们就可以这样，相遇点设置一个指针，链表头部设置一个指针，这两个指针同时按照一步一个节点前进，第一次相遇的时候必定是相遇点指针走y + (n - 1)*R的时候，也就是入口点A的位置。得证，因此获取入口点的实现如下。</p>\n<pre><code>ListNode *loopJoint(ListNode *pHead){\n    if (nullptr == pHead || nullptr == pHead-&gt;next){\n        return nullptr;\n    }\n\n    ListNode *pSlow = pHead;\n    ListNode *pFast = pHead;\n    while (pFast &amp;&amp; pFast-&gt;next){\n        pFast = pFast-&gt;next-&gt;next;\n        pSlow = pSlow-&gt;next;\n\n        if (pFast == pSlow){\n            break;\n        }\n    }\n\n    if (nullptr == pFast || nullptr == pFast-&gt;next){\n        return nullptr;\n    }\n\n    // 此时调整两个指针为普通指针，一次一步，并且其中一个指针从头部开始，第一次相遇点一定是环的入口点\n    pSlow = pHead;\n    while (pFast != pSlow){\n        pFast = pFast-&gt;next;\n        pSlow = pSlow-&gt;next;\n    }\n\n    return pSlow;\n}\n</code></pre><h4 id=\"求出该有环单链表中环的长度\"><a href=\"#求出该有环单链表中环的长度\" class=\"headerlink\" title=\"求出该有环单链表中环的长度\"></a>求出该有环单链表中环的长度</h4><p>有了以上的基础，环状的长度就很明显了，入口点已知，沿着环状走一圈即得。</p>\n<h4 id=\"求出该有环单链表长度\"><a href=\"#求出该有环单链表长度\" class=\"headerlink\" title=\"求出该有环单链表长度\"></a>求出该有环单链表长度</h4><p>同理，当R已知，而问题2中其中指向头部的指针到达环状入口点的时候HA已知，因此单链表的长度等于 L =  R + a;</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>关于有环单链表，即单链表中存在环路，该问题衍生出很多面试题，特在此汇总，方便查阅也帮助自己梳理下思路。</p>","more":"<p>如下图1所示为有环单链表，假设头结点为H， 环的入口点为A。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_1.jpg\" alt=\"有环单链表示例\"></p>\n<h5 id=\"关于有环单链表相关的问题：\"><a href=\"#关于有环单链表相关的问题：\" class=\"headerlink\" title=\"关于有环单链表相关的问题：\"></a>关于有环单链表相关的问题：</h5><ol>\n<li>该单链表中是否真有环存在？</li>\n<li>如何求出环状的入口点？</li>\n<li>如何求出环状的长度？</li>\n<li>求解整条链表的长度？</li>\n</ol>\n<p>下面我们分别针对这几个问题进行分析和解答。</p>\n<h4 id=\"判断一个单链表是否存在环\"><a href=\"#判断一个单链表是否存在环\" class=\"headerlink\" title=\"判断一个单链表是否存在环\"></a>判断一个单链表是否存在环</h4><p>　　首先，关于第一个问题，如何确定一条链表中确实存在环，关于环状的检测主要有三种方法，链表环状检测主要有三种方法：外部记录法，内部记录法以及追赶法。</p>\n<p>　　内部标记法和外部标记法其实是一个道理，不过就是辅助变量一个是在链表节点内，一个是借助辅助数组或者hash或者AVL，红黑树等 把已经访问过的节点地址存起来，每次访问下一个节点的时候进行查询看是否已经出现过。这里不再赘述。主要看追赶法，也称快满指针法，而追赶法大家一定都已经烂熟于心了。</p>\n<p>　　追赶法主要利用最大公倍数原理，用2个游标，对链表进行访问，例如:pSlow， pFast。 pSlow访问每步向前进1个节点，而pFast则每次向前前进2个节点，如果有环则pSlow和pFast必会相遇，如果pFast最终指向了NULL，则说明该链表不存在环路。因为两个指针步子迈的不一样，因为被称作快慢指针。</p>\n<pre><code>// Definition for singly - linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nbool isLoopList(ListNode *pHead){\n    if (nullptr == pHead || nullptr == pHead-&gt;next){\n        return false;\n    }\n\n    ListNode *pSlow = pHead;\n    ListNode *pFast = pHead;\n    while (pFast &amp;&amp; pFast-&gt;next){\n        pFast = pFast-&gt;next-&gt;next;\n        pSlow = pSlow-&gt;next;\n\n        if (pFast == pSlow){\n            break;\n        }\n    }\n\n    return !(nullptr == pFast || nullptr == pFast-&gt;next);\n}\n</code></pre><h4 id=\"确定该有环单链表的环的入口\"><a href=\"#确定该有环单链表的环的入口\" class=\"headerlink\" title=\"确定该有环单链表的环的入口\"></a>确定该有环单链表的环的入口</h4><p>　　关于这个问题，首先我们需要证明当pSlow和pFast第一次相遇的时候，pSlow并未走完整个链表或者恰好到达环入口点。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_2.jpg\" alt=\"有环单链表\"></p>\n<p>看上图（画的比较粗糙），假设pSlow到达环状入口点A的时候，pFast在环上某一点B，假设B逆时针方向离A点距离为y，并且整个环状的长度为R，我们知道y &lt;= R。从A点开始，pSlow向前走y步，此时pFast从点B往前则走2 * y步 并与pSlow相遇于点D，此时pSlow还需R - y 才能到达链表尾端，也即A点。因为y &lt;= R，因此R - y &gt;= 0。得证。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/%E6%9C%89%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8_3.jpg\" alt=\"有环单链表\"></p>\n<p>　　此时我们假设相遇的时候pSlow走了s步，那pFast走2 * s步，而pFast多走的肯定是在环内绕圈，很自然我们有 </p>\n<p>　　2 <em> s = s + n </em> R ;   (n &gt;= 1)</p>\n<p>　　有： s = n * R (n &gt;= 1).</p>\n<p>　　设整个链表的长度为L， HA的长度为a ，第一次相遇点B与A的距离为x，则有</p>\n<p>　　a + x = s = n * R;</p>\n<p>　　a + x = (n - 1 + 1 ) <em> R = (n - 1) </em> R + R =  (n - 1) * R + L - a;</p>\n<p>　　有 a = (n - 1) <em> R + (L - a - x);　　有前面我们证明知，L - a - x 为我们所设变量y。 因此a = (n - 1) </em> R + y; (n &gt;= 1).</p>\n<p>　　这样，我们就可以这样，相遇点设置一个指针，链表头部设置一个指针，这两个指针同时按照一步一个节点前进，第一次相遇的时候必定是相遇点指针走y + (n - 1)*R的时候，也就是入口点A的位置。得证，因此获取入口点的实现如下。</p>\n<pre><code>ListNode *loopJoint(ListNode *pHead){\n    if (nullptr == pHead || nullptr == pHead-&gt;next){\n        return nullptr;\n    }\n\n    ListNode *pSlow = pHead;\n    ListNode *pFast = pHead;\n    while (pFast &amp;&amp; pFast-&gt;next){\n        pFast = pFast-&gt;next-&gt;next;\n        pSlow = pSlow-&gt;next;\n\n        if (pFast == pSlow){\n            break;\n        }\n    }\n\n    if (nullptr == pFast || nullptr == pFast-&gt;next){\n        return nullptr;\n    }\n\n    // 此时调整两个指针为普通指针，一次一步，并且其中一个指针从头部开始，第一次相遇点一定是环的入口点\n    pSlow = pHead;\n    while (pFast != pSlow){\n        pFast = pFast-&gt;next;\n        pSlow = pSlow-&gt;next;\n    }\n\n    return pSlow;\n}\n</code></pre><h4 id=\"求出该有环单链表中环的长度\"><a href=\"#求出该有环单链表中环的长度\" class=\"headerlink\" title=\"求出该有环单链表中环的长度\"></a>求出该有环单链表中环的长度</h4><p>有了以上的基础，环状的长度就很明显了，入口点已知，沿着环状走一圈即得。</p>\n<h4 id=\"求出该有环单链表长度\"><a href=\"#求出该有环单链表长度\" class=\"headerlink\" title=\"求出该有环单链表长度\"></a>求出该有环单链表长度</h4><p>同理，当R已知，而问题2中其中指向头部的指针到达环状入口点的时候HA已知，因此单链表的长度等于 L =  R + a;</p>"},{"title":"关于Lambda的一点梳理","date":"2015-04-29T03:57:00.000Z","_content":"\n关于C++11的新特性，最近接触比较多的就是关于thread的部分，还有就是Lambda表达式，今天主要针对Lambda的用法进行一定的阐述和汇总（参考链接在文章下方，向大师致敬！），同时给自己梳理下知识点，加深印象。 \n\n<!-- more -->\n\n基本的Lambda表达式如下所示，该表达式计算一个整型数据的平方值并返回，并且该表达式能够直接使用，是不是特别方便？不再需要将类本身和函数定义分割开来。\n\n``` C++\n    int result = [](int input){ return input * input; }(10);\n    std::cout << result << std::endl;\n```\n\n如果你需要重用该段代码片段，可以将该函数保存为本地变量，如下所示：\n\n``` C++\n    auto func = [](int input){ return input * input; };\n    std::cout << func(10) << std::endl;\n    std::cout << func(20) << std::endl;\n```\n\n好了，现在我们需要写一个能够计算浮点类型的Lambda表达式怎么办？ 或者我们需要能够计算复数（complex number）怎么办？ 我们需要的就像下面这样：\n\n``` C++\n    // int 的平方\n    std::cout << func(10) << std::endl;\n    // double的平方\n    std::cout << func(3.1415) << std::endl;\n    // 复数的平方\n    std::cout << func(std::complex<double>(3, -2)) << std::endl;\n```\n如何让代码复用起来？ 当然是 函数模板（function template）了。 如下：\n\n\n``` C++\n    template <typename T>\n    T func(T param) {\n         return param * param;\n    }\n```\n但是函数模板并不是那篇文章所追求的，以上的这段代码被称作是 a named global function. 而在最新的通过的C++14标准中引入了 generalized lambda的概念。我们允许lambda表达式的传参类型为auto类型（看来C++是要强化类型自动推导啊，auto关键字能够使用的地方越来越多了。），如下我们能够使用更短，更优雅的代码实现以上需求。\n\n    \n``` C++\nauto func = [](auto input){ return input * input;  };\n```\n\n完整代码如下：\n\n``` C++\n     #include<iostream>\n     #include<complex>\n     int main() {\n        // Store a generalized lambda, that squares a number, in a variable\n        auto func = [](auto input) { return input * input; };\n  \n        // Usage examples:\n        // square of an int\n        std::cout << func(10) << std::endl;\n \n        // square of a double\n        std::cout << func(2.345) << std::endl;\n \n        // square of a complex number\n        std::cout << func(std::complex<double>(3, -2)) << std::endl;\n \n        return 0;\n     }\n```\n其实lambda表达式和STL在一起使用能够发挥很大的作用，假设你要排序一个vector让其降序，使用generic lambda，我们可以这样写：\n\n  \n``` C++\n  std::sort(V.begin(), V.end(), [](auto i, auto j) { return (i > j); });\n```\n\n完整的代码如下，对一个包含10个整型数据的vector进行排序，使之降序。结合STL和Generic Lambda：\n\n``` C++\n     #include<iostream>\n     #include<vector>\n     #include<numeric>\n     #include<algorithm>\n\t    \n\t int main() {\n        std::vector<int> V(10);\n      \n        // Use std::iota to create a sequence of integers 0, 1, ...\n        std::iota(V.begin(), V.end(), 1);\n     \n        // Print the unsorted data using std::for_each and a lambda\n        std::cout << \"Original data\" << std::endl;\n        std::for_each(V.begin(), V.end(), [](auto i) { std::cout << i << \" \"; });\n        std::cout << std::endl;\n \n        // Sort the data using std::sort and a lambda\n        std::sort(V.begin(), V.end(), [](auto i, auto j) { return (i > j); });\n     \n        // Print the sorted data using std::for_each and a lambda\n        std::cout << \"Sorted data\" << std::endl;\n        std::for_each(V.begin(), V.end(), [](auto i) { std::cout << i << \" \"; });\n        std::cout << std::endl;\n \n        return 0；\n    }\n```\n\n其中关于lambda表达式前面的[], 作者只字未提，[]是捕获列表（capture list），我们可以将lambda表达式外围定义的变量捕获使得我们能够在lambda表达式内部使用。不通俗的说capture list指定了在可见域范围内lambda表达式的代码内可见的外部变量的列表，具体有以下几点：\n1. [a, &b] a变量传值捕获，b引用捕获，这和普通函数传参相类似；\n2. [this] 以值的方式捕获this指针\n3. [&]以引用的方式捕获外部自动变量\n4. [=] 以值的方式捕获外部自动变量\n5. [] 不捕获任何外部变量， 以上所有代码均属于此种。\n\n参考文章中作者在回答读者提出的为什么不讲解[]的原因是回答到：使用捕获列表会使你的代码变得bad~,因此他不鼓励。\n\n\n\n参考：\n[https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/](https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/)\n\n","source":"_posts/关于Lambda的一点梳理.md","raw":"title: \"关于Lambda的一点梳理\"\ndate: 2015-04-29 11:57:00\ncategories: C++\ntags: [C++11,Lambda]\n---\n\n关于C++11的新特性，最近接触比较多的就是关于thread的部分，还有就是Lambda表达式，今天主要针对Lambda的用法进行一定的阐述和汇总（参考链接在文章下方，向大师致敬！），同时给自己梳理下知识点，加深印象。 \n\n<!-- more -->\n\n基本的Lambda表达式如下所示，该表达式计算一个整型数据的平方值并返回，并且该表达式能够直接使用，是不是特别方便？不再需要将类本身和函数定义分割开来。\n\n``` C++\n    int result = [](int input){ return input * input; }(10);\n    std::cout << result << std::endl;\n```\n\n如果你需要重用该段代码片段，可以将该函数保存为本地变量，如下所示：\n\n``` C++\n    auto func = [](int input){ return input * input; };\n    std::cout << func(10) << std::endl;\n    std::cout << func(20) << std::endl;\n```\n\n好了，现在我们需要写一个能够计算浮点类型的Lambda表达式怎么办？ 或者我们需要能够计算复数（complex number）怎么办？ 我们需要的就像下面这样：\n\n``` C++\n    // int 的平方\n    std::cout << func(10) << std::endl;\n    // double的平方\n    std::cout << func(3.1415) << std::endl;\n    // 复数的平方\n    std::cout << func(std::complex<double>(3, -2)) << std::endl;\n```\n如何让代码复用起来？ 当然是 函数模板（function template）了。 如下：\n\n\n``` C++\n    template <typename T>\n    T func(T param) {\n         return param * param;\n    }\n```\n但是函数模板并不是那篇文章所追求的，以上的这段代码被称作是 a named global function. 而在最新的通过的C++14标准中引入了 generalized lambda的概念。我们允许lambda表达式的传参类型为auto类型（看来C++是要强化类型自动推导啊，auto关键字能够使用的地方越来越多了。），如下我们能够使用更短，更优雅的代码实现以上需求。\n\n    \n``` C++\nauto func = [](auto input){ return input * input;  };\n```\n\n完整代码如下：\n\n``` C++\n     #include<iostream>\n     #include<complex>\n     int main() {\n        // Store a generalized lambda, that squares a number, in a variable\n        auto func = [](auto input) { return input * input; };\n  \n        // Usage examples:\n        // square of an int\n        std::cout << func(10) << std::endl;\n \n        // square of a double\n        std::cout << func(2.345) << std::endl;\n \n        // square of a complex number\n        std::cout << func(std::complex<double>(3, -2)) << std::endl;\n \n        return 0;\n     }\n```\n其实lambda表达式和STL在一起使用能够发挥很大的作用，假设你要排序一个vector让其降序，使用generic lambda，我们可以这样写：\n\n  \n``` C++\n  std::sort(V.begin(), V.end(), [](auto i, auto j) { return (i > j); });\n```\n\n完整的代码如下，对一个包含10个整型数据的vector进行排序，使之降序。结合STL和Generic Lambda：\n\n``` C++\n     #include<iostream>\n     #include<vector>\n     #include<numeric>\n     #include<algorithm>\n\t    \n\t int main() {\n        std::vector<int> V(10);\n      \n        // Use std::iota to create a sequence of integers 0, 1, ...\n        std::iota(V.begin(), V.end(), 1);\n     \n        // Print the unsorted data using std::for_each and a lambda\n        std::cout << \"Original data\" << std::endl;\n        std::for_each(V.begin(), V.end(), [](auto i) { std::cout << i << \" \"; });\n        std::cout << std::endl;\n \n        // Sort the data using std::sort and a lambda\n        std::sort(V.begin(), V.end(), [](auto i, auto j) { return (i > j); });\n     \n        // Print the sorted data using std::for_each and a lambda\n        std::cout << \"Sorted data\" << std::endl;\n        std::for_each(V.begin(), V.end(), [](auto i) { std::cout << i << \" \"; });\n        std::cout << std::endl;\n \n        return 0；\n    }\n```\n\n其中关于lambda表达式前面的[], 作者只字未提，[]是捕获列表（capture list），我们可以将lambda表达式外围定义的变量捕获使得我们能够在lambda表达式内部使用。不通俗的说capture list指定了在可见域范围内lambda表达式的代码内可见的外部变量的列表，具体有以下几点：\n1. [a, &b] a变量传值捕获，b引用捕获，这和普通函数传参相类似；\n2. [this] 以值的方式捕获this指针\n3. [&]以引用的方式捕获外部自动变量\n4. [=] 以值的方式捕获外部自动变量\n5. [] 不捕获任何外部变量， 以上所有代码均属于此种。\n\n参考文章中作者在回答读者提出的为什么不讲解[]的原因是回答到：使用捕获列表会使你的代码变得bad~,因此他不鼓励。\n\n\n\n参考：\n[https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/](https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/)\n\n","slug":"关于Lambda的一点梳理","published":1,"updated":"2017-05-21T08:33:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2frxf001o79poal6a5zb6","content":"<p>关于C++11的新特性，最近接触比较多的就是关于thread的部分，还有就是Lambda表达式，今天主要针对Lambda的用法进行一定的阐述和汇总（参考链接在文章下方，向大师致敬！），同时给自己梳理下知识点，加深印象。 </p>\n<a id=\"more\"></a>\n<p>基本的Lambda表达式如下所示，该表达式计算一个整型数据的平方值并返回，并且该表达式能够直接使用，是不是特别方便？不再需要将类本身和函数定义分割开来。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> result = [](<span class=\"keyword\">int</span> input)&#123; <span class=\"keyword\">return</span> input * input; &#125;(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>如果你需要重用该段代码片段，可以将该函数保存为本地变量，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> func = [](<span class=\"keyword\">int</span> input)&#123; <span class=\"keyword\">return</span> input * input; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">20</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>好了，现在我们需要写一个能够计算浮点类型的Lambda表达式怎么办？ 或者我们需要能够计算复数（complex number）怎么办？ 我们需要的就像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// int 的平方</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"comment\">// double的平方</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">3.1415</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"comment\">// 复数的平方</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"built_in\">std</span>::<span class=\"keyword\">complex</span>&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">3</span>, <span class=\"number\">-2</span>)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>如何让代码复用起来？ 当然是 函数模板（function template）了。 如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">func</span><span class=\"params\">(T param)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> param * param;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是函数模板并不是那篇文章所追求的，以上的这段代码被称作是 a named global function. 而在最新的通过的C++14标准中引入了 generalized lambda的概念。我们允许lambda表达式的传参类型为auto类型（看来C++是要强化类型自动推导啊，auto关键字能够使用的地方越来越多了。），如下我们能够使用更短，更优雅的代码实现以上需求。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> func = [](<span class=\"keyword\">auto</span> input)&#123; <span class=\"keyword\">return</span> input * input;  &#125;;</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;complex&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Store a generalized lambda, that squares a number, in a variable</span></span><br><span class=\"line\">   <span class=\"keyword\">auto</span> func = [](<span class=\"keyword\">auto</span> input) &#123; <span class=\"keyword\">return</span> input * input; &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"comment\">// Usage examples:</span></span><br><span class=\"line\">   <span class=\"comment\">// square of an int</span></span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// square of a double</span></span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">2.345</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// square of a complex number</span></span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"built_in\">std</span>::<span class=\"keyword\">complex</span>&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">3</span>, <span class=\"number\">-2</span>)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实lambda表达式和STL在一起使用能够发挥很大的作用，假设你要排序一个vector让其降序，使用generic lambda，我们可以这样写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::sort(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i, <span class=\"keyword\">auto</span> j) &#123; <span class=\"keyword\">return</span> (i &gt; j); &#125;);</span><br></pre></td></tr></table></figure>\n<p>完整的代码如下，对一个包含10个整型数据的vector进行排序，使之降序。结合STL和Generic Lambda：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; V(<span class=\"number\">10</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">// Use std::iota to create a sequence of integers 0, 1, ...</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::iota(V.begin(), V.end(), <span class=\"number\">1</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">// Print the unsorted data using std::for_each and a lambda</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Original data\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::for_each(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>; &#125;);</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"comment\">// Sort the data using std::sort and a lambda</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::sort(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i, <span class=\"keyword\">auto</span> j) &#123; <span class=\"keyword\">return</span> (i &gt; j); &#125;);</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">// Print the sorted data using std::for_each and a lambda</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Sorted data\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::for_each(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>; &#125;);</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>；</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中关于lambda表达式前面的[], 作者只字未提，[]是捕获列表（capture list），我们可以将lambda表达式外围定义的变量捕获使得我们能够在lambda表达式内部使用。不通俗的说capture list指定了在可见域范围内lambda表达式的代码内可见的外部变量的列表，具体有以下几点：</p>\n<ol>\n<li>[a, &amp;b] a变量传值捕获，b引用捕获，这和普通函数传参相类似；</li>\n<li>[this] 以值的方式捕获this指针</li>\n<li>[&amp;]以引用的方式捕获外部自动变量</li>\n<li>[=] 以值的方式捕获外部自动变量</li>\n<li>[] 不捕获任何外部变量， 以上所有代码均属于此种。</li>\n</ol>\n<p>参考文章中作者在回答读者提出的为什么不讲解[]的原因是回答到：使用捕获列表会使你的代码变得bad~,因此他不鼓励。</p>\n<p>参考：<br><a href=\"https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/\" target=\"_blank\" rel=\"noopener\">https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>关于C++11的新特性，最近接触比较多的就是关于thread的部分，还有就是Lambda表达式，今天主要针对Lambda的用法进行一定的阐述和汇总（参考链接在文章下方，向大师致敬！），同时给自己梳理下知识点，加深印象。 </p>","more":"<p>基本的Lambda表达式如下所示，该表达式计算一个整型数据的平方值并返回，并且该表达式能够直接使用，是不是特别方便？不再需要将类本身和函数定义分割开来。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> result = [](<span class=\"keyword\">int</span> input)&#123; <span class=\"keyword\">return</span> input * input; &#125;(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>如果你需要重用该段代码片段，可以将该函数保存为本地变量，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> func = [](<span class=\"keyword\">int</span> input)&#123; <span class=\"keyword\">return</span> input * input; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">20</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>好了，现在我们需要写一个能够计算浮点类型的Lambda表达式怎么办？ 或者我们需要能够计算复数（complex number）怎么办？ 我们需要的就像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// int 的平方</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"comment\">// double的平方</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">3.1415</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"comment\">// 复数的平方</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"built_in\">std</span>::<span class=\"keyword\">complex</span>&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">3</span>, <span class=\"number\">-2</span>)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>如何让代码复用起来？ 当然是 函数模板（function template）了。 如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">func</span><span class=\"params\">(T param)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> param * param;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是函数模板并不是那篇文章所追求的，以上的这段代码被称作是 a named global function. 而在最新的通过的C++14标准中引入了 generalized lambda的概念。我们允许lambda表达式的传参类型为auto类型（看来C++是要强化类型自动推导啊，auto关键字能够使用的地方越来越多了。），如下我们能够使用更短，更优雅的代码实现以上需求。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> func = [](<span class=\"keyword\">auto</span> input)&#123; <span class=\"keyword\">return</span> input * input;  &#125;;</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;complex&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Store a generalized lambda, that squares a number, in a variable</span></span><br><span class=\"line\">   <span class=\"keyword\">auto</span> func = [](<span class=\"keyword\">auto</span> input) &#123; <span class=\"keyword\">return</span> input * input; &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"comment\">// Usage examples:</span></span><br><span class=\"line\">   <span class=\"comment\">// square of an int</span></span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">10</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// square of a double</span></span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"number\">2.345</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">// square of a complex number</span></span><br><span class=\"line\">   <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; func(<span class=\"built_in\">std</span>::<span class=\"keyword\">complex</span>&lt;<span class=\"keyword\">double</span>&gt;(<span class=\"number\">3</span>, <span class=\"number\">-2</span>)) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实lambda表达式和STL在一起使用能够发挥很大的作用，假设你要排序一个vector让其降序，使用generic lambda，我们可以这样写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::sort(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i, <span class=\"keyword\">auto</span> j) &#123; <span class=\"keyword\">return</span> (i &gt; j); &#125;);</span><br></pre></td></tr></table></figure>\n<p>完整的代码如下，对一个包含10个整型数据的vector进行排序，使之降序。结合STL和Generic Lambda：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; V(<span class=\"number\">10</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">// Use std::iota to create a sequence of integers 0, 1, ...</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::iota(V.begin(), V.end(), <span class=\"number\">1</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">// Print the unsorted data using std::for_each and a lambda</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Original data\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::for_each(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>; &#125;);</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"comment\">// Sort the data using std::sort and a lambda</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::sort(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i, <span class=\"keyword\">auto</span> j) &#123; <span class=\"keyword\">return</span> (i &gt; j); &#125;);</span><br><span class=\"line\">   </span><br><span class=\"line\">      <span class=\"comment\">// Print the sorted data using std::for_each and a lambda</span></span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Sorted data\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::for_each(V.begin(), V.end(), [](<span class=\"keyword\">auto</span> i) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>; &#125;);</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>；</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其中关于lambda表达式前面的[], 作者只字未提，[]是捕获列表（capture list），我们可以将lambda表达式外围定义的变量捕获使得我们能够在lambda表达式内部使用。不通俗的说capture list指定了在可见域范围内lambda表达式的代码内可见的外部变量的列表，具体有以下几点：</p>\n<ol>\n<li>[a, &amp;b] a变量传值捕获，b引用捕获，这和普通函数传参相类似；</li>\n<li>[this] 以值的方式捕获this指针</li>\n<li>[&amp;]以引用的方式捕获外部自动变量</li>\n<li>[=] 以值的方式捕获外部自动变量</li>\n<li>[] 不捕获任何外部变量， 以上所有代码均属于此种。</li>\n</ol>\n<p>参考文章中作者在回答读者提出的为什么不讲解[]的原因是回答到：使用捕获列表会使你的代码变得bad~,因此他不鼓励。</p>\n<p>参考：<br><a href=\"https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/\" target=\"_blank\" rel=\"noopener\">https://solarianprogrammer.com/2014/08/28/cpp-14-lambda-tutorial/</a></p>"},{"title":"避免在 Swift 中使用单例","date":"2018-07-16T09:34:36.000Z","_content":"\n> 原文：[Modular Xcode projects](https://ppinera.es/2017/09/29/modular-xcode-projects.html)\n> 原作者 & Copyright [@pepibumur](http://twitter.com/pepibumur)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n“我知道单例不好，但是...”，这是开发者常常在讨论代码的时候会提到的。貌似社区大家有共识 ── 单例不好。但是同时，包括 Apple 和第三方的 Swift 开发者还是在 App 内部或者共享的 frameworks 里不断在用它们。\n\n这周，让我们好好看一看单例的问题到底在哪里，探索更多的技巧以便我们日常能够避免使用它们。这就开始吧！\n\n### 为什么单例这么流行？\n\n首先一点我们要想的是问问自己，为什么单例这么流行？热过大多数开发者都认同，单例应该被避免的话，为什么它们还不断的出现呢？\n\n我认为有两部分原因。\n\n我觉得日常开发 Apple 平台上的 App 时候大量使用单例，最大的原因是苹果自己也在经常的用。作为第三方开发者来讲，我们常常会把 Apple 的做法作为最佳实践来用，任何 Apple 自己常常使用的模式在社区也会发展的很迅速。\n\n这个谜题的第二个原因是单例非常方便。单例因为它可以在任何地方获取到，因而经常会扮演一个获取特定核心值或者对象的快捷方式。可以看下下面这个例子，在这个例子中，我们想在 **ProfileViewController** 中展示当前登录用户的名字，同时当某个按钮按下的时候，退登当前用户。\n\n\n``` Swift\n\nclass ProfileViewController: UIViewController {\n    private lazy var nameLabel = UILabel()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        nameLabel.text = UserManager.shared.currentUser?.name\n    }\n    private func handleLogOutButtonTap() {\n        UserManager.shared.logOut()\n    }\n}\n\n```\n\n按照上面这样，把一个 UserManager 单例的用户和账户处理的功能封装起来，确实很方便（而且很常见！），那这种模式的使用到底不好在哪里呢？\n\n### 为什么单例会很糟糕？\n\n当讨论类似模式和架构这些东西的时候，很容易陷入一个特别理论化的圈套。虽然让我们的代码理论上“正确”，遵循最佳实践和原则是很美好的，但是现实经常会很受打击，我们需要寻找一些中间方案。\n\n所以，关于单例引起的实质性问题是什么呢？为什么它们要应该被避免呢？这里我倾向于三个原因：\n\n1. 这些单例是全局的可变的共享状态。它们的状态是在整个 App 里自动共享的，因此当其状态发生不可预期的变化的时候，Bug 也就可能开始发生了；\n2. 单例之间的关系以及依赖这些单例的代码常常不那么好定义。因为单例是如此方便和容易获得，大量的使用它们常常会导致很难维护[面条式代码](https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81)，这些代码中对象和对象之间没有清晰的隔离；\n3. 管理这些单例的生命周期非常的难。因为单例本身会在应用的整个生命周期内存活，管理它们就变得异常困难，因此常常会不得不依赖可选值来跟踪值的变化。这也使得依赖单例的代码变得很难测试，因为你没法在一个测试 case 里把状态重置。\n\n在我们前面的 **ProfileViewController** 的例子中，我们已经看到了有这三个问题的信号出现。首先它依赖 UserManager 导致这二者关系很不清晰，其次，它不得不让 currentUser 作为可选值出现，因为我们没办法在编译期就能够确定视图控制器实际上出现的时候这个数据一定在。听起来就感觉要有 bug 发生的感觉 😬!\n\n\n### 依赖注入\n\n相对于使用 **ProfileViewController** 通过单例来获取它所需的依赖项，我们要在其初始化方法中将依赖项传入。这里我们是将当前的 User 作为非可选传入的，同样，传入一个 **LogOu\u0010tService** 来进行登出操作：\n\n\n```Swift\n\nclass ProfileViewController: UIViewController {\n    private let user: User\n    private let logOutService: LogOutService\n    private lazy var nameLabel = UILabel()\n    init(user: User, logOutService: LogOutService) {\n        self.user = user\n        self.logOutService = logOutService\n        super.init(nibName: nil, bundle: nil)\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        nameLabel.text = user.name\n    }\n    private func handleLogOutButtonTap() {\n        logOutService.logOut()\n    }\n}\n\n```\n\n这样的话，代码就会变得更加清晰，并且容易管理。我们的代码现在安全的依赖其 Model，并且有一个清晰的 API 进行登出的交互。一般情况下，将各种单例以及管理器重构成清晰分离的服务能够使得一个 App 的核心对象之间的关系更加清晰。\n\n### Services\n\n举个例子，让我们更近一些来看下 **LogOutService** 这个类是如何实现的。它内部也对其依赖的服务使用了依赖注入，并且提供了一个优雅的，定义清晰的 API 来只做一件事情 ── 登出。\n\n``` Swift\n\nclass LogOutService {\n    private let user: User\n    private let networkService: NetworkService\n    private let navigationService: NavigationService\n    init(user: User,\n         networkService: NetworkService,\n         navigationService: NavigationService) {\n        self.user = user\n        self.networkService = networkService\n        self.navigationService = navigationService\n    }\n    func logOut() {\n        networkService.request(.logout(user)) { [weak self] in\n            self?.navigationService.showLoginScreen()\n        }\n    }\n}\n\n```\n\n### 翻新\n\n从一个重度使用单例的设置到完全使用服务，依赖注入以及本地状态来改造会非常的困难，会花费大量时间。而且，会很难认为花大量时间在这上面是合理的，而且有些时候可能会需要一次更大规模的重构才行。\n\n谢天谢地，我们可以使用相近的技术，在[Testing Swift code that uses system singletons in 3 easy steps](https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps)这篇文章中也使用到过，其允许我们可以以一种非常容易的方式单例开始。和很多其他解决方案类似 ── 协议来救场！\n\n我们不是一次性重构所有的单例，而是创建 Service 类，我们可以很简单的把我们的 Service 定义成 Protocol，如下所示：\n\n\n``` Swift\n\nprotocol LogOutService {\n    func logOut()\n}\nprotocol NetworkService {\n    func request(_ endpoint: Endpoint, completionHandler: @escaping () -> Void)\n}\nprotocol NavigationService {\n    func showLoginScreen()\n    func showProfile(for user: User)\n    ...\n}\n\n```\n\n然后我们就能通过将单例符合我们新创建的 Service 协议来使其翻新为一堆 Service。在很多情况下，我们甚至不需要改变任何实现，只是简单的传递它们 shared 实例作为一个 Service 即可。\n\n同样的技巧也能够被用作重构我们 app 中其他核心对象，那些对象我们也许也都正在以某种单例形式在使用着，例如使用 AppDelegate 来做导航。\n\n\n``` Swift\n\nextension UserManager: LoginService, LogOutService {}\nextension AppDelegate: NavigationService {\n    func showLoginScreen() {\n        navigationController.viewControllers = [\n            LoginViewController(\n                loginService: UserManager.shared,\n                navigationService: self\n            )\n        ]\n    }\n    func showProfile(for user: User) {\n        let viewController = ProfileViewController(\n            user: user,\n            logOutService: UserManager.shared\n        )\n        navigationController.pushViewController(viewController, animated: true)\n    }\n}\n\n```\n\n我们现在通过使用依赖注入以及 Service 的方式，开始使得我们工程处在 Singleton free 的状态，而不需要进行特别巨大的工程改造和重写。接下来我们就能够使用 Service 或者其他类型的 API 逐个替换掉单例，比如说使用[这篇博文](https://www.swiftbysundell.com/posts/replacing-legacy-code-using-swift-protocols)中的技巧。\n\n### 结论\n\n单例也不是都是不好的，只是在很多情况下，它们会引发一系列问题，这些问题可以通过使用依赖注入的方式为你程序里的对象建立良好的关系来解决。\n\n如果你现在正在开发的 App 里在使用大量的单例，那你一定也在经历或者已经经历过它们所带来的 bug 了吧。希望这篇文章能够给你一些灵感让你没有那么慌乱的开始远离它们。\n\n\n\n\n\n\n\n\n\n","source":"_posts/Avoiding-singletons-in-Swift.md","raw":"---\ntitle: 避免在 Swift 中使用单例\ndate: 2018-07-16 17:34:36\ncategories: 翻译\ntags: [iOS,XCode,Swift,Singleton]\n---\n\n> 原文：[Modular Xcode projects](https://ppinera.es/2017/09/29/modular-xcode-projects.html)\n> 原作者 & Copyright [@pepibumur](http://twitter.com/pepibumur)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n“我知道单例不好，但是...”，这是开发者常常在讨论代码的时候会提到的。貌似社区大家有共识 ── 单例不好。但是同时，包括 Apple 和第三方的 Swift 开发者还是在 App 内部或者共享的 frameworks 里不断在用它们。\n\n这周，让我们好好看一看单例的问题到底在哪里，探索更多的技巧以便我们日常能够避免使用它们。这就开始吧！\n\n### 为什么单例这么流行？\n\n首先一点我们要想的是问问自己，为什么单例这么流行？热过大多数开发者都认同，单例应该被避免的话，为什么它们还不断的出现呢？\n\n我认为有两部分原因。\n\n我觉得日常开发 Apple 平台上的 App 时候大量使用单例，最大的原因是苹果自己也在经常的用。作为第三方开发者来讲，我们常常会把 Apple 的做法作为最佳实践来用，任何 Apple 自己常常使用的模式在社区也会发展的很迅速。\n\n这个谜题的第二个原因是单例非常方便。单例因为它可以在任何地方获取到，因而经常会扮演一个获取特定核心值或者对象的快捷方式。可以看下下面这个例子，在这个例子中，我们想在 **ProfileViewController** 中展示当前登录用户的名字，同时当某个按钮按下的时候，退登当前用户。\n\n\n``` Swift\n\nclass ProfileViewController: UIViewController {\n    private lazy var nameLabel = UILabel()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        nameLabel.text = UserManager.shared.currentUser?.name\n    }\n    private func handleLogOutButtonTap() {\n        UserManager.shared.logOut()\n    }\n}\n\n```\n\n按照上面这样，把一个 UserManager 单例的用户和账户处理的功能封装起来，确实很方便（而且很常见！），那这种模式的使用到底不好在哪里呢？\n\n### 为什么单例会很糟糕？\n\n当讨论类似模式和架构这些东西的时候，很容易陷入一个特别理论化的圈套。虽然让我们的代码理论上“正确”，遵循最佳实践和原则是很美好的，但是现实经常会很受打击，我们需要寻找一些中间方案。\n\n所以，关于单例引起的实质性问题是什么呢？为什么它们要应该被避免呢？这里我倾向于三个原因：\n\n1. 这些单例是全局的可变的共享状态。它们的状态是在整个 App 里自动共享的，因此当其状态发生不可预期的变化的时候，Bug 也就可能开始发生了；\n2. 单例之间的关系以及依赖这些单例的代码常常不那么好定义。因为单例是如此方便和容易获得，大量的使用它们常常会导致很难维护[面条式代码](https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81)，这些代码中对象和对象之间没有清晰的隔离；\n3. 管理这些单例的生命周期非常的难。因为单例本身会在应用的整个生命周期内存活，管理它们就变得异常困难，因此常常会不得不依赖可选值来跟踪值的变化。这也使得依赖单例的代码变得很难测试，因为你没法在一个测试 case 里把状态重置。\n\n在我们前面的 **ProfileViewController** 的例子中，我们已经看到了有这三个问题的信号出现。首先它依赖 UserManager 导致这二者关系很不清晰，其次，它不得不让 currentUser 作为可选值出现，因为我们没办法在编译期就能够确定视图控制器实际上出现的时候这个数据一定在。听起来就感觉要有 bug 发生的感觉 😬!\n\n\n### 依赖注入\n\n相对于使用 **ProfileViewController** 通过单例来获取它所需的依赖项，我们要在其初始化方法中将依赖项传入。这里我们是将当前的 User 作为非可选传入的，同样，传入一个 **LogOu\u0010tService** 来进行登出操作：\n\n\n```Swift\n\nclass ProfileViewController: UIViewController {\n    private let user: User\n    private let logOutService: LogOutService\n    private lazy var nameLabel = UILabel()\n    init(user: User, logOutService: LogOutService) {\n        self.user = user\n        self.logOutService = logOutService\n        super.init(nibName: nil, bundle: nil)\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        nameLabel.text = user.name\n    }\n    private func handleLogOutButtonTap() {\n        logOutService.logOut()\n    }\n}\n\n```\n\n这样的话，代码就会变得更加清晰，并且容易管理。我们的代码现在安全的依赖其 Model，并且有一个清晰的 API 进行登出的交互。一般情况下，将各种单例以及管理器重构成清晰分离的服务能够使得一个 App 的核心对象之间的关系更加清晰。\n\n### Services\n\n举个例子，让我们更近一些来看下 **LogOutService** 这个类是如何实现的。它内部也对其依赖的服务使用了依赖注入，并且提供了一个优雅的，定义清晰的 API 来只做一件事情 ── 登出。\n\n``` Swift\n\nclass LogOutService {\n    private let user: User\n    private let networkService: NetworkService\n    private let navigationService: NavigationService\n    init(user: User,\n         networkService: NetworkService,\n         navigationService: NavigationService) {\n        self.user = user\n        self.networkService = networkService\n        self.navigationService = navigationService\n    }\n    func logOut() {\n        networkService.request(.logout(user)) { [weak self] in\n            self?.navigationService.showLoginScreen()\n        }\n    }\n}\n\n```\n\n### 翻新\n\n从一个重度使用单例的设置到完全使用服务，依赖注入以及本地状态来改造会非常的困难，会花费大量时间。而且，会很难认为花大量时间在这上面是合理的，而且有些时候可能会需要一次更大规模的重构才行。\n\n谢天谢地，我们可以使用相近的技术，在[Testing Swift code that uses system singletons in 3 easy steps](https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps)这篇文章中也使用到过，其允许我们可以以一种非常容易的方式单例开始。和很多其他解决方案类似 ── 协议来救场！\n\n我们不是一次性重构所有的单例，而是创建 Service 类，我们可以很简单的把我们的 Service 定义成 Protocol，如下所示：\n\n\n``` Swift\n\nprotocol LogOutService {\n    func logOut()\n}\nprotocol NetworkService {\n    func request(_ endpoint: Endpoint, completionHandler: @escaping () -> Void)\n}\nprotocol NavigationService {\n    func showLoginScreen()\n    func showProfile(for user: User)\n    ...\n}\n\n```\n\n然后我们就能通过将单例符合我们新创建的 Service 协议来使其翻新为一堆 Service。在很多情况下，我们甚至不需要改变任何实现，只是简单的传递它们 shared 实例作为一个 Service 即可。\n\n同样的技巧也能够被用作重构我们 app 中其他核心对象，那些对象我们也许也都正在以某种单例形式在使用着，例如使用 AppDelegate 来做导航。\n\n\n``` Swift\n\nextension UserManager: LoginService, LogOutService {}\nextension AppDelegate: NavigationService {\n    func showLoginScreen() {\n        navigationController.viewControllers = [\n            LoginViewController(\n                loginService: UserManager.shared,\n                navigationService: self\n            )\n        ]\n    }\n    func showProfile(for user: User) {\n        let viewController = ProfileViewController(\n            user: user,\n            logOutService: UserManager.shared\n        )\n        navigationController.pushViewController(viewController, animated: true)\n    }\n}\n\n```\n\n我们现在通过使用依赖注入以及 Service 的方式，开始使得我们工程处在 Singleton free 的状态，而不需要进行特别巨大的工程改造和重写。接下来我们就能够使用 Service 或者其他类型的 API 逐个替换掉单例，比如说使用[这篇博文](https://www.swiftbysundell.com/posts/replacing-legacy-code-using-swift-protocols)中的技巧。\n\n### 结论\n\n单例也不是都是不好的，只是在很多情况下，它们会引发一系列问题，这些问题可以通过使用依赖注入的方式为你程序里的对象建立良好的关系来解决。\n\n如果你现在正在开发的 App 里在使用大量的单例，那你一定也在经历或者已经经历过它们所带来的 bug 了吧。希望这篇文章能够给你一些灵感让你没有那么慌乱的开始远离它们。\n\n\n\n\n\n\n\n\n\n","slug":"Avoiding-singletons-in-Swift","published":1,"updated":"2018-10-07T11:17:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftb5004579pow0vtm2vc","content":"<blockquote>\n<p>原文：<a href=\"https://ppinera.es/2017/09/29/modular-xcode-projects.html\" target=\"_blank\" rel=\"noopener\">Modular Xcode projects</a><br>原作者 &amp; Copyright <a href=\"http://twitter.com/pepibumur\" target=\"_blank\" rel=\"noopener\">@pepibumur</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>“我知道单例不好，但是…”，这是开发者常常在讨论代码的时候会提到的。貌似社区大家有共识 ── 单例不好。但是同时，包括 Apple 和第三方的 Swift 开发者还是在 App 内部或者共享的 frameworks 里不断在用它们。</p>\n<p>这周，让我们好好看一看单例的问题到底在哪里，探索更多的技巧以便我们日常能够避免使用它们。这就开始吧！</p>\n<h3 id=\"为什么单例这么流行？\"><a href=\"#为什么单例这么流行？\" class=\"headerlink\" title=\"为什么单例这么流行？\"></a>为什么单例这么流行？</h3><p>首先一点我们要想的是问问自己，为什么单例这么流行？热过大多数开发者都认同，单例应该被避免的话，为什么它们还不断的出现呢？</p>\n<p>我认为有两部分原因。</p>\n<p>我觉得日常开发 Apple 平台上的 App 时候大量使用单例，最大的原因是苹果自己也在经常的用。作为第三方开发者来讲，我们常常会把 Apple 的做法作为最佳实践来用，任何 Apple 自己常常使用的模式在社区也会发展的很迅速。</p>\n<p>这个谜题的第二个原因是单例非常方便。单例因为它可以在任何地方获取到，因而经常会扮演一个获取特定核心值或者对象的快捷方式。可以看下下面这个例子，在这个例子中，我们想在 <strong>ProfileViewController</strong> 中展示当前登录用户的名字，同时当某个按钮按下的时候，退登当前用户。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProfileViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> nameLabel = <span class=\"type\">UILabel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        nameLabel.text = <span class=\"type\">UserManager</span>.shared.currentUser?.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleLogOutButtonTap</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UserManager</span>.shared.logOut()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照上面这样，把一个 UserManager 单例的用户和账户处理的功能封装起来，确实很方便（而且很常见！），那这种模式的使用到底不好在哪里呢？</p>\n<h3 id=\"为什么单例会很糟糕？\"><a href=\"#为什么单例会很糟糕？\" class=\"headerlink\" title=\"为什么单例会很糟糕？\"></a>为什么单例会很糟糕？</h3><p>当讨论类似模式和架构这些东西的时候，很容易陷入一个特别理论化的圈套。虽然让我们的代码理论上“正确”，遵循最佳实践和原则是很美好的，但是现实经常会很受打击，我们需要寻找一些中间方案。</p>\n<p>所以，关于单例引起的实质性问题是什么呢？为什么它们要应该被避免呢？这里我倾向于三个原因：</p>\n<ol>\n<li>这些单例是全局的可变的共享状态。它们的状态是在整个 App 里自动共享的，因此当其状态发生不可预期的变化的时候，Bug 也就可能开始发生了；</li>\n<li>单例之间的关系以及依赖这些单例的代码常常不那么好定义。因为单例是如此方便和容易获得，大量的使用它们常常会导致很难维护<a href=\"https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81\" target=\"_blank\" rel=\"noopener\">面条式代码</a>，这些代码中对象和对象之间没有清晰的隔离；</li>\n<li>管理这些单例的生命周期非常的难。因为单例本身会在应用的整个生命周期内存活，管理它们就变得异常困难，因此常常会不得不依赖可选值来跟踪值的变化。这也使得依赖单例的代码变得很难测试，因为你没法在一个测试 case 里把状态重置。</li>\n</ol>\n<p>在我们前面的 <strong>ProfileViewController</strong> 的例子中，我们已经看到了有这三个问题的信号出现。首先它依赖 UserManager 导致这二者关系很不清晰，其次，它不得不让 currentUser 作为可选值出现，因为我们没办法在编译期就能够确定视图控制器实际上出现的时候这个数据一定在。听起来就感觉要有 bug 发生的感觉 😬!</p>\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><p>相对于使用 <strong>ProfileViewController</strong> 通过单例来获取它所需的依赖项，我们要在其初始化方法中将依赖项传入。这里我们是将当前的 User 作为非可选传入的，同样，传入一个 <strong>LogOu\u0010tService</strong> 来进行登出操作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProfileViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> user: <span class=\"type\">User</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> logOutService: <span class=\"type\">LogOutService</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> nameLabel = <span class=\"type\">UILabel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(user: <span class=\"type\">User</span>, logOutService: <span class=\"type\">LogOutService</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.user = user</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.logOutService = logOutService</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(nibName: <span class=\"literal\">nil</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        nameLabel.text = user.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleLogOutButtonTap</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        logOutService.logOut()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话，代码就会变得更加清晰，并且容易管理。我们的代码现在安全的依赖其 Model，并且有一个清晰的 API 进行登出的交互。一般情况下，将各种单例以及管理器重构成清晰分离的服务能够使得一个 App 的核心对象之间的关系更加清晰。</p>\n<h3 id=\"Services\"><a href=\"#Services\" class=\"headerlink\" title=\"Services\"></a>Services</h3><p>举个例子，让我们更近一些来看下 <strong>LogOutService</strong> 这个类是如何实现的。它内部也对其依赖的服务使用了依赖注入，并且提供了一个优雅的，定义清晰的 API 来只做一件事情 ── 登出。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogOutService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> user: <span class=\"type\">User</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> networkService: <span class=\"type\">NetworkService</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> navigationService: <span class=\"type\">NavigationService</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(user: <span class=\"type\">User</span>,</span><br><span class=\"line\">         networkService: <span class=\"type\">NetworkService</span>,</span><br><span class=\"line\">         navigationService: <span class=\"type\">NavigationService</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.user = user</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.networkService = networkService</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.navigationService = navigationService</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logOut</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        networkService.request(.logout(user)) &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>?.navigationService.showLoginScreen()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"翻新\"><a href=\"#翻新\" class=\"headerlink\" title=\"翻新\"></a>翻新</h3><p>从一个重度使用单例的设置到完全使用服务，依赖注入以及本地状态来改造会非常的困难，会花费大量时间。而且，会很难认为花大量时间在这上面是合理的，而且有些时候可能会需要一次更大规模的重构才行。</p>\n<p>谢天谢地，我们可以使用相近的技术，在<a href=\"https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps\" target=\"_blank\" rel=\"noopener\">Testing Swift code that uses system singletons in 3 easy steps</a>这篇文章中也使用到过，其允许我们可以以一种非常容易的方式单例开始。和很多其他解决方案类似 ── 协议来救场！</p>\n<p>我们不是一次性重构所有的单例，而是创建 Service 类，我们可以很简单的把我们的 Service 定义成 Protocol，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">LogOutService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logOut</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">NetworkService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"number\">_</span> endpoint: Endpoint, completionHandler: @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">NavigationService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showLoginScreen</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showProfile</span><span class=\"params\">(<span class=\"keyword\">for</span> user: User)</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们就能通过将单例符合我们新创建的 Service 协议来使其翻新为一堆 Service。在很多情况下，我们甚至不需要改变任何实现，只是简单的传递它们 shared 实例作为一个 Service 即可。</p>\n<p>同样的技巧也能够被用作重构我们 app 中其他核心对象，那些对象我们也许也都正在以某种单例形式在使用着，例如使用 AppDelegate 来做导航。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserManager</span>: <span class=\"title\">LoginService</span>, <span class=\"title\">LogOutService</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">NavigationService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showLoginScreen</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        navigationController.viewControllers = [</span><br><span class=\"line\">            <span class=\"type\">LoginViewController</span>(</span><br><span class=\"line\">                loginService: <span class=\"type\">UserManager</span>.shared,</span><br><span class=\"line\">                navigationService: <span class=\"keyword\">self</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showProfile</span><span class=\"params\">(<span class=\"keyword\">for</span> user: User)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> viewController = <span class=\"type\">ProfileViewController</span>(</span><br><span class=\"line\">            user: user,</span><br><span class=\"line\">            logOutService: <span class=\"type\">UserManager</span>.shared</span><br><span class=\"line\">        )</span><br><span class=\"line\">        navigationController.pushViewController(viewController, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们现在通过使用依赖注入以及 Service 的方式，开始使得我们工程处在 Singleton free 的状态，而不需要进行特别巨大的工程改造和重写。接下来我们就能够使用 Service 或者其他类型的 API 逐个替换掉单例，比如说使用<a href=\"https://www.swiftbysundell.com/posts/replacing-legacy-code-using-swift-protocols\" target=\"_blank\" rel=\"noopener\">这篇博文</a>中的技巧。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>单例也不是都是不好的，只是在很多情况下，它们会引发一系列问题，这些问题可以通过使用依赖注入的方式为你程序里的对象建立良好的关系来解决。</p>\n<p>如果你现在正在开发的 App 里在使用大量的单例，那你一定也在经历或者已经经历过它们所带来的 bug 了吧。希望这篇文章能够给你一些灵感让你没有那么慌乱的开始远离它们。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://ppinera.es/2017/09/29/modular-xcode-projects.html\" target=\"_blank\" rel=\"noopener\">Modular Xcode projects</a><br>原作者 &amp; Copyright <a href=\"http://twitter.com/pepibumur\" target=\"_blank\" rel=\"noopener\">@pepibumur</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>“我知道单例不好，但是…”，这是开发者常常在讨论代码的时候会提到的。貌似社区大家有共识 ── 单例不好。但是同时，包括 Apple 和第三方的 Swift 开发者还是在 App 内部或者共享的 frameworks 里不断在用它们。</p>\n<p>这周，让我们好好看一看单例的问题到底在哪里，探索更多的技巧以便我们日常能够避免使用它们。这就开始吧！</p>\n<h3 id=\"为什么单例这么流行？\"><a href=\"#为什么单例这么流行？\" class=\"headerlink\" title=\"为什么单例这么流行？\"></a>为什么单例这么流行？</h3><p>首先一点我们要想的是问问自己，为什么单例这么流行？热过大多数开发者都认同，单例应该被避免的话，为什么它们还不断的出现呢？</p>\n<p>我认为有两部分原因。</p>\n<p>我觉得日常开发 Apple 平台上的 App 时候大量使用单例，最大的原因是苹果自己也在经常的用。作为第三方开发者来讲，我们常常会把 Apple 的做法作为最佳实践来用，任何 Apple 自己常常使用的模式在社区也会发展的很迅速。</p>\n<p>这个谜题的第二个原因是单例非常方便。单例因为它可以在任何地方获取到，因而经常会扮演一个获取特定核心值或者对象的快捷方式。可以看下下面这个例子，在这个例子中，我们想在 <strong>ProfileViewController</strong> 中展示当前登录用户的名字，同时当某个按钮按下的时候，退登当前用户。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProfileViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> nameLabel = <span class=\"type\">UILabel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        nameLabel.text = <span class=\"type\">UserManager</span>.shared.currentUser?.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleLogOutButtonTap</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UserManager</span>.shared.logOut()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照上面这样，把一个 UserManager 单例的用户和账户处理的功能封装起来，确实很方便（而且很常见！），那这种模式的使用到底不好在哪里呢？</p>\n<h3 id=\"为什么单例会很糟糕？\"><a href=\"#为什么单例会很糟糕？\" class=\"headerlink\" title=\"为什么单例会很糟糕？\"></a>为什么单例会很糟糕？</h3><p>当讨论类似模式和架构这些东西的时候，很容易陷入一个特别理论化的圈套。虽然让我们的代码理论上“正确”，遵循最佳实践和原则是很美好的，但是现实经常会很受打击，我们需要寻找一些中间方案。</p>\n<p>所以，关于单例引起的实质性问题是什么呢？为什么它们要应该被避免呢？这里我倾向于三个原因：</p>\n<ol>\n<li>这些单例是全局的可变的共享状态。它们的状态是在整个 App 里自动共享的，因此当其状态发生不可预期的变化的时候，Bug 也就可能开始发生了；</li>\n<li>单例之间的关系以及依赖这些单例的代码常常不那么好定义。因为单例是如此方便和容易获得，大量的使用它们常常会导致很难维护<a href=\"https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81\" target=\"_blank\" rel=\"noopener\">面条式代码</a>，这些代码中对象和对象之间没有清晰的隔离；</li>\n<li>管理这些单例的生命周期非常的难。因为单例本身会在应用的整个生命周期内存活，管理它们就变得异常困难，因此常常会不得不依赖可选值来跟踪值的变化。这也使得依赖单例的代码变得很难测试，因为你没法在一个测试 case 里把状态重置。</li>\n</ol>\n<p>在我们前面的 <strong>ProfileViewController</strong> 的例子中，我们已经看到了有这三个问题的信号出现。首先它依赖 UserManager 导致这二者关系很不清晰，其次，它不得不让 currentUser 作为可选值出现，因为我们没办法在编译期就能够确定视图控制器实际上出现的时候这个数据一定在。听起来就感觉要有 bug 发生的感觉 😬!</p>\n<h3 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h3><p>相对于使用 <strong>ProfileViewController</strong> 通过单例来获取它所需的依赖项，我们要在其初始化方法中将依赖项传入。这里我们是将当前的 User 作为非可选传入的，同样，传入一个 <strong>LogOu\u0010tService</strong> 来进行登出操作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProfileViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> user: <span class=\"type\">User</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> logOutService: <span class=\"type\">LogOutService</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> nameLabel = <span class=\"type\">UILabel</span>()</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(user: <span class=\"type\">User</span>, logOutService: <span class=\"type\">LogOutService</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.user = user</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.logOutService = logOutService</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(nibName: <span class=\"literal\">nil</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        nameLabel.text = user.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleLogOutButtonTap</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        logOutService.logOut()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话，代码就会变得更加清晰，并且容易管理。我们的代码现在安全的依赖其 Model，并且有一个清晰的 API 进行登出的交互。一般情况下，将各种单例以及管理器重构成清晰分离的服务能够使得一个 App 的核心对象之间的关系更加清晰。</p>\n<h3 id=\"Services\"><a href=\"#Services\" class=\"headerlink\" title=\"Services\"></a>Services</h3><p>举个例子，让我们更近一些来看下 <strong>LogOutService</strong> 这个类是如何实现的。它内部也对其依赖的服务使用了依赖注入，并且提供了一个优雅的，定义清晰的 API 来只做一件事情 ── 登出。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogOutService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> user: <span class=\"type\">User</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> networkService: <span class=\"type\">NetworkService</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> navigationService: <span class=\"type\">NavigationService</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(user: <span class=\"type\">User</span>,</span><br><span class=\"line\">         networkService: <span class=\"type\">NetworkService</span>,</span><br><span class=\"line\">         navigationService: <span class=\"type\">NavigationService</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.user = user</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.networkService = networkService</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.navigationService = navigationService</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logOut</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        networkService.request(.logout(user)) &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>?.navigationService.showLoginScreen()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"翻新\"><a href=\"#翻新\" class=\"headerlink\" title=\"翻新\"></a>翻新</h3><p>从一个重度使用单例的设置到完全使用服务，依赖注入以及本地状态来改造会非常的困难，会花费大量时间。而且，会很难认为花大量时间在这上面是合理的，而且有些时候可能会需要一次更大规模的重构才行。</p>\n<p>谢天谢地，我们可以使用相近的技术，在<a href=\"https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps\" target=\"_blank\" rel=\"noopener\">Testing Swift code that uses system singletons in 3 easy steps</a>这篇文章中也使用到过，其允许我们可以以一种非常容易的方式单例开始。和很多其他解决方案类似 ── 协议来救场！</p>\n<p>我们不是一次性重构所有的单例，而是创建 Service 类，我们可以很简单的把我们的 Service 定义成 Protocol，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">LogOutService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logOut</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">NetworkService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"number\">_</span> endpoint: Endpoint, completionHandler: @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">NavigationService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showLoginScreen</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showProfile</span><span class=\"params\">(<span class=\"keyword\">for</span> user: User)</span></span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们就能通过将单例符合我们新创建的 Service 协议来使其翻新为一堆 Service。在很多情况下，我们甚至不需要改变任何实现，只是简单的传递它们 shared 实例作为一个 Service 即可。</p>\n<p>同样的技巧也能够被用作重构我们 app 中其他核心对象，那些对象我们也许也都正在以某种单例形式在使用着，例如使用 AppDelegate 来做导航。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UserManager</span>: <span class=\"title\">LoginService</span>, <span class=\"title\">LogOutService</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppDelegate</span>: <span class=\"title\">NavigationService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showLoginScreen</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        navigationController.viewControllers = [</span><br><span class=\"line\">            <span class=\"type\">LoginViewController</span>(</span><br><span class=\"line\">                loginService: <span class=\"type\">UserManager</span>.shared,</span><br><span class=\"line\">                navigationService: <span class=\"keyword\">self</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">showProfile</span><span class=\"params\">(<span class=\"keyword\">for</span> user: User)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> viewController = <span class=\"type\">ProfileViewController</span>(</span><br><span class=\"line\">            user: user,</span><br><span class=\"line\">            logOutService: <span class=\"type\">UserManager</span>.shared</span><br><span class=\"line\">        )</span><br><span class=\"line\">        navigationController.pushViewController(viewController, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们现在通过使用依赖注入以及 Service 的方式，开始使得我们工程处在 Singleton free 的状态，而不需要进行特别巨大的工程改造和重写。接下来我们就能够使用 Service 或者其他类型的 API 逐个替换掉单例，比如说使用<a href=\"https://www.swiftbysundell.com/posts/replacing-legacy-code-using-swift-protocols\" target=\"_blank\" rel=\"noopener\">这篇博文</a>中的技巧。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>单例也不是都是不好的，只是在很多情况下，它们会引发一系列问题，这些问题可以通过使用依赖注入的方式为你程序里的对象建立良好的关系来解决。</p>\n<p>如果你现在正在开发的 App 里在使用大量的单例，那你一定也在经历或者已经经历过它们所带来的 bug 了吧。希望这篇文章能够给你一些灵感让你没有那么慌乱的开始远离它们。</p>\n"},{"title":"Capturing objects in Swift closures","date":"2017-11-12T12:56:50.000Z","_content":"\n\n> 原文：[Capturing objects in Swift closures](https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures)\n> 原作者 [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n自从 Block 在 iOS4 被引入 Objective-C 的世界之后就成为了 Apple 各平台上最时髦的 API 的重要组成部分了。当 Swift 语言出现的时候，blocks 的概念就摇身一变通过 closure 的形式引入，成为了目前我们可能每一天都在用的语言特性之一了。\n\nClosure 目前已经被我们广泛的使用了，即使如此，我们在使用它的时候还是需要有很多需要注意的点，并且需要做很多额外的操作。这篇文章，我们来近距离的了解 closure，主要是了解其捕获变量的机制以及那些能够更好的让我们来处理变量捕获的技术。\n\n## 伟大的 escape\n\nClosure 有两种类型：escaping 和 non-escaping。当一个 closure 是 escaping（使用 `@escaping` 修饰闭包参数）的，也就意味着其会被以各种形式存储下来（无论是通过 property 还是被其他 closure 捕获）。相反，Non-Escaping 的　closure 意味着其不能被存储，而且在使用它的地方就必须直接被执行。\n\n> 译者注： 可以参见 [《@autoclosure && @escape》](http://hechen.info/2017/11/12/autoclosure-escape/) 一文。\n\n一个显而易见的例子就是当你在一个集合类型上使用函数式操作的时候，例如 `forEach`：\n\n```\n[1, 2, 3].forEach { number in\n    ...\n}\n```\n\n如上代码所示，closure 都直接作用于集合的每一个元素上，也就无需把该闭包变为 escaping 的。\n\n而 escaping 的 closures 最常见的就是在那些异步 API 中，例如 `DispatchQueue`。例如，当你异步执行某 closure 的时候，这个 closure 就会 escape。\n\n```\nDispatchQueue.main.async {\n    ...\n}\n```\n\n所以，这两种的区别在哪里呢？ 由于 escaping 的 closure 会被以某种形式存储下来，因此，这些 closure 会同时存储当前其所处的上下文，同时就会把上下文中用到的值或者对象都捕获（capture）到，以至于当该 closure 被执行的时候，所需用到的内容没有丢失。实践中最常见的就是在 closure 中使用 self 的 API，此时，我们就需要某种办法显式的捕获 self。\n\n\n## 捕获 & 引用循环\n\n因为 escaping 的 closures 会自助捕获在其内部使用的任何值和对象，因此很容易发生引用循环。举个例子，下面描述的是一个 view controller 被其存储的 viewModel 的 closure 捕获的情况：\n\n```\nclass ListViewController: UITableViewController {\n    private let viewModel: ListViewModel\n\n    init(viewModel: ListViewModel) {\n        self.viewModel = viewModel\n\n        super.init(nibName: nil, bundle: nil)\n\n        viewModel.observeNumberOfItemsChanged {\n            // This will cause a retain cycle, since our view controller\n            // retains its view model, which in turn retains the view\n            // controller by capturing it in an escaping closure.\n            self.tableView.reloadData()\n        }\n    }\n}\n```\n\n最常见的方式，也就是你们大部分人也都会用的解决方式，通过弱引用的方式打破这个循环引用。\n\n```\nviewModel.observeNumberOfItemsChanged { [weak self] in\n    self?.tableView.reloadData()\n}\n```\n\n\n## 捕获 context 而不是捕获 self\n\n上面提到的 [weak self] 的解决方案已经是你希望避免引用循环的最常用，也常常是最有效的解决方案了。但是这种方式也有一些问题：\n\n1. 很容易忘掉写，尤其是编译器又没检查出来潜在的引用循环的时候；\n2. 当你希望从 weak self 中强持有 self 的时候还需要写一堆代码（weak strong dance），例如下面这段代码所示：\n\n```\ndataLoader.loadData(from: url) { [weak self] data in\n    guard let strongSelf = self else {\n        return\n    }\n\n    let model = try strongSelf.parser.parse(data, using: strongSelf.schema)\n    strongSelf.titleLabel.text = model.title\n    strongSelf.textLabel.text = model.text\n}\n```\n\n这里其实有一个可选的解决方案，也就是不要捕获 self，而去捕获那些闭包中所需要的对象即可。例如上面例子中的 labels 和 schema 等，我们可以直接捕获它们而不至于引发引用循环（因为其也并不持有 closure 本身），下面是个解决方案，通过使用 context 的 tuple 来解决。\n\n```\n// We define a context tuple that contains all of our closure's dependencies\nlet context = (\n    parser: parser,\n    schema: schema,\n    titleLabel: titleLabel,\n    textLabel: textLabel\n)\n\ndataLoader.loadData(from: url) { data in\n    // We can now use the context instead of having to capture 'self'\n    let model = try context.parser.parse(data, using: context.schema)\n    context.titleLabel.text = model.title\n    context.textLabel.text = model.text\n}\n```\n\n## 通过显式传递参数而不是隐式的捕获\n\n这里，还有另外一种捕获对象的方式，就是显式的把这些对象通过参数传入。这种手法我在设计我的 [Image Engine]() 项目中的 Event API 的时候用到了，这个 API 就是当使用 closure 来监听 event 的时候，需要你传递一个 observer 给它。如下所示，你把 self 传入进来的同时也使得其被传递到了 event 的 closure 中了，这也使得 self 被隐式的带入，你也无需手动的捕获它了。\n\n```\nactor.events.moved.addObserver(self) { scene in\n    ...\n}\n```\n\n我们回到之前的 ListViewController 的例子中，看一看当我们要监听其 viewModel 的时候，我们是如何通过上面这种手法来实现同样的 API 的。这种方式正好使得我们可以将要 reload 的 tableView 作为观测者传递，实现一个很优雅的调用：\n\n```\nviewModel.numberOfItemsChanged.addObserver(tableView) { tableView in\n    tableView.reloadData()\n}\n```\n\n当然，需要实现上面这段代码，我们还需要做一些事情，就像 Image Engine 的事件系统如何工作类似。我们首先定义一个简单的 Event 类型，其可以记录那些观测闭包。\n\n```\nclass Event {\n    private var observers = [() -> Void]()\n}\n```\n\n然后，我们添加一个方法，该方法会传两个参数进来，一个是引用类型的观测者，另外一个是一个闭包，当观察动作一旦触发，该闭包就会被调用。核心就在这里，我们会封装该闭包，并且在内部闭包中弱捕获该观测者：\n\n```\nfunc addObserver<T: AnyObject>(_ observer: T, using closure: @escaping (T) -> Void) {\n    observers.append { [weak observer] in\n        observer.map(closure)\n    }\n}\n```\n\n这样就使得我们只需要做这么一次 weak/string 的操作，也不影响其调用的地方。\n\n最后，我们添加一个 trigger 方法来使得我们能够触发事件本身。\n\n```\nfunc trigger() {\n    for observer in observers {\n        observer()\n    }\n}\n```\n\n然后回到 `ListViewModel`，为 `numberOfItemsChanged` 方法添加事件，当某个条件满足的时候，就会触发该事件。\n\n```\nclass ListViewModel {\n    let numberOfItemsChanged = Event()\n    var items: [Item] { didSet { itemsDidChange(from: oldValue) } }\n\n    private func itemsDidChange(from previousItems: [Item]) {\n        if previousItems.count != items.count {\n            numberOfItemsChanged.trigger()\n        }\n    }\n}\n```\n\n如上面所看到的，基于 event 的 API 的最大优势就是最大程度上避免了引用循环的发生。我们也可以在我们的代码中为任意类型的观察事件重用相同的执行代码。当然，上面的 demo 中 Event 实现非常简单，缺乏一些高级特性，比如针对观察者的移除等等，但是对于简单使用已经足够了。\n\n我们会在之后的博文中详细的讲述事件驱动的编程范式，你也可以详细看下在 Image Engine 项目中的 [Event 类型的完整实现](https://github.com/JohnSundell/ImagineEngine/blob/master/Sources/Core/API/Event.swift)。\n\n\n## 总结\n\nClosure 自动捕获其内部所使用的对象和值本身是一个非常棒的特色，它使得 closure 本身变得非常好用。但是，捕获同时也引入了一些 bug 和引用循环的问题，甚至最后使得代码变得复杂和难以理解。\n\n当然，我并不是建议大家在所有的场景下去避免捕获发生，而是想通过这篇文章提供给大家一些捕获 self 的选择。在某些场景下，使用经典的 [weak self] 是最有效的解决方案，另外一些场景则可以使用某些手法来帮助你把自己的闭包代码写的更容易使用，也更容易理解吧。\n\n","source":"_posts/Capturing-objects-in-Swift-closures.md","raw":"---\ntitle: Capturing objects in Swift closures\ndate: 2017-11-12 20:56:50\ncategories: 翻译\ntags: [iOS,Swift,Closure]\n---\n\n\n> 原文：[Capturing objects in Swift closures](https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures)\n> 原作者 [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n自从 Block 在 iOS4 被引入 Objective-C 的世界之后就成为了 Apple 各平台上最时髦的 API 的重要组成部分了。当 Swift 语言出现的时候，blocks 的概念就摇身一变通过 closure 的形式引入，成为了目前我们可能每一天都在用的语言特性之一了。\n\nClosure 目前已经被我们广泛的使用了，即使如此，我们在使用它的时候还是需要有很多需要注意的点，并且需要做很多额外的操作。这篇文章，我们来近距离的了解 closure，主要是了解其捕获变量的机制以及那些能够更好的让我们来处理变量捕获的技术。\n\n## 伟大的 escape\n\nClosure 有两种类型：escaping 和 non-escaping。当一个 closure 是 escaping（使用 `@escaping` 修饰闭包参数）的，也就意味着其会被以各种形式存储下来（无论是通过 property 还是被其他 closure 捕获）。相反，Non-Escaping 的　closure 意味着其不能被存储，而且在使用它的地方就必须直接被执行。\n\n> 译者注： 可以参见 [《@autoclosure && @escape》](http://hechen.info/2017/11/12/autoclosure-escape/) 一文。\n\n一个显而易见的例子就是当你在一个集合类型上使用函数式操作的时候，例如 `forEach`：\n\n```\n[1, 2, 3].forEach { number in\n    ...\n}\n```\n\n如上代码所示，closure 都直接作用于集合的每一个元素上，也就无需把该闭包变为 escaping 的。\n\n而 escaping 的 closures 最常见的就是在那些异步 API 中，例如 `DispatchQueue`。例如，当你异步执行某 closure 的时候，这个 closure 就会 escape。\n\n```\nDispatchQueue.main.async {\n    ...\n}\n```\n\n所以，这两种的区别在哪里呢？ 由于 escaping 的 closure 会被以某种形式存储下来，因此，这些 closure 会同时存储当前其所处的上下文，同时就会把上下文中用到的值或者对象都捕获（capture）到，以至于当该 closure 被执行的时候，所需用到的内容没有丢失。实践中最常见的就是在 closure 中使用 self 的 API，此时，我们就需要某种办法显式的捕获 self。\n\n\n## 捕获 & 引用循环\n\n因为 escaping 的 closures 会自助捕获在其内部使用的任何值和对象，因此很容易发生引用循环。举个例子，下面描述的是一个 view controller 被其存储的 viewModel 的 closure 捕获的情况：\n\n```\nclass ListViewController: UITableViewController {\n    private let viewModel: ListViewModel\n\n    init(viewModel: ListViewModel) {\n        self.viewModel = viewModel\n\n        super.init(nibName: nil, bundle: nil)\n\n        viewModel.observeNumberOfItemsChanged {\n            // This will cause a retain cycle, since our view controller\n            // retains its view model, which in turn retains the view\n            // controller by capturing it in an escaping closure.\n            self.tableView.reloadData()\n        }\n    }\n}\n```\n\n最常见的方式，也就是你们大部分人也都会用的解决方式，通过弱引用的方式打破这个循环引用。\n\n```\nviewModel.observeNumberOfItemsChanged { [weak self] in\n    self?.tableView.reloadData()\n}\n```\n\n\n## 捕获 context 而不是捕获 self\n\n上面提到的 [weak self] 的解决方案已经是你希望避免引用循环的最常用，也常常是最有效的解决方案了。但是这种方式也有一些问题：\n\n1. 很容易忘掉写，尤其是编译器又没检查出来潜在的引用循环的时候；\n2. 当你希望从 weak self 中强持有 self 的时候还需要写一堆代码（weak strong dance），例如下面这段代码所示：\n\n```\ndataLoader.loadData(from: url) { [weak self] data in\n    guard let strongSelf = self else {\n        return\n    }\n\n    let model = try strongSelf.parser.parse(data, using: strongSelf.schema)\n    strongSelf.titleLabel.text = model.title\n    strongSelf.textLabel.text = model.text\n}\n```\n\n这里其实有一个可选的解决方案，也就是不要捕获 self，而去捕获那些闭包中所需要的对象即可。例如上面例子中的 labels 和 schema 等，我们可以直接捕获它们而不至于引发引用循环（因为其也并不持有 closure 本身），下面是个解决方案，通过使用 context 的 tuple 来解决。\n\n```\n// We define a context tuple that contains all of our closure's dependencies\nlet context = (\n    parser: parser,\n    schema: schema,\n    titleLabel: titleLabel,\n    textLabel: textLabel\n)\n\ndataLoader.loadData(from: url) { data in\n    // We can now use the context instead of having to capture 'self'\n    let model = try context.parser.parse(data, using: context.schema)\n    context.titleLabel.text = model.title\n    context.textLabel.text = model.text\n}\n```\n\n## 通过显式传递参数而不是隐式的捕获\n\n这里，还有另外一种捕获对象的方式，就是显式的把这些对象通过参数传入。这种手法我在设计我的 [Image Engine]() 项目中的 Event API 的时候用到了，这个 API 就是当使用 closure 来监听 event 的时候，需要你传递一个 observer 给它。如下所示，你把 self 传入进来的同时也使得其被传递到了 event 的 closure 中了，这也使得 self 被隐式的带入，你也无需手动的捕获它了。\n\n```\nactor.events.moved.addObserver(self) { scene in\n    ...\n}\n```\n\n我们回到之前的 ListViewController 的例子中，看一看当我们要监听其 viewModel 的时候，我们是如何通过上面这种手法来实现同样的 API 的。这种方式正好使得我们可以将要 reload 的 tableView 作为观测者传递，实现一个很优雅的调用：\n\n```\nviewModel.numberOfItemsChanged.addObserver(tableView) { tableView in\n    tableView.reloadData()\n}\n```\n\n当然，需要实现上面这段代码，我们还需要做一些事情，就像 Image Engine 的事件系统如何工作类似。我们首先定义一个简单的 Event 类型，其可以记录那些观测闭包。\n\n```\nclass Event {\n    private var observers = [() -> Void]()\n}\n```\n\n然后，我们添加一个方法，该方法会传两个参数进来，一个是引用类型的观测者，另外一个是一个闭包，当观察动作一旦触发，该闭包就会被调用。核心就在这里，我们会封装该闭包，并且在内部闭包中弱捕获该观测者：\n\n```\nfunc addObserver<T: AnyObject>(_ observer: T, using closure: @escaping (T) -> Void) {\n    observers.append { [weak observer] in\n        observer.map(closure)\n    }\n}\n```\n\n这样就使得我们只需要做这么一次 weak/string 的操作，也不影响其调用的地方。\n\n最后，我们添加一个 trigger 方法来使得我们能够触发事件本身。\n\n```\nfunc trigger() {\n    for observer in observers {\n        observer()\n    }\n}\n```\n\n然后回到 `ListViewModel`，为 `numberOfItemsChanged` 方法添加事件，当某个条件满足的时候，就会触发该事件。\n\n```\nclass ListViewModel {\n    let numberOfItemsChanged = Event()\n    var items: [Item] { didSet { itemsDidChange(from: oldValue) } }\n\n    private func itemsDidChange(from previousItems: [Item]) {\n        if previousItems.count != items.count {\n            numberOfItemsChanged.trigger()\n        }\n    }\n}\n```\n\n如上面所看到的，基于 event 的 API 的最大优势就是最大程度上避免了引用循环的发生。我们也可以在我们的代码中为任意类型的观察事件重用相同的执行代码。当然，上面的 demo 中 Event 实现非常简单，缺乏一些高级特性，比如针对观察者的移除等等，但是对于简单使用已经足够了。\n\n我们会在之后的博文中详细的讲述事件驱动的编程范式，你也可以详细看下在 Image Engine 项目中的 [Event 类型的完整实现](https://github.com/JohnSundell/ImagineEngine/blob/master/Sources/Core/API/Event.swift)。\n\n\n## 总结\n\nClosure 自动捕获其内部所使用的对象和值本身是一个非常棒的特色，它使得 closure 本身变得非常好用。但是，捕获同时也引入了一些 bug 和引用循环的问题，甚至最后使得代码变得复杂和难以理解。\n\n当然，我并不是建议大家在所有的场景下去避免捕获发生，而是想通过这篇文章提供给大家一些捕获 self 的选择。在某些场景下，使用经典的 [weak self] 是最有效的解决方案，另外一些场景则可以使用某些手法来帮助你把自己的闭包代码写的更容易使用，也更容易理解吧。\n\n","slug":"Capturing-objects-in-Swift-closures","published":1,"updated":"2017-11-13T01:32:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftb8004679pom5252una","content":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures\" target=\"_blank\" rel=\"noopener\">Capturing objects in Swift closures</a><br>原作者 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>自从 Block 在 iOS4 被引入 Objective-C 的世界之后就成为了 Apple 各平台上最时髦的 API 的重要组成部分了。当 Swift 语言出现的时候，blocks 的概念就摇身一变通过 closure 的形式引入，成为了目前我们可能每一天都在用的语言特性之一了。</p>\n<p>Closure 目前已经被我们广泛的使用了，即使如此，我们在使用它的时候还是需要有很多需要注意的点，并且需要做很多额外的操作。这篇文章，我们来近距离的了解 closure，主要是了解其捕获变量的机制以及那些能够更好的让我们来处理变量捕获的技术。</p>\n<h2 id=\"伟大的-escape\"><a href=\"#伟大的-escape\" class=\"headerlink\" title=\"伟大的 escape\"></a>伟大的 escape</h2><p>Closure 有两种类型：escaping 和 non-escaping。当一个 closure 是 escaping（使用 <code>@escaping</code> 修饰闭包参数）的，也就意味着其会被以各种形式存储下来（无论是通过 property 还是被其他 closure 捕获）。相反，Non-Escaping 的　closure 意味着其不能被存储，而且在使用它的地方就必须直接被执行。</p>\n<blockquote>\n<p>译者注： 可以参见 <a href=\"http://hechen.info/2017/11/12/autoclosure-escape/\" target=\"_blank\" rel=\"noopener\">《@autoclosure &amp;&amp; @escape》</a> 一文。</p>\n</blockquote>\n<p>一个显而易见的例子就是当你在一个集合类型上使用函数式操作的时候，例如 <code>forEach</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].forEach &#123; number in</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码所示，closure 都直接作用于集合的每一个元素上，也就无需把该闭包变为 escaping 的。</p>\n<p>而 escaping 的 closures 最常见的就是在那些异步 API 中，例如 <code>DispatchQueue</code>。例如，当你异步执行某 closure 的时候，这个 closure 就会 escape。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，这两种的区别在哪里呢？ 由于 escaping 的 closure 会被以某种形式存储下来，因此，这些 closure 会同时存储当前其所处的上下文，同时就会把上下文中用到的值或者对象都捕获（capture）到，以至于当该 closure 被执行的时候，所需用到的内容没有丢失。实践中最常见的就是在 closure 中使用 self 的 API，此时，我们就需要某种办法显式的捕获 self。</p>\n<h2 id=\"捕获-amp-引用循环\"><a href=\"#捕获-amp-引用循环\" class=\"headerlink\" title=\"捕获 &amp; 引用循环\"></a>捕获 &amp; 引用循环</h2><p>因为 escaping 的 closures 会自助捕获在其内部使用的任何值和对象，因此很容易发生引用循环。举个例子，下面描述的是一个 view controller 被其存储的 viewModel 的 closure 捕获的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ListViewController: UITableViewController &#123;</span><br><span class=\"line\">    private let viewModel: ListViewModel</span><br><span class=\"line\"></span><br><span class=\"line\">    init(viewModel: ListViewModel) &#123;</span><br><span class=\"line\">        self.viewModel = viewModel</span><br><span class=\"line\"></span><br><span class=\"line\">        super.init(nibName: nil, bundle: nil)</span><br><span class=\"line\"></span><br><span class=\"line\">        viewModel.observeNumberOfItemsChanged &#123;</span><br><span class=\"line\">            // This will cause a retain cycle, since our view controller</span><br><span class=\"line\">            // retains its view model, which in turn retains the view</span><br><span class=\"line\">            // controller by capturing it in an escaping closure.</span><br><span class=\"line\">            self.tableView.reloadData()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最常见的方式，也就是你们大部分人也都会用的解决方式，通过弱引用的方式打破这个循环引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">viewModel.observeNumberOfItemsChanged &#123; [weak self] in</span><br><span class=\"line\">    self?.tableView.reloadData()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"捕获-context-而不是捕获-self\"><a href=\"#捕获-context-而不是捕获-self\" class=\"headerlink\" title=\"捕获 context 而不是捕获 self\"></a>捕获 context 而不是捕获 self</h2><p>上面提到的 [weak self] 的解决方案已经是你希望避免引用循环的最常用，也常常是最有效的解决方案了。但是这种方式也有一些问题：</p>\n<ol>\n<li>很容易忘掉写，尤其是编译器又没检查出来潜在的引用循环的时候；</li>\n<li>当你希望从 weak self 中强持有 self 的时候还需要写一堆代码（weak strong dance），例如下面这段代码所示：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dataLoader.loadData(from: url) &#123; [weak self] data in</span><br><span class=\"line\">    guard let strongSelf = self else &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let model = try strongSelf.parser.parse(data, using: strongSelf.schema)</span><br><span class=\"line\">    strongSelf.titleLabel.text = model.title</span><br><span class=\"line\">    strongSelf.textLabel.text = model.text</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实有一个可选的解决方案，也就是不要捕获 self，而去捕获那些闭包中所需要的对象即可。例如上面例子中的 labels 和 schema 等，我们可以直接捕获它们而不至于引发引用循环（因为其也并不持有 closure 本身），下面是个解决方案，通过使用 context 的 tuple 来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// We define a context tuple that contains all of our closure&apos;s dependencies</span><br><span class=\"line\">let context = (</span><br><span class=\"line\">    parser: parser,</span><br><span class=\"line\">    schema: schema,</span><br><span class=\"line\">    titleLabel: titleLabel,</span><br><span class=\"line\">    textLabel: textLabel</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">dataLoader.loadData(from: url) &#123; data in</span><br><span class=\"line\">    // We can now use the context instead of having to capture &apos;self&apos;</span><br><span class=\"line\">    let model = try context.parser.parse(data, using: context.schema)</span><br><span class=\"line\">    context.titleLabel.text = model.title</span><br><span class=\"line\">    context.textLabel.text = model.text</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过显式传递参数而不是隐式的捕获\"><a href=\"#通过显式传递参数而不是隐式的捕获\" class=\"headerlink\" title=\"通过显式传递参数而不是隐式的捕获\"></a>通过显式传递参数而不是隐式的捕获</h2><p>这里，还有另外一种捕获对象的方式，就是显式的把这些对象通过参数传入。这种手法我在设计我的 <a href=\"\">Image Engine</a> 项目中的 Event API 的时候用到了，这个 API 就是当使用 closure 来监听 event 的时候，需要你传递一个 observer 给它。如下所示，你把 self 传入进来的同时也使得其被传递到了 event 的 closure 中了，这也使得 self 被隐式的带入，你也无需手动的捕获它了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">actor.events.moved.addObserver(self) &#123; scene in</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们回到之前的 ListViewController 的例子中，看一看当我们要监听其 viewModel 的时候，我们是如何通过上面这种手法来实现同样的 API 的。这种方式正好使得我们可以将要 reload 的 tableView 作为观测者传递，实现一个很优雅的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">viewModel.numberOfItemsChanged.addObserver(tableView) &#123; tableView in</span><br><span class=\"line\">    tableView.reloadData()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，需要实现上面这段代码，我们还需要做一些事情，就像 Image Engine 的事件系统如何工作类似。我们首先定义一个简单的 Event 类型，其可以记录那些观测闭包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Event &#123;</span><br><span class=\"line\">    private var observers = [() -&gt; Void]()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们添加一个方法，该方法会传两个参数进来，一个是引用类型的观测者，另外一个是一个闭包，当观察动作一旦触发，该闭包就会被调用。核心就在这里，我们会封装该闭包，并且在内部闭包中弱捕获该观测者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func addObserver&lt;T: AnyObject&gt;(_ observer: T, using closure: @escaping (T) -&gt; Void) &#123;</span><br><span class=\"line\">    observers.append &#123; [weak observer] in</span><br><span class=\"line\">        observer.map(closure)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就使得我们只需要做这么一次 weak/string 的操作，也不影响其调用的地方。</p>\n<p>最后，我们添加一个 trigger 方法来使得我们能够触发事件本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func trigger() &#123;</span><br><span class=\"line\">    for observer in observers &#123;</span><br><span class=\"line\">        observer()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后回到 <code>ListViewModel</code>，为 <code>numberOfItemsChanged</code> 方法添加事件，当某个条件满足的时候，就会触发该事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ListViewModel &#123;</span><br><span class=\"line\">    let numberOfItemsChanged = Event()</span><br><span class=\"line\">    var items: [Item] &#123; didSet &#123; itemsDidChange(from: oldValue) &#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private func itemsDidChange(from previousItems: [Item]) &#123;</span><br><span class=\"line\">        if previousItems.count != items.count &#123;</span><br><span class=\"line\">            numberOfItemsChanged.trigger()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上面所看到的，基于 event 的 API 的最大优势就是最大程度上避免了引用循环的发生。我们也可以在我们的代码中为任意类型的观察事件重用相同的执行代码。当然，上面的 demo 中 Event 实现非常简单，缺乏一些高级特性，比如针对观察者的移除等等，但是对于简单使用已经足够了。</p>\n<p>我们会在之后的博文中详细的讲述事件驱动的编程范式，你也可以详细看下在 Image Engine 项目中的 <a href=\"https://github.com/JohnSundell/ImagineEngine/blob/master/Sources/Core/API/Event.swift\" target=\"_blank\" rel=\"noopener\">Event 类型的完整实现</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Closure 自动捕获其内部所使用的对象和值本身是一个非常棒的特色，它使得 closure 本身变得非常好用。但是，捕获同时也引入了一些 bug 和引用循环的问题，甚至最后使得代码变得复杂和难以理解。</p>\n<p>当然，我并不是建议大家在所有的场景下去避免捕获发生，而是想通过这篇文章提供给大家一些捕获 self 的选择。在某些场景下，使用经典的 [weak self] 是最有效的解决方案，另外一些场景则可以使用某些手法来帮助你把自己的闭包代码写的更容易使用，也更容易理解吧。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures\" target=\"_blank\" rel=\"noopener\">Capturing objects in Swift closures</a><br>原作者 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>自从 Block 在 iOS4 被引入 Objective-C 的世界之后就成为了 Apple 各平台上最时髦的 API 的重要组成部分了。当 Swift 语言出现的时候，blocks 的概念就摇身一变通过 closure 的形式引入，成为了目前我们可能每一天都在用的语言特性之一了。</p>\n<p>Closure 目前已经被我们广泛的使用了，即使如此，我们在使用它的时候还是需要有很多需要注意的点，并且需要做很多额外的操作。这篇文章，我们来近距离的了解 closure，主要是了解其捕获变量的机制以及那些能够更好的让我们来处理变量捕获的技术。</p>\n<h2 id=\"伟大的-escape\"><a href=\"#伟大的-escape\" class=\"headerlink\" title=\"伟大的 escape\"></a>伟大的 escape</h2><p>Closure 有两种类型：escaping 和 non-escaping。当一个 closure 是 escaping（使用 <code>@escaping</code> 修饰闭包参数）的，也就意味着其会被以各种形式存储下来（无论是通过 property 还是被其他 closure 捕获）。相反，Non-Escaping 的　closure 意味着其不能被存储，而且在使用它的地方就必须直接被执行。</p>\n<blockquote>\n<p>译者注： 可以参见 <a href=\"http://hechen.info/2017/11/12/autoclosure-escape/\" target=\"_blank\" rel=\"noopener\">《@autoclosure &amp;&amp; @escape》</a> 一文。</p>\n</blockquote>\n<p>一个显而易见的例子就是当你在一个集合类型上使用函数式操作的时候，例如 <code>forEach</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].forEach &#123; number in</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码所示，closure 都直接作用于集合的每一个元素上，也就无需把该闭包变为 escaping 的。</p>\n<p>而 escaping 的 closures 最常见的就是在那些异步 API 中，例如 <code>DispatchQueue</code>。例如，当你异步执行某 closure 的时候，这个 closure 就会 escape。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，这两种的区别在哪里呢？ 由于 escaping 的 closure 会被以某种形式存储下来，因此，这些 closure 会同时存储当前其所处的上下文，同时就会把上下文中用到的值或者对象都捕获（capture）到，以至于当该 closure 被执行的时候，所需用到的内容没有丢失。实践中最常见的就是在 closure 中使用 self 的 API，此时，我们就需要某种办法显式的捕获 self。</p>\n<h2 id=\"捕获-amp-引用循环\"><a href=\"#捕获-amp-引用循环\" class=\"headerlink\" title=\"捕获 &amp; 引用循环\"></a>捕获 &amp; 引用循环</h2><p>因为 escaping 的 closures 会自助捕获在其内部使用的任何值和对象，因此很容易发生引用循环。举个例子，下面描述的是一个 view controller 被其存储的 viewModel 的 closure 捕获的情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ListViewController: UITableViewController &#123;</span><br><span class=\"line\">    private let viewModel: ListViewModel</span><br><span class=\"line\"></span><br><span class=\"line\">    init(viewModel: ListViewModel) &#123;</span><br><span class=\"line\">        self.viewModel = viewModel</span><br><span class=\"line\"></span><br><span class=\"line\">        super.init(nibName: nil, bundle: nil)</span><br><span class=\"line\"></span><br><span class=\"line\">        viewModel.observeNumberOfItemsChanged &#123;</span><br><span class=\"line\">            // This will cause a retain cycle, since our view controller</span><br><span class=\"line\">            // retains its view model, which in turn retains the view</span><br><span class=\"line\">            // controller by capturing it in an escaping closure.</span><br><span class=\"line\">            self.tableView.reloadData()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最常见的方式，也就是你们大部分人也都会用的解决方式，通过弱引用的方式打破这个循环引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">viewModel.observeNumberOfItemsChanged &#123; [weak self] in</span><br><span class=\"line\">    self?.tableView.reloadData()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"捕获-context-而不是捕获-self\"><a href=\"#捕获-context-而不是捕获-self\" class=\"headerlink\" title=\"捕获 context 而不是捕获 self\"></a>捕获 context 而不是捕获 self</h2><p>上面提到的 [weak self] 的解决方案已经是你希望避免引用循环的最常用，也常常是最有效的解决方案了。但是这种方式也有一些问题：</p>\n<ol>\n<li>很容易忘掉写，尤其是编译器又没检查出来潜在的引用循环的时候；</li>\n<li>当你希望从 weak self 中强持有 self 的时候还需要写一堆代码（weak strong dance），例如下面这段代码所示：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dataLoader.loadData(from: url) &#123; [weak self] data in</span><br><span class=\"line\">    guard let strongSelf = self else &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let model = try strongSelf.parser.parse(data, using: strongSelf.schema)</span><br><span class=\"line\">    strongSelf.titleLabel.text = model.title</span><br><span class=\"line\">    strongSelf.textLabel.text = model.text</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其实有一个可选的解决方案，也就是不要捕获 self，而去捕获那些闭包中所需要的对象即可。例如上面例子中的 labels 和 schema 等，我们可以直接捕获它们而不至于引发引用循环（因为其也并不持有 closure 本身），下面是个解决方案，通过使用 context 的 tuple 来解决。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// We define a context tuple that contains all of our closure&apos;s dependencies</span><br><span class=\"line\">let context = (</span><br><span class=\"line\">    parser: parser,</span><br><span class=\"line\">    schema: schema,</span><br><span class=\"line\">    titleLabel: titleLabel,</span><br><span class=\"line\">    textLabel: textLabel</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">dataLoader.loadData(from: url) &#123; data in</span><br><span class=\"line\">    // We can now use the context instead of having to capture &apos;self&apos;</span><br><span class=\"line\">    let model = try context.parser.parse(data, using: context.schema)</span><br><span class=\"line\">    context.titleLabel.text = model.title</span><br><span class=\"line\">    context.textLabel.text = model.text</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过显式传递参数而不是隐式的捕获\"><a href=\"#通过显式传递参数而不是隐式的捕获\" class=\"headerlink\" title=\"通过显式传递参数而不是隐式的捕获\"></a>通过显式传递参数而不是隐式的捕获</h2><p>这里，还有另外一种捕获对象的方式，就是显式的把这些对象通过参数传入。这种手法我在设计我的 <a href=\"\">Image Engine</a> 项目中的 Event API 的时候用到了，这个 API 就是当使用 closure 来监听 event 的时候，需要你传递一个 observer 给它。如下所示，你把 self 传入进来的同时也使得其被传递到了 event 的 closure 中了，这也使得 self 被隐式的带入，你也无需手动的捕获它了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">actor.events.moved.addObserver(self) &#123; scene in</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们回到之前的 ListViewController 的例子中，看一看当我们要监听其 viewModel 的时候，我们是如何通过上面这种手法来实现同样的 API 的。这种方式正好使得我们可以将要 reload 的 tableView 作为观测者传递，实现一个很优雅的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">viewModel.numberOfItemsChanged.addObserver(tableView) &#123; tableView in</span><br><span class=\"line\">    tableView.reloadData()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，需要实现上面这段代码，我们还需要做一些事情，就像 Image Engine 的事件系统如何工作类似。我们首先定义一个简单的 Event 类型，其可以记录那些观测闭包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Event &#123;</span><br><span class=\"line\">    private var observers = [() -&gt; Void]()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们添加一个方法，该方法会传两个参数进来，一个是引用类型的观测者，另外一个是一个闭包，当观察动作一旦触发，该闭包就会被调用。核心就在这里，我们会封装该闭包，并且在内部闭包中弱捕获该观测者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func addObserver&lt;T: AnyObject&gt;(_ observer: T, using closure: @escaping (T) -&gt; Void) &#123;</span><br><span class=\"line\">    observers.append &#123; [weak observer] in</span><br><span class=\"line\">        observer.map(closure)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就使得我们只需要做这么一次 weak/string 的操作，也不影响其调用的地方。</p>\n<p>最后，我们添加一个 trigger 方法来使得我们能够触发事件本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func trigger() &#123;</span><br><span class=\"line\">    for observer in observers &#123;</span><br><span class=\"line\">        observer()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后回到 <code>ListViewModel</code>，为 <code>numberOfItemsChanged</code> 方法添加事件，当某个条件满足的时候，就会触发该事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class ListViewModel &#123;</span><br><span class=\"line\">    let numberOfItemsChanged = Event()</span><br><span class=\"line\">    var items: [Item] &#123; didSet &#123; itemsDidChange(from: oldValue) &#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private func itemsDidChange(from previousItems: [Item]) &#123;</span><br><span class=\"line\">        if previousItems.count != items.count &#123;</span><br><span class=\"line\">            numberOfItemsChanged.trigger()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上面所看到的，基于 event 的 API 的最大优势就是最大程度上避免了引用循环的发生。我们也可以在我们的代码中为任意类型的观察事件重用相同的执行代码。当然，上面的 demo 中 Event 实现非常简单，缺乏一些高级特性，比如针对观察者的移除等等，但是对于简单使用已经足够了。</p>\n<p>我们会在之后的博文中详细的讲述事件驱动的编程范式，你也可以详细看下在 Image Engine 项目中的 <a href=\"https://github.com/JohnSundell/ImagineEngine/blob/master/Sources/Core/API/Event.swift\" target=\"_blank\" rel=\"noopener\">Event 类型的完整实现</a>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Closure 自动捕获其内部所使用的对象和值本身是一个非常棒的特色，它使得 closure 本身变得非常好用。但是，捕获同时也引入了一些 bug 和引用循环的问题，甚至最后使得代码变得复杂和难以理解。</p>\n<p>当然，我并不是建议大家在所有的场景下去避免捕获发生，而是想通过这篇文章提供给大家一些捕获 self 的选择。在某些场景下，使用经典的 [weak self] 是最有效的解决方案，另外一些场景则可以使用某些手法来帮助你把自己的闭包代码写的更容易使用，也更容易理解吧。</p>\n"},{"title":"处理 Swift 中非可选的可选值类型","date":"2017-11-14T13:53:52.000Z","_content":"\n> 原文：[Handling non-optional optionals in Swift](https://www.swiftbysundell.com/posts/handling-non-optional-optionals-in-swift)\n> 原作者 [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n可选值（optionals）无可争议的是 `swift` 语言中最重要的特性之一，也是和其他语言，例如 `Objective-C` 的最大区别。通过强制处理那些有可能出现 `nil` 的地方，我们就能写出更有预测性的以及更健壮的代码。\n\n然而，有些时候可选值可能会致你于尴尬的境地，尤其是你作为开发者了解（甚至是有些猜测的成分在），有的特定变量始终是非空（non-nil）的，即使它是一个可选类型。例如，我们在一个视图控制器中处理视图的时候：\n\n```\nclass TableViewController: UIViewController {\n    var tableView: UITableView?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        tableView = UITableView(frame: view.bounds)\n        view.addSubview(tableView!)\n    }\n\n    func viewModelDidUpdate(_ viewModel: ViewModel) {\n        tableView?.reloadData()\n    }\n}\n```\n\n这也是对于很多 Swift 程序员争论比较激烈的地方，程度不亚于讨论 tabs 和 spaces 的用法。有的人会说：\n\n> 既然它是一个可选值，你就应该时刻使用 `if let` 或者 `guard let` 的方式进行解包。\n\n然而另外一些人则采用完全相反，说：\n\n> 既然你知道这个变量在使用的时候不会为 `nil`，使用 `!` 强制解包多好。崩溃也要比让你的程序处于一个未知状态要好吧。\n\n本质上来讲，我们这里讨论的是要不要采用防御性编程（[defensive programming](https://en.wikipedia.org/wiki/Defensive_programming)）的问题。我们是试图让程序从一个未知状态恢复还是简单的放弃，然后让它崩溃掉？\n\n如果非得让我对这个问题给出一个答案的话，我更倾向于后者。未知状态真的很难追踪 bug，会导致执行很多不想执行的逻辑，采用防御性编程就会使得你的代码很难追踪，出现问题很难追踪。\n\n但是，我不太喜欢给出一个二选一的答案。相反，我们可以寻找一些技术手法，用更精妙的方式的解决上面提到的问题。\n\n\n## 它真的可选的吗？\n\n那些可选类型的，但是被代码逻辑真实需要的变量和属性，实际上是架构瑕疵的一个体现。如果在某些地方确实需要它，但是它又不在，就会使得你的代码逻辑处于未知状态，那么它就不应该是可选类型的。\n\n当然，在某些特定场景下，可选值确实很难避免（尤其是和特定的系统 API 交互的时候），那对于大部分这种情况，我们有一些技术来处理从而避免可选值。\n\n### lazy 要比非可选的可选值更好\n\n某些属性的值需要在其父类创建之后再生成（比如视图控制器中的那些视图，应该在 `loadView()`或者 `viewDidLoad()`方法中被创建），对于这种属性要避免其可选类型的方法就是使用 `lazy` 属性。一个`lazy`属性是可以是非可选类型的，同时也不在其父类的初始化方法里被需要，它会在其第一次被获取的时候创建出来。\n\n让我们改一下上面的代码，使用 lazy 来改造 tableView 属性：\n\n```\nclass TableViewController: UIViewController {\n    lazy var tableView = UITableView()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        tableView.frame = view.bounds\n        view.addSubview(tableView)\n    }\n\n    func viewModelDidUpdate(_ viewModel: ViewModel) {\n        tableView.reloadData()\n    }\n}\n```\n\n这样，没有可选值了，也不会有未知状态咯🎉\n\n\n### 适当的依赖管理要比非可选的可选值要好\n\n可选值类型另外一种常用的场景就是用来打破循环依赖（[circular dependencies](https://en.wikipedia.org/wiki/Circular_dependency)）。有的时候，你就陷入 A 依赖 B，B 又依赖 A 的情况，如下：\n\n```\nclass UserManager {\n    private weak var commentManager: CommentManager?\n\n    func userDidPostComment(_ comment: Comment) {\n        user.totalNumberOfComments += 1\n    }\n\n    func logOutCurrentUser() {\n        user.logOut()\n        commentManager?.clearCache()\n    }\n}\n\nclass CommentManager {\n    private weak var userManager: UserManager?\n\n    func composer(_ composer: CommentComposer\n                  didPostComment comment: Comment) {\n        userManager?.userDidPostComment(comment)\n        handle(comment)\n    }\n\n    func clearCache() {\n        cache.clear()\n    }\n}\n```\n\n从上面的代码，我们可以看到，`UserManager` 和 `CommentManager` 之间有一个循环依赖的问题，它们二者都没法假设自己拥有对方，但是它们都在各自的代码逻辑里依赖彼此。这里就很容易产生 bug。\n\n那要解决上面的问题，我们创建一个 `CommentComposer` 来做一个协调者，负责通知`UserManager` 和 `CommentManager`二人一个评论产生了。\n\n```\nclass CommentComposer {\n    private let commentManager: CommentManager\n    private let userManager: UserManager\n    private lazy var textView = UITextView()\n\n    init(commentManager: CommentManager,\n         userManager: UserManager) {\n        self.commentManager = commentManager\n        self.userManager = userManager\n    }\n\n    func postComment() {\n        let comment = Comment(text: textView.text)\n        commentManager.handle(comment)\n        userManager.userDidPostComment(comment)\n    }\n}\n```\n\n通过这种形式，UserManager 可以强持有 CommentManager 也不产生任何依赖循环。\n\n```\nclass UserManager {\n    private let commentManager: CommentManager\n\n    init(commentManager: CommentManager) {\n        self.commentManager = commentManager\n    }\n\n    func userDidPostComment(_ comment: Comment) {\n        user.totalNumberOfComments += 1\n    }\n}\n```\n\n我们又一次的移除了所有的可选类型，代码也更好预测了🎉。\n\n\n### 优雅的崩溃（Crashing gracefully）\n\n通过上面几个例子，我们通过对代码做一些调整，移除了可选类型从而排除了不确定性。然而，有的时候，移除可选类型是不可能的。让我们举个例子，比如你在加载一个本地的包含针对你 App 的配置项的 JSON 文件，这个操作本身一定会存在失败的情况，我们就需要添加错误处理。\n\n继续上面这个场景，加载配置文件失败的时候继续执行代码就会使得你的 app 进入一个未知状态，在这种情况下，最好的方式让它崩溃。这样，我们会得到一个崩溃日志，希望这个问题能够在用户感知之前早早的被我们的测试人员以及 QA 处理掉。\n\n所以，我们如何崩溃。。。最简单的方式就是添加 `!` 操作符，针对这个可选值强制解包，就会在其是 nil 的时候发生崩溃：\n\n```\nlet configuration = loadConfiguration()!\n```\n\n虽然这个方法比较简单，但是它有个比较大的问题，就是一旦这段代码崩溃，我们能得到的只有一个错误信息：\n\n> fatal error: unexpectedly found nil while unwrapping an Optional value\n\n\n这个错误信息并不告诉我们为什么发生这个错误，在哪里发生的，给不了我们什么线索来解决它。这个时候，我们可以使用 guard 关键字，结合 `preconditionFailure()` 函数，在程序退出的时候给出定制消息。\n\n```\nguard let configuration = loadConfiguration() else {\n    preconditionFailure(\"Configuration couldn't be loaded. \" +\n                        \"Verify that Config.JSON is valid.\")\n}\n```\n\n上面这段代码发生崩溃的时候，我们就能获得更多更有效的错误信息：\n\n> fatal error: Configuration couldn’t be loaded. Verify that Config.JSON is valid.: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17\n\n\n这样，我们现在有了一个更清晰的解决问题的办法，能够准确的知道这个问题在我们代码里的哪个未知发生的。\n\n### 引入 Require 库\n\n使用上面的 guard-let-preconditionFailure 的方案还是有一些冗长，确实让我们呃代码更难驾驭。我们也确实不希望在我们的代码里占很多篇幅去些这种代码，我们想更专注于我们的代码逻辑上。\n\n我的解决方案就是使用 `Require`。它只是简单的在可选值添加简单的 `require()` 方法，但能够使得调用的地方更简洁。用这种方法来处理上面加载 `JSON` 文件的代码就可以这样写：\n\n```\nlet configuration = loadConfiguration().require(hint: \"Verify that Config.JSON is valid\")\n```\n\n当出现异常的时候，会给出下面的错误信息：\n\n\n> fatal error: Required value was nil. Debugging hint: Verify that Config.JSON is valid: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17\n\n`Require` 的另一个优势就是它和调用 `preconditionFailure()` 方法一样也会抛异常 `NSException`，就能使得那些异常上报工具能够捕获异常发生时候的元数据。\n\n你如果想在自己代码中使用的话，[Require 现在在 Github 上开源了](https://github.com/JohnSundell/Require.git)\n\n\n## 总结\n\n所以，总结来看，在 `Swift` 语言里处理那些非可选的可选值，我有几点自己的贴心小提示给大家：\n\n1. `lazy` 属性要比非可选的可选值要更好\n2. 适当的依赖管理要比非可选的可选值要好\n3. 当你使用非可选的可选值的时候，优雅的崩溃\n\n如果有任何问题、建议或者反馈，都欢迎随时在 [Twitter](https://twitter.com/johnsundell) 上联系我，我非常乐意听到你们希望我在接下来的文章里谈论哪些主题哦。\n\n谢谢阅读。\n\n\n","source":"_posts/Handling-non-optional-optionals-in-Swift.md","raw":"---\ntitle: 处理 Swift 中非可选的可选值类型\ndate: 2017-11-14 21:53:52\ncategories: 翻译\ntags: [iOS,Swift,Optional]\n---\n\n> 原文：[Handling non-optional optionals in Swift](https://www.swiftbysundell.com/posts/handling-non-optional-optionals-in-swift)\n> 原作者 [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n可选值（optionals）无可争议的是 `swift` 语言中最重要的特性之一，也是和其他语言，例如 `Objective-C` 的最大区别。通过强制处理那些有可能出现 `nil` 的地方，我们就能写出更有预测性的以及更健壮的代码。\n\n然而，有些时候可选值可能会致你于尴尬的境地，尤其是你作为开发者了解（甚至是有些猜测的成分在），有的特定变量始终是非空（non-nil）的，即使它是一个可选类型。例如，我们在一个视图控制器中处理视图的时候：\n\n```\nclass TableViewController: UIViewController {\n    var tableView: UITableView?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        tableView = UITableView(frame: view.bounds)\n        view.addSubview(tableView!)\n    }\n\n    func viewModelDidUpdate(_ viewModel: ViewModel) {\n        tableView?.reloadData()\n    }\n}\n```\n\n这也是对于很多 Swift 程序员争论比较激烈的地方，程度不亚于讨论 tabs 和 spaces 的用法。有的人会说：\n\n> 既然它是一个可选值，你就应该时刻使用 `if let` 或者 `guard let` 的方式进行解包。\n\n然而另外一些人则采用完全相反，说：\n\n> 既然你知道这个变量在使用的时候不会为 `nil`，使用 `!` 强制解包多好。崩溃也要比让你的程序处于一个未知状态要好吧。\n\n本质上来讲，我们这里讨论的是要不要采用防御性编程（[defensive programming](https://en.wikipedia.org/wiki/Defensive_programming)）的问题。我们是试图让程序从一个未知状态恢复还是简单的放弃，然后让它崩溃掉？\n\n如果非得让我对这个问题给出一个答案的话，我更倾向于后者。未知状态真的很难追踪 bug，会导致执行很多不想执行的逻辑，采用防御性编程就会使得你的代码很难追踪，出现问题很难追踪。\n\n但是，我不太喜欢给出一个二选一的答案。相反，我们可以寻找一些技术手法，用更精妙的方式的解决上面提到的问题。\n\n\n## 它真的可选的吗？\n\n那些可选类型的，但是被代码逻辑真实需要的变量和属性，实际上是架构瑕疵的一个体现。如果在某些地方确实需要它，但是它又不在，就会使得你的代码逻辑处于未知状态，那么它就不应该是可选类型的。\n\n当然，在某些特定场景下，可选值确实很难避免（尤其是和特定的系统 API 交互的时候），那对于大部分这种情况，我们有一些技术来处理从而避免可选值。\n\n### lazy 要比非可选的可选值更好\n\n某些属性的值需要在其父类创建之后再生成（比如视图控制器中的那些视图，应该在 `loadView()`或者 `viewDidLoad()`方法中被创建），对于这种属性要避免其可选类型的方法就是使用 `lazy` 属性。一个`lazy`属性是可以是非可选类型的，同时也不在其父类的初始化方法里被需要，它会在其第一次被获取的时候创建出来。\n\n让我们改一下上面的代码，使用 lazy 来改造 tableView 属性：\n\n```\nclass TableViewController: UIViewController {\n    lazy var tableView = UITableView()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        tableView.frame = view.bounds\n        view.addSubview(tableView)\n    }\n\n    func viewModelDidUpdate(_ viewModel: ViewModel) {\n        tableView.reloadData()\n    }\n}\n```\n\n这样，没有可选值了，也不会有未知状态咯🎉\n\n\n### 适当的依赖管理要比非可选的可选值要好\n\n可选值类型另外一种常用的场景就是用来打破循环依赖（[circular dependencies](https://en.wikipedia.org/wiki/Circular_dependency)）。有的时候，你就陷入 A 依赖 B，B 又依赖 A 的情况，如下：\n\n```\nclass UserManager {\n    private weak var commentManager: CommentManager?\n\n    func userDidPostComment(_ comment: Comment) {\n        user.totalNumberOfComments += 1\n    }\n\n    func logOutCurrentUser() {\n        user.logOut()\n        commentManager?.clearCache()\n    }\n}\n\nclass CommentManager {\n    private weak var userManager: UserManager?\n\n    func composer(_ composer: CommentComposer\n                  didPostComment comment: Comment) {\n        userManager?.userDidPostComment(comment)\n        handle(comment)\n    }\n\n    func clearCache() {\n        cache.clear()\n    }\n}\n```\n\n从上面的代码，我们可以看到，`UserManager` 和 `CommentManager` 之间有一个循环依赖的问题，它们二者都没法假设自己拥有对方，但是它们都在各自的代码逻辑里依赖彼此。这里就很容易产生 bug。\n\n那要解决上面的问题，我们创建一个 `CommentComposer` 来做一个协调者，负责通知`UserManager` 和 `CommentManager`二人一个评论产生了。\n\n```\nclass CommentComposer {\n    private let commentManager: CommentManager\n    private let userManager: UserManager\n    private lazy var textView = UITextView()\n\n    init(commentManager: CommentManager,\n         userManager: UserManager) {\n        self.commentManager = commentManager\n        self.userManager = userManager\n    }\n\n    func postComment() {\n        let comment = Comment(text: textView.text)\n        commentManager.handle(comment)\n        userManager.userDidPostComment(comment)\n    }\n}\n```\n\n通过这种形式，UserManager 可以强持有 CommentManager 也不产生任何依赖循环。\n\n```\nclass UserManager {\n    private let commentManager: CommentManager\n\n    init(commentManager: CommentManager) {\n        self.commentManager = commentManager\n    }\n\n    func userDidPostComment(_ comment: Comment) {\n        user.totalNumberOfComments += 1\n    }\n}\n```\n\n我们又一次的移除了所有的可选类型，代码也更好预测了🎉。\n\n\n### 优雅的崩溃（Crashing gracefully）\n\n通过上面几个例子，我们通过对代码做一些调整，移除了可选类型从而排除了不确定性。然而，有的时候，移除可选类型是不可能的。让我们举个例子，比如你在加载一个本地的包含针对你 App 的配置项的 JSON 文件，这个操作本身一定会存在失败的情况，我们就需要添加错误处理。\n\n继续上面这个场景，加载配置文件失败的时候继续执行代码就会使得你的 app 进入一个未知状态，在这种情况下，最好的方式让它崩溃。这样，我们会得到一个崩溃日志，希望这个问题能够在用户感知之前早早的被我们的测试人员以及 QA 处理掉。\n\n所以，我们如何崩溃。。。最简单的方式就是添加 `!` 操作符，针对这个可选值强制解包，就会在其是 nil 的时候发生崩溃：\n\n```\nlet configuration = loadConfiguration()!\n```\n\n虽然这个方法比较简单，但是它有个比较大的问题，就是一旦这段代码崩溃，我们能得到的只有一个错误信息：\n\n> fatal error: unexpectedly found nil while unwrapping an Optional value\n\n\n这个错误信息并不告诉我们为什么发生这个错误，在哪里发生的，给不了我们什么线索来解决它。这个时候，我们可以使用 guard 关键字，结合 `preconditionFailure()` 函数，在程序退出的时候给出定制消息。\n\n```\nguard let configuration = loadConfiguration() else {\n    preconditionFailure(\"Configuration couldn't be loaded. \" +\n                        \"Verify that Config.JSON is valid.\")\n}\n```\n\n上面这段代码发生崩溃的时候，我们就能获得更多更有效的错误信息：\n\n> fatal error: Configuration couldn’t be loaded. Verify that Config.JSON is valid.: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17\n\n\n这样，我们现在有了一个更清晰的解决问题的办法，能够准确的知道这个问题在我们代码里的哪个未知发生的。\n\n### 引入 Require 库\n\n使用上面的 guard-let-preconditionFailure 的方案还是有一些冗长，确实让我们呃代码更难驾驭。我们也确实不希望在我们的代码里占很多篇幅去些这种代码，我们想更专注于我们的代码逻辑上。\n\n我的解决方案就是使用 `Require`。它只是简单的在可选值添加简单的 `require()` 方法，但能够使得调用的地方更简洁。用这种方法来处理上面加载 `JSON` 文件的代码就可以这样写：\n\n```\nlet configuration = loadConfiguration().require(hint: \"Verify that Config.JSON is valid\")\n```\n\n当出现异常的时候，会给出下面的错误信息：\n\n\n> fatal error: Required value was nil. Debugging hint: Verify that Config.JSON is valid: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17\n\n`Require` 的另一个优势就是它和调用 `preconditionFailure()` 方法一样也会抛异常 `NSException`，就能使得那些异常上报工具能够捕获异常发生时候的元数据。\n\n你如果想在自己代码中使用的话，[Require 现在在 Github 上开源了](https://github.com/JohnSundell/Require.git)\n\n\n## 总结\n\n所以，总结来看，在 `Swift` 语言里处理那些非可选的可选值，我有几点自己的贴心小提示给大家：\n\n1. `lazy` 属性要比非可选的可选值要更好\n2. 适当的依赖管理要比非可选的可选值要好\n3. 当你使用非可选的可选值的时候，优雅的崩溃\n\n如果有任何问题、建议或者反馈，都欢迎随时在 [Twitter](https://twitter.com/johnsundell) 上联系我，我非常乐意听到你们希望我在接下来的文章里谈论哪些主题哦。\n\n谢谢阅读。\n\n\n","slug":"Handling-non-optional-optionals-in-Swift","published":1,"updated":"2017-11-14T15:43:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftbb004879podrr69o5v","content":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/handling-non-optional-optionals-in-swift\" target=\"_blank\" rel=\"noopener\">Handling non-optional optionals in Swift</a><br>原作者 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>可选值（optionals）无可争议的是 <code>swift</code> 语言中最重要的特性之一，也是和其他语言，例如 <code>Objective-C</code> 的最大区别。通过强制处理那些有可能出现 <code>nil</code> 的地方，我们就能写出更有预测性的以及更健壮的代码。</p>\n<p>然而，有些时候可选值可能会致你于尴尬的境地，尤其是你作为开发者了解（甚至是有些猜测的成分在），有的特定变量始终是非空（non-nil）的，即使它是一个可选类型。例如，我们在一个视图控制器中处理视图的时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class TableViewController: UIViewController &#123;</span><br><span class=\"line\">    var tableView: UITableView?</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        tableView = UITableView(frame: view.bounds)</span><br><span class=\"line\">        view.addSubview(tableView!)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func viewModelDidUpdate(_ viewModel: ViewModel) &#123;</span><br><span class=\"line\">        tableView?.reloadData()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这也是对于很多 Swift 程序员争论比较激烈的地方，程度不亚于讨论 tabs 和 spaces 的用法。有的人会说：</p>\n<blockquote>\n<p>既然它是一个可选值，你就应该时刻使用 <code>if let</code> 或者 <code>guard let</code> 的方式进行解包。</p>\n</blockquote>\n<p>然而另外一些人则采用完全相反，说：</p>\n<blockquote>\n<p>既然你知道这个变量在使用的时候不会为 <code>nil</code>，使用 <code>!</code> 强制解包多好。崩溃也要比让你的程序处于一个未知状态要好吧。</p>\n</blockquote>\n<p>本质上来讲，我们这里讨论的是要不要采用防御性编程（<a href=\"https://en.wikipedia.org/wiki/Defensive_programming\" target=\"_blank\" rel=\"noopener\">defensive programming</a>）的问题。我们是试图让程序从一个未知状态恢复还是简单的放弃，然后让它崩溃掉？</p>\n<p>如果非得让我对这个问题给出一个答案的话，我更倾向于后者。未知状态真的很难追踪 bug，会导致执行很多不想执行的逻辑，采用防御性编程就会使得你的代码很难追踪，出现问题很难追踪。</p>\n<p>但是，我不太喜欢给出一个二选一的答案。相反，我们可以寻找一些技术手法，用更精妙的方式的解决上面提到的问题。</p>\n<h2 id=\"它真的可选的吗？\"><a href=\"#它真的可选的吗？\" class=\"headerlink\" title=\"它真的可选的吗？\"></a>它真的可选的吗？</h2><p>那些可选类型的，但是被代码逻辑真实需要的变量和属性，实际上是架构瑕疵的一个体现。如果在某些地方确实需要它，但是它又不在，就会使得你的代码逻辑处于未知状态，那么它就不应该是可选类型的。</p>\n<p>当然，在某些特定场景下，可选值确实很难避免（尤其是和特定的系统 API 交互的时候），那对于大部分这种情况，我们有一些技术来处理从而避免可选值。</p>\n<h3 id=\"lazy-要比非可选的可选值更好\"><a href=\"#lazy-要比非可选的可选值更好\" class=\"headerlink\" title=\"lazy 要比非可选的可选值更好\"></a>lazy 要比非可选的可选值更好</h3><p>某些属性的值需要在其父类创建之后再生成（比如视图控制器中的那些视图，应该在 <code>loadView()</code>或者 <code>viewDidLoad()</code>方法中被创建），对于这种属性要避免其可选类型的方法就是使用 <code>lazy</code> 属性。一个<code>lazy</code>属性是可以是非可选类型的，同时也不在其父类的初始化方法里被需要，它会在其第一次被获取的时候创建出来。</p>\n<p>让我们改一下上面的代码，使用 lazy 来改造 tableView 属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class TableViewController: UIViewController &#123;</span><br><span class=\"line\">    lazy var tableView = UITableView()</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        tableView.frame = view.bounds</span><br><span class=\"line\">        view.addSubview(tableView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func viewModelDidUpdate(_ viewModel: ViewModel) &#123;</span><br><span class=\"line\">        tableView.reloadData()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，没有可选值了，也不会有未知状态咯🎉</p>\n<h3 id=\"适当的依赖管理要比非可选的可选值要好\"><a href=\"#适当的依赖管理要比非可选的可选值要好\" class=\"headerlink\" title=\"适当的依赖管理要比非可选的可选值要好\"></a>适当的依赖管理要比非可选的可选值要好</h3><p>可选值类型另外一种常用的场景就是用来打破循环依赖（<a href=\"https://en.wikipedia.org/wiki/Circular_dependency\" target=\"_blank\" rel=\"noopener\">circular dependencies</a>）。有的时候，你就陷入 A 依赖 B，B 又依赖 A 的情况，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UserManager &#123;</span><br><span class=\"line\">    private weak var commentManager: CommentManager?</span><br><span class=\"line\"></span><br><span class=\"line\">    func userDidPostComment(_ comment: Comment) &#123;</span><br><span class=\"line\">        user.totalNumberOfComments += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func logOutCurrentUser() &#123;</span><br><span class=\"line\">        user.logOut()</span><br><span class=\"line\">        commentManager?.clearCache()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class CommentManager &#123;</span><br><span class=\"line\">    private weak var userManager: UserManager?</span><br><span class=\"line\"></span><br><span class=\"line\">    func composer(_ composer: CommentComposer</span><br><span class=\"line\">                  didPostComment comment: Comment) &#123;</span><br><span class=\"line\">        userManager?.userDidPostComment(comment)</span><br><span class=\"line\">        handle(comment)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func clearCache() &#123;</span><br><span class=\"line\">        cache.clear()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码，我们可以看到，<code>UserManager</code> 和 <code>CommentManager</code> 之间有一个循环依赖的问题，它们二者都没法假设自己拥有对方，但是它们都在各自的代码逻辑里依赖彼此。这里就很容易产生 bug。</p>\n<p>那要解决上面的问题，我们创建一个 <code>CommentComposer</code> 来做一个协调者，负责通知<code>UserManager</code> 和 <code>CommentManager</code>二人一个评论产生了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class CommentComposer &#123;</span><br><span class=\"line\">    private let commentManager: CommentManager</span><br><span class=\"line\">    private let userManager: UserManager</span><br><span class=\"line\">    private lazy var textView = UITextView()</span><br><span class=\"line\"></span><br><span class=\"line\">    init(commentManager: CommentManager,</span><br><span class=\"line\">         userManager: UserManager) &#123;</span><br><span class=\"line\">        self.commentManager = commentManager</span><br><span class=\"line\">        self.userManager = userManager</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func postComment() &#123;</span><br><span class=\"line\">        let comment = Comment(text: textView.text)</span><br><span class=\"line\">        commentManager.handle(comment)</span><br><span class=\"line\">        userManager.userDidPostComment(comment)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种形式，UserManager 可以强持有 CommentManager 也不产生任何依赖循环。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UserManager &#123;</span><br><span class=\"line\">    private let commentManager: CommentManager</span><br><span class=\"line\"></span><br><span class=\"line\">    init(commentManager: CommentManager) &#123;</span><br><span class=\"line\">        self.commentManager = commentManager</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func userDidPostComment(_ comment: Comment) &#123;</span><br><span class=\"line\">        user.totalNumberOfComments += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们又一次的移除了所有的可选类型，代码也更好预测了🎉。</p>\n<h3 id=\"优雅的崩溃（Crashing-gracefully）\"><a href=\"#优雅的崩溃（Crashing-gracefully）\" class=\"headerlink\" title=\"优雅的崩溃（Crashing gracefully）\"></a>优雅的崩溃（Crashing gracefully）</h3><p>通过上面几个例子，我们通过对代码做一些调整，移除了可选类型从而排除了不确定性。然而，有的时候，移除可选类型是不可能的。让我们举个例子，比如你在加载一个本地的包含针对你 App 的配置项的 JSON 文件，这个操作本身一定会存在失败的情况，我们就需要添加错误处理。</p>\n<p>继续上面这个场景，加载配置文件失败的时候继续执行代码就会使得你的 app 进入一个未知状态，在这种情况下，最好的方式让它崩溃。这样，我们会得到一个崩溃日志，希望这个问题能够在用户感知之前早早的被我们的测试人员以及 QA 处理掉。</p>\n<p>所以，我们如何崩溃。。。最简单的方式就是添加 <code>!</code> 操作符，针对这个可选值强制解包，就会在其是 nil 的时候发生崩溃：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let configuration = loadConfiguration()!</span><br></pre></td></tr></table></figure>\n<p>虽然这个方法比较简单，但是它有个比较大的问题，就是一旦这段代码崩溃，我们能得到的只有一个错误信息：</p>\n<blockquote>\n<p>fatal error: unexpectedly found nil while unwrapping an Optional value</p>\n</blockquote>\n<p>这个错误信息并不告诉我们为什么发生这个错误，在哪里发生的，给不了我们什么线索来解决它。这个时候，我们可以使用 guard 关键字，结合 <code>preconditionFailure()</code> 函数，在程序退出的时候给出定制消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">guard let configuration = loadConfiguration() else &#123;</span><br><span class=\"line\">    preconditionFailure(&quot;Configuration couldn&apos;t be loaded. &quot; +</span><br><span class=\"line\">                        &quot;Verify that Config.JSON is valid.&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码发生崩溃的时候，我们就能获得更多更有效的错误信息：</p>\n<blockquote>\n<p>fatal error: Configuration couldn’t be loaded. Verify that Config.JSON is valid.: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17</p>\n</blockquote>\n<p>这样，我们现在有了一个更清晰的解决问题的办法，能够准确的知道这个问题在我们代码里的哪个未知发生的。</p>\n<h3 id=\"引入-Require-库\"><a href=\"#引入-Require-库\" class=\"headerlink\" title=\"引入 Require 库\"></a>引入 Require 库</h3><p>使用上面的 guard-let-preconditionFailure 的方案还是有一些冗长，确实让我们呃代码更难驾驭。我们也确实不希望在我们的代码里占很多篇幅去些这种代码，我们想更专注于我们的代码逻辑上。</p>\n<p>我的解决方案就是使用 <code>Require</code>。它只是简单的在可选值添加简单的 <code>require()</code> 方法，但能够使得调用的地方更简洁。用这种方法来处理上面加载 <code>JSON</code> 文件的代码就可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let configuration = loadConfiguration().require(hint: &quot;Verify that Config.JSON is valid&quot;)</span><br></pre></td></tr></table></figure>\n<p>当出现异常的时候，会给出下面的错误信息：</p>\n<blockquote>\n<p>fatal error: Required value was nil. Debugging hint: Verify that Config.JSON is valid: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17</p>\n</blockquote>\n<p><code>Require</code> 的另一个优势就是它和调用 <code>preconditionFailure()</code> 方法一样也会抛异常 <code>NSException</code>，就能使得那些异常上报工具能够捕获异常发生时候的元数据。</p>\n<p>你如果想在自己代码中使用的话，<a href=\"https://github.com/JohnSundell/Require.git\" target=\"_blank\" rel=\"noopener\">Require 现在在 Github 上开源了</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>所以，总结来看，在 <code>Swift</code> 语言里处理那些非可选的可选值，我有几点自己的贴心小提示给大家：</p>\n<ol>\n<li><code>lazy</code> 属性要比非可选的可选值要更好</li>\n<li>适当的依赖管理要比非可选的可选值要好</li>\n<li>当你使用非可选的可选值的时候，优雅的崩溃</li>\n</ol>\n<p>如果有任何问题、建议或者反馈，都欢迎随时在 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">Twitter</a> 上联系我，我非常乐意听到你们希望我在接下来的文章里谈论哪些主题哦。</p>\n<p>谢谢阅读。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/handling-non-optional-optionals-in-swift\" target=\"_blank\" rel=\"noopener\">Handling non-optional optionals in Swift</a><br>原作者 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>可选值（optionals）无可争议的是 <code>swift</code> 语言中最重要的特性之一，也是和其他语言，例如 <code>Objective-C</code> 的最大区别。通过强制处理那些有可能出现 <code>nil</code> 的地方，我们就能写出更有预测性的以及更健壮的代码。</p>\n<p>然而，有些时候可选值可能会致你于尴尬的境地，尤其是你作为开发者了解（甚至是有些猜测的成分在），有的特定变量始终是非空（non-nil）的，即使它是一个可选类型。例如，我们在一个视图控制器中处理视图的时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class TableViewController: UIViewController &#123;</span><br><span class=\"line\">    var tableView: UITableView?</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        tableView = UITableView(frame: view.bounds)</span><br><span class=\"line\">        view.addSubview(tableView!)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func viewModelDidUpdate(_ viewModel: ViewModel) &#123;</span><br><span class=\"line\">        tableView?.reloadData()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这也是对于很多 Swift 程序员争论比较激烈的地方，程度不亚于讨论 tabs 和 spaces 的用法。有的人会说：</p>\n<blockquote>\n<p>既然它是一个可选值，你就应该时刻使用 <code>if let</code> 或者 <code>guard let</code> 的方式进行解包。</p>\n</blockquote>\n<p>然而另外一些人则采用完全相反，说：</p>\n<blockquote>\n<p>既然你知道这个变量在使用的时候不会为 <code>nil</code>，使用 <code>!</code> 强制解包多好。崩溃也要比让你的程序处于一个未知状态要好吧。</p>\n</blockquote>\n<p>本质上来讲，我们这里讨论的是要不要采用防御性编程（<a href=\"https://en.wikipedia.org/wiki/Defensive_programming\" target=\"_blank\" rel=\"noopener\">defensive programming</a>）的问题。我们是试图让程序从一个未知状态恢复还是简单的放弃，然后让它崩溃掉？</p>\n<p>如果非得让我对这个问题给出一个答案的话，我更倾向于后者。未知状态真的很难追踪 bug，会导致执行很多不想执行的逻辑，采用防御性编程就会使得你的代码很难追踪，出现问题很难追踪。</p>\n<p>但是，我不太喜欢给出一个二选一的答案。相反，我们可以寻找一些技术手法，用更精妙的方式的解决上面提到的问题。</p>\n<h2 id=\"它真的可选的吗？\"><a href=\"#它真的可选的吗？\" class=\"headerlink\" title=\"它真的可选的吗？\"></a>它真的可选的吗？</h2><p>那些可选类型的，但是被代码逻辑真实需要的变量和属性，实际上是架构瑕疵的一个体现。如果在某些地方确实需要它，但是它又不在，就会使得你的代码逻辑处于未知状态，那么它就不应该是可选类型的。</p>\n<p>当然，在某些特定场景下，可选值确实很难避免（尤其是和特定的系统 API 交互的时候），那对于大部分这种情况，我们有一些技术来处理从而避免可选值。</p>\n<h3 id=\"lazy-要比非可选的可选值更好\"><a href=\"#lazy-要比非可选的可选值更好\" class=\"headerlink\" title=\"lazy 要比非可选的可选值更好\"></a>lazy 要比非可选的可选值更好</h3><p>某些属性的值需要在其父类创建之后再生成（比如视图控制器中的那些视图，应该在 <code>loadView()</code>或者 <code>viewDidLoad()</code>方法中被创建），对于这种属性要避免其可选类型的方法就是使用 <code>lazy</code> 属性。一个<code>lazy</code>属性是可以是非可选类型的，同时也不在其父类的初始化方法里被需要，它会在其第一次被获取的时候创建出来。</p>\n<p>让我们改一下上面的代码，使用 lazy 来改造 tableView 属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class TableViewController: UIViewController &#123;</span><br><span class=\"line\">    lazy var tableView = UITableView()</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        tableView.frame = view.bounds</span><br><span class=\"line\">        view.addSubview(tableView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func viewModelDidUpdate(_ viewModel: ViewModel) &#123;</span><br><span class=\"line\">        tableView.reloadData()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，没有可选值了，也不会有未知状态咯🎉</p>\n<h3 id=\"适当的依赖管理要比非可选的可选值要好\"><a href=\"#适当的依赖管理要比非可选的可选值要好\" class=\"headerlink\" title=\"适当的依赖管理要比非可选的可选值要好\"></a>适当的依赖管理要比非可选的可选值要好</h3><p>可选值类型另外一种常用的场景就是用来打破循环依赖（<a href=\"https://en.wikipedia.org/wiki/Circular_dependency\" target=\"_blank\" rel=\"noopener\">circular dependencies</a>）。有的时候，你就陷入 A 依赖 B，B 又依赖 A 的情况，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UserManager &#123;</span><br><span class=\"line\">    private weak var commentManager: CommentManager?</span><br><span class=\"line\"></span><br><span class=\"line\">    func userDidPostComment(_ comment: Comment) &#123;</span><br><span class=\"line\">        user.totalNumberOfComments += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func logOutCurrentUser() &#123;</span><br><span class=\"line\">        user.logOut()</span><br><span class=\"line\">        commentManager?.clearCache()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class CommentManager &#123;</span><br><span class=\"line\">    private weak var userManager: UserManager?</span><br><span class=\"line\"></span><br><span class=\"line\">    func composer(_ composer: CommentComposer</span><br><span class=\"line\">                  didPostComment comment: Comment) &#123;</span><br><span class=\"line\">        userManager?.userDidPostComment(comment)</span><br><span class=\"line\">        handle(comment)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func clearCache() &#123;</span><br><span class=\"line\">        cache.clear()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码，我们可以看到，<code>UserManager</code> 和 <code>CommentManager</code> 之间有一个循环依赖的问题，它们二者都没法假设自己拥有对方，但是它们都在各自的代码逻辑里依赖彼此。这里就很容易产生 bug。</p>\n<p>那要解决上面的问题，我们创建一个 <code>CommentComposer</code> 来做一个协调者，负责通知<code>UserManager</code> 和 <code>CommentManager</code>二人一个评论产生了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class CommentComposer &#123;</span><br><span class=\"line\">    private let commentManager: CommentManager</span><br><span class=\"line\">    private let userManager: UserManager</span><br><span class=\"line\">    private lazy var textView = UITextView()</span><br><span class=\"line\"></span><br><span class=\"line\">    init(commentManager: CommentManager,</span><br><span class=\"line\">         userManager: UserManager) &#123;</span><br><span class=\"line\">        self.commentManager = commentManager</span><br><span class=\"line\">        self.userManager = userManager</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func postComment() &#123;</span><br><span class=\"line\">        let comment = Comment(text: textView.text)</span><br><span class=\"line\">        commentManager.handle(comment)</span><br><span class=\"line\">        userManager.userDidPostComment(comment)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种形式，UserManager 可以强持有 CommentManager 也不产生任何依赖循环。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UserManager &#123;</span><br><span class=\"line\">    private let commentManager: CommentManager</span><br><span class=\"line\"></span><br><span class=\"line\">    init(commentManager: CommentManager) &#123;</span><br><span class=\"line\">        self.commentManager = commentManager</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func userDidPostComment(_ comment: Comment) &#123;</span><br><span class=\"line\">        user.totalNumberOfComments += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们又一次的移除了所有的可选类型，代码也更好预测了🎉。</p>\n<h3 id=\"优雅的崩溃（Crashing-gracefully）\"><a href=\"#优雅的崩溃（Crashing-gracefully）\" class=\"headerlink\" title=\"优雅的崩溃（Crashing gracefully）\"></a>优雅的崩溃（Crashing gracefully）</h3><p>通过上面几个例子，我们通过对代码做一些调整，移除了可选类型从而排除了不确定性。然而，有的时候，移除可选类型是不可能的。让我们举个例子，比如你在加载一个本地的包含针对你 App 的配置项的 JSON 文件，这个操作本身一定会存在失败的情况，我们就需要添加错误处理。</p>\n<p>继续上面这个场景，加载配置文件失败的时候继续执行代码就会使得你的 app 进入一个未知状态，在这种情况下，最好的方式让它崩溃。这样，我们会得到一个崩溃日志，希望这个问题能够在用户感知之前早早的被我们的测试人员以及 QA 处理掉。</p>\n<p>所以，我们如何崩溃。。。最简单的方式就是添加 <code>!</code> 操作符，针对这个可选值强制解包，就会在其是 nil 的时候发生崩溃：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let configuration = loadConfiguration()!</span><br></pre></td></tr></table></figure>\n<p>虽然这个方法比较简单，但是它有个比较大的问题，就是一旦这段代码崩溃，我们能得到的只有一个错误信息：</p>\n<blockquote>\n<p>fatal error: unexpectedly found nil while unwrapping an Optional value</p>\n</blockquote>\n<p>这个错误信息并不告诉我们为什么发生这个错误，在哪里发生的，给不了我们什么线索来解决它。这个时候，我们可以使用 guard 关键字，结合 <code>preconditionFailure()</code> 函数，在程序退出的时候给出定制消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">guard let configuration = loadConfiguration() else &#123;</span><br><span class=\"line\">    preconditionFailure(&quot;Configuration couldn&apos;t be loaded. &quot; +</span><br><span class=\"line\">                        &quot;Verify that Config.JSON is valid.&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码发生崩溃的时候，我们就能获得更多更有效的错误信息：</p>\n<blockquote>\n<p>fatal error: Configuration couldn’t be loaded. Verify that Config.JSON is valid.: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17</p>\n</blockquote>\n<p>这样，我们现在有了一个更清晰的解决问题的办法，能够准确的知道这个问题在我们代码里的哪个未知发生的。</p>\n<h3 id=\"引入-Require-库\"><a href=\"#引入-Require-库\" class=\"headerlink\" title=\"引入 Require 库\"></a>引入 Require 库</h3><p>使用上面的 guard-let-preconditionFailure 的方案还是有一些冗长，确实让我们呃代码更难驾驭。我们也确实不希望在我们的代码里占很多篇幅去些这种代码，我们想更专注于我们的代码逻辑上。</p>\n<p>我的解决方案就是使用 <code>Require</code>。它只是简单的在可选值添加简单的 <code>require()</code> 方法，但能够使得调用的地方更简洁。用这种方法来处理上面加载 <code>JSON</code> 文件的代码就可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let configuration = loadConfiguration().require(hint: &quot;Verify that Config.JSON is valid&quot;)</span><br></pre></td></tr></table></figure>\n<p>当出现异常的时候，会给出下面的错误信息：</p>\n<blockquote>\n<p>fatal error: Required value was nil. Debugging hint: Verify that Config.JSON is valid: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17</p>\n</blockquote>\n<p><code>Require</code> 的另一个优势就是它和调用 <code>preconditionFailure()</code> 方法一样也会抛异常 <code>NSException</code>，就能使得那些异常上报工具能够捕获异常发生时候的元数据。</p>\n<p>你如果想在自己代码中使用的话，<a href=\"https://github.com/JohnSundell/Require.git\" target=\"_blank\" rel=\"noopener\">Require 现在在 Github 上开源了</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>所以，总结来看，在 <code>Swift</code> 语言里处理那些非可选的可选值，我有几点自己的贴心小提示给大家：</p>\n<ol>\n<li><code>lazy</code> 属性要比非可选的可选值要更好</li>\n<li>适当的依赖管理要比非可选的可选值要好</li>\n<li>当你使用非可选的可选值的时候，优雅的崩溃</li>\n</ol>\n<p>如果有任何问题、建议或者反馈，都欢迎随时在 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">Twitter</a> 上联系我，我非常乐意听到你们希望我在接下来的文章里谈论哪些主题哦。</p>\n<p>谢谢阅读。</p>\n"},{"title":"在 Swift 中使用工厂模式进行依赖注入","date":"2017-11-19T10:17:15.000Z","_content":"\n\n> 原文：[Dependency injection using factories in Swift](https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift)\n> 原作者 [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n依赖注入是一项使得代码更加可测试的关键工具。我们不需要持有某些对象，或者创建这些对象的自有依赖，或者通过单例来获取他们，而是尽可能使那些对象能够正常运转所必须的一切内容（其他对象）通过外界传入，这样做的好处在于，一方面能清晰的看得到某个对象的所有依赖项，另一方便也使得测试工作变得更为简单（因为我们可以模拟这些依赖项来捕获、验证状态以及值。）\n\n然而，尽管依赖注入确实很有用，但是当在工程中广泛使用的时候还是会有一些痛点。随着某个对象的依赖项越来越多，初始化该对象就变得越来越蹩脚。虽然使得代码可测没毛病，但是如果像下面这种每次需要这样来写初始化方法，也太不爽了。\n\n```\nclass UserManager {\n    init(dataLoader: DataLoader, database: Database, cache: Cache,\n        keychain: Keychain, tokenManager: TokenManager) {\n        // ...\n    }\n}\n```\n\n所以，这周咱们来深入了解一下某种依赖注入的技巧，使得我们的代码不失去可测性，我们也不需要再强迫自己去写一团初始化方法或者复杂的依赖管理的代码。\n\n## 传递依赖项\n\n我们遇到上面代码 demo 中的问题，最主要的原因是我们需要把这么多依赖项传递给某个对象，以便之后来使用。举例来说，我们在构建一个消息收发的 App，这里有一个 view controller 需要展示某个用户所有的消息：\n\n```\nclass MessageListViewController: UITableViewController {\n    private let loader: MessageLoader\n\n    init(loader: MessageLoader) {\n        self.loader = loader\n        super.init(nibName: nil, bundle: nil)\n    }\n\n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n\n        loader.load { [weak self]() messages in\n            self?.reloadTableView(with: messages)\n        }\n    }\n}\n```\n\n如上代码能看到，我们给 `MessageListViewController` 传入某个依赖项 `MessageLoader`，之后其被用来加载数据。这里其实并没有太大的问题，因为仅仅只有一个依赖而已。然而，我们的列表视图并不是一个死气沉沉的展示而已，某些状态下还需要们进行导航到某视图控制器的工作。\n\n具体来讲，我们想让用户在点击消息列表中某个 cell 的时候，导航到一个新的视图中。我们为这个新的视图创建一个视图控制器 `MessageViewController`，使得用户能够单独查看某条消息，并且能够回复该消息。为了该功能，我们实现了 `MessageSender` 类，当创建该类的时候，我们将前面那个新的视图控制器传递给他，代码类似下面这样：\n\n```\noverride func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    let message = messages[indexPath.row]()\n    let viewController = MessageViewController(message: message, sender: sender)\n    navigationController?.pushViewController(viewController, animated: true)\n}\n```\n\n问题来了，`MessageViewController` 需要有一个 `MessageSender` 实例，我们也需要使得 `MessageListViewController` 看到该类。一种办法就是简单的，将 sender 加入到 列表视图控制器的初始化方法中，如下所示：\n\n```\nclass MessageListViewController: UITableViewController {\n    init(loader: MessageLoader, sender: MessageSender) {\n        ...\n    }\n}\n```\n\n一旦如上面这样开始写代码，我们就逐步的进入庞大初始化方法的不归路上咯，然后使得 `MessageListViewController` 会变得越来越难用（也会让调用这很困惑，为什么一个列表视图控制器还需要关心某个发送消息的人？）。\n\n另外一个可能的解决方案（也是一个很常用的解决方案），就是把 MessageSender 做成一个单例，这样的话，我们可以很容易在任何地方取到他的值，也可以随时将单例对象注入`MessageViewController` 中：\n\n```\nlet viewController = MessageViewController(\n    message: message,\n    sender: MessageSender.shared\n)\n```\n\n然而，就如 [Avoiding singletons in Swift](https://www.swiftbysundell.com/posts/avoiding-singletons-in-swift) 这篇文章中讲的，单例这种方式会伴随一些明显的缺陷，导致我们会难以看清依赖关系，从而对整个框架都难以理解。\n\n## 工厂模式来救场\n\nWouldn't it be nice if we could just skip all of the above, and enable MessageListViewController to be completely unaware of MessageSender, and all other dependencies that any subsequent view controllers might need?\n\n如果我们能够避免掉上面这些问题，能够使得 `MessageListViewController` 完全不关心 `MessageSender`，甚至是后续的视图控制器的其他依赖，岂不是很爽？\n\n如果我们有某种形式的工厂，我们可以给其传入指定的 message，然后很方便的产出一个 `MessageViewController` 出来，类似下面这样，就能够很方便并且简洁的实现上面的理想：\n\n```\nlet viewController = factory.makeMessageViewController(for: message)\n```\n\n如 [Using the factory pattern to avoid shared state in Swift](https://www.swiftbysundell.com/posts/using-the-factory-pattern-to-avoid-shared-state-in-swift?rq=factories) 这篇文章中我们看到的，关于工厂模式中，我最喜欢的一点就是，他能够使得你将某个对象的创建和使用两者解耦，也能使得许多对象和这些对象的依赖之间有一个相对解耦的关系，进而能使得我们想重构代码或者修改某些部分的时候相对更容易一些。\n\n### 那我们该怎么做呢？\n\n首先，我们定义一个工厂协议，该协议使得我们能够在并不知道某个视图控制器的依赖项或者其初始化方法的前提下，很容易的在我们的应用中创建出我们需要的任意的视图控制器。\n\n```\nprotocol ViewControllerFactory {\n    func makeMessageListViewController() -> MessageListViewController\n    func makeMessageViewController(for message: Message) -> MessageViewController\n}\n```\n\n到这里我们还不能停止。我们同样为工厂添加一些附件的协议用来创建视图控制器的依赖，比如下面这个协议，使得我们可以为某个列表视图控制器生成一个 `MessageLoader` 出来：\n\n\n```\nprotocol MessageLoaderFactory {\n    func makeMessageLoader() -> MessageLoader\n}\n```\n\n## 单例依赖\n\n一旦我们准备好这些工厂协议之后，回到上面 `MessageListViewController` 的地方，重构这段代码，无需使用其依赖项的实例而是简单的引入一个工厂实例即可。\n\n```\nclass MessageListViewController: UITableViewController {\n    \n    \n    typealias Factory = MessageLoaderFactory & ViewControllerFactory\n\n    private let factory: Factory\n    \n    private lazy var loader = factory.makeMessageLoader()\n\n    init(factory: Factory) {\n        self.factory = factory\n        super.init(nibName: nil, bundle: nil)\n    }\n}\n```\n\n通过上面这么做，我们可以做到两点：\n\n1. 我们将一堆依赖项简化成了一个单一的工厂；\n2. `MessageListViewController` 无需再需再关心 `MessageViewController` 的依赖项了\n\n## 一个使用 Container 的例子\n\n接下来，我们该实现工厂协议了。首先，我们需要定义一个 `DependencyContainer`，该对象会包含我们应用中那些正常情况下会被直接用来作为依赖的核心工具对象们。这些不仅仅包括类似之前 `MessageSender`，也包括更加底层的业务逻辑上的类，比如我们可能会用到 `NetworkManager`。\n\n```\nclass DependencyContainer {\n    private lazy var messageSender = MessageSender(networkManager: networkManager)\n    private lazy var networkManager = NetworkManager(urlSession: .shared)\n}\n```\n\n从上面这段代码，你能看到，我们使用了懒加载属性以便能够在初始化该对象的时候能够引用相同类中的其他属性。这是设置你依赖关系的一种非常方便而且优雅的方式，你可以利用编译器帮助你避免比如[引用循环](https://en.wikipedia.org/wiki/Circular_dependency)等问题。\n\n最后，我们为 `DependencyContainer` 实现我们的工厂协议，使得我们能够将该工厂注入各种视图控制器或其他对象中：\n\n\n```\nextension DependencyContainer: ViewControllerFactory {\n    func makeMessageListViewController() -> MessageListViewController {\n        return MessageListViewController(factory: self)\n    }\n\n    func makeMessageViewController(for message: Message) -> MessageViewController {\n        return MessageViewController(message: message, sender: messageSender)\n    }\n}\n\nextension DependencyContainer: MessageLoaderFactory {\n    func makeMessageLoader() -> MessageLoader {\n        return MessageLoader(networkManager: networkManager)\n    }\n}\n```\n\n## 分布式的所有权\n\n最后一步了，我们在哪里实际储存依赖存储器，谁应该拥有它？它应该在哪里设置？这里有些比较 cool 的事情就是，由于我们把依赖容器作为对象们所需要的工厂的一种实现，而对象们强持有其工厂，所以，我们其实无需在任何地方储存该依赖容器。\n\n举例来说，如果 `MessageListViewController` 是我们应用的初始化视图控制器，我们可以很简单的创建一个 `DependencyContainer` 的实例传入：\n\n\n```\nlet container = DependencyContainer()\nlet listViewController = container.makeMessageListViewController()\n\nwindow.rootViewController = UINavigationController(\n    rootViewController: listViewController\n)\n```\n\n无需保留任何全局的变量或者在 app delegate 中使用可选属性。\n\n\n## 总结\n\n使用工厂协议和容器配置依赖注入是一种很好的方式，其可以避免需要传递大量依赖而创建很复杂的初始化方法。它可以使得依赖注入使用起来更加方便，使得你能够对自己创建的对象实际的依赖关系有很明晰的判断，也使得测试更加简单。\n\n因为我们能够把工厂定义为协议，因此可以很容易的在测试中通过给定不同测试指定版本的具体实现来模拟输出。未来我会写大量关于模拟数据以及如何在测试中充分利用依赖注入的博文。\n\n\n","source":"_posts/Dependency-injection-using-factories-in-Swift.md","raw":"---\ntitle: 在 Swift 中使用工厂模式进行依赖注入\ndate: 2017-11-19 18:17:15\ncategories: 翻译\ntags: [iOS,XCode,Swift]\n---\n\n\n> 原文：[Dependency injection using factories in Swift](https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift)\n> 原作者 [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n依赖注入是一项使得代码更加可测试的关键工具。我们不需要持有某些对象，或者创建这些对象的自有依赖，或者通过单例来获取他们，而是尽可能使那些对象能够正常运转所必须的一切内容（其他对象）通过外界传入，这样做的好处在于，一方面能清晰的看得到某个对象的所有依赖项，另一方便也使得测试工作变得更为简单（因为我们可以模拟这些依赖项来捕获、验证状态以及值。）\n\n然而，尽管依赖注入确实很有用，但是当在工程中广泛使用的时候还是会有一些痛点。随着某个对象的依赖项越来越多，初始化该对象就变得越来越蹩脚。虽然使得代码可测没毛病，但是如果像下面这种每次需要这样来写初始化方法，也太不爽了。\n\n```\nclass UserManager {\n    init(dataLoader: DataLoader, database: Database, cache: Cache,\n        keychain: Keychain, tokenManager: TokenManager) {\n        // ...\n    }\n}\n```\n\n所以，这周咱们来深入了解一下某种依赖注入的技巧，使得我们的代码不失去可测性，我们也不需要再强迫自己去写一团初始化方法或者复杂的依赖管理的代码。\n\n## 传递依赖项\n\n我们遇到上面代码 demo 中的问题，最主要的原因是我们需要把这么多依赖项传递给某个对象，以便之后来使用。举例来说，我们在构建一个消息收发的 App，这里有一个 view controller 需要展示某个用户所有的消息：\n\n```\nclass MessageListViewController: UITableViewController {\n    private let loader: MessageLoader\n\n    init(loader: MessageLoader) {\n        self.loader = loader\n        super.init(nibName: nil, bundle: nil)\n    }\n\n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n\n        loader.load { [weak self]() messages in\n            self?.reloadTableView(with: messages)\n        }\n    }\n}\n```\n\n如上代码能看到，我们给 `MessageListViewController` 传入某个依赖项 `MessageLoader`，之后其被用来加载数据。这里其实并没有太大的问题，因为仅仅只有一个依赖而已。然而，我们的列表视图并不是一个死气沉沉的展示而已，某些状态下还需要们进行导航到某视图控制器的工作。\n\n具体来讲，我们想让用户在点击消息列表中某个 cell 的时候，导航到一个新的视图中。我们为这个新的视图创建一个视图控制器 `MessageViewController`，使得用户能够单独查看某条消息，并且能够回复该消息。为了该功能，我们实现了 `MessageSender` 类，当创建该类的时候，我们将前面那个新的视图控制器传递给他，代码类似下面这样：\n\n```\noverride func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    let message = messages[indexPath.row]()\n    let viewController = MessageViewController(message: message, sender: sender)\n    navigationController?.pushViewController(viewController, animated: true)\n}\n```\n\n问题来了，`MessageViewController` 需要有一个 `MessageSender` 实例，我们也需要使得 `MessageListViewController` 看到该类。一种办法就是简单的，将 sender 加入到 列表视图控制器的初始化方法中，如下所示：\n\n```\nclass MessageListViewController: UITableViewController {\n    init(loader: MessageLoader, sender: MessageSender) {\n        ...\n    }\n}\n```\n\n一旦如上面这样开始写代码，我们就逐步的进入庞大初始化方法的不归路上咯，然后使得 `MessageListViewController` 会变得越来越难用（也会让调用这很困惑，为什么一个列表视图控制器还需要关心某个发送消息的人？）。\n\n另外一个可能的解决方案（也是一个很常用的解决方案），就是把 MessageSender 做成一个单例，这样的话，我们可以很容易在任何地方取到他的值，也可以随时将单例对象注入`MessageViewController` 中：\n\n```\nlet viewController = MessageViewController(\n    message: message,\n    sender: MessageSender.shared\n)\n```\n\n然而，就如 [Avoiding singletons in Swift](https://www.swiftbysundell.com/posts/avoiding-singletons-in-swift) 这篇文章中讲的，单例这种方式会伴随一些明显的缺陷，导致我们会难以看清依赖关系，从而对整个框架都难以理解。\n\n## 工厂模式来救场\n\nWouldn't it be nice if we could just skip all of the above, and enable MessageListViewController to be completely unaware of MessageSender, and all other dependencies that any subsequent view controllers might need?\n\n如果我们能够避免掉上面这些问题，能够使得 `MessageListViewController` 完全不关心 `MessageSender`，甚至是后续的视图控制器的其他依赖，岂不是很爽？\n\n如果我们有某种形式的工厂，我们可以给其传入指定的 message，然后很方便的产出一个 `MessageViewController` 出来，类似下面这样，就能够很方便并且简洁的实现上面的理想：\n\n```\nlet viewController = factory.makeMessageViewController(for: message)\n```\n\n如 [Using the factory pattern to avoid shared state in Swift](https://www.swiftbysundell.com/posts/using-the-factory-pattern-to-avoid-shared-state-in-swift?rq=factories) 这篇文章中我们看到的，关于工厂模式中，我最喜欢的一点就是，他能够使得你将某个对象的创建和使用两者解耦，也能使得许多对象和这些对象的依赖之间有一个相对解耦的关系，进而能使得我们想重构代码或者修改某些部分的时候相对更容易一些。\n\n### 那我们该怎么做呢？\n\n首先，我们定义一个工厂协议，该协议使得我们能够在并不知道某个视图控制器的依赖项或者其初始化方法的前提下，很容易的在我们的应用中创建出我们需要的任意的视图控制器。\n\n```\nprotocol ViewControllerFactory {\n    func makeMessageListViewController() -> MessageListViewController\n    func makeMessageViewController(for message: Message) -> MessageViewController\n}\n```\n\n到这里我们还不能停止。我们同样为工厂添加一些附件的协议用来创建视图控制器的依赖，比如下面这个协议，使得我们可以为某个列表视图控制器生成一个 `MessageLoader` 出来：\n\n\n```\nprotocol MessageLoaderFactory {\n    func makeMessageLoader() -> MessageLoader\n}\n```\n\n## 单例依赖\n\n一旦我们准备好这些工厂协议之后，回到上面 `MessageListViewController` 的地方，重构这段代码，无需使用其依赖项的实例而是简单的引入一个工厂实例即可。\n\n```\nclass MessageListViewController: UITableViewController {\n    \n    \n    typealias Factory = MessageLoaderFactory & ViewControllerFactory\n\n    private let factory: Factory\n    \n    private lazy var loader = factory.makeMessageLoader()\n\n    init(factory: Factory) {\n        self.factory = factory\n        super.init(nibName: nil, bundle: nil)\n    }\n}\n```\n\n通过上面这么做，我们可以做到两点：\n\n1. 我们将一堆依赖项简化成了一个单一的工厂；\n2. `MessageListViewController` 无需再需再关心 `MessageViewController` 的依赖项了\n\n## 一个使用 Container 的例子\n\n接下来，我们该实现工厂协议了。首先，我们需要定义一个 `DependencyContainer`，该对象会包含我们应用中那些正常情况下会被直接用来作为依赖的核心工具对象们。这些不仅仅包括类似之前 `MessageSender`，也包括更加底层的业务逻辑上的类，比如我们可能会用到 `NetworkManager`。\n\n```\nclass DependencyContainer {\n    private lazy var messageSender = MessageSender(networkManager: networkManager)\n    private lazy var networkManager = NetworkManager(urlSession: .shared)\n}\n```\n\n从上面这段代码，你能看到，我们使用了懒加载属性以便能够在初始化该对象的时候能够引用相同类中的其他属性。这是设置你依赖关系的一种非常方便而且优雅的方式，你可以利用编译器帮助你避免比如[引用循环](https://en.wikipedia.org/wiki/Circular_dependency)等问题。\n\n最后，我们为 `DependencyContainer` 实现我们的工厂协议，使得我们能够将该工厂注入各种视图控制器或其他对象中：\n\n\n```\nextension DependencyContainer: ViewControllerFactory {\n    func makeMessageListViewController() -> MessageListViewController {\n        return MessageListViewController(factory: self)\n    }\n\n    func makeMessageViewController(for message: Message) -> MessageViewController {\n        return MessageViewController(message: message, sender: messageSender)\n    }\n}\n\nextension DependencyContainer: MessageLoaderFactory {\n    func makeMessageLoader() -> MessageLoader {\n        return MessageLoader(networkManager: networkManager)\n    }\n}\n```\n\n## 分布式的所有权\n\n最后一步了，我们在哪里实际储存依赖存储器，谁应该拥有它？它应该在哪里设置？这里有些比较 cool 的事情就是，由于我们把依赖容器作为对象们所需要的工厂的一种实现，而对象们强持有其工厂，所以，我们其实无需在任何地方储存该依赖容器。\n\n举例来说，如果 `MessageListViewController` 是我们应用的初始化视图控制器，我们可以很简单的创建一个 `DependencyContainer` 的实例传入：\n\n\n```\nlet container = DependencyContainer()\nlet listViewController = container.makeMessageListViewController()\n\nwindow.rootViewController = UINavigationController(\n    rootViewController: listViewController\n)\n```\n\n无需保留任何全局的变量或者在 app delegate 中使用可选属性。\n\n\n## 总结\n\n使用工厂协议和容器配置依赖注入是一种很好的方式，其可以避免需要传递大量依赖而创建很复杂的初始化方法。它可以使得依赖注入使用起来更加方便，使得你能够对自己创建的对象实际的依赖关系有很明晰的判断，也使得测试更加简单。\n\n因为我们能够把工厂定义为协议，因此可以很容易的在测试中通过给定不同测试指定版本的具体实现来模拟输出。未来我会写大量关于模拟数据以及如何在测试中充分利用依赖注入的博文。\n\n\n","slug":"Dependency-injection-using-factories-in-Swift","published":1,"updated":"2017-12-23T15:45:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftbe004b79ponhhil6l3","content":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift\" target=\"_blank\" rel=\"noopener\">Dependency injection using factories in Swift</a><br>原作者 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>依赖注入是一项使得代码更加可测试的关键工具。我们不需要持有某些对象，或者创建这些对象的自有依赖，或者通过单例来获取他们，而是尽可能使那些对象能够正常运转所必须的一切内容（其他对象）通过外界传入，这样做的好处在于，一方面能清晰的看得到某个对象的所有依赖项，另一方便也使得测试工作变得更为简单（因为我们可以模拟这些依赖项来捕获、验证状态以及值。）</p>\n<p>然而，尽管依赖注入确实很有用，但是当在工程中广泛使用的时候还是会有一些痛点。随着某个对象的依赖项越来越多，初始化该对象就变得越来越蹩脚。虽然使得代码可测没毛病，但是如果像下面这种每次需要这样来写初始化方法，也太不爽了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UserManager &#123;</span><br><span class=\"line\">    init(dataLoader: DataLoader, database: Database, cache: Cache,</span><br><span class=\"line\">        keychain: Keychain, tokenManager: TokenManager) &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，这周咱们来深入了解一下某种依赖注入的技巧，使得我们的代码不失去可测性，我们也不需要再强迫自己去写一团初始化方法或者复杂的依赖管理的代码。</p>\n<h2 id=\"传递依赖项\"><a href=\"#传递依赖项\" class=\"headerlink\" title=\"传递依赖项\"></a>传递依赖项</h2><p>我们遇到上面代码 demo 中的问题，最主要的原因是我们需要把这么多依赖项传递给某个对象，以便之后来使用。举例来说，我们在构建一个消息收发的 App，这里有一个 view controller 需要展示某个用户所有的消息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MessageListViewController: UITableViewController &#123;</span><br><span class=\"line\">    private let loader: MessageLoader</span><br><span class=\"line\"></span><br><span class=\"line\">    init(loader: MessageLoader) &#123;</span><br><span class=\"line\">        self.loader = loader</span><br><span class=\"line\">        super.init(nibName: nil, bundle: nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class=\"line\">        super.viewWillAppear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">        loader.load &#123; [weak self]() messages in</span><br><span class=\"line\">            self?.reloadTableView(with: messages)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码能看到，我们给 <code>MessageListViewController</code> 传入某个依赖项 <code>MessageLoader</code>，之后其被用来加载数据。这里其实并没有太大的问题，因为仅仅只有一个依赖而已。然而，我们的列表视图并不是一个死气沉沉的展示而已，某些状态下还需要们进行导航到某视图控制器的工作。</p>\n<p>具体来讲，我们想让用户在点击消息列表中某个 cell 的时候，导航到一个新的视图中。我们为这个新的视图创建一个视图控制器 <code>MessageViewController</code>，使得用户能够单独查看某条消息，并且能够回复该消息。为了该功能，我们实现了 <code>MessageSender</code> 类，当创建该类的时候，我们将前面那个新的视图控制器传递给他，代码类似下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;</span><br><span class=\"line\">    let message = messages[indexPath.row]()</span><br><span class=\"line\">    let viewController = MessageViewController(message: message, sender: sender)</span><br><span class=\"line\">    navigationController?.pushViewController(viewController, animated: true)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了，<code>MessageViewController</code> 需要有一个 <code>MessageSender</code> 实例，我们也需要使得 <code>MessageListViewController</code> 看到该类。一种办法就是简单的，将 sender 加入到 列表视图控制器的初始化方法中，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MessageListViewController: UITableViewController &#123;</span><br><span class=\"line\">    init(loader: MessageLoader, sender: MessageSender) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦如上面这样开始写代码，我们就逐步的进入庞大初始化方法的不归路上咯，然后使得 <code>MessageListViewController</code> 会变得越来越难用（也会让调用这很困惑，为什么一个列表视图控制器还需要关心某个发送消息的人？）。</p>\n<p>另外一个可能的解决方案（也是一个很常用的解决方案），就是把 MessageSender 做成一个单例，这样的话，我们可以很容易在任何地方取到他的值，也可以随时将单例对象注入<code>MessageViewController</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let viewController = MessageViewController(</span><br><span class=\"line\">    message: message,</span><br><span class=\"line\">    sender: MessageSender.shared</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>然而，就如 <a href=\"https://www.swiftbysundell.com/posts/avoiding-singletons-in-swift\" target=\"_blank\" rel=\"noopener\">Avoiding singletons in Swift</a> 这篇文章中讲的，单例这种方式会伴随一些明显的缺陷，导致我们会难以看清依赖关系，从而对整个框架都难以理解。</p>\n<h2 id=\"工厂模式来救场\"><a href=\"#工厂模式来救场\" class=\"headerlink\" title=\"工厂模式来救场\"></a>工厂模式来救场</h2><p>Wouldn’t it be nice if we could just skip all of the above, and enable MessageListViewController to be completely unaware of MessageSender, and all other dependencies that any subsequent view controllers might need?</p>\n<p>如果我们能够避免掉上面这些问题，能够使得 <code>MessageListViewController</code> 完全不关心 <code>MessageSender</code>，甚至是后续的视图控制器的其他依赖，岂不是很爽？</p>\n<p>如果我们有某种形式的工厂，我们可以给其传入指定的 message，然后很方便的产出一个 <code>MessageViewController</code> 出来，类似下面这样，就能够很方便并且简洁的实现上面的理想：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let viewController = factory.makeMessageViewController(for: message)</span><br></pre></td></tr></table></figure>\n<p>如 <a href=\"https://www.swiftbysundell.com/posts/using-the-factory-pattern-to-avoid-shared-state-in-swift?rq=factories\" target=\"_blank\" rel=\"noopener\">Using the factory pattern to avoid shared state in Swift</a> 这篇文章中我们看到的，关于工厂模式中，我最喜欢的一点就是，他能够使得你将某个对象的创建和使用两者解耦，也能使得许多对象和这些对象的依赖之间有一个相对解耦的关系，进而能使得我们想重构代码或者修改某些部分的时候相对更容易一些。</p>\n<h3 id=\"那我们该怎么做呢？\"><a href=\"#那我们该怎么做呢？\" class=\"headerlink\" title=\"那我们该怎么做呢？\"></a>那我们该怎么做呢？</h3><p>首先，我们定义一个工厂协议，该协议使得我们能够在并不知道某个视图控制器的依赖项或者其初始化方法的前提下，很容易的在我们的应用中创建出我们需要的任意的视图控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol ViewControllerFactory &#123;</span><br><span class=\"line\">    func makeMessageListViewController() -&gt; MessageListViewController</span><br><span class=\"line\">    func makeMessageViewController(for message: Message) -&gt; MessageViewController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里我们还不能停止。我们同样为工厂添加一些附件的协议用来创建视图控制器的依赖，比如下面这个协议，使得我们可以为某个列表视图控制器生成一个 <code>MessageLoader</code> 出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol MessageLoaderFactory &#123;</span><br><span class=\"line\">    func makeMessageLoader() -&gt; MessageLoader</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单例依赖\"><a href=\"#单例依赖\" class=\"headerlink\" title=\"单例依赖\"></a>单例依赖</h2><p>一旦我们准备好这些工厂协议之后，回到上面 <code>MessageListViewController</code> 的地方，重构这段代码，无需使用其依赖项的实例而是简单的引入一个工厂实例即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MessageListViewController: UITableViewController &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    typealias Factory = MessageLoaderFactory &amp; ViewControllerFactory</span><br><span class=\"line\"></span><br><span class=\"line\">    private let factory: Factory</span><br><span class=\"line\">    </span><br><span class=\"line\">    private lazy var loader = factory.makeMessageLoader()</span><br><span class=\"line\"></span><br><span class=\"line\">    init(factory: Factory) &#123;</span><br><span class=\"line\">        self.factory = factory</span><br><span class=\"line\">        super.init(nibName: nil, bundle: nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面这么做，我们可以做到两点：</p>\n<ol>\n<li>我们将一堆依赖项简化成了一个单一的工厂；</li>\n<li><code>MessageListViewController</code> 无需再需再关心 <code>MessageViewController</code> 的依赖项了</li>\n</ol>\n<h2 id=\"一个使用-Container-的例子\"><a href=\"#一个使用-Container-的例子\" class=\"headerlink\" title=\"一个使用 Container 的例子\"></a>一个使用 Container 的例子</h2><p>接下来，我们该实现工厂协议了。首先，我们需要定义一个 <code>DependencyContainer</code>，该对象会包含我们应用中那些正常情况下会被直接用来作为依赖的核心工具对象们。这些不仅仅包括类似之前 <code>MessageSender</code>，也包括更加底层的业务逻辑上的类，比如我们可能会用到 <code>NetworkManager</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class DependencyContainer &#123;</span><br><span class=\"line\">    private lazy var messageSender = MessageSender(networkManager: networkManager)</span><br><span class=\"line\">    private lazy var networkManager = NetworkManager(urlSession: .shared)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面这段代码，你能看到，我们使用了懒加载属性以便能够在初始化该对象的时候能够引用相同类中的其他属性。这是设置你依赖关系的一种非常方便而且优雅的方式，你可以利用编译器帮助你避免比如<a href=\"https://en.wikipedia.org/wiki/Circular_dependency\" target=\"_blank\" rel=\"noopener\">引用循环</a>等问题。</p>\n<p>最后，我们为 <code>DependencyContainer</code> 实现我们的工厂协议，使得我们能够将该工厂注入各种视图控制器或其他对象中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extension DependencyContainer: ViewControllerFactory &#123;</span><br><span class=\"line\">    func makeMessageListViewController() -&gt; MessageListViewController &#123;</span><br><span class=\"line\">        return MessageListViewController(factory: self)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func makeMessageViewController(for message: Message) -&gt; MessageViewController &#123;</span><br><span class=\"line\">        return MessageViewController(message: message, sender: messageSender)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">extension DependencyContainer: MessageLoaderFactory &#123;</span><br><span class=\"line\">    func makeMessageLoader() -&gt; MessageLoader &#123;</span><br><span class=\"line\">        return MessageLoader(networkManager: networkManager)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分布式的所有权\"><a href=\"#分布式的所有权\" class=\"headerlink\" title=\"分布式的所有权\"></a>分布式的所有权</h2><p>最后一步了，我们在哪里实际储存依赖存储器，谁应该拥有它？它应该在哪里设置？这里有些比较 cool 的事情就是，由于我们把依赖容器作为对象们所需要的工厂的一种实现，而对象们强持有其工厂，所以，我们其实无需在任何地方储存该依赖容器。</p>\n<p>举例来说，如果 <code>MessageListViewController</code> 是我们应用的初始化视图控制器，我们可以很简单的创建一个 <code>DependencyContainer</code> 的实例传入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let container = DependencyContainer()</span><br><span class=\"line\">let listViewController = container.makeMessageListViewController()</span><br><span class=\"line\"></span><br><span class=\"line\">window.rootViewController = UINavigationController(</span><br><span class=\"line\">    rootViewController: listViewController</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>无需保留任何全局的变量或者在 app delegate 中使用可选属性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用工厂协议和容器配置依赖注入是一种很好的方式，其可以避免需要传递大量依赖而创建很复杂的初始化方法。它可以使得依赖注入使用起来更加方便，使得你能够对自己创建的对象实际的依赖关系有很明晰的判断，也使得测试更加简单。</p>\n<p>因为我们能够把工厂定义为协议，因此可以很容易的在测试中通过给定不同测试指定版本的具体实现来模拟输出。未来我会写大量关于模拟数据以及如何在测试中充分利用依赖注入的博文。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift\" target=\"_blank\" rel=\"noopener\">Dependency injection using factories in Swift</a><br>原作者 <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>依赖注入是一项使得代码更加可测试的关键工具。我们不需要持有某些对象，或者创建这些对象的自有依赖，或者通过单例来获取他们，而是尽可能使那些对象能够正常运转所必须的一切内容（其他对象）通过外界传入，这样做的好处在于，一方面能清晰的看得到某个对象的所有依赖项，另一方便也使得测试工作变得更为简单（因为我们可以模拟这些依赖项来捕获、验证状态以及值。）</p>\n<p>然而，尽管依赖注入确实很有用，但是当在工程中广泛使用的时候还是会有一些痛点。随着某个对象的依赖项越来越多，初始化该对象就变得越来越蹩脚。虽然使得代码可测没毛病，但是如果像下面这种每次需要这样来写初始化方法，也太不爽了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class UserManager &#123;</span><br><span class=\"line\">    init(dataLoader: DataLoader, database: Database, cache: Cache,</span><br><span class=\"line\">        keychain: Keychain, tokenManager: TokenManager) &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，这周咱们来深入了解一下某种依赖注入的技巧，使得我们的代码不失去可测性，我们也不需要再强迫自己去写一团初始化方法或者复杂的依赖管理的代码。</p>\n<h2 id=\"传递依赖项\"><a href=\"#传递依赖项\" class=\"headerlink\" title=\"传递依赖项\"></a>传递依赖项</h2><p>我们遇到上面代码 demo 中的问题，最主要的原因是我们需要把这么多依赖项传递给某个对象，以便之后来使用。举例来说，我们在构建一个消息收发的 App，这里有一个 view controller 需要展示某个用户所有的消息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MessageListViewController: UITableViewController &#123;</span><br><span class=\"line\">    private let loader: MessageLoader</span><br><span class=\"line\"></span><br><span class=\"line\">    init(loader: MessageLoader) &#123;</span><br><span class=\"line\">        self.loader = loader</span><br><span class=\"line\">        super.init(nibName: nil, bundle: nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class=\"line\">        super.viewWillAppear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">        loader.load &#123; [weak self]() messages in</span><br><span class=\"line\">            self?.reloadTableView(with: messages)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码能看到，我们给 <code>MessageListViewController</code> 传入某个依赖项 <code>MessageLoader</code>，之后其被用来加载数据。这里其实并没有太大的问题，因为仅仅只有一个依赖而已。然而，我们的列表视图并不是一个死气沉沉的展示而已，某些状态下还需要们进行导航到某视图控制器的工作。</p>\n<p>具体来讲，我们想让用户在点击消息列表中某个 cell 的时候，导航到一个新的视图中。我们为这个新的视图创建一个视图控制器 <code>MessageViewController</code>，使得用户能够单独查看某条消息，并且能够回复该消息。为了该功能，我们实现了 <code>MessageSender</code> 类，当创建该类的时候，我们将前面那个新的视图控制器传递给他，代码类似下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;</span><br><span class=\"line\">    let message = messages[indexPath.row]()</span><br><span class=\"line\">    let viewController = MessageViewController(message: message, sender: sender)</span><br><span class=\"line\">    navigationController?.pushViewController(viewController, animated: true)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题来了，<code>MessageViewController</code> 需要有一个 <code>MessageSender</code> 实例，我们也需要使得 <code>MessageListViewController</code> 看到该类。一种办法就是简单的，将 sender 加入到 列表视图控制器的初始化方法中，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MessageListViewController: UITableViewController &#123;</span><br><span class=\"line\">    init(loader: MessageLoader, sender: MessageSender) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦如上面这样开始写代码，我们就逐步的进入庞大初始化方法的不归路上咯，然后使得 <code>MessageListViewController</code> 会变得越来越难用（也会让调用这很困惑，为什么一个列表视图控制器还需要关心某个发送消息的人？）。</p>\n<p>另外一个可能的解决方案（也是一个很常用的解决方案），就是把 MessageSender 做成一个单例，这样的话，我们可以很容易在任何地方取到他的值，也可以随时将单例对象注入<code>MessageViewController</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let viewController = MessageViewController(</span><br><span class=\"line\">    message: message,</span><br><span class=\"line\">    sender: MessageSender.shared</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>然而，就如 <a href=\"https://www.swiftbysundell.com/posts/avoiding-singletons-in-swift\" target=\"_blank\" rel=\"noopener\">Avoiding singletons in Swift</a> 这篇文章中讲的，单例这种方式会伴随一些明显的缺陷，导致我们会难以看清依赖关系，从而对整个框架都难以理解。</p>\n<h2 id=\"工厂模式来救场\"><a href=\"#工厂模式来救场\" class=\"headerlink\" title=\"工厂模式来救场\"></a>工厂模式来救场</h2><p>Wouldn’t it be nice if we could just skip all of the above, and enable MessageListViewController to be completely unaware of MessageSender, and all other dependencies that any subsequent view controllers might need?</p>\n<p>如果我们能够避免掉上面这些问题，能够使得 <code>MessageListViewController</code> 完全不关心 <code>MessageSender</code>，甚至是后续的视图控制器的其他依赖，岂不是很爽？</p>\n<p>如果我们有某种形式的工厂，我们可以给其传入指定的 message，然后很方便的产出一个 <code>MessageViewController</code> 出来，类似下面这样，就能够很方便并且简洁的实现上面的理想：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let viewController = factory.makeMessageViewController(for: message)</span><br></pre></td></tr></table></figure>\n<p>如 <a href=\"https://www.swiftbysundell.com/posts/using-the-factory-pattern-to-avoid-shared-state-in-swift?rq=factories\" target=\"_blank\" rel=\"noopener\">Using the factory pattern to avoid shared state in Swift</a> 这篇文章中我们看到的，关于工厂模式中，我最喜欢的一点就是，他能够使得你将某个对象的创建和使用两者解耦，也能使得许多对象和这些对象的依赖之间有一个相对解耦的关系，进而能使得我们想重构代码或者修改某些部分的时候相对更容易一些。</p>\n<h3 id=\"那我们该怎么做呢？\"><a href=\"#那我们该怎么做呢？\" class=\"headerlink\" title=\"那我们该怎么做呢？\"></a>那我们该怎么做呢？</h3><p>首先，我们定义一个工厂协议，该协议使得我们能够在并不知道某个视图控制器的依赖项或者其初始化方法的前提下，很容易的在我们的应用中创建出我们需要的任意的视图控制器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol ViewControllerFactory &#123;</span><br><span class=\"line\">    func makeMessageListViewController() -&gt; MessageListViewController</span><br><span class=\"line\">    func makeMessageViewController(for message: Message) -&gt; MessageViewController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里我们还不能停止。我们同样为工厂添加一些附件的协议用来创建视图控制器的依赖，比如下面这个协议，使得我们可以为某个列表视图控制器生成一个 <code>MessageLoader</code> 出来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protocol MessageLoaderFactory &#123;</span><br><span class=\"line\">    func makeMessageLoader() -&gt; MessageLoader</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单例依赖\"><a href=\"#单例依赖\" class=\"headerlink\" title=\"单例依赖\"></a>单例依赖</h2><p>一旦我们准备好这些工厂协议之后，回到上面 <code>MessageListViewController</code> 的地方，重构这段代码，无需使用其依赖项的实例而是简单的引入一个工厂实例即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MessageListViewController: UITableViewController &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    typealias Factory = MessageLoaderFactory &amp; ViewControllerFactory</span><br><span class=\"line\"></span><br><span class=\"line\">    private let factory: Factory</span><br><span class=\"line\">    </span><br><span class=\"line\">    private lazy var loader = factory.makeMessageLoader()</span><br><span class=\"line\"></span><br><span class=\"line\">    init(factory: Factory) &#123;</span><br><span class=\"line\">        self.factory = factory</span><br><span class=\"line\">        super.init(nibName: nil, bundle: nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面这么做，我们可以做到两点：</p>\n<ol>\n<li>我们将一堆依赖项简化成了一个单一的工厂；</li>\n<li><code>MessageListViewController</code> 无需再需再关心 <code>MessageViewController</code> 的依赖项了</li>\n</ol>\n<h2 id=\"一个使用-Container-的例子\"><a href=\"#一个使用-Container-的例子\" class=\"headerlink\" title=\"一个使用 Container 的例子\"></a>一个使用 Container 的例子</h2><p>接下来，我们该实现工厂协议了。首先，我们需要定义一个 <code>DependencyContainer</code>，该对象会包含我们应用中那些正常情况下会被直接用来作为依赖的核心工具对象们。这些不仅仅包括类似之前 <code>MessageSender</code>，也包括更加底层的业务逻辑上的类，比如我们可能会用到 <code>NetworkManager</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class DependencyContainer &#123;</span><br><span class=\"line\">    private lazy var messageSender = MessageSender(networkManager: networkManager)</span><br><span class=\"line\">    private lazy var networkManager = NetworkManager(urlSession: .shared)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面这段代码，你能看到，我们使用了懒加载属性以便能够在初始化该对象的时候能够引用相同类中的其他属性。这是设置你依赖关系的一种非常方便而且优雅的方式，你可以利用编译器帮助你避免比如<a href=\"https://en.wikipedia.org/wiki/Circular_dependency\" target=\"_blank\" rel=\"noopener\">引用循环</a>等问题。</p>\n<p>最后，我们为 <code>DependencyContainer</code> 实现我们的工厂协议，使得我们能够将该工厂注入各种视图控制器或其他对象中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extension DependencyContainer: ViewControllerFactory &#123;</span><br><span class=\"line\">    func makeMessageListViewController() -&gt; MessageListViewController &#123;</span><br><span class=\"line\">        return MessageListViewController(factory: self)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    func makeMessageViewController(for message: Message) -&gt; MessageViewController &#123;</span><br><span class=\"line\">        return MessageViewController(message: message, sender: messageSender)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">extension DependencyContainer: MessageLoaderFactory &#123;</span><br><span class=\"line\">    func makeMessageLoader() -&gt; MessageLoader &#123;</span><br><span class=\"line\">        return MessageLoader(networkManager: networkManager)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分布式的所有权\"><a href=\"#分布式的所有权\" class=\"headerlink\" title=\"分布式的所有权\"></a>分布式的所有权</h2><p>最后一步了，我们在哪里实际储存依赖存储器，谁应该拥有它？它应该在哪里设置？这里有些比较 cool 的事情就是，由于我们把依赖容器作为对象们所需要的工厂的一种实现，而对象们强持有其工厂，所以，我们其实无需在任何地方储存该依赖容器。</p>\n<p>举例来说，如果 <code>MessageListViewController</code> 是我们应用的初始化视图控制器，我们可以很简单的创建一个 <code>DependencyContainer</code> 的实例传入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let container = DependencyContainer()</span><br><span class=\"line\">let listViewController = container.makeMessageListViewController()</span><br><span class=\"line\"></span><br><span class=\"line\">window.rootViewController = UINavigationController(</span><br><span class=\"line\">    rootViewController: listViewController</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>无需保留任何全局的变量或者在 app delegate 中使用可选属性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用工厂协议和容器配置依赖注入是一种很好的方式，其可以避免需要传递大量依赖而创建很复杂的初始化方法。它可以使得依赖注入使用起来更加方便，使得你能够对自己创建的对象实际的依赖关系有很明晰的判断，也使得测试更加简单。</p>\n<p>因为我们能够把工厂定义为协议，因此可以很容易的在测试中通过给定不同测试指定版本的具体实现来模拟输出。未来我会写大量关于模拟数据以及如何在测试中充分利用依赖注入的博文。</p>\n"},{"title":"我们是如何创建iOS版的Guillotine菜单动画的","date":"2015-09-01T07:52:07.000Z","_content":"\n> 原文：[How We Created Guillotine Menu Animation for iOS](https://yalantis.com/blog/how-we-created-guillotine-menu-animation/)\n> 翻译：[@这个昵称有点萌](http://weibo.com/hc2feifei)\n\n\n你是否曾经有过这样的疑问？为什么app中几乎是清一色的**侧**边栏（sidebar），为什么不把它做成**top**Bar或者**bottom**Bar，甚至**corner**Bar呢？\n\n本文将要谈到的就是当前导航条动画的一个新趋势。\n\n<!-- more -->\n\n动画很有趣，但更重要的是能发挥很大的作用，它们可以改变你思考问题的方式，使得你的产品更好用并提升的app整体的用户体验。接下来我们将要展示的是设计师**Vitaly Rubtsov**的一个非常棒的点子：\n\n“每个设计师都有那么一刻感到无聊。因为几乎所有（对动画）的完善修补、裁剪以及规格设定都给他们留下了很少发挥想象的余地。而每当这些时候，我就会驱使自己打开Adobe After Effects软件然后创作一些比较有趣的东西。\n\n当我开始想我要创建一个什么东西的时候，我突然有个想法，通常侧边栏都从屏幕左侧划出，同时将所有的内容都移动到右侧位置。这种传统侧边栏的实现方式太过无聊了。那如果我们将侧边栏变成上边栏会怎么样呢？它从页面的上方掉落然后以一种特别的方式呈现，听起来很棒不是吗？“\n\n**Vitaly**设计的topBar动画由我们的iOS开发工程师**Maksym Lazebnyi**使用`swift`语言实现，并且开发者给了它一个很有趣的名字—— **Guillotine Menu**。\n\n![Guillotine Menu Animation](https://yalantis.com/media/content/ckeditor/2015/04/14/activitytopmenu_vKfwzSX.gif)\n\n\n----------\n\n### 我们是如何开发Guillotine Menu的？   \n**by Makssym Lazebnyi** \n\n实际上，我们的iOS团队见到过很多实现这种动画效果的方法。我们选择了其中一种方式实现，这种方式允许开发者在Storyboard中以任何方式自定义菜单。\n\n为了实现我们的转场动画（transitioning animation），我们创建了一个UIStoryboardSegue的子类和一个自定义动画管理器（custom animation controller）。基本上这就是你实现该动画所需要做的全部工作，除非你想让它更炫酷。当然我们也确实想这样做，因此还创建了一些辅助的类。\n\n整体上，你需要三个类以及一个`UIView`的扩展类来创建这个动画，如下所示：\n\n- `GuillotineMenuSegue`.  该类是继承自`UIStoryboardSegue`类。我们使用它来模态显示菜单，并实现由 `GuillotineMenuTransitionAnimation`类控制的呈现动画。 `GuillotineMenuSegue`允许你为菜单添加透明度，当然本文并没有做这个工作。\n\n- `GuillotineMenuTransitionAnimation`.  该类是为了自定义呈现  `GuillotineMenuViewController` 类中视图的动画所用。\n\n- `GuillotineMenuViewController`. 该类是一个UIViewController的子类，存放菜单视图所用。\n\n除此之外，我们还为UIView添加了扩展方法以便能为子视图添加约束来更好的适应父视图。\n   \n接下来，我们逐一对每一个类进行阐述。\n     \n#### GuillotineMenuSegue\n这个类中没有什么特别的地方，我只提及一些关键点。\n\n在该类重载的init方法中，我们检查目标视图控制器（destination view controller）是否遵守`GuillotineAnimationProtocol` 协议（该协议我们后面会讲到）。在重载的perform方法中我们将self设置成一个过渡动画的代理。\n     \n在代理方法 `animationControllerForPresentedController` 中我们使用关联对象将`GuillotineMenuSegue`的实例对象（**self**）关联到具体的将要呈现的视图控制器中，这样当menu view controller呈现在屏幕上的时候，segue实例不会被销毁。（译者注：代码如下）\n\n``` objc\n- (id <UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source\n{\n\t// 将segue示例self关联到将要呈现的试图控制器presented中，这样确保presented生命周期内segue实例不会被释放\n    objc_setAssociatedObject(presented, &key, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    \n    return [[GuillotineTransitionAnimation alloc] initWithMode:AnimationModePresentation];\n}\n```\n     \n#### GuillotineMenuTransitionAnimation\n所有的动画处理逻辑都在这个类中实现。\n\n起初我们考虑使用 `animateWithDuration usingSpringWithDamping & initialSprintVelocity`方法，但是当我们认真考虑这个动画之后我们改变了主意。我们需要实现的菜单动画中，当菜单从上方掉落之后，需要和父视图的左侧边界发生碰撞，产生碰撞效果。而上面方法中的回弹效果会穿过左边界（spring through the border of the superview），因此我们放弃了这个实现方式，转而采用了`UIDynamicAnimator`。\n\n为了实现我们的动画，`GuillotineMenuTransitionAnimation`类必须遵从 `UIViewControllerAnimatedTransitioning` 协议，该协议中有两个代理方法：\n\n- transitionDuration  动画的过渡时间对我们影响不是太多，因此你可以返回任意的时间值。 \n\n- animationDurtation 当菜单开启和关闭均会调用该方法\n\n\n----------\n\n###我们如何计算动画的位置信息？\n     \n我们需要了解动画中每一刻的精确位置。`GuillotineMenuTransitionAnimation`类需要`GuillotineMenuViewController`提供menu button中心的坐标来做为旋转动画的锚点（anchorPoint）。另外还需要`GuillotineMenuViewController`提供一些其他属性，因此我们创建一个协议`GuillotineMenuViewController`，视图控制器通过遵守该协议返回我们所需要的几个属性。\n代码如下：\n    \n``` Swift\n @objc protocol GuillotineAnimationProtocol: NSObjectProtocol {\n      func navigationBarHeight() ->CGFloat\n      func anchorPoint() ->CGPoint\n      func hostTitle() ->NSString\n }\n```\n\n译者注：Objective-C版本代码如下：\n\n``` objc\n@protocol GuillotineAnimationProtocol <NSObject>\n\t- (CGFloat) navigationBarHeight;\n\t- (CGPoint) anchorPoint;\n\t- (NSString*) hostTitle;\n@end\n```\n\n这三个方法的意义如下：\n- **navigationBarHeight**  `GuillotineMenuViewController`开始显示动画的时候需要旋转90度，同时覆盖导航条（navigation bar）。我们需要将`GuillotineMenuViewController`中的视图位置设置成`CGPoint(0，navigationBarHeight)`；\n\n- **anchorPoint** 提供我们动画的旋转轴心，这里是`GuillotineMenuViewController`中的menu button的中心位置；\n\n- **hostTitle** 用来询问`GuillotineMenuViewController`获得主视图控制器的标题。  \n\n----------\n\n### 我们如何实现菜单视图的掉落以及旋转？\n\n为了实现掉落以及旋转的动画，我们使用`UIDynamicAnimator`并为其添加四种动力行为：\n （译者注：实际上实现UIKit动力学中的推动力、吸附、碰撞以及辅助行为，详见[UIKit动力学](http://www.coderyi.com/archives/426)）\n- `UIPushBehavior`  为view添加一个拖拽的力，当我们需要呈现显示动画的时候，施加到view的底部，当我们需要呈现关闭菜单的动画时，施加到view的顶部；\n\n- `UIAttachmentBehavior` 相当于一个钉子在menu button的中心点将整个view固定住。\n\n- `UICollisionBehavior`  我们为view的父视图（**superview**）添加了一个边界，从视图中心位置到左下角位置的长度。用以实现`GuillotineMenuViewController`在掉落路径的末端模拟碰撞效果（译者注：当菜单视图关闭而回弹到上方时，同样需要添加boundary，不过此时是在顶部，屏幕水平方向菜单视图的中心位置到其右下角位置）；\n\n- `UIDynamicItemBehavior` 实现菜单碰撞左边界之后的回弹效果。\n\n基本上，我们的动画是这样，首先使用`CGAffineTransformRotate`将`GuillotineMenuViewController`的view旋转正向90度，设置该view的边框位置为`CGPoint(0, navigationBarHeight)`。然后，我们将该view添加以上每一种需要使用的`UIDynamicBehavior`（UIPushBehavior、UIAttachmentBehavior、UICollisionBehavior以及UIDynamicItemBehavior）。\n\n`UIDynamicAnimator`会使得菜单的动画持续，一直到所有附加在其上的物理作用力达到平衡。\n\n我们通过代理协议`UIDynamicAnimatorDelegate`来告知视图控制器动画的完成情况。另外，我们还需要调用`endAppearanceTransition()`方法。\n\n这里有一个比较棘手的地方就是设置**anchorPoint**。为了使得动画正确呈现，锚点的位置到`GuillotineMenuViewController`中视图的左边界的距离必须和锚点到顶部导航条底部之间的距离相同。而且，当设备发生旋转也需要修改锚点位置。但是`GuillotineMenuTransitionAnimation`类调用代理方法`anchorPoint()`是在`viewDidLayoutSubviews()`用之前。\n\n因此我们将设备处于水平方向时的按钮位置进行了硬编码\n\n译者注： 设备布局一旦发生变化，例如设备进行了旋转，便会调用`viewDidLayoutSubviews()`方法，本身我们可以在该方法中动态调整按钮位置（也就是锚点位置），可是转场动画必须在该方法调用之前取到锚点位置，因此矛盾。作者就在代码里硬编码处理布局发生变化之后菜单按钮的位置了。\n\n#### UIViewExtension\n针对UIView的简单扩展，主要是针对子视图添加约束以更好的适应父视图。代码本身就很好能够说明功能了（self explanatory），这里就不叙述了。\n\n译者注： 针对Objective-C语言的类扩展和swift语言不同，在objc实现版本中，文件名字为UIView+ConstraintExtension.h和UIView+ConstraintExtension.m\n\n#### Guillotine Menu View Controller\n\n你可以继承该视图控制器或者进行任何的自定义甚至重写。唯一必须要记得是的遵守`GuillotineAnimationProtocol`协议。\n\n----------\n### 你如何才能定制该动画？\n\n你可以用任何可能的方式来定制菜单视图！你只需要创建一个自定义的`GuillotineMenuSegue`，其中源视图控制器就是你的主视图控制器（host view controller），目标视图控制器就是你需要呈现的菜单视图控制器。\n\n实话讲，刚开始创建这个动画的时候我自认为这是一件很简单的事情，这个过程应该也没什么挑战。可是现在我们必须承认，对于iOS开发者而言这里面还有巨大的潜力可挖。另外，我们的动画还可以作为一个简单的动画视图来使用，或者作为一个带有自定义导航条的`UINavigationViewController`的子类来使用。接下来我们计划将不断更新这项工作，力图创造一个完整的带自定义转场动画效果的`UINavigationViewController`的子类。\n\n你可以在以下这几个位置找到我们的工程源码以及设计：\n\n* [GitHub](https://github.com/Yalantis/GuillotineMenu)\n* [Dribbble](https://dribbble.com/shots/2018249-Side-Topbar-Animation)\n\n\n>译者注：Objective-C 版本实现可以参见[GuillotineMenu-objc](https://github.com/hechen/GuillotineMenu-objc)\n\n","source":"_posts/How-We-Created-Guillotine-Menu-Animation-for-iOS.md","raw":"title: \"我们是如何创建iOS版的Guillotine菜单动画的\"\ndate: 2015-09-01 15:52:07\ncategories: 翻译\ntags: [iOS,Animation,Objective-C]\n---\n\n> 原文：[How We Created Guillotine Menu Animation for iOS](https://yalantis.com/blog/how-we-created-guillotine-menu-animation/)\n> 翻译：[@这个昵称有点萌](http://weibo.com/hc2feifei)\n\n\n你是否曾经有过这样的疑问？为什么app中几乎是清一色的**侧**边栏（sidebar），为什么不把它做成**top**Bar或者**bottom**Bar，甚至**corner**Bar呢？\n\n本文将要谈到的就是当前导航条动画的一个新趋势。\n\n<!-- more -->\n\n动画很有趣，但更重要的是能发挥很大的作用，它们可以改变你思考问题的方式，使得你的产品更好用并提升的app整体的用户体验。接下来我们将要展示的是设计师**Vitaly Rubtsov**的一个非常棒的点子：\n\n“每个设计师都有那么一刻感到无聊。因为几乎所有（对动画）的完善修补、裁剪以及规格设定都给他们留下了很少发挥想象的余地。而每当这些时候，我就会驱使自己打开Adobe After Effects软件然后创作一些比较有趣的东西。\n\n当我开始想我要创建一个什么东西的时候，我突然有个想法，通常侧边栏都从屏幕左侧划出，同时将所有的内容都移动到右侧位置。这种传统侧边栏的实现方式太过无聊了。那如果我们将侧边栏变成上边栏会怎么样呢？它从页面的上方掉落然后以一种特别的方式呈现，听起来很棒不是吗？“\n\n**Vitaly**设计的topBar动画由我们的iOS开发工程师**Maksym Lazebnyi**使用`swift`语言实现，并且开发者给了它一个很有趣的名字—— **Guillotine Menu**。\n\n![Guillotine Menu Animation](https://yalantis.com/media/content/ckeditor/2015/04/14/activitytopmenu_vKfwzSX.gif)\n\n\n----------\n\n### 我们是如何开发Guillotine Menu的？   \n**by Makssym Lazebnyi** \n\n实际上，我们的iOS团队见到过很多实现这种动画效果的方法。我们选择了其中一种方式实现，这种方式允许开发者在Storyboard中以任何方式自定义菜单。\n\n为了实现我们的转场动画（transitioning animation），我们创建了一个UIStoryboardSegue的子类和一个自定义动画管理器（custom animation controller）。基本上这就是你实现该动画所需要做的全部工作，除非你想让它更炫酷。当然我们也确实想这样做，因此还创建了一些辅助的类。\n\n整体上，你需要三个类以及一个`UIView`的扩展类来创建这个动画，如下所示：\n\n- `GuillotineMenuSegue`.  该类是继承自`UIStoryboardSegue`类。我们使用它来模态显示菜单，并实现由 `GuillotineMenuTransitionAnimation`类控制的呈现动画。 `GuillotineMenuSegue`允许你为菜单添加透明度，当然本文并没有做这个工作。\n\n- `GuillotineMenuTransitionAnimation`.  该类是为了自定义呈现  `GuillotineMenuViewController` 类中视图的动画所用。\n\n- `GuillotineMenuViewController`. 该类是一个UIViewController的子类，存放菜单视图所用。\n\n除此之外，我们还为UIView添加了扩展方法以便能为子视图添加约束来更好的适应父视图。\n   \n接下来，我们逐一对每一个类进行阐述。\n     \n#### GuillotineMenuSegue\n这个类中没有什么特别的地方，我只提及一些关键点。\n\n在该类重载的init方法中，我们检查目标视图控制器（destination view controller）是否遵守`GuillotineAnimationProtocol` 协议（该协议我们后面会讲到）。在重载的perform方法中我们将self设置成一个过渡动画的代理。\n     \n在代理方法 `animationControllerForPresentedController` 中我们使用关联对象将`GuillotineMenuSegue`的实例对象（**self**）关联到具体的将要呈现的视图控制器中，这样当menu view controller呈现在屏幕上的时候，segue实例不会被销毁。（译者注：代码如下）\n\n``` objc\n- (id <UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source\n{\n\t// 将segue示例self关联到将要呈现的试图控制器presented中，这样确保presented生命周期内segue实例不会被释放\n    objc_setAssociatedObject(presented, &key, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n    \n    return [[GuillotineTransitionAnimation alloc] initWithMode:AnimationModePresentation];\n}\n```\n     \n#### GuillotineMenuTransitionAnimation\n所有的动画处理逻辑都在这个类中实现。\n\n起初我们考虑使用 `animateWithDuration usingSpringWithDamping & initialSprintVelocity`方法，但是当我们认真考虑这个动画之后我们改变了主意。我们需要实现的菜单动画中，当菜单从上方掉落之后，需要和父视图的左侧边界发生碰撞，产生碰撞效果。而上面方法中的回弹效果会穿过左边界（spring through the border of the superview），因此我们放弃了这个实现方式，转而采用了`UIDynamicAnimator`。\n\n为了实现我们的动画，`GuillotineMenuTransitionAnimation`类必须遵从 `UIViewControllerAnimatedTransitioning` 协议，该协议中有两个代理方法：\n\n- transitionDuration  动画的过渡时间对我们影响不是太多，因此你可以返回任意的时间值。 \n\n- animationDurtation 当菜单开启和关闭均会调用该方法\n\n\n----------\n\n###我们如何计算动画的位置信息？\n     \n我们需要了解动画中每一刻的精确位置。`GuillotineMenuTransitionAnimation`类需要`GuillotineMenuViewController`提供menu button中心的坐标来做为旋转动画的锚点（anchorPoint）。另外还需要`GuillotineMenuViewController`提供一些其他属性，因此我们创建一个协议`GuillotineMenuViewController`，视图控制器通过遵守该协议返回我们所需要的几个属性。\n代码如下：\n    \n``` Swift\n @objc protocol GuillotineAnimationProtocol: NSObjectProtocol {\n      func navigationBarHeight() ->CGFloat\n      func anchorPoint() ->CGPoint\n      func hostTitle() ->NSString\n }\n```\n\n译者注：Objective-C版本代码如下：\n\n``` objc\n@protocol GuillotineAnimationProtocol <NSObject>\n\t- (CGFloat) navigationBarHeight;\n\t- (CGPoint) anchorPoint;\n\t- (NSString*) hostTitle;\n@end\n```\n\n这三个方法的意义如下：\n- **navigationBarHeight**  `GuillotineMenuViewController`开始显示动画的时候需要旋转90度，同时覆盖导航条（navigation bar）。我们需要将`GuillotineMenuViewController`中的视图位置设置成`CGPoint(0，navigationBarHeight)`；\n\n- **anchorPoint** 提供我们动画的旋转轴心，这里是`GuillotineMenuViewController`中的menu button的中心位置；\n\n- **hostTitle** 用来询问`GuillotineMenuViewController`获得主视图控制器的标题。  \n\n----------\n\n### 我们如何实现菜单视图的掉落以及旋转？\n\n为了实现掉落以及旋转的动画，我们使用`UIDynamicAnimator`并为其添加四种动力行为：\n （译者注：实际上实现UIKit动力学中的推动力、吸附、碰撞以及辅助行为，详见[UIKit动力学](http://www.coderyi.com/archives/426)）\n- `UIPushBehavior`  为view添加一个拖拽的力，当我们需要呈现显示动画的时候，施加到view的底部，当我们需要呈现关闭菜单的动画时，施加到view的顶部；\n\n- `UIAttachmentBehavior` 相当于一个钉子在menu button的中心点将整个view固定住。\n\n- `UICollisionBehavior`  我们为view的父视图（**superview**）添加了一个边界，从视图中心位置到左下角位置的长度。用以实现`GuillotineMenuViewController`在掉落路径的末端模拟碰撞效果（译者注：当菜单视图关闭而回弹到上方时，同样需要添加boundary，不过此时是在顶部，屏幕水平方向菜单视图的中心位置到其右下角位置）；\n\n- `UIDynamicItemBehavior` 实现菜单碰撞左边界之后的回弹效果。\n\n基本上，我们的动画是这样，首先使用`CGAffineTransformRotate`将`GuillotineMenuViewController`的view旋转正向90度，设置该view的边框位置为`CGPoint(0, navigationBarHeight)`。然后，我们将该view添加以上每一种需要使用的`UIDynamicBehavior`（UIPushBehavior、UIAttachmentBehavior、UICollisionBehavior以及UIDynamicItemBehavior）。\n\n`UIDynamicAnimator`会使得菜单的动画持续，一直到所有附加在其上的物理作用力达到平衡。\n\n我们通过代理协议`UIDynamicAnimatorDelegate`来告知视图控制器动画的完成情况。另外，我们还需要调用`endAppearanceTransition()`方法。\n\n这里有一个比较棘手的地方就是设置**anchorPoint**。为了使得动画正确呈现，锚点的位置到`GuillotineMenuViewController`中视图的左边界的距离必须和锚点到顶部导航条底部之间的距离相同。而且，当设备发生旋转也需要修改锚点位置。但是`GuillotineMenuTransitionAnimation`类调用代理方法`anchorPoint()`是在`viewDidLayoutSubviews()`用之前。\n\n因此我们将设备处于水平方向时的按钮位置进行了硬编码\n\n译者注： 设备布局一旦发生变化，例如设备进行了旋转，便会调用`viewDidLayoutSubviews()`方法，本身我们可以在该方法中动态调整按钮位置（也就是锚点位置），可是转场动画必须在该方法调用之前取到锚点位置，因此矛盾。作者就在代码里硬编码处理布局发生变化之后菜单按钮的位置了。\n\n#### UIViewExtension\n针对UIView的简单扩展，主要是针对子视图添加约束以更好的适应父视图。代码本身就很好能够说明功能了（self explanatory），这里就不叙述了。\n\n译者注： 针对Objective-C语言的类扩展和swift语言不同，在objc实现版本中，文件名字为UIView+ConstraintExtension.h和UIView+ConstraintExtension.m\n\n#### Guillotine Menu View Controller\n\n你可以继承该视图控制器或者进行任何的自定义甚至重写。唯一必须要记得是的遵守`GuillotineAnimationProtocol`协议。\n\n----------\n### 你如何才能定制该动画？\n\n你可以用任何可能的方式来定制菜单视图！你只需要创建一个自定义的`GuillotineMenuSegue`，其中源视图控制器就是你的主视图控制器（host view controller），目标视图控制器就是你需要呈现的菜单视图控制器。\n\n实话讲，刚开始创建这个动画的时候我自认为这是一件很简单的事情，这个过程应该也没什么挑战。可是现在我们必须承认，对于iOS开发者而言这里面还有巨大的潜力可挖。另外，我们的动画还可以作为一个简单的动画视图来使用，或者作为一个带有自定义导航条的`UINavigationViewController`的子类来使用。接下来我们计划将不断更新这项工作，力图创造一个完整的带自定义转场动画效果的`UINavigationViewController`的子类。\n\n你可以在以下这几个位置找到我们的工程源码以及设计：\n\n* [GitHub](https://github.com/Yalantis/GuillotineMenu)\n* [Dribbble](https://dribbble.com/shots/2018249-Side-Topbar-Animation)\n\n\n>译者注：Objective-C 版本实现可以参见[GuillotineMenu-objc](https://github.com/hechen/GuillotineMenu-objc)\n\n","slug":"How-We-Created-Guillotine-Menu-Animation-for-iOS","published":1,"updated":"2017-05-21T12:34:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftbg004e79pox2llc0kl","content":"<blockquote>\n<p>原文：<a href=\"https://yalantis.com/blog/how-we-created-guillotine-menu-animation/\" target=\"_blank\" rel=\"noopener\">How We Created Guillotine Menu Animation for iOS</a><br>翻译：<a href=\"http://weibo.com/hc2feifei\" target=\"_blank\" rel=\"noopener\">@这个昵称有点萌</a></p>\n</blockquote>\n<p>你是否曾经有过这样的疑问？为什么app中几乎是清一色的<strong>侧</strong>边栏（sidebar），为什么不把它做成<strong>top</strong>Bar或者<strong>bottom</strong>Bar，甚至<strong>corner</strong>Bar呢？</p>\n<p>本文将要谈到的就是当前导航条动画的一个新趋势。</p>\n<a id=\"more\"></a>\n<p>动画很有趣，但更重要的是能发挥很大的作用，它们可以改变你思考问题的方式，使得你的产品更好用并提升的app整体的用户体验。接下来我们将要展示的是设计师<strong>Vitaly Rubtsov</strong>的一个非常棒的点子：</p>\n<p>“每个设计师都有那么一刻感到无聊。因为几乎所有（对动画）的完善修补、裁剪以及规格设定都给他们留下了很少发挥想象的余地。而每当这些时候，我就会驱使自己打开Adobe After Effects软件然后创作一些比较有趣的东西。</p>\n<p>当我开始想我要创建一个什么东西的时候，我突然有个想法，通常侧边栏都从屏幕左侧划出，同时将所有的内容都移动到右侧位置。这种传统侧边栏的实现方式太过无聊了。那如果我们将侧边栏变成上边栏会怎么样呢？它从页面的上方掉落然后以一种特别的方式呈现，听起来很棒不是吗？“</p>\n<p><strong>Vitaly</strong>设计的topBar动画由我们的iOS开发工程师<strong>Maksym Lazebnyi</strong>使用<code>swift</code>语言实现，并且开发者给了它一个很有趣的名字—— <strong>Guillotine Menu</strong>。</p>\n<p><img src=\"https://yalantis.com/media/content/ckeditor/2015/04/14/activitytopmenu_vKfwzSX.gif\" alt=\"Guillotine Menu Animation\"></p>\n<hr>\n<h3 id=\"我们是如何开发Guillotine-Menu的？\"><a href=\"#我们是如何开发Guillotine-Menu的？\" class=\"headerlink\" title=\"我们是如何开发Guillotine Menu的？\"></a>我们是如何开发Guillotine Menu的？</h3><p><strong>by Makssym Lazebnyi</strong> </p>\n<p>实际上，我们的iOS团队见到过很多实现这种动画效果的方法。我们选择了其中一种方式实现，这种方式允许开发者在Storyboard中以任何方式自定义菜单。</p>\n<p>为了实现我们的转场动画（transitioning animation），我们创建了一个UIStoryboardSegue的子类和一个自定义动画管理器（custom animation controller）。基本上这就是你实现该动画所需要做的全部工作，除非你想让它更炫酷。当然我们也确实想这样做，因此还创建了一些辅助的类。</p>\n<p>整体上，你需要三个类以及一个<code>UIView</code>的扩展类来创建这个动画，如下所示：</p>\n<ul>\n<li><p><code>GuillotineMenuSegue</code>.  该类是继承自<code>UIStoryboardSegue</code>类。我们使用它来模态显示菜单，并实现由 <code>GuillotineMenuTransitionAnimation</code>类控制的呈现动画。 <code>GuillotineMenuSegue</code>允许你为菜单添加透明度，当然本文并没有做这个工作。</p>\n</li>\n<li><p><code>GuillotineMenuTransitionAnimation</code>.  该类是为了自定义呈现  <code>GuillotineMenuViewController</code> 类中视图的动画所用。</p>\n</li>\n<li><p><code>GuillotineMenuViewController</code>. 该类是一个UIViewController的子类，存放菜单视图所用。</p>\n</li>\n</ul>\n<p>除此之外，我们还为UIView添加了扩展方法以便能为子视图添加约束来更好的适应父视图。</p>\n<p>接下来，我们逐一对每一个类进行阐述。</p>\n<h4 id=\"GuillotineMenuSegue\"><a href=\"#GuillotineMenuSegue\" class=\"headerlink\" title=\"GuillotineMenuSegue\"></a>GuillotineMenuSegue</h4><p>这个类中没有什么特别的地方，我只提及一些关键点。</p>\n<p>在该类重载的init方法中，我们检查目标视图控制器（destination view controller）是否遵守<code>GuillotineAnimationProtocol</code> 协议（该协议我们后面会讲到）。在重载的perform方法中我们将self设置成一个过渡动画的代理。</p>\n<p>在代理方法 <code>animationControllerForPresentedController</code> 中我们使用关联对象将<code>GuillotineMenuSegue</code>的实例对象（<strong>self</strong>）关联到具体的将要呈现的视图控制器中，这样当menu view controller呈现在屏幕上的时候，segue实例不会被销毁。（译者注：代码如下）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class=\"built_in\">UIViewController</span> *)presented presentingController:(<span class=\"built_in\">UIViewController</span> *)presenting sourceController:(<span class=\"built_in\">UIViewController</span> *)source</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将segue示例self关联到将要呈现的试图控制器presented中，这样确保presented生命周期内segue实例不会被释放</span></span><br><span class=\"line\">    objc_setAssociatedObject(presented, &amp;key, <span class=\"keyword\">self</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[GuillotineTransitionAnimation alloc] initWithMode:AnimationModePresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"GuillotineMenuTransitionAnimation\"><a href=\"#GuillotineMenuTransitionAnimation\" class=\"headerlink\" title=\"GuillotineMenuTransitionAnimation\"></a>GuillotineMenuTransitionAnimation</h4><p>所有的动画处理逻辑都在这个类中实现。</p>\n<p>起初我们考虑使用 <code>animateWithDuration usingSpringWithDamping &amp; initialSprintVelocity</code>方法，但是当我们认真考虑这个动画之后我们改变了主意。我们需要实现的菜单动画中，当菜单从上方掉落之后，需要和父视图的左侧边界发生碰撞，产生碰撞效果。而上面方法中的回弹效果会穿过左边界（spring through the border of the superview），因此我们放弃了这个实现方式，转而采用了<code>UIDynamicAnimator</code>。</p>\n<p>为了实现我们的动画，<code>GuillotineMenuTransitionAnimation</code>类必须遵从 <code>UIViewControllerAnimatedTransitioning</code> 协议，该协议中有两个代理方法：</p>\n<ul>\n<li><p>transitionDuration  动画的过渡时间对我们影响不是太多，因此你可以返回任意的时间值。 </p>\n</li>\n<li><p>animationDurtation 当菜单开启和关闭均会调用该方法</p>\n</li>\n</ul>\n<hr>\n<p>###我们如何计算动画的位置信息？</p>\n<p>我们需要了解动画中每一刻的精确位置。<code>GuillotineMenuTransitionAnimation</code>类需要<code>GuillotineMenuViewController</code>提供menu button中心的坐标来做为旋转动画的锚点（anchorPoint）。另外还需要<code>GuillotineMenuViewController</code>提供一些其他属性，因此我们创建一个协议<code>GuillotineMenuViewController</code>，视图控制器通过遵守该协议返回我们所需要的几个属性。<br>代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">GuillotineAnimationProtocol</span>: <span class=\"title\">NSObjectProtocol</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">navigationBarHeight</span><span class=\"params\">()</span></span> -&gt;<span class=\"type\">CGFloat</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">anchorPoint</span><span class=\"params\">()</span></span> -&gt;<span class=\"type\">CGPoint</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hostTitle</span><span class=\"params\">()</span></span> -&gt;<span class=\"type\">NSString</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>译者注：Objective-C版本代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">GuillotineAnimationProtocol</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">\t- (<span class=\"built_in\">CGFloat</span>) navigationBarHeight;</span><br><span class=\"line\">\t- (<span class=\"built_in\">CGPoint</span>) anchorPoint;</span><br><span class=\"line\">\t- (<span class=\"built_in\">NSString</span>*) hostTitle;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这三个方法的意义如下：</p>\n<ul>\n<li><p><strong>navigationBarHeight</strong>  <code>GuillotineMenuViewController</code>开始显示动画的时候需要旋转90度，同时覆盖导航条（navigation bar）。我们需要将<code>GuillotineMenuViewController</code>中的视图位置设置成<code>CGPoint(0，navigationBarHeight)</code>；</p>\n</li>\n<li><p><strong>anchorPoint</strong> 提供我们动画的旋转轴心，这里是<code>GuillotineMenuViewController</code>中的menu button的中心位置；</p>\n</li>\n<li><p><strong>hostTitle</strong> 用来询问<code>GuillotineMenuViewController</code>获得主视图控制器的标题。  </p>\n</li>\n</ul>\n<hr>\n<h3 id=\"我们如何实现菜单视图的掉落以及旋转？\"><a href=\"#我们如何实现菜单视图的掉落以及旋转？\" class=\"headerlink\" title=\"我们如何实现菜单视图的掉落以及旋转？\"></a>我们如何实现菜单视图的掉落以及旋转？</h3><p>为了实现掉落以及旋转的动画，我们使用<code>UIDynamicAnimator</code>并为其添加四种动力行为：<br> （译者注：实际上实现UIKit动力学中的推动力、吸附、碰撞以及辅助行为，详见<a href=\"http://www.coderyi.com/archives/426\" target=\"_blank\" rel=\"noopener\">UIKit动力学</a>）</p>\n<ul>\n<li><p><code>UIPushBehavior</code>  为view添加一个拖拽的力，当我们需要呈现显示动画的时候，施加到view的底部，当我们需要呈现关闭菜单的动画时，施加到view的顶部；</p>\n</li>\n<li><p><code>UIAttachmentBehavior</code> 相当于一个钉子在menu button的中心点将整个view固定住。</p>\n</li>\n<li><p><code>UICollisionBehavior</code>  我们为view的父视图（<strong>superview</strong>）添加了一个边界，从视图中心位置到左下角位置的长度。用以实现<code>GuillotineMenuViewController</code>在掉落路径的末端模拟碰撞效果（译者注：当菜单视图关闭而回弹到上方时，同样需要添加boundary，不过此时是在顶部，屏幕水平方向菜单视图的中心位置到其右下角位置）；</p>\n</li>\n<li><p><code>UIDynamicItemBehavior</code> 实现菜单碰撞左边界之后的回弹效果。</p>\n</li>\n</ul>\n<p>基本上，我们的动画是这样，首先使用<code>CGAffineTransformRotate</code>将<code>GuillotineMenuViewController</code>的view旋转正向90度，设置该view的边框位置为<code>CGPoint(0, navigationBarHeight)</code>。然后，我们将该view添加以上每一种需要使用的<code>UIDynamicBehavior</code>（UIPushBehavior、UIAttachmentBehavior、UICollisionBehavior以及UIDynamicItemBehavior）。</p>\n<p><code>UIDynamicAnimator</code>会使得菜单的动画持续，一直到所有附加在其上的物理作用力达到平衡。</p>\n<p>我们通过代理协议<code>UIDynamicAnimatorDelegate</code>来告知视图控制器动画的完成情况。另外，我们还需要调用<code>endAppearanceTransition()</code>方法。</p>\n<p>这里有一个比较棘手的地方就是设置<strong>anchorPoint</strong>。为了使得动画正确呈现，锚点的位置到<code>GuillotineMenuViewController</code>中视图的左边界的距离必须和锚点到顶部导航条底部之间的距离相同。而且，当设备发生旋转也需要修改锚点位置。但是<code>GuillotineMenuTransitionAnimation</code>类调用代理方法<code>anchorPoint()</code>是在<code>viewDidLayoutSubviews()</code>用之前。</p>\n<p>因此我们将设备处于水平方向时的按钮位置进行了硬编码</p>\n<p>译者注： 设备布局一旦发生变化，例如设备进行了旋转，便会调用<code>viewDidLayoutSubviews()</code>方法，本身我们可以在该方法中动态调整按钮位置（也就是锚点位置），可是转场动画必须在该方法调用之前取到锚点位置，因此矛盾。作者就在代码里硬编码处理布局发生变化之后菜单按钮的位置了。</p>\n<h4 id=\"UIViewExtension\"><a href=\"#UIViewExtension\" class=\"headerlink\" title=\"UIViewExtension\"></a>UIViewExtension</h4><p>针对UIView的简单扩展，主要是针对子视图添加约束以更好的适应父视图。代码本身就很好能够说明功能了（self explanatory），这里就不叙述了。</p>\n<p>译者注： 针对Objective-C语言的类扩展和swift语言不同，在objc实现版本中，文件名字为UIView+ConstraintExtension.h和UIView+ConstraintExtension.m</p>\n<h4 id=\"Guillotine-Menu-View-Controller\"><a href=\"#Guillotine-Menu-View-Controller\" class=\"headerlink\" title=\"Guillotine Menu View Controller\"></a>Guillotine Menu View Controller</h4><p>你可以继承该视图控制器或者进行任何的自定义甚至重写。唯一必须要记得是的遵守<code>GuillotineAnimationProtocol</code>协议。</p>\n<hr>\n<h3 id=\"你如何才能定制该动画？\"><a href=\"#你如何才能定制该动画？\" class=\"headerlink\" title=\"你如何才能定制该动画？\"></a>你如何才能定制该动画？</h3><p>你可以用任何可能的方式来定制菜单视图！你只需要创建一个自定义的<code>GuillotineMenuSegue</code>，其中源视图控制器就是你的主视图控制器（host view controller），目标视图控制器就是你需要呈现的菜单视图控制器。</p>\n<p>实话讲，刚开始创建这个动画的时候我自认为这是一件很简单的事情，这个过程应该也没什么挑战。可是现在我们必须承认，对于iOS开发者而言这里面还有巨大的潜力可挖。另外，我们的动画还可以作为一个简单的动画视图来使用，或者作为一个带有自定义导航条的<code>UINavigationViewController</code>的子类来使用。接下来我们计划将不断更新这项工作，力图创造一个完整的带自定义转场动画效果的<code>UINavigationViewController</code>的子类。</p>\n<p>你可以在以下这几个位置找到我们的工程源码以及设计：</p>\n<ul>\n<li><a href=\"https://github.com/Yalantis/GuillotineMenu\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n<li><a href=\"https://dribbble.com/shots/2018249-Side-Topbar-Animation\" target=\"_blank\" rel=\"noopener\">Dribbble</a></li>\n</ul>\n<blockquote>\n<p>译者注：Objective-C 版本实现可以参见<a href=\"https://github.com/hechen/GuillotineMenu-objc\" target=\"_blank\" rel=\"noopener\">GuillotineMenu-objc</a></p>\n</blockquote>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<blockquote>\n<p>原文：<a href=\"https://yalantis.com/blog/how-we-created-guillotine-menu-animation/\" target=\"_blank\" rel=\"noopener\">How We Created Guillotine Menu Animation for iOS</a><br>翻译：<a href=\"http://weibo.com/hc2feifei\" target=\"_blank\" rel=\"noopener\">@这个昵称有点萌</a></p>\n</blockquote>\n<p>你是否曾经有过这样的疑问？为什么app中几乎是清一色的<strong>侧</strong>边栏（sidebar），为什么不把它做成<strong>top</strong>Bar或者<strong>bottom</strong>Bar，甚至<strong>corner</strong>Bar呢？</p>\n<p>本文将要谈到的就是当前导航条动画的一个新趋势。</p>","more":"<p>动画很有趣，但更重要的是能发挥很大的作用，它们可以改变你思考问题的方式，使得你的产品更好用并提升的app整体的用户体验。接下来我们将要展示的是设计师<strong>Vitaly Rubtsov</strong>的一个非常棒的点子：</p>\n<p>“每个设计师都有那么一刻感到无聊。因为几乎所有（对动画）的完善修补、裁剪以及规格设定都给他们留下了很少发挥想象的余地。而每当这些时候，我就会驱使自己打开Adobe After Effects软件然后创作一些比较有趣的东西。</p>\n<p>当我开始想我要创建一个什么东西的时候，我突然有个想法，通常侧边栏都从屏幕左侧划出，同时将所有的内容都移动到右侧位置。这种传统侧边栏的实现方式太过无聊了。那如果我们将侧边栏变成上边栏会怎么样呢？它从页面的上方掉落然后以一种特别的方式呈现，听起来很棒不是吗？“</p>\n<p><strong>Vitaly</strong>设计的topBar动画由我们的iOS开发工程师<strong>Maksym Lazebnyi</strong>使用<code>swift</code>语言实现，并且开发者给了它一个很有趣的名字—— <strong>Guillotine Menu</strong>。</p>\n<p><img src=\"https://yalantis.com/media/content/ckeditor/2015/04/14/activitytopmenu_vKfwzSX.gif\" alt=\"Guillotine Menu Animation\"></p>\n<hr>\n<h3 id=\"我们是如何开发Guillotine-Menu的？\"><a href=\"#我们是如何开发Guillotine-Menu的？\" class=\"headerlink\" title=\"我们是如何开发Guillotine Menu的？\"></a>我们是如何开发Guillotine Menu的？</h3><p><strong>by Makssym Lazebnyi</strong> </p>\n<p>实际上，我们的iOS团队见到过很多实现这种动画效果的方法。我们选择了其中一种方式实现，这种方式允许开发者在Storyboard中以任何方式自定义菜单。</p>\n<p>为了实现我们的转场动画（transitioning animation），我们创建了一个UIStoryboardSegue的子类和一个自定义动画管理器（custom animation controller）。基本上这就是你实现该动画所需要做的全部工作，除非你想让它更炫酷。当然我们也确实想这样做，因此还创建了一些辅助的类。</p>\n<p>整体上，你需要三个类以及一个<code>UIView</code>的扩展类来创建这个动画，如下所示：</p>\n<ul>\n<li><p><code>GuillotineMenuSegue</code>.  该类是继承自<code>UIStoryboardSegue</code>类。我们使用它来模态显示菜单，并实现由 <code>GuillotineMenuTransitionAnimation</code>类控制的呈现动画。 <code>GuillotineMenuSegue</code>允许你为菜单添加透明度，当然本文并没有做这个工作。</p>\n</li>\n<li><p><code>GuillotineMenuTransitionAnimation</code>.  该类是为了自定义呈现  <code>GuillotineMenuViewController</code> 类中视图的动画所用。</p>\n</li>\n<li><p><code>GuillotineMenuViewController</code>. 该类是一个UIViewController的子类，存放菜单视图所用。</p>\n</li>\n</ul>\n<p>除此之外，我们还为UIView添加了扩展方法以便能为子视图添加约束来更好的适应父视图。</p>\n<p>接下来，我们逐一对每一个类进行阐述。</p>\n<h4 id=\"GuillotineMenuSegue\"><a href=\"#GuillotineMenuSegue\" class=\"headerlink\" title=\"GuillotineMenuSegue\"></a>GuillotineMenuSegue</h4><p>这个类中没有什么特别的地方，我只提及一些关键点。</p>\n<p>在该类重载的init方法中，我们检查目标视图控制器（destination view controller）是否遵守<code>GuillotineAnimationProtocol</code> 协议（该协议我们后面会讲到）。在重载的perform方法中我们将self设置成一个过渡动画的代理。</p>\n<p>在代理方法 <code>animationControllerForPresentedController</code> 中我们使用关联对象将<code>GuillotineMenuSegue</code>的实例对象（<strong>self</strong>）关联到具体的将要呈现的视图控制器中，这样当menu view controller呈现在屏幕上的时候，segue实例不会被销毁。（译者注：代码如下）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span> &lt;<span class=\"built_in\">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class=\"built_in\">UIViewController</span> *)presented presentingController:(<span class=\"built_in\">UIViewController</span> *)presenting sourceController:(<span class=\"built_in\">UIViewController</span> *)source</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将segue示例self关联到将要呈现的试图控制器presented中，这样确保presented生命周期内segue实例不会被释放</span></span><br><span class=\"line\">    objc_setAssociatedObject(presented, &amp;key, <span class=\"keyword\">self</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[GuillotineTransitionAnimation alloc] initWithMode:AnimationModePresentation];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"GuillotineMenuTransitionAnimation\"><a href=\"#GuillotineMenuTransitionAnimation\" class=\"headerlink\" title=\"GuillotineMenuTransitionAnimation\"></a>GuillotineMenuTransitionAnimation</h4><p>所有的动画处理逻辑都在这个类中实现。</p>\n<p>起初我们考虑使用 <code>animateWithDuration usingSpringWithDamping &amp; initialSprintVelocity</code>方法，但是当我们认真考虑这个动画之后我们改变了主意。我们需要实现的菜单动画中，当菜单从上方掉落之后，需要和父视图的左侧边界发生碰撞，产生碰撞效果。而上面方法中的回弹效果会穿过左边界（spring through the border of the superview），因此我们放弃了这个实现方式，转而采用了<code>UIDynamicAnimator</code>。</p>\n<p>为了实现我们的动画，<code>GuillotineMenuTransitionAnimation</code>类必须遵从 <code>UIViewControllerAnimatedTransitioning</code> 协议，该协议中有两个代理方法：</p>\n<ul>\n<li><p>transitionDuration  动画的过渡时间对我们影响不是太多，因此你可以返回任意的时间值。 </p>\n</li>\n<li><p>animationDurtation 当菜单开启和关闭均会调用该方法</p>\n</li>\n</ul>\n<hr>\n<p>###我们如何计算动画的位置信息？</p>\n<p>我们需要了解动画中每一刻的精确位置。<code>GuillotineMenuTransitionAnimation</code>类需要<code>GuillotineMenuViewController</code>提供menu button中心的坐标来做为旋转动画的锚点（anchorPoint）。另外还需要<code>GuillotineMenuViewController</code>提供一些其他属性，因此我们创建一个协议<code>GuillotineMenuViewController</code>，视图控制器通过遵守该协议返回我们所需要的几个属性。<br>代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">GuillotineAnimationProtocol</span>: <span class=\"title\">NSObjectProtocol</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">navigationBarHeight</span><span class=\"params\">()</span></span> -&gt;<span class=\"type\">CGFloat</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">anchorPoint</span><span class=\"params\">()</span></span> -&gt;<span class=\"type\">CGPoint</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hostTitle</span><span class=\"params\">()</span></span> -&gt;<span class=\"type\">NSString</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>译者注：Objective-C版本代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@protocol</span> <span class=\"title\">GuillotineAnimationProtocol</span> &lt;<span class=\"title\">NSObject</span>&gt;</span></span><br><span class=\"line\">\t- (<span class=\"built_in\">CGFloat</span>) navigationBarHeight;</span><br><span class=\"line\">\t- (<span class=\"built_in\">CGPoint</span>) anchorPoint;</span><br><span class=\"line\">\t- (<span class=\"built_in\">NSString</span>*) hostTitle;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这三个方法的意义如下：</p>\n<ul>\n<li><p><strong>navigationBarHeight</strong>  <code>GuillotineMenuViewController</code>开始显示动画的时候需要旋转90度，同时覆盖导航条（navigation bar）。我们需要将<code>GuillotineMenuViewController</code>中的视图位置设置成<code>CGPoint(0，navigationBarHeight)</code>；</p>\n</li>\n<li><p><strong>anchorPoint</strong> 提供我们动画的旋转轴心，这里是<code>GuillotineMenuViewController</code>中的menu button的中心位置；</p>\n</li>\n<li><p><strong>hostTitle</strong> 用来询问<code>GuillotineMenuViewController</code>获得主视图控制器的标题。  </p>\n</li>\n</ul>\n<hr>\n<h3 id=\"我们如何实现菜单视图的掉落以及旋转？\"><a href=\"#我们如何实现菜单视图的掉落以及旋转？\" class=\"headerlink\" title=\"我们如何实现菜单视图的掉落以及旋转？\"></a>我们如何实现菜单视图的掉落以及旋转？</h3><p>为了实现掉落以及旋转的动画，我们使用<code>UIDynamicAnimator</code>并为其添加四种动力行为：<br> （译者注：实际上实现UIKit动力学中的推动力、吸附、碰撞以及辅助行为，详见<a href=\"http://www.coderyi.com/archives/426\" target=\"_blank\" rel=\"noopener\">UIKit动力学</a>）</p>\n<ul>\n<li><p><code>UIPushBehavior</code>  为view添加一个拖拽的力，当我们需要呈现显示动画的时候，施加到view的底部，当我们需要呈现关闭菜单的动画时，施加到view的顶部；</p>\n</li>\n<li><p><code>UIAttachmentBehavior</code> 相当于一个钉子在menu button的中心点将整个view固定住。</p>\n</li>\n<li><p><code>UICollisionBehavior</code>  我们为view的父视图（<strong>superview</strong>）添加了一个边界，从视图中心位置到左下角位置的长度。用以实现<code>GuillotineMenuViewController</code>在掉落路径的末端模拟碰撞效果（译者注：当菜单视图关闭而回弹到上方时，同样需要添加boundary，不过此时是在顶部，屏幕水平方向菜单视图的中心位置到其右下角位置）；</p>\n</li>\n<li><p><code>UIDynamicItemBehavior</code> 实现菜单碰撞左边界之后的回弹效果。</p>\n</li>\n</ul>\n<p>基本上，我们的动画是这样，首先使用<code>CGAffineTransformRotate</code>将<code>GuillotineMenuViewController</code>的view旋转正向90度，设置该view的边框位置为<code>CGPoint(0, navigationBarHeight)</code>。然后，我们将该view添加以上每一种需要使用的<code>UIDynamicBehavior</code>（UIPushBehavior、UIAttachmentBehavior、UICollisionBehavior以及UIDynamicItemBehavior）。</p>\n<p><code>UIDynamicAnimator</code>会使得菜单的动画持续，一直到所有附加在其上的物理作用力达到平衡。</p>\n<p>我们通过代理协议<code>UIDynamicAnimatorDelegate</code>来告知视图控制器动画的完成情况。另外，我们还需要调用<code>endAppearanceTransition()</code>方法。</p>\n<p>这里有一个比较棘手的地方就是设置<strong>anchorPoint</strong>。为了使得动画正确呈现，锚点的位置到<code>GuillotineMenuViewController</code>中视图的左边界的距离必须和锚点到顶部导航条底部之间的距离相同。而且，当设备发生旋转也需要修改锚点位置。但是<code>GuillotineMenuTransitionAnimation</code>类调用代理方法<code>anchorPoint()</code>是在<code>viewDidLayoutSubviews()</code>用之前。</p>\n<p>因此我们将设备处于水平方向时的按钮位置进行了硬编码</p>\n<p>译者注： 设备布局一旦发生变化，例如设备进行了旋转，便会调用<code>viewDidLayoutSubviews()</code>方法，本身我们可以在该方法中动态调整按钮位置（也就是锚点位置），可是转场动画必须在该方法调用之前取到锚点位置，因此矛盾。作者就在代码里硬编码处理布局发生变化之后菜单按钮的位置了。</p>\n<h4 id=\"UIViewExtension\"><a href=\"#UIViewExtension\" class=\"headerlink\" title=\"UIViewExtension\"></a>UIViewExtension</h4><p>针对UIView的简单扩展，主要是针对子视图添加约束以更好的适应父视图。代码本身就很好能够说明功能了（self explanatory），这里就不叙述了。</p>\n<p>译者注： 针对Objective-C语言的类扩展和swift语言不同，在objc实现版本中，文件名字为UIView+ConstraintExtension.h和UIView+ConstraintExtension.m</p>\n<h4 id=\"Guillotine-Menu-View-Controller\"><a href=\"#Guillotine-Menu-View-Controller\" class=\"headerlink\" title=\"Guillotine Menu View Controller\"></a>Guillotine Menu View Controller</h4><p>你可以继承该视图控制器或者进行任何的自定义甚至重写。唯一必须要记得是的遵守<code>GuillotineAnimationProtocol</code>协议。</p>\n<hr>\n<h3 id=\"你如何才能定制该动画？\"><a href=\"#你如何才能定制该动画？\" class=\"headerlink\" title=\"你如何才能定制该动画？\"></a>你如何才能定制该动画？</h3><p>你可以用任何可能的方式来定制菜单视图！你只需要创建一个自定义的<code>GuillotineMenuSegue</code>，其中源视图控制器就是你的主视图控制器（host view controller），目标视图控制器就是你需要呈现的菜单视图控制器。</p>\n<p>实话讲，刚开始创建这个动画的时候我自认为这是一件很简单的事情，这个过程应该也没什么挑战。可是现在我们必须承认，对于iOS开发者而言这里面还有巨大的潜力可挖。另外，我们的动画还可以作为一个简单的动画视图来使用，或者作为一个带有自定义导航条的<code>UINavigationViewController</code>的子类来使用。接下来我们计划将不断更新这项工作，力图创造一个完整的带自定义转场动画效果的<code>UINavigationViewController</code>的子类。</p>\n<p>你可以在以下这几个位置找到我们的工程源码以及设计：</p>\n<ul>\n<li><a href=\"https://github.com/Yalantis/GuillotineMenu\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n<li><a href=\"https://dribbble.com/shots/2018249-Side-Topbar-Animation\" target=\"_blank\" rel=\"noopener\">Dribbble</a></li>\n</ul>\n<blockquote>\n<p>译者注：Objective-C 版本实现可以参见<a href=\"https://github.com/hechen/GuillotineMenu-objc\" target=\"_blank\" rel=\"noopener\">GuillotineMenu-objc</a></p>\n</blockquote>"},{"title":"In App Purchase","date":"2018-05-24T02:40:39.000Z","_content":"\n\n对于在 App Store 中上架的应⽤来说，应⽤内购买(In-App Purchase，简称 IAP) 应该是一个避不开的话题，尤其是去年微信打赏和 Apple 之间的争执更让 IAP 火了一把，不仅仅大公司，作为个人开发者来讲，IAP 也是非常重要的，说不定就是你养家糊口的工具呢。\n\n<!-- more -->\n\n整个 IAP 的过程，在客户端的实现依赖于 `StoreKit` 这个框架，所有的支付相关操作都是交由 StoreKit 来完成的。\n\n首先，我们先复习一下 IAP 的整个流程。\n\n## In App Purchase 的整体流程\n\n### 阶段 1\n\n![In App Purchase 过程](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-4DDE8387-EDB1-42CC-B18C-3DC6CA1DC688.png)\n\n1. 加载 In-App Identifier\n2. 客户端从 AppStore 中获取本地化的商品信息。\n3. 把 IAP 的购买界⾯面展示给⽤用户，⽤用户可以同意购买并点击购买按钮。\n4. ⽤用户授权购买，客户端向服务器器发送购买请求。\n5. 服务器器处理理购买请求，并把结果返回给 StoreKit。\n6. 如果购买请求验证通过，客户端此时解锁内容或者提供⾦金金币。\n7. 至此，整个交易易流程结束。\n\n### 阶段 2\n\n具体到和 Apple Store 打交道的话，如下所示：\n\n![IAP With App Store](http://7xilk1.com1.z0.glb.clouddn.com/2018-08-27-intro_2x.png)\n\n### 阶段 3\n\n如果涉及到自己 App 端 Server 的参与，基本如下图所示：\n\n![IAP With Business Server](http://7xilk1.com1.z0.glb.clouddn.com/2018-08-29-1*MwLeHUGSupbb9j-oYQyflw.png)\n\n正常多出的几步：\n\n1. 获取 Product 标识列表；\n2. 客户端上传 Receipt 数据给 Server，Server 自行校验或者使用 Apple 的接口校验；\n3. Server 端告知给客户端付费内容\n\n\n### 注册商品\n\n商品注册是通过 iTunes Connect 后台进行的，其中商品类型需要提前明确好。\n\n#### 商品类型\n\n参与 App 内支付动作的商品有四种类型：\n\n- Consumable products （消耗型商品）\n- Non-consumable products （非消耗型商品）\n- Auto-renewable subscriptions （自动续约订阅）\n- Non-renewable subscriptions （非自动续约订阅）\n\n其中关于非自动续约订阅，App 的开发者有义务同步服务到用户的所有设备上。\n\n如下，是官方文档列出来的四种商品类型的一些主要属性。\n\n| Product type | Non-consumable | Consumable | Auto-renewable | Non-renewing\n| --- | --- | --- | --- | --- | \n| Users can buy | Once | Multiple times | Multiple times | Multiple times |\n| Appears in the receipt | Always | Once | Always | Always | \n| Synced across devices | By the system | Not synced | By the system | By your app |\n| Restored | By the system | Not restored |  By the system | By your app |\n\n其中需要注意的几点：\n\n1. 除了非消耗型商品只能买一次，再次购买应该会失败以外，其他三种类型（消耗型，连续/非连续订阅）都是可以无限制购买的，Apple 是不会报错的；\n2. 除了消耗型商品在 Receipt 中出现一次，其他三种类型（非消耗型，连续/非连续订阅）是始终都会在其中的，这也是后续做订阅校验至关重要的一环；\n\n### 获取 Product ID\n\n这里获取的是 Product 在 iTunes Connect 后台注册商品时填写的 Product ID\n\n![Product ID](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-15359854946888.png)\n\nIn-App Identifier 为每个可销售的商品提供一个唯一标识。在客户端上，我们可以直接写死代码:\n\n``` Swift\nlet identifiers = [\"com.myCompany.myApp.product1\", \"com.myCompany.myApp.product2\" ]\n```\n\n或者从 Server 端获取。\n\n### 获取商品信息\n\n然后通过上一步取得的 Product ID 来获取具体某个 Product 的详细信息，包括价格，描述等等。\n\n``` Swift\n// 获取一批商品的信息\n\nlet request = SKProductsRequest(productIdentifiers: identifierSet) \n\nrequest.delegate = self\n\nrequest.start()\n```\n\n在代理回调中处理获取的结果，进行展示或者 Cache。\n\n``` Swift\nfunc productRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {\n\n    for product in response.products {\n    \n    } \n} \n```\n\n官方建议是不要进行缓存，因为 Product 的信息有可能会更新，比如用户切换 AppStore 的区域，价格信息也会因为相应的汇率发生变化。不过！在国内，被牺牲最大的用户体验不是这种边界情况，而是获取 Product 信息是需要和 Apple Server 打交道的，这就有个问题 —— 慢！\n\n我们会在开机的时候提前预取所有 Product 信息，并且缓存起来。下次弹出充值面板的时候就直接列出商品信息即可。\n\n\n## 展示支付 UI\n\n接下来就看什么时候进行购买了，展示商品面板进行购买。用户在面板上进行选择之后，就进入了下一阶段 ── 支付\n\n## 发出购买请求\n\n这⼀步也很简单， 两⾏行代码就可以搞定。只需要把之前拿到的商品对象传到 `SKPayment` 的初始化方法中，构造一个 `SKPayment` 实例，再把这个实例加⼊到购买队列中即可:\n\n``` Swift\nlet payment = SKPayment(product: product) SKPaymentQueue.default().add(payment)\n```\n\n之后就交给 Apple 了，此时应用内会弹出苹果设计的购买窗口，用户只要使⽤指纹或者输入密码即可同意付款。\n\n\n## 处理购买结果\n\n当⽤户的购买请求经过 `StoreKit` 和苹果服务器的验证后，开发者可以在回调函数中接收到。Apple 具体的回调会通过 `SKPaymentQueue` 来进行，如下，我们需要在支付之前就向 `SKPaymentQueue` 中加入代理监听。\n\n``` Swift\nSKPaymentQueue.default().add(self)\n```\n\n你可以把具体的监听放在一个独立的类中完成。在该 Observer 中，实现代理方法：\n\n``` Swift\n// 处理理 SKPaymentQueueObserver 事件\n// MARK: - SKPaymentTransactionObserver\nfunc paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions:[SK PaymentTransaction]) {\n    for transaction in transactions {\n        switch transaction.transactionState { \n            case .purchased:\n            // Validate the purchase\n            \n            // Locate the file\n            guard let url = Bundle.main.appStoreReceiptURL else {\n                // Handle failure\n                return    \n            }\n\n            // Read the contents\n            let receipt = Data(contentsOf: url)\n        } \n    }\n} \n```\n\n对于每一个你提交的 Payment，就一定会有一个相应的 Transaction 生成以便其后续处理。通过检查 transaction 的状态，我们可以指定每种状态下的处理逻辑。如果状态显示已购买， 我们还是应该和⾃己的服务器器进行一次校验，确保交易真实有效⽽而不是通过越狱后的某些插件完成的。被检验的，是一种被苹果称之为收据(receipt)的凭证，就像我们在超市购物或者饭店就餐后拿到的收据一样，每⼀个购买的商品都有⾃己的收据。这个收据由苹果签发，保存在客户端本地。\n\n目前 Apple 官方提供两种方式，一种是本机校验，一种是 Server 端校验。\n\n![Receipt Validation Ways](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-E9DC4D03-7F18-49CC-B21D-835904E2B39F.png)\n\n\n## Final，投递商品\n\n当 Server 端检验完成之后，说明本地交易已经成功完成，因此将用户购买的内容提供给用户使用。当然，对于业务方，购买完成不代表业务完成，因此大多数情况下还有一步进行商品业务校验的过程。\n\n需要注意的一点是：\n\nApple 也明确告诉开发者有几个关键的路径节点需要注意：\n\n![关键路径](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-C1BB8495-728D-43E7-9C40-8EC9B3A22905.png)\n\n监听交易状态的代码一定要越早越好，比如在 App 完成启动之后进行注册，确保整个生命周期内都有代码逻辑来处理监听到的交易，根据监听到的 Transaction 的状态来分发处理逻辑。因为很有可能你监听的时机太晚，导致 Apple 通知有一些之前未完成的交易的时候你无法捕获。说白了就是用户的购买流程跟 App 生命周期不挂钩导致的，典型的有以下几个场景\n\n1. 用户杀死了 App\n2. 用户需要更新帐号中的付费信息（此时已跳出 App ）\n3. App 闪退\n4. 用户进行了订阅续期\n5. 用户进入了推介促销价的流程\n6. 用户跳出 App 输入推广码\n\n## 结束交易\n\n在最后一步中，如果是正常的交易，那么简单的结束它们就⾏了。但对于其他异常的交易易，⽐比如出现了一些 error，也要妥善的结束它们。如果是⾃动续期的订阅，也会经过这一步。如果 交易没有被正确的结束，它们会一直停留留在上文提到的队列中，每次回调函数被调用时，队列 中都会有这些没有被结束的交易。也就是为什么需要提前监听的原因了。\n\n结束交易的代码⾮常简单，只有一行:\n\n``` Swift\nSKPaymentQueue.default().finishTransaction(transaction)\n```\n\n### 关于 Transaction 和 Receipt 的区别和联系\n\n很多同学在进行 IAP 开发的时候常常有一个很大的困惑就是 Transaction 和 Receipt 傻傻分不清楚，这里重新梳理了一下。\n\n#### 关于 Transaction\n\n其实前面讲 Payment 的操作的时候已经表明了， Transaction 是和具体的一次 Payment 对应的，也就是发生一次 Payment 就会生成 Transaction，但是，并不是 1 对 1 的关系，比如本次 Payment 对应的 Transaction 已经被 finish 了，用户换了手机，登陆同样 AppleID 的时候使用 Restore 功能，Apple 会生成 Transaction 给你，本次的 Transaction 就对应的之前的 Payment，只是状态标记为 .restored。\n\nTransaction 的状态主要有以下这么几种：\n\n| 状态 | 含义 |\n|:--|:--|\n| .purchasing | 不需要做什么，继续等待 SKPaymentTransactionState 的状态流转 |\n| .purchased | 用户已完成付费，处理付费后的流程并调用 finishTransaction 方法 |\n| .failed | 用户付费失败，处理付费失败的流程并调用 finishTransaction 方法 |\n| .restored | 用户付费成功，处理付费后的流程并调用 finishTransaction 方法 |\n| .deferred | 不需要做什么，继续等待 SKPaymentTransactionState 的状态流转 |\n\n\n**Note**: 对于 `finishTransaction` 的几点说明：\n\n1. 对于那些依赖苹果下载服务的，比如存储在 iTunes Connect 上的付费内容要下载到本地，如果下载完成之前就进行了 finish 动作会导致 Apple 阻断所有的下载流程，并且无法重新下载；\n2. Transaction 需要配合 Receipt 验证是否合法，单纯靠前端是不靠谱的，因此交由业务后端验证 Receipt 更安全合理，业务后端来决定是否需要 finish\n3. 文档里说：Your app needs to finish every transaction, regardless of whether the transaction succeeded or failed. 所以我们需要将 Transaction Finish 掉，否则会始终出现在 PaymentQueue 里，BUT，中间态的交易是不需要 finish 的，比如 .purchasing 和 .deferred\n\n\n#### 关于 Receipt\n\nReceipt 是 App Store 签发的，是你的 App 上和该 App 上发生的支付行为记录。它存储在设备上的某个固定地址，StoreKit 并不会生成它，它是从 App Store 拉取下来的一个文件。如图所示：\n\n``` Swift\n\nguard let url = Bundle.main.appStoreReceiptURL else {\n    // handle failure\n    return\n}\n\n// read the contents\nlet receipt = Data(contentsOf: url)\n```\n\n如果本地该地址里没有，我们还可以进行刷新，实质上就是从 App Store 请求 Receipt 数据。请求如下：\n\n``` Swift\nlet request = SKReceiptRefreshRequest()\n\nrequest.delegate = self\n\nrequest.start()\n```\n\n\n## 这里有几个需要注意的点：\n\n### 恢复已经购买的商品\n\n这里有一个需要注意的事情就是：如果一个用户试图去购买一个之前购买过的商\u0010品，而不是使用你App 提供的 Restore 功能恢复的话，App Store 会依然创建一个正常的新交易。用户是不会被再次收费的，这里的问题是，Transaction 的状态可不是 restored，而是完全新的 Transaction，你可以按照之前的正常流程走，当然对于自带账户体系的 App 来讲，需要自行判断和计算。\n\n\n## 参考资料：\n\n1. [In App Purchase](https://developer.apple.com/in-app-purchase/)\n2. [In-App Purchase Programming Guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Introduction.html)\n3. [Receipt Validation Programming Guide](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html)\n4. [How to detect refunded IAPs from receipts?](https://forums.developer.apple.com/thread/46737)\n5. [Check if a non-renewable subscription was refunded by Apple?](https://stackoverflow.com/questions/10771240/check-if-a-non-renewable-subscription-was-refunded-by-apple)\n6. [How does Apple notify iOS apps of refunds of in-app purchases (IAP)?](https://stackoverflow.com/questions/6439482/how-does-apple-notify-ios-apps-of-refunds-of-in-app-purchases-iap)","source":"_posts/In-App-Purchase.md","raw":"---\ntitle: In App Purchase\ndate: 2018-05-24 10:40:39\ncategories: iOS\ntags: [iOS,IAP,Receipt]\n---\n\n\n对于在 App Store 中上架的应⽤来说，应⽤内购买(In-App Purchase，简称 IAP) 应该是一个避不开的话题，尤其是去年微信打赏和 Apple 之间的争执更让 IAP 火了一把，不仅仅大公司，作为个人开发者来讲，IAP 也是非常重要的，说不定就是你养家糊口的工具呢。\n\n<!-- more -->\n\n整个 IAP 的过程，在客户端的实现依赖于 `StoreKit` 这个框架，所有的支付相关操作都是交由 StoreKit 来完成的。\n\n首先，我们先复习一下 IAP 的整个流程。\n\n## In App Purchase 的整体流程\n\n### 阶段 1\n\n![In App Purchase 过程](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-4DDE8387-EDB1-42CC-B18C-3DC6CA1DC688.png)\n\n1. 加载 In-App Identifier\n2. 客户端从 AppStore 中获取本地化的商品信息。\n3. 把 IAP 的购买界⾯面展示给⽤用户，⽤用户可以同意购买并点击购买按钮。\n4. ⽤用户授权购买，客户端向服务器器发送购买请求。\n5. 服务器器处理理购买请求，并把结果返回给 StoreKit。\n6. 如果购买请求验证通过，客户端此时解锁内容或者提供⾦金金币。\n7. 至此，整个交易易流程结束。\n\n### 阶段 2\n\n具体到和 Apple Store 打交道的话，如下所示：\n\n![IAP With App Store](http://7xilk1.com1.z0.glb.clouddn.com/2018-08-27-intro_2x.png)\n\n### 阶段 3\n\n如果涉及到自己 App 端 Server 的参与，基本如下图所示：\n\n![IAP With Business Server](http://7xilk1.com1.z0.glb.clouddn.com/2018-08-29-1*MwLeHUGSupbb9j-oYQyflw.png)\n\n正常多出的几步：\n\n1. 获取 Product 标识列表；\n2. 客户端上传 Receipt 数据给 Server，Server 自行校验或者使用 Apple 的接口校验；\n3. Server 端告知给客户端付费内容\n\n\n### 注册商品\n\n商品注册是通过 iTunes Connect 后台进行的，其中商品类型需要提前明确好。\n\n#### 商品类型\n\n参与 App 内支付动作的商品有四种类型：\n\n- Consumable products （消耗型商品）\n- Non-consumable products （非消耗型商品）\n- Auto-renewable subscriptions （自动续约订阅）\n- Non-renewable subscriptions （非自动续约订阅）\n\n其中关于非自动续约订阅，App 的开发者有义务同步服务到用户的所有设备上。\n\n如下，是官方文档列出来的四种商品类型的一些主要属性。\n\n| Product type | Non-consumable | Consumable | Auto-renewable | Non-renewing\n| --- | --- | --- | --- | --- | \n| Users can buy | Once | Multiple times | Multiple times | Multiple times |\n| Appears in the receipt | Always | Once | Always | Always | \n| Synced across devices | By the system | Not synced | By the system | By your app |\n| Restored | By the system | Not restored |  By the system | By your app |\n\n其中需要注意的几点：\n\n1. 除了非消耗型商品只能买一次，再次购买应该会失败以外，其他三种类型（消耗型，连续/非连续订阅）都是可以无限制购买的，Apple 是不会报错的；\n2. 除了消耗型商品在 Receipt 中出现一次，其他三种类型（非消耗型，连续/非连续订阅）是始终都会在其中的，这也是后续做订阅校验至关重要的一环；\n\n### 获取 Product ID\n\n这里获取的是 Product 在 iTunes Connect 后台注册商品时填写的 Product ID\n\n![Product ID](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-15359854946888.png)\n\nIn-App Identifier 为每个可销售的商品提供一个唯一标识。在客户端上，我们可以直接写死代码:\n\n``` Swift\nlet identifiers = [\"com.myCompany.myApp.product1\", \"com.myCompany.myApp.product2\" ]\n```\n\n或者从 Server 端获取。\n\n### 获取商品信息\n\n然后通过上一步取得的 Product ID 来获取具体某个 Product 的详细信息，包括价格，描述等等。\n\n``` Swift\n// 获取一批商品的信息\n\nlet request = SKProductsRequest(productIdentifiers: identifierSet) \n\nrequest.delegate = self\n\nrequest.start()\n```\n\n在代理回调中处理获取的结果，进行展示或者 Cache。\n\n``` Swift\nfunc productRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {\n\n    for product in response.products {\n    \n    } \n} \n```\n\n官方建议是不要进行缓存，因为 Product 的信息有可能会更新，比如用户切换 AppStore 的区域，价格信息也会因为相应的汇率发生变化。不过！在国内，被牺牲最大的用户体验不是这种边界情况，而是获取 Product 信息是需要和 Apple Server 打交道的，这就有个问题 —— 慢！\n\n我们会在开机的时候提前预取所有 Product 信息，并且缓存起来。下次弹出充值面板的时候就直接列出商品信息即可。\n\n\n## 展示支付 UI\n\n接下来就看什么时候进行购买了，展示商品面板进行购买。用户在面板上进行选择之后，就进入了下一阶段 ── 支付\n\n## 发出购买请求\n\n这⼀步也很简单， 两⾏行代码就可以搞定。只需要把之前拿到的商品对象传到 `SKPayment` 的初始化方法中，构造一个 `SKPayment` 实例，再把这个实例加⼊到购买队列中即可:\n\n``` Swift\nlet payment = SKPayment(product: product) SKPaymentQueue.default().add(payment)\n```\n\n之后就交给 Apple 了，此时应用内会弹出苹果设计的购买窗口，用户只要使⽤指纹或者输入密码即可同意付款。\n\n\n## 处理购买结果\n\n当⽤户的购买请求经过 `StoreKit` 和苹果服务器的验证后，开发者可以在回调函数中接收到。Apple 具体的回调会通过 `SKPaymentQueue` 来进行，如下，我们需要在支付之前就向 `SKPaymentQueue` 中加入代理监听。\n\n``` Swift\nSKPaymentQueue.default().add(self)\n```\n\n你可以把具体的监听放在一个独立的类中完成。在该 Observer 中，实现代理方法：\n\n``` Swift\n// 处理理 SKPaymentQueueObserver 事件\n// MARK: - SKPaymentTransactionObserver\nfunc paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions:[SK PaymentTransaction]) {\n    for transaction in transactions {\n        switch transaction.transactionState { \n            case .purchased:\n            // Validate the purchase\n            \n            // Locate the file\n            guard let url = Bundle.main.appStoreReceiptURL else {\n                // Handle failure\n                return    \n            }\n\n            // Read the contents\n            let receipt = Data(contentsOf: url)\n        } \n    }\n} \n```\n\n对于每一个你提交的 Payment，就一定会有一个相应的 Transaction 生成以便其后续处理。通过检查 transaction 的状态，我们可以指定每种状态下的处理逻辑。如果状态显示已购买， 我们还是应该和⾃己的服务器器进行一次校验，确保交易真实有效⽽而不是通过越狱后的某些插件完成的。被检验的，是一种被苹果称之为收据(receipt)的凭证，就像我们在超市购物或者饭店就餐后拿到的收据一样，每⼀个购买的商品都有⾃己的收据。这个收据由苹果签发，保存在客户端本地。\n\n目前 Apple 官方提供两种方式，一种是本机校验，一种是 Server 端校验。\n\n![Receipt Validation Ways](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-E9DC4D03-7F18-49CC-B21D-835904E2B39F.png)\n\n\n## Final，投递商品\n\n当 Server 端检验完成之后，说明本地交易已经成功完成，因此将用户购买的内容提供给用户使用。当然，对于业务方，购买完成不代表业务完成，因此大多数情况下还有一步进行商品业务校验的过程。\n\n需要注意的一点是：\n\nApple 也明确告诉开发者有几个关键的路径节点需要注意：\n\n![关键路径](http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-C1BB8495-728D-43E7-9C40-8EC9B3A22905.png)\n\n监听交易状态的代码一定要越早越好，比如在 App 完成启动之后进行注册，确保整个生命周期内都有代码逻辑来处理监听到的交易，根据监听到的 Transaction 的状态来分发处理逻辑。因为很有可能你监听的时机太晚，导致 Apple 通知有一些之前未完成的交易的时候你无法捕获。说白了就是用户的购买流程跟 App 生命周期不挂钩导致的，典型的有以下几个场景\n\n1. 用户杀死了 App\n2. 用户需要更新帐号中的付费信息（此时已跳出 App ）\n3. App 闪退\n4. 用户进行了订阅续期\n5. 用户进入了推介促销价的流程\n6. 用户跳出 App 输入推广码\n\n## 结束交易\n\n在最后一步中，如果是正常的交易，那么简单的结束它们就⾏了。但对于其他异常的交易易，⽐比如出现了一些 error，也要妥善的结束它们。如果是⾃动续期的订阅，也会经过这一步。如果 交易没有被正确的结束，它们会一直停留留在上文提到的队列中，每次回调函数被调用时，队列 中都会有这些没有被结束的交易。也就是为什么需要提前监听的原因了。\n\n结束交易的代码⾮常简单，只有一行:\n\n``` Swift\nSKPaymentQueue.default().finishTransaction(transaction)\n```\n\n### 关于 Transaction 和 Receipt 的区别和联系\n\n很多同学在进行 IAP 开发的时候常常有一个很大的困惑就是 Transaction 和 Receipt 傻傻分不清楚，这里重新梳理了一下。\n\n#### 关于 Transaction\n\n其实前面讲 Payment 的操作的时候已经表明了， Transaction 是和具体的一次 Payment 对应的，也就是发生一次 Payment 就会生成 Transaction，但是，并不是 1 对 1 的关系，比如本次 Payment 对应的 Transaction 已经被 finish 了，用户换了手机，登陆同样 AppleID 的时候使用 Restore 功能，Apple 会生成 Transaction 给你，本次的 Transaction 就对应的之前的 Payment，只是状态标记为 .restored。\n\nTransaction 的状态主要有以下这么几种：\n\n| 状态 | 含义 |\n|:--|:--|\n| .purchasing | 不需要做什么，继续等待 SKPaymentTransactionState 的状态流转 |\n| .purchased | 用户已完成付费，处理付费后的流程并调用 finishTransaction 方法 |\n| .failed | 用户付费失败，处理付费失败的流程并调用 finishTransaction 方法 |\n| .restored | 用户付费成功，处理付费后的流程并调用 finishTransaction 方法 |\n| .deferred | 不需要做什么，继续等待 SKPaymentTransactionState 的状态流转 |\n\n\n**Note**: 对于 `finishTransaction` 的几点说明：\n\n1. 对于那些依赖苹果下载服务的，比如存储在 iTunes Connect 上的付费内容要下载到本地，如果下载完成之前就进行了 finish 动作会导致 Apple 阻断所有的下载流程，并且无法重新下载；\n2. Transaction 需要配合 Receipt 验证是否合法，单纯靠前端是不靠谱的，因此交由业务后端验证 Receipt 更安全合理，业务后端来决定是否需要 finish\n3. 文档里说：Your app needs to finish every transaction, regardless of whether the transaction succeeded or failed. 所以我们需要将 Transaction Finish 掉，否则会始终出现在 PaymentQueue 里，BUT，中间态的交易是不需要 finish 的，比如 .purchasing 和 .deferred\n\n\n#### 关于 Receipt\n\nReceipt 是 App Store 签发的，是你的 App 上和该 App 上发生的支付行为记录。它存储在设备上的某个固定地址，StoreKit 并不会生成它，它是从 App Store 拉取下来的一个文件。如图所示：\n\n``` Swift\n\nguard let url = Bundle.main.appStoreReceiptURL else {\n    // handle failure\n    return\n}\n\n// read the contents\nlet receipt = Data(contentsOf: url)\n```\n\n如果本地该地址里没有，我们还可以进行刷新，实质上就是从 App Store 请求 Receipt 数据。请求如下：\n\n``` Swift\nlet request = SKReceiptRefreshRequest()\n\nrequest.delegate = self\n\nrequest.start()\n```\n\n\n## 这里有几个需要注意的点：\n\n### 恢复已经购买的商品\n\n这里有一个需要注意的事情就是：如果一个用户试图去购买一个之前购买过的商\u0010品，而不是使用你App 提供的 Restore 功能恢复的话，App Store 会依然创建一个正常的新交易。用户是不会被再次收费的，这里的问题是，Transaction 的状态可不是 restored，而是完全新的 Transaction，你可以按照之前的正常流程走，当然对于自带账户体系的 App 来讲，需要自行判断和计算。\n\n\n## 参考资料：\n\n1. [In App Purchase](https://developer.apple.com/in-app-purchase/)\n2. [In-App Purchase Programming Guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Introduction.html)\n3. [Receipt Validation Programming Guide](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html)\n4. [How to detect refunded IAPs from receipts?](https://forums.developer.apple.com/thread/46737)\n5. [Check if a non-renewable subscription was refunded by Apple?](https://stackoverflow.com/questions/10771240/check-if-a-non-renewable-subscription-was-refunded-by-apple)\n6. [How does Apple notify iOS apps of refunds of in-app purchases (IAP)?](https://stackoverflow.com/questions/6439482/how-does-apple-notify-ios-apps-of-refunds-of-in-app-purchases-iap)","slug":"In-App-Purchase","published":1,"updated":"2018-10-07T11:09:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftbi004h79po2sohtkxj","content":"<p>对于在 App Store 中上架的应⽤来说，应⽤内购买(In-App Purchase，简称 IAP) 应该是一个避不开的话题，尤其是去年微信打赏和 Apple 之间的争执更让 IAP 火了一把，不仅仅大公司，作为个人开发者来讲，IAP 也是非常重要的，说不定就是你养家糊口的工具呢。</p>\n<a id=\"more\"></a>\n<p>整个 IAP 的过程，在客户端的实现依赖于 <code>StoreKit</code> 这个框架，所有的支付相关操作都是交由 StoreKit 来完成的。</p>\n<p>首先，我们先复习一下 IAP 的整个流程。</p>\n<h2 id=\"In-App-Purchase-的整体流程\"><a href=\"#In-App-Purchase-的整体流程\" class=\"headerlink\" title=\"In App Purchase 的整体流程\"></a>In App Purchase 的整体流程</h2><h3 id=\"阶段-1\"><a href=\"#阶段-1\" class=\"headerlink\" title=\"阶段 1\"></a>阶段 1</h3><p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-4DDE8387-EDB1-42CC-B18C-3DC6CA1DC688.png\" alt=\"In App Purchase 过程\"></p>\n<ol>\n<li>加载 In-App Identifier</li>\n<li>客户端从 AppStore 中获取本地化的商品信息。</li>\n<li>把 IAP 的购买界⾯面展示给⽤用户，⽤用户可以同意购买并点击购买按钮。</li>\n<li>⽤用户授权购买，客户端向服务器器发送购买请求。</li>\n<li>服务器器处理理购买请求，并把结果返回给 StoreKit。</li>\n<li>如果购买请求验证通过，客户端此时解锁内容或者提供⾦金金币。</li>\n<li>至此，整个交易易流程结束。</li>\n</ol>\n<h3 id=\"阶段-2\"><a href=\"#阶段-2\" class=\"headerlink\" title=\"阶段 2\"></a>阶段 2</h3><p>具体到和 Apple Store 打交道的话，如下所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-08-27-intro_2x.png\" alt=\"IAP With App Store\"></p>\n<h3 id=\"阶段-3\"><a href=\"#阶段-3\" class=\"headerlink\" title=\"阶段 3\"></a>阶段 3</h3><p>如果涉及到自己 App 端 Server 的参与，基本如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-08-29-1*MwLeHUGSupbb9j-oYQyflw.png\" alt=\"IAP With Business Server\"></p>\n<p>正常多出的几步：</p>\n<ol>\n<li>获取 Product 标识列表；</li>\n<li>客户端上传 Receipt 数据给 Server，Server 自行校验或者使用 Apple 的接口校验；</li>\n<li>Server 端告知给客户端付费内容</li>\n</ol>\n<h3 id=\"注册商品\"><a href=\"#注册商品\" class=\"headerlink\" title=\"注册商品\"></a>注册商品</h3><p>商品注册是通过 iTunes Connect 后台进行的，其中商品类型需要提前明确好。</p>\n<h4 id=\"商品类型\"><a href=\"#商品类型\" class=\"headerlink\" title=\"商品类型\"></a>商品类型</h4><p>参与 App 内支付动作的商品有四种类型：</p>\n<ul>\n<li>Consumable products （消耗型商品）</li>\n<li>Non-consumable products （非消耗型商品）</li>\n<li>Auto-renewable subscriptions （自动续约订阅）</li>\n<li>Non-renewable subscriptions （非自动续约订阅）</li>\n</ul>\n<p>其中关于非自动续约订阅，App 的开发者有义务同步服务到用户的所有设备上。</p>\n<p>如下，是官方文档列出来的四种商品类型的一些主要属性。</p>\n<table>\n<thead>\n<tr>\n<th>Product type</th>\n<th>Non-consumable</th>\n<th>Consumable</th>\n<th>Auto-renewable</th>\n<th>Non-renewing</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Users can buy</td>\n<td>Once</td>\n<td>Multiple times</td>\n<td>Multiple times</td>\n<td>Multiple times</td>\n</tr>\n<tr>\n<td>Appears in the receipt</td>\n<td>Always</td>\n<td>Once</td>\n<td>Always</td>\n<td>Always</td>\n</tr>\n<tr>\n<td>Synced across devices</td>\n<td>By the system</td>\n<td>Not synced</td>\n<td>By the system</td>\n<td>By your app</td>\n</tr>\n<tr>\n<td>Restored</td>\n<td>By the system</td>\n<td>Not restored</td>\n<td>By the system</td>\n<td>By your app</td>\n</tr>\n</tbody>\n</table>\n<p>其中需要注意的几点：</p>\n<ol>\n<li>除了非消耗型商品只能买一次，再次购买应该会失败以外，其他三种类型（消耗型，连续/非连续订阅）都是可以无限制购买的，Apple 是不会报错的；</li>\n<li>除了消耗型商品在 Receipt 中出现一次，其他三种类型（非消耗型，连续/非连续订阅）是始终都会在其中的，这也是后续做订阅校验至关重要的一环；</li>\n</ol>\n<h3 id=\"获取-Product-ID\"><a href=\"#获取-Product-ID\" class=\"headerlink\" title=\"获取 Product ID\"></a>获取 Product ID</h3><p>这里获取的是 Product 在 iTunes Connect 后台注册商品时填写的 Product ID</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-15359854946888.png\" alt=\"Product ID\"></p>\n<p>In-App Identifier 为每个可销售的商品提供一个唯一标识。在客户端上，我们可以直接写死代码:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identifiers = [<span class=\"string\">\"com.myCompany.myApp.product1\"</span>, <span class=\"string\">\"com.myCompany.myApp.product2\"</span> ]</span><br></pre></td></tr></table></figure>\n<p>或者从 Server 端获取。</p>\n<h3 id=\"获取商品信息\"><a href=\"#获取商品信息\" class=\"headerlink\" title=\"获取商品信息\"></a>获取商品信息</h3><p>然后通过上一步取得的 Product ID 来获取具体某个 Product 的详细信息，包括价格，描述等等。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取一批商品的信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">SKProductsRequest</span>(productIdentifiers: identifierSet) </span><br><span class=\"line\"></span><br><span class=\"line\">request.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\">request.start()</span><br></pre></td></tr></table></figure>\n<p>在代理回调中处理获取的结果，进行展示或者 Cache。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">productRequest</span><span class=\"params\">(<span class=\"number\">_</span> request: SKProductsRequest, didReceive response: SKProductsResponse)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> product <span class=\"keyword\">in</span> response.products &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>官方建议是不要进行缓存，因为 Product 的信息有可能会更新，比如用户切换 AppStore 的区域，价格信息也会因为相应的汇率发生变化。不过！在国内，被牺牲最大的用户体验不是这种边界情况，而是获取 Product 信息是需要和 Apple Server 打交道的，这就有个问题 —— 慢！</p>\n<p>我们会在开机的时候提前预取所有 Product 信息，并且缓存起来。下次弹出充值面板的时候就直接列出商品信息即可。</p>\n<h2 id=\"展示支付-UI\"><a href=\"#展示支付-UI\" class=\"headerlink\" title=\"展示支付 UI\"></a>展示支付 UI</h2><p>接下来就看什么时候进行购买了，展示商品面板进行购买。用户在面板上进行选择之后，就进入了下一阶段 ── 支付</p>\n<h2 id=\"发出购买请求\"><a href=\"#发出购买请求\" class=\"headerlink\" title=\"发出购买请求\"></a>发出购买请求</h2><p>这⼀步也很简单， 两⾏行代码就可以搞定。只需要把之前拿到的商品对象传到 <code>SKPayment</code> 的初始化方法中，构造一个 <code>SKPayment</code> 实例，再把这个实例加⼊到购买队列中即可:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> payment = <span class=\"type\">SKPayment</span>(product: product) <span class=\"type\">SKPaymentQueue</span>.<span class=\"keyword\">default</span>().add(payment)</span><br></pre></td></tr></table></figure>\n<p>之后就交给 Apple 了，此时应用内会弹出苹果设计的购买窗口，用户只要使⽤指纹或者输入密码即可同意付款。</p>\n<h2 id=\"处理购买结果\"><a href=\"#处理购买结果\" class=\"headerlink\" title=\"处理购买结果\"></a>处理购买结果</h2><p>当⽤户的购买请求经过 <code>StoreKit</code> 和苹果服务器的验证后，开发者可以在回调函数中接收到。Apple 具体的回调会通过 <code>SKPaymentQueue</code> 来进行，如下，我们需要在支付之前就向 <code>SKPaymentQueue</code> 中加入代理监听。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SKPaymentQueue</span>.<span class=\"keyword\">default</span>().add(<span class=\"keyword\">self</span>)</span><br></pre></td></tr></table></figure>\n<p>你可以把具体的监听放在一个独立的类中完成。在该 Observer 中，实现代理方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理理 SKPaymentQueueObserver 事件</span></span><br><span class=\"line\"><span class=\"comment\">// MARK: - SKPaymentTransactionObserver</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">paymentQueue</span><span class=\"params\">(<span class=\"number\">_</span> queue: SKPaymentQueue, updatedTransactions transactions:[SK PaymentTransaction])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> transaction <span class=\"keyword\">in</span> transactions &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> transaction.transactionState &#123; </span><br><span class=\"line\">            <span class=\"keyword\">case</span> .purchased:</span><br><span class=\"line\">            <span class=\"comment\">// Validate the purchase</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// Locate the file</span></span><br><span class=\"line\">            <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> url = <span class=\"type\">Bundle</span>.main.appStoreReceiptURL <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Handle failure</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Read the contents</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> receipt = <span class=\"type\">Data</span>(contentsOf: url)</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于每一个你提交的 Payment，就一定会有一个相应的 Transaction 生成以便其后续处理。通过检查 transaction 的状态，我们可以指定每种状态下的处理逻辑。如果状态显示已购买， 我们还是应该和⾃己的服务器器进行一次校验，确保交易真实有效⽽而不是通过越狱后的某些插件完成的。被检验的，是一种被苹果称之为收据(receipt)的凭证，就像我们在超市购物或者饭店就餐后拿到的收据一样，每⼀个购买的商品都有⾃己的收据。这个收据由苹果签发，保存在客户端本地。</p>\n<p>目前 Apple 官方提供两种方式，一种是本机校验，一种是 Server 端校验。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-E9DC4D03-7F18-49CC-B21D-835904E2B39F.png\" alt=\"Receipt Validation Ways\"></p>\n<h2 id=\"Final，投递商品\"><a href=\"#Final，投递商品\" class=\"headerlink\" title=\"Final，投递商品\"></a>Final，投递商品</h2><p>当 Server 端检验完成之后，说明本地交易已经成功完成，因此将用户购买的内容提供给用户使用。当然，对于业务方，购买完成不代表业务完成，因此大多数情况下还有一步进行商品业务校验的过程。</p>\n<p>需要注意的一点是：</p>\n<p>Apple 也明确告诉开发者有几个关键的路径节点需要注意：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-C1BB8495-728D-43E7-9C40-8EC9B3A22905.png\" alt=\"关键路径\"></p>\n<p>监听交易状态的代码一定要越早越好，比如在 App 完成启动之后进行注册，确保整个生命周期内都有代码逻辑来处理监听到的交易，根据监听到的 Transaction 的状态来分发处理逻辑。因为很有可能你监听的时机太晚，导致 Apple 通知有一些之前未完成的交易的时候你无法捕获。说白了就是用户的购买流程跟 App 生命周期不挂钩导致的，典型的有以下几个场景</p>\n<ol>\n<li>用户杀死了 App</li>\n<li>用户需要更新帐号中的付费信息（此时已跳出 App ）</li>\n<li>App 闪退</li>\n<li>用户进行了订阅续期</li>\n<li>用户进入了推介促销价的流程</li>\n<li>用户跳出 App 输入推广码</li>\n</ol>\n<h2 id=\"结束交易\"><a href=\"#结束交易\" class=\"headerlink\" title=\"结束交易\"></a>结束交易</h2><p>在最后一步中，如果是正常的交易，那么简单的结束它们就⾏了。但对于其他异常的交易易，⽐比如出现了一些 error，也要妥善的结束它们。如果是⾃动续期的订阅，也会经过这一步。如果 交易没有被正确的结束，它们会一直停留留在上文提到的队列中，每次回调函数被调用时，队列 中都会有这些没有被结束的交易。也就是为什么需要提前监听的原因了。</p>\n<p>结束交易的代码⾮常简单，只有一行:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SKPaymentQueue</span>.<span class=\"keyword\">default</span>().finishTransaction(transaction)</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于-Transaction-和-Receipt-的区别和联系\"><a href=\"#关于-Transaction-和-Receipt-的区别和联系\" class=\"headerlink\" title=\"关于 Transaction 和 Receipt 的区别和联系\"></a>关于 Transaction 和 Receipt 的区别和联系</h3><p>很多同学在进行 IAP 开发的时候常常有一个很大的困惑就是 Transaction 和 Receipt 傻傻分不清楚，这里重新梳理了一下。</p>\n<h4 id=\"关于-Transaction\"><a href=\"#关于-Transaction\" class=\"headerlink\" title=\"关于 Transaction\"></a>关于 Transaction</h4><p>其实前面讲 Payment 的操作的时候已经表明了， Transaction 是和具体的一次 Payment 对应的，也就是发生一次 Payment 就会生成 Transaction，但是，并不是 1 对 1 的关系，比如本次 Payment 对应的 Transaction 已经被 finish 了，用户换了手机，登陆同样 AppleID 的时候使用 Restore 功能，Apple 会生成 Transaction 给你，本次的 Transaction 就对应的之前的 Payment，只是状态标记为 .restored。</p>\n<p>Transaction 的状态主要有以下这么几种：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">.purchasing</td>\n<td style=\"text-align:left\">不需要做什么，继续等待 SKPaymentTransactionState 的状态流转</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.purchased</td>\n<td style=\"text-align:left\">用户已完成付费，处理付费后的流程并调用 finishTransaction 方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.failed</td>\n<td style=\"text-align:left\">用户付费失败，处理付费失败的流程并调用 finishTransaction 方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.restored</td>\n<td style=\"text-align:left\">用户付费成功，处理付费后的流程并调用 finishTransaction 方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.deferred</td>\n<td style=\"text-align:left\">不需要做什么，继续等待 SKPaymentTransactionState 的状态流转</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Note</strong>: 对于 <code>finishTransaction</code> 的几点说明：</p>\n<ol>\n<li>对于那些依赖苹果下载服务的，比如存储在 iTunes Connect 上的付费内容要下载到本地，如果下载完成之前就进行了 finish 动作会导致 Apple 阻断所有的下载流程，并且无法重新下载；</li>\n<li>Transaction 需要配合 Receipt 验证是否合法，单纯靠前端是不靠谱的，因此交由业务后端验证 Receipt 更安全合理，业务后端来决定是否需要 finish</li>\n<li>文档里说：Your app needs to finish every transaction, regardless of whether the transaction succeeded or failed. 所以我们需要将 Transaction Finish 掉，否则会始终出现在 PaymentQueue 里，BUT，中间态的交易是不需要 finish 的，比如 .purchasing 和 .deferred</li>\n</ol>\n<h4 id=\"关于-Receipt\"><a href=\"#关于-Receipt\" class=\"headerlink\" title=\"关于 Receipt\"></a>关于 Receipt</h4><p>Receipt 是 App Store 签发的，是你的 App 上和该 App 上发生的支付行为记录。它存储在设备上的某个固定地址，StoreKit 并不会生成它，它是从 App Store 拉取下来的一个文件。如图所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> url = <span class=\"type\">Bundle</span>.main.appStoreReceiptURL <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle failure</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// read the contents</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> receipt = <span class=\"type\">Data</span>(contentsOf: url)</span><br></pre></td></tr></table></figure>\n<p>如果本地该地址里没有，我们还可以进行刷新，实质上就是从 App Store 请求 Receipt 数据。请求如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">SKReceiptRefreshRequest</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">request.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\">request.start()</span><br></pre></td></tr></table></figure>\n<h2 id=\"这里有几个需要注意的点：\"><a href=\"#这里有几个需要注意的点：\" class=\"headerlink\" title=\"这里有几个需要注意的点：\"></a>这里有几个需要注意的点：</h2><h3 id=\"恢复已经购买的商品\"><a href=\"#恢复已经购买的商品\" class=\"headerlink\" title=\"恢复已经购买的商品\"></a>恢复已经购买的商品</h3><p>这里有一个需要注意的事情就是：如果一个用户试图去购买一个之前购买过的商\u0010品，而不是使用你App 提供的 Restore 功能恢复的话，App Store 会依然创建一个正常的新交易。用户是不会被再次收费的，这里的问题是，Transaction 的状态可不是 restored，而是完全新的 Transaction，你可以按照之前的正常流程走，当然对于自带账户体系的 App 来讲，需要自行判断和计算。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ol>\n<li><a href=\"https://developer.apple.com/in-app-purchase/\" target=\"_blank\" rel=\"noopener\">In App Purchase</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Introduction.html\" target=\"_blank\" rel=\"noopener\">In-App Purchase Programming Guide</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html\" target=\"_blank\" rel=\"noopener\">Receipt Validation Programming Guide</a></li>\n<li><a href=\"https://forums.developer.apple.com/thread/46737\" target=\"_blank\" rel=\"noopener\">How to detect refunded IAPs from receipts?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10771240/check-if-a-non-renewable-subscription-was-refunded-by-apple\" target=\"_blank\" rel=\"noopener\">Check if a non-renewable subscription was refunded by Apple?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/6439482/how-does-apple-notify-ios-apps-of-refunds-of-in-app-purchases-iap\" target=\"_blank\" rel=\"noopener\">How does Apple notify iOS apps of refunds of in-app purchases (IAP)?</a></li>\n</ol>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>对于在 App Store 中上架的应⽤来说，应⽤内购买(In-App Purchase，简称 IAP) 应该是一个避不开的话题，尤其是去年微信打赏和 Apple 之间的争执更让 IAP 火了一把，不仅仅大公司，作为个人开发者来讲，IAP 也是非常重要的，说不定就是你养家糊口的工具呢。</p>","more":"<p>整个 IAP 的过程，在客户端的实现依赖于 <code>StoreKit</code> 这个框架，所有的支付相关操作都是交由 StoreKit 来完成的。</p>\n<p>首先，我们先复习一下 IAP 的整个流程。</p>\n<h2 id=\"In-App-Purchase-的整体流程\"><a href=\"#In-App-Purchase-的整体流程\" class=\"headerlink\" title=\"In App Purchase 的整体流程\"></a>In App Purchase 的整体流程</h2><h3 id=\"阶段-1\"><a href=\"#阶段-1\" class=\"headerlink\" title=\"阶段 1\"></a>阶段 1</h3><p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-4DDE8387-EDB1-42CC-B18C-3DC6CA1DC688.png\" alt=\"In App Purchase 过程\"></p>\n<ol>\n<li>加载 In-App Identifier</li>\n<li>客户端从 AppStore 中获取本地化的商品信息。</li>\n<li>把 IAP 的购买界⾯面展示给⽤用户，⽤用户可以同意购买并点击购买按钮。</li>\n<li>⽤用户授权购买，客户端向服务器器发送购买请求。</li>\n<li>服务器器处理理购买请求，并把结果返回给 StoreKit。</li>\n<li>如果购买请求验证通过，客户端此时解锁内容或者提供⾦金金币。</li>\n<li>至此，整个交易易流程结束。</li>\n</ol>\n<h3 id=\"阶段-2\"><a href=\"#阶段-2\" class=\"headerlink\" title=\"阶段 2\"></a>阶段 2</h3><p>具体到和 Apple Store 打交道的话，如下所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-08-27-intro_2x.png\" alt=\"IAP With App Store\"></p>\n<h3 id=\"阶段-3\"><a href=\"#阶段-3\" class=\"headerlink\" title=\"阶段 3\"></a>阶段 3</h3><p>如果涉及到自己 App 端 Server 的参与，基本如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-08-29-1*MwLeHUGSupbb9j-oYQyflw.png\" alt=\"IAP With Business Server\"></p>\n<p>正常多出的几步：</p>\n<ol>\n<li>获取 Product 标识列表；</li>\n<li>客户端上传 Receipt 数据给 Server，Server 自行校验或者使用 Apple 的接口校验；</li>\n<li>Server 端告知给客户端付费内容</li>\n</ol>\n<h3 id=\"注册商品\"><a href=\"#注册商品\" class=\"headerlink\" title=\"注册商品\"></a>注册商品</h3><p>商品注册是通过 iTunes Connect 后台进行的，其中商品类型需要提前明确好。</p>\n<h4 id=\"商品类型\"><a href=\"#商品类型\" class=\"headerlink\" title=\"商品类型\"></a>商品类型</h4><p>参与 App 内支付动作的商品有四种类型：</p>\n<ul>\n<li>Consumable products （消耗型商品）</li>\n<li>Non-consumable products （非消耗型商品）</li>\n<li>Auto-renewable subscriptions （自动续约订阅）</li>\n<li>Non-renewable subscriptions （非自动续约订阅）</li>\n</ul>\n<p>其中关于非自动续约订阅，App 的开发者有义务同步服务到用户的所有设备上。</p>\n<p>如下，是官方文档列出来的四种商品类型的一些主要属性。</p>\n<table>\n<thead>\n<tr>\n<th>Product type</th>\n<th>Non-consumable</th>\n<th>Consumable</th>\n<th>Auto-renewable</th>\n<th>Non-renewing</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Users can buy</td>\n<td>Once</td>\n<td>Multiple times</td>\n<td>Multiple times</td>\n<td>Multiple times</td>\n</tr>\n<tr>\n<td>Appears in the receipt</td>\n<td>Always</td>\n<td>Once</td>\n<td>Always</td>\n<td>Always</td>\n</tr>\n<tr>\n<td>Synced across devices</td>\n<td>By the system</td>\n<td>Not synced</td>\n<td>By the system</td>\n<td>By your app</td>\n</tr>\n<tr>\n<td>Restored</td>\n<td>By the system</td>\n<td>Not restored</td>\n<td>By the system</td>\n<td>By your app</td>\n</tr>\n</tbody>\n</table>\n<p>其中需要注意的几点：</p>\n<ol>\n<li>除了非消耗型商品只能买一次，再次购买应该会失败以外，其他三种类型（消耗型，连续/非连续订阅）都是可以无限制购买的，Apple 是不会报错的；</li>\n<li>除了消耗型商品在 Receipt 中出现一次，其他三种类型（非消耗型，连续/非连续订阅）是始终都会在其中的，这也是后续做订阅校验至关重要的一环；</li>\n</ol>\n<h3 id=\"获取-Product-ID\"><a href=\"#获取-Product-ID\" class=\"headerlink\" title=\"获取 Product ID\"></a>获取 Product ID</h3><p>这里获取的是 Product 在 iTunes Connect 后台注册商品时填写的 Product ID</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-15359854946888.png\" alt=\"Product ID\"></p>\n<p>In-App Identifier 为每个可销售的商品提供一个唯一标识。在客户端上，我们可以直接写死代码:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identifiers = [<span class=\"string\">\"com.myCompany.myApp.product1\"</span>, <span class=\"string\">\"com.myCompany.myApp.product2\"</span> ]</span><br></pre></td></tr></table></figure>\n<p>或者从 Server 端获取。</p>\n<h3 id=\"获取商品信息\"><a href=\"#获取商品信息\" class=\"headerlink\" title=\"获取商品信息\"></a>获取商品信息</h3><p>然后通过上一步取得的 Product ID 来获取具体某个 Product 的详细信息，包括价格，描述等等。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取一批商品的信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">SKProductsRequest</span>(productIdentifiers: identifierSet) </span><br><span class=\"line\"></span><br><span class=\"line\">request.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\">request.start()</span><br></pre></td></tr></table></figure>\n<p>在代理回调中处理获取的结果，进行展示或者 Cache。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">productRequest</span><span class=\"params\">(<span class=\"number\">_</span> request: SKProductsRequest, didReceive response: SKProductsResponse)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> product <span class=\"keyword\">in</span> response.products &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>官方建议是不要进行缓存，因为 Product 的信息有可能会更新，比如用户切换 AppStore 的区域，价格信息也会因为相应的汇率发生变化。不过！在国内，被牺牲最大的用户体验不是这种边界情况，而是获取 Product 信息是需要和 Apple Server 打交道的，这就有个问题 —— 慢！</p>\n<p>我们会在开机的时候提前预取所有 Product 信息，并且缓存起来。下次弹出充值面板的时候就直接列出商品信息即可。</p>\n<h2 id=\"展示支付-UI\"><a href=\"#展示支付-UI\" class=\"headerlink\" title=\"展示支付 UI\"></a>展示支付 UI</h2><p>接下来就看什么时候进行购买了，展示商品面板进行购买。用户在面板上进行选择之后，就进入了下一阶段 ── 支付</p>\n<h2 id=\"发出购买请求\"><a href=\"#发出购买请求\" class=\"headerlink\" title=\"发出购买请求\"></a>发出购买请求</h2><p>这⼀步也很简单， 两⾏行代码就可以搞定。只需要把之前拿到的商品对象传到 <code>SKPayment</code> 的初始化方法中，构造一个 <code>SKPayment</code> 实例，再把这个实例加⼊到购买队列中即可:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> payment = <span class=\"type\">SKPayment</span>(product: product) <span class=\"type\">SKPaymentQueue</span>.<span class=\"keyword\">default</span>().add(payment)</span><br></pre></td></tr></table></figure>\n<p>之后就交给 Apple 了，此时应用内会弹出苹果设计的购买窗口，用户只要使⽤指纹或者输入密码即可同意付款。</p>\n<h2 id=\"处理购买结果\"><a href=\"#处理购买结果\" class=\"headerlink\" title=\"处理购买结果\"></a>处理购买结果</h2><p>当⽤户的购买请求经过 <code>StoreKit</code> 和苹果服务器的验证后，开发者可以在回调函数中接收到。Apple 具体的回调会通过 <code>SKPaymentQueue</code> 来进行，如下，我们需要在支付之前就向 <code>SKPaymentQueue</code> 中加入代理监听。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SKPaymentQueue</span>.<span class=\"keyword\">default</span>().add(<span class=\"keyword\">self</span>)</span><br></pre></td></tr></table></figure>\n<p>你可以把具体的监听放在一个独立的类中完成。在该 Observer 中，实现代理方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理理 SKPaymentQueueObserver 事件</span></span><br><span class=\"line\"><span class=\"comment\">// MARK: - SKPaymentTransactionObserver</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">paymentQueue</span><span class=\"params\">(<span class=\"number\">_</span> queue: SKPaymentQueue, updatedTransactions transactions:[SK PaymentTransaction])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> transaction <span class=\"keyword\">in</span> transactions &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> transaction.transactionState &#123; </span><br><span class=\"line\">            <span class=\"keyword\">case</span> .purchased:</span><br><span class=\"line\">            <span class=\"comment\">// Validate the purchase</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// Locate the file</span></span><br><span class=\"line\">            <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> url = <span class=\"type\">Bundle</span>.main.appStoreReceiptURL <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Handle failure</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>    </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Read the contents</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> receipt = <span class=\"type\">Data</span>(contentsOf: url)</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于每一个你提交的 Payment，就一定会有一个相应的 Transaction 生成以便其后续处理。通过检查 transaction 的状态，我们可以指定每种状态下的处理逻辑。如果状态显示已购买， 我们还是应该和⾃己的服务器器进行一次校验，确保交易真实有效⽽而不是通过越狱后的某些插件完成的。被检验的，是一种被苹果称之为收据(receipt)的凭证，就像我们在超市购物或者饭店就餐后拿到的收据一样，每⼀个购买的商品都有⾃己的收据。这个收据由苹果签发，保存在客户端本地。</p>\n<p>目前 Apple 官方提供两种方式，一种是本机校验，一种是 Server 端校验。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-E9DC4D03-7F18-49CC-B21D-835904E2B39F.png\" alt=\"Receipt Validation Ways\"></p>\n<h2 id=\"Final，投递商品\"><a href=\"#Final，投递商品\" class=\"headerlink\" title=\"Final，投递商品\"></a>Final，投递商品</h2><p>当 Server 端检验完成之后，说明本地交易已经成功完成，因此将用户购买的内容提供给用户使用。当然，对于业务方，购买完成不代表业务完成，因此大多数情况下还有一步进行商品业务校验的过程。</p>\n<p>需要注意的一点是：</p>\n<p>Apple 也明确告诉开发者有几个关键的路径节点需要注意：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-C1BB8495-728D-43E7-9C40-8EC9B3A22905.png\" alt=\"关键路径\"></p>\n<p>监听交易状态的代码一定要越早越好，比如在 App 完成启动之后进行注册，确保整个生命周期内都有代码逻辑来处理监听到的交易，根据监听到的 Transaction 的状态来分发处理逻辑。因为很有可能你监听的时机太晚，导致 Apple 通知有一些之前未完成的交易的时候你无法捕获。说白了就是用户的购买流程跟 App 生命周期不挂钩导致的，典型的有以下几个场景</p>\n<ol>\n<li>用户杀死了 App</li>\n<li>用户需要更新帐号中的付费信息（此时已跳出 App ）</li>\n<li>App 闪退</li>\n<li>用户进行了订阅续期</li>\n<li>用户进入了推介促销价的流程</li>\n<li>用户跳出 App 输入推广码</li>\n</ol>\n<h2 id=\"结束交易\"><a href=\"#结束交易\" class=\"headerlink\" title=\"结束交易\"></a>结束交易</h2><p>在最后一步中，如果是正常的交易，那么简单的结束它们就⾏了。但对于其他异常的交易易，⽐比如出现了一些 error，也要妥善的结束它们。如果是⾃动续期的订阅，也会经过这一步。如果 交易没有被正确的结束，它们会一直停留留在上文提到的队列中，每次回调函数被调用时，队列 中都会有这些没有被结束的交易。也就是为什么需要提前监听的原因了。</p>\n<p>结束交易的代码⾮常简单，只有一行:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SKPaymentQueue</span>.<span class=\"keyword\">default</span>().finishTransaction(transaction)</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于-Transaction-和-Receipt-的区别和联系\"><a href=\"#关于-Transaction-和-Receipt-的区别和联系\" class=\"headerlink\" title=\"关于 Transaction 和 Receipt 的区别和联系\"></a>关于 Transaction 和 Receipt 的区别和联系</h3><p>很多同学在进行 IAP 开发的时候常常有一个很大的困惑就是 Transaction 和 Receipt 傻傻分不清楚，这里重新梳理了一下。</p>\n<h4 id=\"关于-Transaction\"><a href=\"#关于-Transaction\" class=\"headerlink\" title=\"关于 Transaction\"></a>关于 Transaction</h4><p>其实前面讲 Payment 的操作的时候已经表明了， Transaction 是和具体的一次 Payment 对应的，也就是发生一次 Payment 就会生成 Transaction，但是，并不是 1 对 1 的关系，比如本次 Payment 对应的 Transaction 已经被 finish 了，用户换了手机，登陆同样 AppleID 的时候使用 Restore 功能，Apple 会生成 Transaction 给你，本次的 Transaction 就对应的之前的 Payment，只是状态标记为 .restored。</p>\n<p>Transaction 的状态主要有以下这么几种：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">.purchasing</td>\n<td style=\"text-align:left\">不需要做什么，继续等待 SKPaymentTransactionState 的状态流转</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.purchased</td>\n<td style=\"text-align:left\">用户已完成付费，处理付费后的流程并调用 finishTransaction 方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.failed</td>\n<td style=\"text-align:left\">用户付费失败，处理付费失败的流程并调用 finishTransaction 方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.restored</td>\n<td style=\"text-align:left\">用户付费成功，处理付费后的流程并调用 finishTransaction 方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">.deferred</td>\n<td style=\"text-align:left\">不需要做什么，继续等待 SKPaymentTransactionState 的状态流转</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Note</strong>: 对于 <code>finishTransaction</code> 的几点说明：</p>\n<ol>\n<li>对于那些依赖苹果下载服务的，比如存储在 iTunes Connect 上的付费内容要下载到本地，如果下载完成之前就进行了 finish 动作会导致 Apple 阻断所有的下载流程，并且无法重新下载；</li>\n<li>Transaction 需要配合 Receipt 验证是否合法，单纯靠前端是不靠谱的，因此交由业务后端验证 Receipt 更安全合理，业务后端来决定是否需要 finish</li>\n<li>文档里说：Your app needs to finish every transaction, regardless of whether the transaction succeeded or failed. 所以我们需要将 Transaction Finish 掉，否则会始终出现在 PaymentQueue 里，BUT，中间态的交易是不需要 finish 的，比如 .purchasing 和 .deferred</li>\n</ol>\n<h4 id=\"关于-Receipt\"><a href=\"#关于-Receipt\" class=\"headerlink\" title=\"关于 Receipt\"></a>关于 Receipt</h4><p>Receipt 是 App Store 签发的，是你的 App 上和该 App 上发生的支付行为记录。它存储在设备上的某个固定地址，StoreKit 并不会生成它，它是从 App Store 拉取下来的一个文件。如图所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> url = <span class=\"type\">Bundle</span>.main.appStoreReceiptURL <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle failure</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// read the contents</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> receipt = <span class=\"type\">Data</span>(contentsOf: url)</span><br></pre></td></tr></table></figure>\n<p>如果本地该地址里没有，我们还可以进行刷新，实质上就是从 App Store 请求 Receipt 数据。请求如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">SKReceiptRefreshRequest</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">request.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\"></span><br><span class=\"line\">request.start()</span><br></pre></td></tr></table></figure>\n<h2 id=\"这里有几个需要注意的点：\"><a href=\"#这里有几个需要注意的点：\" class=\"headerlink\" title=\"这里有几个需要注意的点：\"></a>这里有几个需要注意的点：</h2><h3 id=\"恢复已经购买的商品\"><a href=\"#恢复已经购买的商品\" class=\"headerlink\" title=\"恢复已经购买的商品\"></a>恢复已经购买的商品</h3><p>这里有一个需要注意的事情就是：如果一个用户试图去购买一个之前购买过的商\u0010品，而不是使用你App 提供的 Restore 功能恢复的话，App Store 会依然创建一个正常的新交易。用户是不会被再次收费的，这里的问题是，Transaction 的状态可不是 restored，而是完全新的 Transaction，你可以按照之前的正常流程走，当然对于自带账户体系的 App 来讲，需要自行判断和计算。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ol>\n<li><a href=\"https://developer.apple.com/in-app-purchase/\" target=\"_blank\" rel=\"noopener\">In App Purchase</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Introduction.html\" target=\"_blank\" rel=\"noopener\">In-App Purchase Programming Guide</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html\" target=\"_blank\" rel=\"noopener\">Receipt Validation Programming Guide</a></li>\n<li><a href=\"https://forums.developer.apple.com/thread/46737\" target=\"_blank\" rel=\"noopener\">How to detect refunded IAPs from receipts?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10771240/check-if-a-non-renewable-subscription-was-refunded-by-apple\" target=\"_blank\" rel=\"noopener\">Check if a non-renewable subscription was refunded by Apple?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/6439482/how-does-apple-notify-ios-apps-of-refunds-of-in-app-purchases-iap\" target=\"_blank\" rel=\"noopener\">How does Apple notify iOS apps of refunds of in-app purchases (IAP)?</a></li>\n</ol>"},{"title":"那些我恢复 Mac 系统之后要安装的 Apps","date":"2018-07-11T04:58:37.000Z","top_img":null,"_content":"\n记录一下自己常用的 Mac Apps，每次重装之后到了用的时候发现忘记安装了(不是每次都用 TimeMachine 恢复)，而且强烈简易大家如果某个 App 有对应的独立安装版本的话，购买其独立安装版本为好，沙盒环境以及和 Apple ID 绑定的特性就使得功能性以及灵活度大减。\n\n<!-- more -->\n\n> 更新时间 2018-10-07\n> 更换图床，更新图片\n\n> 更新时间 2018-08-10 \n> 不久前，已经订阅了一年的 Setapp，发现上面好多 App 自己都之前买过了，Sigh！\n> 如果你使用 Ulysses 或者 MoneyWiz 3.0 的话，订阅 Setapp 就会非常的值得！\n\n![Mac Apps](https://i.imgur.com/q3yToeZ.png)\n\n## 办公工具\n\n离开这些工具，貌似无法办公的。\n\t\t\n### AirMail\n\n[下载地址](https://itunes.apple.com/cn/app/airmail-3/id918858936?l=en&mt=12)\n\n![AirMai](https://i.imgur.com/19ADIxn.jpg)\n\n\n邮箱客户端，看中 AirMail 主要是因为其强大的第三方服务集成。\n\n\n### Slack\n\n[下载地址](https://itunes.apple.com/cn/app/slack/id803453959?mt=12)\n\n![Slack](https://i.imgur.com/W1wtsje.jpg)\n\n公司的日常沟通交流主要战场，其实整个操作体验我是不太适应的，不过它强大在第三方服务的集成上，可以做很多自动化的事情。\n\n### Fantastical 2\n\n[下载地址](https://flexibits.com/fantastical)\n\n![Fantastical](https://i.imgur.com/1naxpaM.jpg)\n\n日历工具，查看满满的一屏幕日程，你会感觉很舒服的。\n\n#### Tunnelblick\n\n[下载地址](https://tunnelblick.net/downloads.html)\n\n![Tunnelblick-menu](https://i.imgur.com/ghIEHNQ.png)\n\n公司需要使用该 App 来接入办公室网络。远程办公必备。\n\n\n#### Office 三件套\n\n微软的 Office 三件套，Word，Excel，PowerPoint。 用的频率不高，但是用的时候得有。\n\n\n## GTD\n\n日常 GTD 工具，基本就是各家评测常提起的几款 App。\n\n### 2Do\n\n[下载地址](https://www.2doapp.com/)\n\n![2Do on Mac](https://i.imgur.com/st89Smb.jpg)\n\n\n最近才完全转向 2Do，这个 GTD 工具是我最早买入的，但是后来因为其自动化太弱，被打入冷宫。最近几个月又开始捡起来了，吸引我的几个点：\n\n1. Colorful Tab\n2. Mail AutoCapture\n3. Smart List\n\n还有一点就是，其同步目前稳定的就只能使用 Dropbox 了，在国内基本对大部分人就是个障碍。\n\n### Things 3\n\n![Things3](https://i.imgur.com/5ifAVwf.jpg)\n\n\nThings 2 之前也有，不过因为功能太简单，基本处于买了看看的状态，后来 Things 3 的出现主要看中它的设计元素。\n\n### OmniFocus 3\n\n![OmniFocus 3](https://i.imgur.com/D72LM50.jpg)\n\n\n使用它最主要的原因是它支持 AppleScript 比较方便。尤其是结合 Keyboard Maestro 来用太方便。比如我会建立一些定时任务，每周五下午下班前自动生成一张周报表单，列出来本周完成的 Task 等。\n\n最近刚又从 2 升级到 3 代，半价折扣 39.99$\n\n3 主要将之前 Context 更换为支持多属性的 Tag，也算补充了一个竞争点吧。\n\n## 系统工具\n\n基本是系统缺少的或者功能难以满足日常使用的一些 App。\n\n### 1 Blocker\n\n[下载地址](https://itunes.apple.com/app/id1107421413)\n\n![1 Blocker](https://i.imgur.com/l3aGI1P.jpg)\n\n\n### iStat Menus\n\n[下载地址](http://download.bjango.com/istatmenus/)\n\n![iStat Menus](https://i.imgur.com/PtO8FNP.jpg)\n\n### Bartender 3\n\n[下载地址](https://www.macbartender.com/Demo/Bartender%203.zip)\n\n![Bartender](https://i.imgur.com/EnE2fyQ.png)\n\n### Surge\n\n[Surge](https://nssurge.com/)\n\n最近 Yachen Liu 发布了 Surge 3 的 Mac 版本预览版本\n\n![Surge 3](https://i.imgur.com/CNc6AIK.png)\n\n实质上是个网络调试工具，但是大部分情况下被用来作为爱国上网工具了。 而且定价策略也是引发了很多口水战，不过商品嘛，如果你觉得不值就不买就行了，不必要想用还骂他定价高，对吧。\n\n![Surge Dashboard](https://i.imgur.com/gkhCynx.png)\n\n\n### Wallpaper Wizard\n\n[下载地址](https://itunes.apple.com/cn/app/wallpaper-wizard-2/id1266674560?mt=12)\n\n![Wallpaper Wizard](https://i.imgur.com/lYnieJQ.jpg)\n\nMacPaw 家的壁纸应用，限时免费的时候入的。\n\n### TinkerTool\n\n[下载地址](https://www.bresink.com/osx/TinkerTool.html)\n\n![TinkerTool](https://i.imgur.com/YqvFP1Y.png)\n\n\n一个系统增强工具，可以对 Dashboard 和 Docker 等进行定制化修改。\n\n### Capto\n\n[下载地址](https://www.globaldelight.com/capto/)\n\n![Capto](https://i.imgur.com/9QeUc6Z.jpg)\n\n\n截屏和录制视频工具。\n\n## 效率工具\n\n### 1Password 7 for Mac\n\n[下载地址](https://app-updates.agilebits.com/download/OPM7)\n\n![1Password 7](https://i.imgur.com/Bb13IZD.jpg)\n\n\n\n### Alfred 3\n\n[下载地址](https://cachefly.alfredapp.com/Alfred_3.6.2_922.dmg)\n\n![Alfred](https://i.imgur.com/WeFkSYh.jpg)\n\n\n### LaunchBar 6\n\n[下载地址](https://www.obdev.at/products/launchbar/download.html)\n\n![LaunchBar](https://i.imgur.com/FVgOB3g.png)\n\n\n### BetterTouchTool\n\n[下载地址](https://bettertouchtool.net/releases/BetterTouchTool.zip)\n\n![BetterTouchTool](https://i.imgur.com/4RfNX0T.jpg)\n\n\n### Keyboard Maestro\n\n[下载地址](https://www.keyboardmaestro.com/action/download?km-kmi-7-b3)\n\n![Keyboard Maestro](https://i.imgur.com/IOZeiaH.png)\n\n### Yoink\n\n[下载地址](https://eternalstorms.at/yoink/mac/)\n\n![Yoink](https://i.imgur.com/oMcckyM.jpg)\n\n\n### Unclutter\n\n[下载地址](https://unclutterapp.com/)\n\n![Unclutter](https://i.imgur.com/SunNE17.png)\n\n\n### ToothFairy\n\n[下载地址](https://itunes.apple.com/cn/app/toothfairy/id1191449274?l=en&mt=12)\n\n![ToothFairy](https://i.imgur.com/2crElmV.jpg)\n\n\n### PopClip\n\n[下载地址](https://itunes.apple.com/cn/app/popclip/id445189367?l=en&mt=12)\n\n![PopClip](https://i.imgur.com/qytMbLT.jpg)\n\n\n### Copied\n\n[下载地址](https://geo.itunes.apple.com/us/app/copied/id1026349850?ls=1&mt=12&at=1010l8Ju&ct=web&uo=8&at=1010l8Ju)\n\n![Copied](https://i.imgur.com/hRW1Xoo.jpg)\n\n一款剪贴板工具，应该是目前 Mac 上最强大的剪贴板工具了。\n\n## 写作\n\n### Day One\n\n[下载地址](https://itunes.apple.com/cn/app/day-one/id1055511498?l=en&mt=12)\n\n![Day One](https://i.imgur.com/fKmOZa9.jpg)\n\n日记应用，之前买了 iOS 和 Mac 双版本，改成订阅之后自动升级为 Plus 会员了，功能已经完全足够。最近的 Premium 会员增加了音频日记以及 Dark Theme 的主题了。\n\n### Ulysses\n\n[下载地址](https://itunes.apple.com/cn/app/ulysses/id1225570693?l=en&mt=12)\n\n![Ulysses](https://i.imgur.com/GBaAJW2.jpg)\n\n\n这个完全是冲动消费，就是想看看大家捧杀这么狠到底优秀在哪里，说实话其自定义的 Markdown 格式我还是用不太习惯，不过用了每几次。从非订阅用到了订阅\n\n### MWeb\n\n推荐安装其非 MAS 版本，[下载地址](https://zh.mweb.im/)\n\n![MWeb](https://i.imgur.com/fMxRIDB.jpg)\n\n\n前一阵子刚又升级到了 3.0 版本，虽然 UI 上和 Ulysses 差得远，不过因为本地化做的好，各项服务接入的比较完整，比如图床，静态网站自动生成等都是比较吸引人的地方。\n\n### Notability\n\n[下载地址](https://itunes.apple.com/cn/app/notability/id736189492?l=en&mt=12)\n\n![Notability](https://i.imgur.com/GPiorsk.jpg)\n\n\n### GoodNotes\n\n[下载地址](https://itunes.apple.com/cn/app/goodnotes/id1026566364?l=en&mt=12)\n\n![GoodNotes](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-2400x2400bb -2-.jpg)\n\n\n### MindNode 5\n\n[下载地址](https://itunes.apple.com/cn/app/mindnode-5/id1289197285?l=en&mt=12)\n\n![MindNode 5](https://i.imgur.com/1er4hI3.jpg)\n\n## 阅读\n\n### DEVONThink Pro Office\n\n[下载地址](https://www.devontechnologies.com/download/products.html)\n\n![DEVONThink Pro Office](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-42007085dd.png)\n\n已经完全把 DENONThink 家的产品作为构建我知识图谱的工具了。必备。\n\n### Reeder 3\n\n[下载地址](https://itunes.apple.com/us/app/reeder-3/id880001334?mt=12&uo=4&at=1001lsTF&ct=iOS_detail_share_880001334)\n\n![Reeder 3](https://i.imgur.com/NPLz9Wl.jpg)\n\n\n\n### MarginNote 3\n\n[下载地址](https://marginnote.com/?lang=zh-hans)\n\n![MarginNote 3](https://i.imgur.com/kPu5B0k.jpg)\n\n## 开发工具\n\n### IDE\n\n#### Xcode\n\n话不多说，老老实实的从 App Store 下载吧。\n\n![Xcode](https://i.imgur.com/NSW9lFo.jpg)\n\n#### AppCode\n\n[下载地址](https://www.jetbrains.com/objc/)\n\n![AppCode](https://i.imgur.com/pdXy6FK.png)\n\nAppCode 强大就强大在 Jetbrain 团队一贯的 Refactor 功能。不过在 15寸 中配 MacBook Pro 上依然会时不时卡顿，不清楚时不时因为其基于 JVM 那一套所致。推荐个人开发者或者项目不太庞大的团队或者个人使用。\n\n### 编辑器\n\n#### Visual Studio Code\n\n[下载地址](https://code.visualstudio.com/)\n\n![Visual Studio Code](https://i.imgur.com/ExXn0QN.png)\n\n\n目前当之无愧最好使的编辑器了，当然可以作为大量脚本语言的轻量 IDE 使用了。\n\n\n### 代码管理\n\n#### Tower\n\nTower 是一款多平台支持的 Git GUI，使用命令行虽然某些程度上比较快，也显得 Geek 范儿，但是在查看 Diff 等功能上确实不太直观，因此一款 Git 的 UI 工具显得很重要。Tower 是一款收费软件，最近 3.0 转为了订阅式。刚订阅了一年基础版再接着用，毕竟切换工具的代价有时候蛮大的。\n\n[下载地址](https://www.git-tower.com/)\n\n![Microsoft.VisualStudio.Services.Screenshots](https://i.imgur.com/r4FdJaF.jpg)\n\n\n\n#### OhMyStar\n\n[下载地址](https://itunes.apple.com/us/app/ohmystar2/id1218642292?ls=1&mt=8)\n\n![OhMyStar 2](https://i.imgur.com/3NNd0ct.jpg)\n\n\n#### SnippetsLab\n\n[下载地址](https://itunes.apple.com/cn/app/snippetslab/id1006087419?l=en&mt=12)\n\n![SnippetsLab](https://i.imgur.com/qd4LQGz.jpg)\n\n### 设计\n\n\n#### Sketch\n\n[下载地址](https://www.sketchapp.com/)\n\n![Sketch](https://i.imgur.com/NXGXH8X.jpg)\n\n\n\n#### Sip for Mac\n\n[下载地址](https://sipapp.io/)\n\n![sip-color-format-mac-2016](https://i.imgur.com/f3NUIHy.jpg)\n\n\n\n#### PaintCode\n\n[下载地址](https://www.paintcodeapp.com/)\n\n![PaintCode 3](https://i.imgur.com/E7UILLI.png)\n\n\n主要针对一些复杂的设计图形，用代码绘制会非常复杂，比如一个需要使用 Bezier 绘制复杂的图形，如果人工画，费时费力。使用 PaintCode 能够解决这个痛点，支持 Objective-C 和 Swift 两种语言。\n\n结合 Playground 的话你感受一下。\n\n\n#### Eagle\n\n![Eagle](https://i.imgur.com/4kEFUi4.png)\n\n设计师用来收集素材所用\n\n### 调试\n\n#### Charles\n\n[下载地址](https://www.charlesproxy.com/)\n\n![Charles](https://i.imgur.com/s7LX5NO.png)\n\n\n使用公司的序列号，手机版本我也入了，不过在 iOS 生态里其并没有 Mac 上在同等功能上的地位，在 iOS 上我更喜欢使用 surge 或者 Thor 来抓包，而后者的功能基本上目前是市面上最完整的 App 了。 但是在 Mac 平台，Charles 的地位依然无人撼动。\n\n#### Paw\n\n[下载地址](https://paw.cloud/)\n\n![paw-lg](https://i.imgur.com/zt7Up5u.jpg)\n\n\n强大的 API 调试工具\n\n#### Reveal\n\n[下载地址](https://revealapp.com/features/)\n\n![Reveal](https://i.imgur.com/ITkfXe6.jpg)\n\n\n### 其他\n\n#### Monodraw\n\n[下载地址](https://monodraw.helftone.com/)\n\n![Monodraw](https://i.imgur.com/M20TPBn.jpg)\n\n代码注释加强工具，可以用来对代码进行注释。\n\n#### CuteBaby\n\n![CuteBaby](https://i.imgur.com/GyIzViM.jpg)\n\nModel 序列化工具，解决的痛点就是后端给你一个 JSON 结构，你需要自行映射成工程中的类，这个重复工作有时候会让您炸掉，因为有的接口返回的结构复杂，字段繁杂。不过网络上有很多开源的项目其实也可以做到一定程度。\n\n## 社交\n\n#### Telegram\n\n[下载地址](https://telegram.org/dl/macos)\n\n![Telegram](https://i.imgur.com/cWw9qpK.jpg)\n\n\n#### Tweetbot 3\n\n[下载地址](https://itunes.apple.com/cn/app/tweetbot-3-for-twitter/id1384080005?l=en&mt=12)\n\n![Tweetbot](https://i.imgur.com/yK4hhTr.jpg)\n\n\n## 其他\n#### RescueTime\n\n买了 Premium 会员，记录我日常在 Mac 上的工作记录。已经记录了大概有 2 年多的数据了，很直观。\n\n#### PCalc\n\n![PCalc](https://i.imgur.com/PRMDseI.jpg)\n\n也算是老牌的计算器了","source":"_posts/My-Favorite-Mac-Apps.md","raw":"---\ntitle: 那些我恢复 Mac 系统之后要安装的 Apps\ndate: 2018-07-11 12:58:37\ntop_img:\ncategories: Application\ntags: [App,Mac]\n---\n\n记录一下自己常用的 Mac Apps，每次重装之后到了用的时候发现忘记安装了(不是每次都用 TimeMachine 恢复)，而且强烈简易大家如果某个 App 有对应的独立安装版本的话，购买其独立安装版本为好，沙盒环境以及和 Apple ID 绑定的特性就使得功能性以及灵活度大减。\n\n<!-- more -->\n\n> 更新时间 2018-10-07\n> 更换图床，更新图片\n\n> 更新时间 2018-08-10 \n> 不久前，已经订阅了一年的 Setapp，发现上面好多 App 自己都之前买过了，Sigh！\n> 如果你使用 Ulysses 或者 MoneyWiz 3.0 的话，订阅 Setapp 就会非常的值得！\n\n![Mac Apps](https://i.imgur.com/q3yToeZ.png)\n\n## 办公工具\n\n离开这些工具，貌似无法办公的。\n\t\t\n### AirMail\n\n[下载地址](https://itunes.apple.com/cn/app/airmail-3/id918858936?l=en&mt=12)\n\n![AirMai](https://i.imgur.com/19ADIxn.jpg)\n\n\n邮箱客户端，看中 AirMail 主要是因为其强大的第三方服务集成。\n\n\n### Slack\n\n[下载地址](https://itunes.apple.com/cn/app/slack/id803453959?mt=12)\n\n![Slack](https://i.imgur.com/W1wtsje.jpg)\n\n公司的日常沟通交流主要战场，其实整个操作体验我是不太适应的，不过它强大在第三方服务的集成上，可以做很多自动化的事情。\n\n### Fantastical 2\n\n[下载地址](https://flexibits.com/fantastical)\n\n![Fantastical](https://i.imgur.com/1naxpaM.jpg)\n\n日历工具，查看满满的一屏幕日程，你会感觉很舒服的。\n\n#### Tunnelblick\n\n[下载地址](https://tunnelblick.net/downloads.html)\n\n![Tunnelblick-menu](https://i.imgur.com/ghIEHNQ.png)\n\n公司需要使用该 App 来接入办公室网络。远程办公必备。\n\n\n#### Office 三件套\n\n微软的 Office 三件套，Word，Excel，PowerPoint。 用的频率不高，但是用的时候得有。\n\n\n## GTD\n\n日常 GTD 工具，基本就是各家评测常提起的几款 App。\n\n### 2Do\n\n[下载地址](https://www.2doapp.com/)\n\n![2Do on Mac](https://i.imgur.com/st89Smb.jpg)\n\n\n最近才完全转向 2Do，这个 GTD 工具是我最早买入的，但是后来因为其自动化太弱，被打入冷宫。最近几个月又开始捡起来了，吸引我的几个点：\n\n1. Colorful Tab\n2. Mail AutoCapture\n3. Smart List\n\n还有一点就是，其同步目前稳定的就只能使用 Dropbox 了，在国内基本对大部分人就是个障碍。\n\n### Things 3\n\n![Things3](https://i.imgur.com/5ifAVwf.jpg)\n\n\nThings 2 之前也有，不过因为功能太简单，基本处于买了看看的状态，后来 Things 3 的出现主要看中它的设计元素。\n\n### OmniFocus 3\n\n![OmniFocus 3](https://i.imgur.com/D72LM50.jpg)\n\n\n使用它最主要的原因是它支持 AppleScript 比较方便。尤其是结合 Keyboard Maestro 来用太方便。比如我会建立一些定时任务，每周五下午下班前自动生成一张周报表单，列出来本周完成的 Task 等。\n\n最近刚又从 2 升级到 3 代，半价折扣 39.99$\n\n3 主要将之前 Context 更换为支持多属性的 Tag，也算补充了一个竞争点吧。\n\n## 系统工具\n\n基本是系统缺少的或者功能难以满足日常使用的一些 App。\n\n### 1 Blocker\n\n[下载地址](https://itunes.apple.com/app/id1107421413)\n\n![1 Blocker](https://i.imgur.com/l3aGI1P.jpg)\n\n\n### iStat Menus\n\n[下载地址](http://download.bjango.com/istatmenus/)\n\n![iStat Menus](https://i.imgur.com/PtO8FNP.jpg)\n\n### Bartender 3\n\n[下载地址](https://www.macbartender.com/Demo/Bartender%203.zip)\n\n![Bartender](https://i.imgur.com/EnE2fyQ.png)\n\n### Surge\n\n[Surge](https://nssurge.com/)\n\n最近 Yachen Liu 发布了 Surge 3 的 Mac 版本预览版本\n\n![Surge 3](https://i.imgur.com/CNc6AIK.png)\n\n实质上是个网络调试工具，但是大部分情况下被用来作为爱国上网工具了。 而且定价策略也是引发了很多口水战，不过商品嘛，如果你觉得不值就不买就行了，不必要想用还骂他定价高，对吧。\n\n![Surge Dashboard](https://i.imgur.com/gkhCynx.png)\n\n\n### Wallpaper Wizard\n\n[下载地址](https://itunes.apple.com/cn/app/wallpaper-wizard-2/id1266674560?mt=12)\n\n![Wallpaper Wizard](https://i.imgur.com/lYnieJQ.jpg)\n\nMacPaw 家的壁纸应用，限时免费的时候入的。\n\n### TinkerTool\n\n[下载地址](https://www.bresink.com/osx/TinkerTool.html)\n\n![TinkerTool](https://i.imgur.com/YqvFP1Y.png)\n\n\n一个系统增强工具，可以对 Dashboard 和 Docker 等进行定制化修改。\n\n### Capto\n\n[下载地址](https://www.globaldelight.com/capto/)\n\n![Capto](https://i.imgur.com/9QeUc6Z.jpg)\n\n\n截屏和录制视频工具。\n\n## 效率工具\n\n### 1Password 7 for Mac\n\n[下载地址](https://app-updates.agilebits.com/download/OPM7)\n\n![1Password 7](https://i.imgur.com/Bb13IZD.jpg)\n\n\n\n### Alfred 3\n\n[下载地址](https://cachefly.alfredapp.com/Alfred_3.6.2_922.dmg)\n\n![Alfred](https://i.imgur.com/WeFkSYh.jpg)\n\n\n### LaunchBar 6\n\n[下载地址](https://www.obdev.at/products/launchbar/download.html)\n\n![LaunchBar](https://i.imgur.com/FVgOB3g.png)\n\n\n### BetterTouchTool\n\n[下载地址](https://bettertouchtool.net/releases/BetterTouchTool.zip)\n\n![BetterTouchTool](https://i.imgur.com/4RfNX0T.jpg)\n\n\n### Keyboard Maestro\n\n[下载地址](https://www.keyboardmaestro.com/action/download?km-kmi-7-b3)\n\n![Keyboard Maestro](https://i.imgur.com/IOZeiaH.png)\n\n### Yoink\n\n[下载地址](https://eternalstorms.at/yoink/mac/)\n\n![Yoink](https://i.imgur.com/oMcckyM.jpg)\n\n\n### Unclutter\n\n[下载地址](https://unclutterapp.com/)\n\n![Unclutter](https://i.imgur.com/SunNE17.png)\n\n\n### ToothFairy\n\n[下载地址](https://itunes.apple.com/cn/app/toothfairy/id1191449274?l=en&mt=12)\n\n![ToothFairy](https://i.imgur.com/2crElmV.jpg)\n\n\n### PopClip\n\n[下载地址](https://itunes.apple.com/cn/app/popclip/id445189367?l=en&mt=12)\n\n![PopClip](https://i.imgur.com/qytMbLT.jpg)\n\n\n### Copied\n\n[下载地址](https://geo.itunes.apple.com/us/app/copied/id1026349850?ls=1&mt=12&at=1010l8Ju&ct=web&uo=8&at=1010l8Ju)\n\n![Copied](https://i.imgur.com/hRW1Xoo.jpg)\n\n一款剪贴板工具，应该是目前 Mac 上最强大的剪贴板工具了。\n\n## 写作\n\n### Day One\n\n[下载地址](https://itunes.apple.com/cn/app/day-one/id1055511498?l=en&mt=12)\n\n![Day One](https://i.imgur.com/fKmOZa9.jpg)\n\n日记应用，之前买了 iOS 和 Mac 双版本，改成订阅之后自动升级为 Plus 会员了，功能已经完全足够。最近的 Premium 会员增加了音频日记以及 Dark Theme 的主题了。\n\n### Ulysses\n\n[下载地址](https://itunes.apple.com/cn/app/ulysses/id1225570693?l=en&mt=12)\n\n![Ulysses](https://i.imgur.com/GBaAJW2.jpg)\n\n\n这个完全是冲动消费，就是想看看大家捧杀这么狠到底优秀在哪里，说实话其自定义的 Markdown 格式我还是用不太习惯，不过用了每几次。从非订阅用到了订阅\n\n### MWeb\n\n推荐安装其非 MAS 版本，[下载地址](https://zh.mweb.im/)\n\n![MWeb](https://i.imgur.com/fMxRIDB.jpg)\n\n\n前一阵子刚又升级到了 3.0 版本，虽然 UI 上和 Ulysses 差得远，不过因为本地化做的好，各项服务接入的比较完整，比如图床，静态网站自动生成等都是比较吸引人的地方。\n\n### Notability\n\n[下载地址](https://itunes.apple.com/cn/app/notability/id736189492?l=en&mt=12)\n\n![Notability](https://i.imgur.com/GPiorsk.jpg)\n\n\n### GoodNotes\n\n[下载地址](https://itunes.apple.com/cn/app/goodnotes/id1026566364?l=en&mt=12)\n\n![GoodNotes](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-2400x2400bb -2-.jpg)\n\n\n### MindNode 5\n\n[下载地址](https://itunes.apple.com/cn/app/mindnode-5/id1289197285?l=en&mt=12)\n\n![MindNode 5](https://i.imgur.com/1er4hI3.jpg)\n\n## 阅读\n\n### DEVONThink Pro Office\n\n[下载地址](https://www.devontechnologies.com/download/products.html)\n\n![DEVONThink Pro Office](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-42007085dd.png)\n\n已经完全把 DENONThink 家的产品作为构建我知识图谱的工具了。必备。\n\n### Reeder 3\n\n[下载地址](https://itunes.apple.com/us/app/reeder-3/id880001334?mt=12&uo=4&at=1001lsTF&ct=iOS_detail_share_880001334)\n\n![Reeder 3](https://i.imgur.com/NPLz9Wl.jpg)\n\n\n\n### MarginNote 3\n\n[下载地址](https://marginnote.com/?lang=zh-hans)\n\n![MarginNote 3](https://i.imgur.com/kPu5B0k.jpg)\n\n## 开发工具\n\n### IDE\n\n#### Xcode\n\n话不多说，老老实实的从 App Store 下载吧。\n\n![Xcode](https://i.imgur.com/NSW9lFo.jpg)\n\n#### AppCode\n\n[下载地址](https://www.jetbrains.com/objc/)\n\n![AppCode](https://i.imgur.com/pdXy6FK.png)\n\nAppCode 强大就强大在 Jetbrain 团队一贯的 Refactor 功能。不过在 15寸 中配 MacBook Pro 上依然会时不时卡顿，不清楚时不时因为其基于 JVM 那一套所致。推荐个人开发者或者项目不太庞大的团队或者个人使用。\n\n### 编辑器\n\n#### Visual Studio Code\n\n[下载地址](https://code.visualstudio.com/)\n\n![Visual Studio Code](https://i.imgur.com/ExXn0QN.png)\n\n\n目前当之无愧最好使的编辑器了，当然可以作为大量脚本语言的轻量 IDE 使用了。\n\n\n### 代码管理\n\n#### Tower\n\nTower 是一款多平台支持的 Git GUI，使用命令行虽然某些程度上比较快，也显得 Geek 范儿，但是在查看 Diff 等功能上确实不太直观，因此一款 Git 的 UI 工具显得很重要。Tower 是一款收费软件，最近 3.0 转为了订阅式。刚订阅了一年基础版再接着用，毕竟切换工具的代价有时候蛮大的。\n\n[下载地址](https://www.git-tower.com/)\n\n![Microsoft.VisualStudio.Services.Screenshots](https://i.imgur.com/r4FdJaF.jpg)\n\n\n\n#### OhMyStar\n\n[下载地址](https://itunes.apple.com/us/app/ohmystar2/id1218642292?ls=1&mt=8)\n\n![OhMyStar 2](https://i.imgur.com/3NNd0ct.jpg)\n\n\n#### SnippetsLab\n\n[下载地址](https://itunes.apple.com/cn/app/snippetslab/id1006087419?l=en&mt=12)\n\n![SnippetsLab](https://i.imgur.com/qd4LQGz.jpg)\n\n### 设计\n\n\n#### Sketch\n\n[下载地址](https://www.sketchapp.com/)\n\n![Sketch](https://i.imgur.com/NXGXH8X.jpg)\n\n\n\n#### Sip for Mac\n\n[下载地址](https://sipapp.io/)\n\n![sip-color-format-mac-2016](https://i.imgur.com/f3NUIHy.jpg)\n\n\n\n#### PaintCode\n\n[下载地址](https://www.paintcodeapp.com/)\n\n![PaintCode 3](https://i.imgur.com/E7UILLI.png)\n\n\n主要针对一些复杂的设计图形，用代码绘制会非常复杂，比如一个需要使用 Bezier 绘制复杂的图形，如果人工画，费时费力。使用 PaintCode 能够解决这个痛点，支持 Objective-C 和 Swift 两种语言。\n\n结合 Playground 的话你感受一下。\n\n\n#### Eagle\n\n![Eagle](https://i.imgur.com/4kEFUi4.png)\n\n设计师用来收集素材所用\n\n### 调试\n\n#### Charles\n\n[下载地址](https://www.charlesproxy.com/)\n\n![Charles](https://i.imgur.com/s7LX5NO.png)\n\n\n使用公司的序列号，手机版本我也入了，不过在 iOS 生态里其并没有 Mac 上在同等功能上的地位，在 iOS 上我更喜欢使用 surge 或者 Thor 来抓包，而后者的功能基本上目前是市面上最完整的 App 了。 但是在 Mac 平台，Charles 的地位依然无人撼动。\n\n#### Paw\n\n[下载地址](https://paw.cloud/)\n\n![paw-lg](https://i.imgur.com/zt7Up5u.jpg)\n\n\n强大的 API 调试工具\n\n#### Reveal\n\n[下载地址](https://revealapp.com/features/)\n\n![Reveal](https://i.imgur.com/ITkfXe6.jpg)\n\n\n### 其他\n\n#### Monodraw\n\n[下载地址](https://monodraw.helftone.com/)\n\n![Monodraw](https://i.imgur.com/M20TPBn.jpg)\n\n代码注释加强工具，可以用来对代码进行注释。\n\n#### CuteBaby\n\n![CuteBaby](https://i.imgur.com/GyIzViM.jpg)\n\nModel 序列化工具，解决的痛点就是后端给你一个 JSON 结构，你需要自行映射成工程中的类，这个重复工作有时候会让您炸掉，因为有的接口返回的结构复杂，字段繁杂。不过网络上有很多开源的项目其实也可以做到一定程度。\n\n## 社交\n\n#### Telegram\n\n[下载地址](https://telegram.org/dl/macos)\n\n![Telegram](https://i.imgur.com/cWw9qpK.jpg)\n\n\n#### Tweetbot 3\n\n[下载地址](https://itunes.apple.com/cn/app/tweetbot-3-for-twitter/id1384080005?l=en&mt=12)\n\n![Tweetbot](https://i.imgur.com/yK4hhTr.jpg)\n\n\n## 其他\n#### RescueTime\n\n买了 Premium 会员，记录我日常在 Mac 上的工作记录。已经记录了大概有 2 年多的数据了，很直观。\n\n#### PCalc\n\n![PCalc](https://i.imgur.com/PRMDseI.jpg)\n\n也算是老牌的计算器了","slug":"My-Favorite-Mac-Apps","published":1,"updated":"2018-10-07T11:09:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftbl004l79po4p9yrfm6","content":"<p>记录一下自己常用的 Mac Apps，每次重装之后到了用的时候发现忘记安装了(不是每次都用 TimeMachine 恢复)，而且强烈简易大家如果某个 App 有对应的独立安装版本的话，购买其独立安装版本为好，沙盒环境以及和 Apple ID 绑定的特性就使得功能性以及灵活度大减。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>更新时间 2018-10-07<br>更换图床，更新图片</p>\n</blockquote>\n<blockquote>\n<p>更新时间 2018-08-10<br>不久前，已经订阅了一年的 Setapp，发现上面好多 App 自己都之前买过了，Sigh！<br>如果你使用 Ulysses 或者 MoneyWiz 3.0 的话，订阅 Setapp 就会非常的值得！</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/q3yToeZ.png\" alt=\"Mac Apps\"></p>\n<h2 id=\"办公工具\"><a href=\"#办公工具\" class=\"headerlink\" title=\"办公工具\"></a>办公工具</h2><p>离开这些工具，貌似无法办公的。</p>\n<h3 id=\"AirMail\"><a href=\"#AirMail\" class=\"headerlink\" title=\"AirMail\"></a>AirMail</h3><p><a href=\"https://itunes.apple.com/cn/app/airmail-3/id918858936?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/19ADIxn.jpg\" alt=\"AirMai\"></p>\n<p>邮箱客户端，看中 AirMail 主要是因为其强大的第三方服务集成。</p>\n<h3 id=\"Slack\"><a href=\"#Slack\" class=\"headerlink\" title=\"Slack\"></a>Slack</h3><p><a href=\"https://itunes.apple.com/cn/app/slack/id803453959?mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/W1wtsje.jpg\" alt=\"Slack\"></p>\n<p>公司的日常沟通交流主要战场，其实整个操作体验我是不太适应的，不过它强大在第三方服务的集成上，可以做很多自动化的事情。</p>\n<h3 id=\"Fantastical-2\"><a href=\"#Fantastical-2\" class=\"headerlink\" title=\"Fantastical 2\"></a>Fantastical 2</h3><p><a href=\"https://flexibits.com/fantastical\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/1naxpaM.jpg\" alt=\"Fantastical\"></p>\n<p>日历工具，查看满满的一屏幕日程，你会感觉很舒服的。</p>\n<h4 id=\"Tunnelblick\"><a href=\"#Tunnelblick\" class=\"headerlink\" title=\"Tunnelblick\"></a>Tunnelblick</h4><p><a href=\"https://tunnelblick.net/downloads.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/ghIEHNQ.png\" alt=\"Tunnelblick-menu\"></p>\n<p>公司需要使用该 App 来接入办公室网络。远程办公必备。</p>\n<h4 id=\"Office-三件套\"><a href=\"#Office-三件套\" class=\"headerlink\" title=\"Office 三件套\"></a>Office 三件套</h4><p>微软的 Office 三件套，Word，Excel，PowerPoint。 用的频率不高，但是用的时候得有。</p>\n<h2 id=\"GTD\"><a href=\"#GTD\" class=\"headerlink\" title=\"GTD\"></a>GTD</h2><p>日常 GTD 工具，基本就是各家评测常提起的几款 App。</p>\n<h3 id=\"2Do\"><a href=\"#2Do\" class=\"headerlink\" title=\"2Do\"></a>2Do</h3><p><a href=\"https://www.2doapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/st89Smb.jpg\" alt=\"2Do on Mac\"></p>\n<p>最近才完全转向 2Do，这个 GTD 工具是我最早买入的，但是后来因为其自动化太弱，被打入冷宫。最近几个月又开始捡起来了，吸引我的几个点：</p>\n<ol>\n<li>Colorful Tab</li>\n<li>Mail AutoCapture</li>\n<li>Smart List</li>\n</ol>\n<p>还有一点就是，其同步目前稳定的就只能使用 Dropbox 了，在国内基本对大部分人就是个障碍。</p>\n<h3 id=\"Things-3\"><a href=\"#Things-3\" class=\"headerlink\" title=\"Things 3\"></a>Things 3</h3><p><img src=\"https://i.imgur.com/5ifAVwf.jpg\" alt=\"Things3\"></p>\n<p>Things 2 之前也有，不过因为功能太简单，基本处于买了看看的状态，后来 Things 3 的出现主要看中它的设计元素。</p>\n<h3 id=\"OmniFocus-3\"><a href=\"#OmniFocus-3\" class=\"headerlink\" title=\"OmniFocus 3\"></a>OmniFocus 3</h3><p><img src=\"https://i.imgur.com/D72LM50.jpg\" alt=\"OmniFocus 3\"></p>\n<p>使用它最主要的原因是它支持 AppleScript 比较方便。尤其是结合 Keyboard Maestro 来用太方便。比如我会建立一些定时任务，每周五下午下班前自动生成一张周报表单，列出来本周完成的 Task 等。</p>\n<p>最近刚又从 2 升级到 3 代，半价折扣 39.99$</p>\n<p>3 主要将之前 Context 更换为支持多属性的 Tag，也算补充了一个竞争点吧。</p>\n<h2 id=\"系统工具\"><a href=\"#系统工具\" class=\"headerlink\" title=\"系统工具\"></a>系统工具</h2><p>基本是系统缺少的或者功能难以满足日常使用的一些 App。</p>\n<h3 id=\"1-Blocker\"><a href=\"#1-Blocker\" class=\"headerlink\" title=\"1 Blocker\"></a>1 Blocker</h3><p><a href=\"https://itunes.apple.com/app/id1107421413\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/l3aGI1P.jpg\" alt=\"1 Blocker\"></p>\n<h3 id=\"iStat-Menus\"><a href=\"#iStat-Menus\" class=\"headerlink\" title=\"iStat Menus\"></a>iStat Menus</h3><p><a href=\"http://download.bjango.com/istatmenus/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/PtO8FNP.jpg\" alt=\"iStat Menus\"></p>\n<h3 id=\"Bartender-3\"><a href=\"#Bartender-3\" class=\"headerlink\" title=\"Bartender 3\"></a>Bartender 3</h3><p><a href=\"https://www.macbartender.com/Demo/Bartender%203.zip\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/EnE2fyQ.png\" alt=\"Bartender\"></p>\n<h3 id=\"Surge\"><a href=\"#Surge\" class=\"headerlink\" title=\"Surge\"></a>Surge</h3><p><a href=\"https://nssurge.com/\" target=\"_blank\" rel=\"noopener\">Surge</a></p>\n<p>最近 Yachen Liu 发布了 Surge 3 的 Mac 版本预览版本</p>\n<p><img src=\"https://i.imgur.com/CNc6AIK.png\" alt=\"Surge 3\"></p>\n<p>实质上是个网络调试工具，但是大部分情况下被用来作为爱国上网工具了。 而且定价策略也是引发了很多口水战，不过商品嘛，如果你觉得不值就不买就行了，不必要想用还骂他定价高，对吧。</p>\n<p><img src=\"https://i.imgur.com/gkhCynx.png\" alt=\"Surge Dashboard\"></p>\n<h3 id=\"Wallpaper-Wizard\"><a href=\"#Wallpaper-Wizard\" class=\"headerlink\" title=\"Wallpaper Wizard\"></a>Wallpaper Wizard</h3><p><a href=\"https://itunes.apple.com/cn/app/wallpaper-wizard-2/id1266674560?mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/lYnieJQ.jpg\" alt=\"Wallpaper Wizard\"></p>\n<p>MacPaw 家的壁纸应用，限时免费的时候入的。</p>\n<h3 id=\"TinkerTool\"><a href=\"#TinkerTool\" class=\"headerlink\" title=\"TinkerTool\"></a>TinkerTool</h3><p><a href=\"https://www.bresink.com/osx/TinkerTool.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/YqvFP1Y.png\" alt=\"TinkerTool\"></p>\n<p>一个系统增强工具，可以对 Dashboard 和 Docker 等进行定制化修改。</p>\n<h3 id=\"Capto\"><a href=\"#Capto\" class=\"headerlink\" title=\"Capto\"></a>Capto</h3><p><a href=\"https://www.globaldelight.com/capto/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/9QeUc6Z.jpg\" alt=\"Capto\"></p>\n<p>截屏和录制视频工具。</p>\n<h2 id=\"效率工具\"><a href=\"#效率工具\" class=\"headerlink\" title=\"效率工具\"></a>效率工具</h2><h3 id=\"1Password-7-for-Mac\"><a href=\"#1Password-7-for-Mac\" class=\"headerlink\" title=\"1Password 7 for Mac\"></a>1Password 7 for Mac</h3><p><a href=\"https://app-updates.agilebits.com/download/OPM7\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/Bb13IZD.jpg\" alt=\"1Password 7\"></p>\n<h3 id=\"Alfred-3\"><a href=\"#Alfred-3\" class=\"headerlink\" title=\"Alfred 3\"></a>Alfred 3</h3><p><a href=\"https://cachefly.alfredapp.com/Alfred_3.6.2_922.dmg\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/WeFkSYh.jpg\" alt=\"Alfred\"></p>\n<h3 id=\"LaunchBar-6\"><a href=\"#LaunchBar-6\" class=\"headerlink\" title=\"LaunchBar 6\"></a>LaunchBar 6</h3><p><a href=\"https://www.obdev.at/products/launchbar/download.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/FVgOB3g.png\" alt=\"LaunchBar\"></p>\n<h3 id=\"BetterTouchTool\"><a href=\"#BetterTouchTool\" class=\"headerlink\" title=\"BetterTouchTool\"></a>BetterTouchTool</h3><p><a href=\"https://bettertouchtool.net/releases/BetterTouchTool.zip\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/4RfNX0T.jpg\" alt=\"BetterTouchTool\"></p>\n<h3 id=\"Keyboard-Maestro\"><a href=\"#Keyboard-Maestro\" class=\"headerlink\" title=\"Keyboard Maestro\"></a>Keyboard Maestro</h3><p><a href=\"https://www.keyboardmaestro.com/action/download?km-kmi-7-b3\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/IOZeiaH.png\" alt=\"Keyboard Maestro\"></p>\n<h3 id=\"Yoink\"><a href=\"#Yoink\" class=\"headerlink\" title=\"Yoink\"></a>Yoink</h3><p><a href=\"https://eternalstorms.at/yoink/mac/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/oMcckyM.jpg\" alt=\"Yoink\"></p>\n<h3 id=\"Unclutter\"><a href=\"#Unclutter\" class=\"headerlink\" title=\"Unclutter\"></a>Unclutter</h3><p><a href=\"https://unclutterapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/SunNE17.png\" alt=\"Unclutter\"></p>\n<h3 id=\"ToothFairy\"><a href=\"#ToothFairy\" class=\"headerlink\" title=\"ToothFairy\"></a>ToothFairy</h3><p><a href=\"https://itunes.apple.com/cn/app/toothfairy/id1191449274?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/2crElmV.jpg\" alt=\"ToothFairy\"></p>\n<h3 id=\"PopClip\"><a href=\"#PopClip\" class=\"headerlink\" title=\"PopClip\"></a>PopClip</h3><p><a href=\"https://itunes.apple.com/cn/app/popclip/id445189367?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/qytMbLT.jpg\" alt=\"PopClip\"></p>\n<h3 id=\"Copied\"><a href=\"#Copied\" class=\"headerlink\" title=\"Copied\"></a>Copied</h3><p><a href=\"https://geo.itunes.apple.com/us/app/copied/id1026349850?ls=1&amp;mt=12&amp;at=1010l8Ju&amp;ct=web&amp;uo=8&amp;at=1010l8Ju\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/hRW1Xoo.jpg\" alt=\"Copied\"></p>\n<p>一款剪贴板工具，应该是目前 Mac 上最强大的剪贴板工具了。</p>\n<h2 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h2><h3 id=\"Day-One\"><a href=\"#Day-One\" class=\"headerlink\" title=\"Day One\"></a>Day One</h3><p><a href=\"https://itunes.apple.com/cn/app/day-one/id1055511498?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/fKmOZa9.jpg\" alt=\"Day One\"></p>\n<p>日记应用，之前买了 iOS 和 Mac 双版本，改成订阅之后自动升级为 Plus 会员了，功能已经完全足够。最近的 Premium 会员增加了音频日记以及 Dark Theme 的主题了。</p>\n<h3 id=\"Ulysses\"><a href=\"#Ulysses\" class=\"headerlink\" title=\"Ulysses\"></a>Ulysses</h3><p><a href=\"https://itunes.apple.com/cn/app/ulysses/id1225570693?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/GBaAJW2.jpg\" alt=\"Ulysses\"></p>\n<p>这个完全是冲动消费，就是想看看大家捧杀这么狠到底优秀在哪里，说实话其自定义的 Markdown 格式我还是用不太习惯，不过用了每几次。从非订阅用到了订阅</p>\n<h3 id=\"MWeb\"><a href=\"#MWeb\" class=\"headerlink\" title=\"MWeb\"></a>MWeb</h3><p>推荐安装其非 MAS 版本，<a href=\"https://zh.mweb.im/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/fMxRIDB.jpg\" alt=\"MWeb\"></p>\n<p>前一阵子刚又升级到了 3.0 版本，虽然 UI 上和 Ulysses 差得远，不过因为本地化做的好，各项服务接入的比较完整，比如图床，静态网站自动生成等都是比较吸引人的地方。</p>\n<h3 id=\"Notability\"><a href=\"#Notability\" class=\"headerlink\" title=\"Notability\"></a>Notability</h3><p><a href=\"https://itunes.apple.com/cn/app/notability/id736189492?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/GPiorsk.jpg\" alt=\"Notability\"></p>\n<h3 id=\"GoodNotes\"><a href=\"#GoodNotes\" class=\"headerlink\" title=\"GoodNotes\"></a>GoodNotes</h3><p><a href=\"https://itunes.apple.com/cn/app/goodnotes/id1026566364?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-2400x2400bb -2-.jpg\" alt=\"GoodNotes\"></p>\n<h3 id=\"MindNode-5\"><a href=\"#MindNode-5\" class=\"headerlink\" title=\"MindNode 5\"></a>MindNode 5</h3><p><a href=\"https://itunes.apple.com/cn/app/mindnode-5/id1289197285?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/1er4hI3.jpg\" alt=\"MindNode 5\"></p>\n<h2 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h2><h3 id=\"DEVONThink-Pro-Office\"><a href=\"#DEVONThink-Pro-Office\" class=\"headerlink\" title=\"DEVONThink Pro Office\"></a>DEVONThink Pro Office</h3><p><a href=\"https://www.devontechnologies.com/download/products.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-42007085dd.png\" alt=\"DEVONThink Pro Office\"></p>\n<p>已经完全把 DENONThink 家的产品作为构建我知识图谱的工具了。必备。</p>\n<h3 id=\"Reeder-3\"><a href=\"#Reeder-3\" class=\"headerlink\" title=\"Reeder 3\"></a>Reeder 3</h3><p><a href=\"https://itunes.apple.com/us/app/reeder-3/id880001334?mt=12&amp;uo=4&amp;at=1001lsTF&amp;ct=iOS_detail_share_880001334\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/NPLz9Wl.jpg\" alt=\"Reeder 3\"></p>\n<h3 id=\"MarginNote-3\"><a href=\"#MarginNote-3\" class=\"headerlink\" title=\"MarginNote 3\"></a>MarginNote 3</h3><p><a href=\"https://marginnote.com/?lang=zh-hans\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/kPu5B0k.jpg\" alt=\"MarginNote 3\"></p>\n<h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><h4 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h4><p>话不多说，老老实实的从 App Store 下载吧。</p>\n<p><img src=\"https://i.imgur.com/NSW9lFo.jpg\" alt=\"Xcode\"></p>\n<h4 id=\"AppCode\"><a href=\"#AppCode\" class=\"headerlink\" title=\"AppCode\"></a>AppCode</h4><p><a href=\"https://www.jetbrains.com/objc/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/pdXy6FK.png\" alt=\"AppCode\"></p>\n<p>AppCode 强大就强大在 Jetbrain 团队一贯的 Refactor 功能。不过在 15寸 中配 MacBook Pro 上依然会时不时卡顿，不清楚时不时因为其基于 JVM 那一套所致。推荐个人开发者或者项目不太庞大的团队或者个人使用。</p>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><h4 id=\"Visual-Studio-Code\"><a href=\"#Visual-Studio-Code\" class=\"headerlink\" title=\"Visual Studio Code\"></a>Visual Studio Code</h4><p><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/ExXn0QN.png\" alt=\"Visual Studio Code\"></p>\n<p>目前当之无愧最好使的编辑器了，当然可以作为大量脚本语言的轻量 IDE 使用了。</p>\n<h3 id=\"代码管理\"><a href=\"#代码管理\" class=\"headerlink\" title=\"代码管理\"></a>代码管理</h3><h4 id=\"Tower\"><a href=\"#Tower\" class=\"headerlink\" title=\"Tower\"></a>Tower</h4><p>Tower 是一款多平台支持的 Git GUI，使用命令行虽然某些程度上比较快，也显得 Geek 范儿，但是在查看 Diff 等功能上确实不太直观，因此一款 Git 的 UI 工具显得很重要。Tower 是一款收费软件，最近 3.0 转为了订阅式。刚订阅了一年基础版再接着用，毕竟切换工具的代价有时候蛮大的。</p>\n<p><a href=\"https://www.git-tower.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/r4FdJaF.jpg\" alt=\"Microsoft.VisualStudio.Services.Screenshots\"></p>\n<h4 id=\"OhMyStar\"><a href=\"#OhMyStar\" class=\"headerlink\" title=\"OhMyStar\"></a>OhMyStar</h4><p><a href=\"https://itunes.apple.com/us/app/ohmystar2/id1218642292?ls=1&amp;mt=8\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/3NNd0ct.jpg\" alt=\"OhMyStar 2\"></p>\n<h4 id=\"SnippetsLab\"><a href=\"#SnippetsLab\" class=\"headerlink\" title=\"SnippetsLab\"></a>SnippetsLab</h4><p><a href=\"https://itunes.apple.com/cn/app/snippetslab/id1006087419?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/qd4LQGz.jpg\" alt=\"SnippetsLab\"></p>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><h4 id=\"Sketch\"><a href=\"#Sketch\" class=\"headerlink\" title=\"Sketch\"></a>Sketch</h4><p><a href=\"https://www.sketchapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/NXGXH8X.jpg\" alt=\"Sketch\"></p>\n<h4 id=\"Sip-for-Mac\"><a href=\"#Sip-for-Mac\" class=\"headerlink\" title=\"Sip for Mac\"></a>Sip for Mac</h4><p><a href=\"https://sipapp.io/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/f3NUIHy.jpg\" alt=\"sip-color-format-mac-2016\"></p>\n<h4 id=\"PaintCode\"><a href=\"#PaintCode\" class=\"headerlink\" title=\"PaintCode\"></a>PaintCode</h4><p><a href=\"https://www.paintcodeapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/E7UILLI.png\" alt=\"PaintCode 3\"></p>\n<p>主要针对一些复杂的设计图形，用代码绘制会非常复杂，比如一个需要使用 Bezier 绘制复杂的图形，如果人工画，费时费力。使用 PaintCode 能够解决这个痛点，支持 Objective-C 和 Swift 两种语言。</p>\n<p>结合 Playground 的话你感受一下。</p>\n<h4 id=\"Eagle\"><a href=\"#Eagle\" class=\"headerlink\" title=\"Eagle\"></a>Eagle</h4><p><img src=\"https://i.imgur.com/4kEFUi4.png\" alt=\"Eagle\"></p>\n<p>设计师用来收集素材所用</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><h4 id=\"Charles\"><a href=\"#Charles\" class=\"headerlink\" title=\"Charles\"></a>Charles</h4><p><a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/s7LX5NO.png\" alt=\"Charles\"></p>\n<p>使用公司的序列号，手机版本我也入了，不过在 iOS 生态里其并没有 Mac 上在同等功能上的地位，在 iOS 上我更喜欢使用 surge 或者 Thor 来抓包，而后者的功能基本上目前是市面上最完整的 App 了。 但是在 Mac 平台，Charles 的地位依然无人撼动。</p>\n<h4 id=\"Paw\"><a href=\"#Paw\" class=\"headerlink\" title=\"Paw\"></a>Paw</h4><p><a href=\"https://paw.cloud/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/zt7Up5u.jpg\" alt=\"paw-lg\"></p>\n<p>强大的 API 调试工具</p>\n<h4 id=\"Reveal\"><a href=\"#Reveal\" class=\"headerlink\" title=\"Reveal\"></a>Reveal</h4><p><a href=\"https://revealapp.com/features/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/ITkfXe6.jpg\" alt=\"Reveal\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"Monodraw\"><a href=\"#Monodraw\" class=\"headerlink\" title=\"Monodraw\"></a>Monodraw</h4><p><a href=\"https://monodraw.helftone.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/M20TPBn.jpg\" alt=\"Monodraw\"></p>\n<p>代码注释加强工具，可以用来对代码进行注释。</p>\n<h4 id=\"CuteBaby\"><a href=\"#CuteBaby\" class=\"headerlink\" title=\"CuteBaby\"></a>CuteBaby</h4><p><img src=\"https://i.imgur.com/GyIzViM.jpg\" alt=\"CuteBaby\"></p>\n<p>Model 序列化工具，解决的痛点就是后端给你一个 JSON 结构，你需要自行映射成工程中的类，这个重复工作有时候会让您炸掉，因为有的接口返回的结构复杂，字段繁杂。不过网络上有很多开源的项目其实也可以做到一定程度。</p>\n<h2 id=\"社交\"><a href=\"#社交\" class=\"headerlink\" title=\"社交\"></a>社交</h2><h4 id=\"Telegram\"><a href=\"#Telegram\" class=\"headerlink\" title=\"Telegram\"></a>Telegram</h4><p><a href=\"https://telegram.org/dl/macos\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/cWw9qpK.jpg\" alt=\"Telegram\"></p>\n<h4 id=\"Tweetbot-3\"><a href=\"#Tweetbot-3\" class=\"headerlink\" title=\"Tweetbot 3\"></a>Tweetbot 3</h4><p><a href=\"https://itunes.apple.com/cn/app/tweetbot-3-for-twitter/id1384080005?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/yK4hhTr.jpg\" alt=\"Tweetbot\"></p>\n<h2 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h4 id=\"RescueTime\"><a href=\"#RescueTime\" class=\"headerlink\" title=\"RescueTime\"></a>RescueTime</h4><p>买了 Premium 会员，记录我日常在 Mac 上的工作记录。已经记录了大概有 2 年多的数据了，很直观。</p>\n<h4 id=\"PCalc\"><a href=\"#PCalc\" class=\"headerlink\" title=\"PCalc\"></a>PCalc</h4><p><img src=\"https://i.imgur.com/PRMDseI.jpg\" alt=\"PCalc\"></p>\n<p>也算是老牌的计算器了</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>记录一下自己常用的 Mac Apps，每次重装之后到了用的时候发现忘记安装了(不是每次都用 TimeMachine 恢复)，而且强烈简易大家如果某个 App 有对应的独立安装版本的话，购买其独立安装版本为好，沙盒环境以及和 Apple ID 绑定的特性就使得功能性以及灵活度大减。</p>","more":"<blockquote>\n<p>更新时间 2018-10-07<br>更换图床，更新图片</p>\n</blockquote>\n<blockquote>\n<p>更新时间 2018-08-10<br>不久前，已经订阅了一年的 Setapp，发现上面好多 App 自己都之前买过了，Sigh！<br>如果你使用 Ulysses 或者 MoneyWiz 3.0 的话，订阅 Setapp 就会非常的值得！</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/q3yToeZ.png\" alt=\"Mac Apps\"></p>\n<h2 id=\"办公工具\"><a href=\"#办公工具\" class=\"headerlink\" title=\"办公工具\"></a>办公工具</h2><p>离开这些工具，貌似无法办公的。</p>\n<h3 id=\"AirMail\"><a href=\"#AirMail\" class=\"headerlink\" title=\"AirMail\"></a>AirMail</h3><p><a href=\"https://itunes.apple.com/cn/app/airmail-3/id918858936?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/19ADIxn.jpg\" alt=\"AirMai\"></p>\n<p>邮箱客户端，看中 AirMail 主要是因为其强大的第三方服务集成。</p>\n<h3 id=\"Slack\"><a href=\"#Slack\" class=\"headerlink\" title=\"Slack\"></a>Slack</h3><p><a href=\"https://itunes.apple.com/cn/app/slack/id803453959?mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/W1wtsje.jpg\" alt=\"Slack\"></p>\n<p>公司的日常沟通交流主要战场，其实整个操作体验我是不太适应的，不过它强大在第三方服务的集成上，可以做很多自动化的事情。</p>\n<h3 id=\"Fantastical-2\"><a href=\"#Fantastical-2\" class=\"headerlink\" title=\"Fantastical 2\"></a>Fantastical 2</h3><p><a href=\"https://flexibits.com/fantastical\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/1naxpaM.jpg\" alt=\"Fantastical\"></p>\n<p>日历工具，查看满满的一屏幕日程，你会感觉很舒服的。</p>\n<h4 id=\"Tunnelblick\"><a href=\"#Tunnelblick\" class=\"headerlink\" title=\"Tunnelblick\"></a>Tunnelblick</h4><p><a href=\"https://tunnelblick.net/downloads.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/ghIEHNQ.png\" alt=\"Tunnelblick-menu\"></p>\n<p>公司需要使用该 App 来接入办公室网络。远程办公必备。</p>\n<h4 id=\"Office-三件套\"><a href=\"#Office-三件套\" class=\"headerlink\" title=\"Office 三件套\"></a>Office 三件套</h4><p>微软的 Office 三件套，Word，Excel，PowerPoint。 用的频率不高，但是用的时候得有。</p>\n<h2 id=\"GTD\"><a href=\"#GTD\" class=\"headerlink\" title=\"GTD\"></a>GTD</h2><p>日常 GTD 工具，基本就是各家评测常提起的几款 App。</p>\n<h3 id=\"2Do\"><a href=\"#2Do\" class=\"headerlink\" title=\"2Do\"></a>2Do</h3><p><a href=\"https://www.2doapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/st89Smb.jpg\" alt=\"2Do on Mac\"></p>\n<p>最近才完全转向 2Do，这个 GTD 工具是我最早买入的，但是后来因为其自动化太弱，被打入冷宫。最近几个月又开始捡起来了，吸引我的几个点：</p>\n<ol>\n<li>Colorful Tab</li>\n<li>Mail AutoCapture</li>\n<li>Smart List</li>\n</ol>\n<p>还有一点就是，其同步目前稳定的就只能使用 Dropbox 了，在国内基本对大部分人就是个障碍。</p>\n<h3 id=\"Things-3\"><a href=\"#Things-3\" class=\"headerlink\" title=\"Things 3\"></a>Things 3</h3><p><img src=\"https://i.imgur.com/5ifAVwf.jpg\" alt=\"Things3\"></p>\n<p>Things 2 之前也有，不过因为功能太简单，基本处于买了看看的状态，后来 Things 3 的出现主要看中它的设计元素。</p>\n<h3 id=\"OmniFocus-3\"><a href=\"#OmniFocus-3\" class=\"headerlink\" title=\"OmniFocus 3\"></a>OmniFocus 3</h3><p><img src=\"https://i.imgur.com/D72LM50.jpg\" alt=\"OmniFocus 3\"></p>\n<p>使用它最主要的原因是它支持 AppleScript 比较方便。尤其是结合 Keyboard Maestro 来用太方便。比如我会建立一些定时任务，每周五下午下班前自动生成一张周报表单，列出来本周完成的 Task 等。</p>\n<p>最近刚又从 2 升级到 3 代，半价折扣 39.99$</p>\n<p>3 主要将之前 Context 更换为支持多属性的 Tag，也算补充了一个竞争点吧。</p>\n<h2 id=\"系统工具\"><a href=\"#系统工具\" class=\"headerlink\" title=\"系统工具\"></a>系统工具</h2><p>基本是系统缺少的或者功能难以满足日常使用的一些 App。</p>\n<h3 id=\"1-Blocker\"><a href=\"#1-Blocker\" class=\"headerlink\" title=\"1 Blocker\"></a>1 Blocker</h3><p><a href=\"https://itunes.apple.com/app/id1107421413\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/l3aGI1P.jpg\" alt=\"1 Blocker\"></p>\n<h3 id=\"iStat-Menus\"><a href=\"#iStat-Menus\" class=\"headerlink\" title=\"iStat Menus\"></a>iStat Menus</h3><p><a href=\"http://download.bjango.com/istatmenus/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/PtO8FNP.jpg\" alt=\"iStat Menus\"></p>\n<h3 id=\"Bartender-3\"><a href=\"#Bartender-3\" class=\"headerlink\" title=\"Bartender 3\"></a>Bartender 3</h3><p><a href=\"https://www.macbartender.com/Demo/Bartender%203.zip\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/EnE2fyQ.png\" alt=\"Bartender\"></p>\n<h3 id=\"Surge\"><a href=\"#Surge\" class=\"headerlink\" title=\"Surge\"></a>Surge</h3><p><a href=\"https://nssurge.com/\" target=\"_blank\" rel=\"noopener\">Surge</a></p>\n<p>最近 Yachen Liu 发布了 Surge 3 的 Mac 版本预览版本</p>\n<p><img src=\"https://i.imgur.com/CNc6AIK.png\" alt=\"Surge 3\"></p>\n<p>实质上是个网络调试工具，但是大部分情况下被用来作为爱国上网工具了。 而且定价策略也是引发了很多口水战，不过商品嘛，如果你觉得不值就不买就行了，不必要想用还骂他定价高，对吧。</p>\n<p><img src=\"https://i.imgur.com/gkhCynx.png\" alt=\"Surge Dashboard\"></p>\n<h3 id=\"Wallpaper-Wizard\"><a href=\"#Wallpaper-Wizard\" class=\"headerlink\" title=\"Wallpaper Wizard\"></a>Wallpaper Wizard</h3><p><a href=\"https://itunes.apple.com/cn/app/wallpaper-wizard-2/id1266674560?mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/lYnieJQ.jpg\" alt=\"Wallpaper Wizard\"></p>\n<p>MacPaw 家的壁纸应用，限时免费的时候入的。</p>\n<h3 id=\"TinkerTool\"><a href=\"#TinkerTool\" class=\"headerlink\" title=\"TinkerTool\"></a>TinkerTool</h3><p><a href=\"https://www.bresink.com/osx/TinkerTool.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/YqvFP1Y.png\" alt=\"TinkerTool\"></p>\n<p>一个系统增强工具，可以对 Dashboard 和 Docker 等进行定制化修改。</p>\n<h3 id=\"Capto\"><a href=\"#Capto\" class=\"headerlink\" title=\"Capto\"></a>Capto</h3><p><a href=\"https://www.globaldelight.com/capto/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/9QeUc6Z.jpg\" alt=\"Capto\"></p>\n<p>截屏和录制视频工具。</p>\n<h2 id=\"效率工具\"><a href=\"#效率工具\" class=\"headerlink\" title=\"效率工具\"></a>效率工具</h2><h3 id=\"1Password-7-for-Mac\"><a href=\"#1Password-7-for-Mac\" class=\"headerlink\" title=\"1Password 7 for Mac\"></a>1Password 7 for Mac</h3><p><a href=\"https://app-updates.agilebits.com/download/OPM7\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/Bb13IZD.jpg\" alt=\"1Password 7\"></p>\n<h3 id=\"Alfred-3\"><a href=\"#Alfred-3\" class=\"headerlink\" title=\"Alfred 3\"></a>Alfred 3</h3><p><a href=\"https://cachefly.alfredapp.com/Alfred_3.6.2_922.dmg\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/WeFkSYh.jpg\" alt=\"Alfred\"></p>\n<h3 id=\"LaunchBar-6\"><a href=\"#LaunchBar-6\" class=\"headerlink\" title=\"LaunchBar 6\"></a>LaunchBar 6</h3><p><a href=\"https://www.obdev.at/products/launchbar/download.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/FVgOB3g.png\" alt=\"LaunchBar\"></p>\n<h3 id=\"BetterTouchTool\"><a href=\"#BetterTouchTool\" class=\"headerlink\" title=\"BetterTouchTool\"></a>BetterTouchTool</h3><p><a href=\"https://bettertouchtool.net/releases/BetterTouchTool.zip\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/4RfNX0T.jpg\" alt=\"BetterTouchTool\"></p>\n<h3 id=\"Keyboard-Maestro\"><a href=\"#Keyboard-Maestro\" class=\"headerlink\" title=\"Keyboard Maestro\"></a>Keyboard Maestro</h3><p><a href=\"https://www.keyboardmaestro.com/action/download?km-kmi-7-b3\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/IOZeiaH.png\" alt=\"Keyboard Maestro\"></p>\n<h3 id=\"Yoink\"><a href=\"#Yoink\" class=\"headerlink\" title=\"Yoink\"></a>Yoink</h3><p><a href=\"https://eternalstorms.at/yoink/mac/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/oMcckyM.jpg\" alt=\"Yoink\"></p>\n<h3 id=\"Unclutter\"><a href=\"#Unclutter\" class=\"headerlink\" title=\"Unclutter\"></a>Unclutter</h3><p><a href=\"https://unclutterapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/SunNE17.png\" alt=\"Unclutter\"></p>\n<h3 id=\"ToothFairy\"><a href=\"#ToothFairy\" class=\"headerlink\" title=\"ToothFairy\"></a>ToothFairy</h3><p><a href=\"https://itunes.apple.com/cn/app/toothfairy/id1191449274?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/2crElmV.jpg\" alt=\"ToothFairy\"></p>\n<h3 id=\"PopClip\"><a href=\"#PopClip\" class=\"headerlink\" title=\"PopClip\"></a>PopClip</h3><p><a href=\"https://itunes.apple.com/cn/app/popclip/id445189367?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/qytMbLT.jpg\" alt=\"PopClip\"></p>\n<h3 id=\"Copied\"><a href=\"#Copied\" class=\"headerlink\" title=\"Copied\"></a>Copied</h3><p><a href=\"https://geo.itunes.apple.com/us/app/copied/id1026349850?ls=1&amp;mt=12&amp;at=1010l8Ju&amp;ct=web&amp;uo=8&amp;at=1010l8Ju\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/hRW1Xoo.jpg\" alt=\"Copied\"></p>\n<p>一款剪贴板工具，应该是目前 Mac 上最强大的剪贴板工具了。</p>\n<h2 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h2><h3 id=\"Day-One\"><a href=\"#Day-One\" class=\"headerlink\" title=\"Day One\"></a>Day One</h3><p><a href=\"https://itunes.apple.com/cn/app/day-one/id1055511498?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/fKmOZa9.jpg\" alt=\"Day One\"></p>\n<p>日记应用，之前买了 iOS 和 Mac 双版本，改成订阅之后自动升级为 Plus 会员了，功能已经完全足够。最近的 Premium 会员增加了音频日记以及 Dark Theme 的主题了。</p>\n<h3 id=\"Ulysses\"><a href=\"#Ulysses\" class=\"headerlink\" title=\"Ulysses\"></a>Ulysses</h3><p><a href=\"https://itunes.apple.com/cn/app/ulysses/id1225570693?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/GBaAJW2.jpg\" alt=\"Ulysses\"></p>\n<p>这个完全是冲动消费，就是想看看大家捧杀这么狠到底优秀在哪里，说实话其自定义的 Markdown 格式我还是用不太习惯，不过用了每几次。从非订阅用到了订阅</p>\n<h3 id=\"MWeb\"><a href=\"#MWeb\" class=\"headerlink\" title=\"MWeb\"></a>MWeb</h3><p>推荐安装其非 MAS 版本，<a href=\"https://zh.mweb.im/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/fMxRIDB.jpg\" alt=\"MWeb\"></p>\n<p>前一阵子刚又升级到了 3.0 版本，虽然 UI 上和 Ulysses 差得远，不过因为本地化做的好，各项服务接入的比较完整，比如图床，静态网站自动生成等都是比较吸引人的地方。</p>\n<h3 id=\"Notability\"><a href=\"#Notability\" class=\"headerlink\" title=\"Notability\"></a>Notability</h3><p><a href=\"https://itunes.apple.com/cn/app/notability/id736189492?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/GPiorsk.jpg\" alt=\"Notability\"></p>\n<h3 id=\"GoodNotes\"><a href=\"#GoodNotes\" class=\"headerlink\" title=\"GoodNotes\"></a>GoodNotes</h3><p><a href=\"https://itunes.apple.com/cn/app/goodnotes/id1026566364?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-2400x2400bb -2-.jpg\" alt=\"GoodNotes\"></p>\n<h3 id=\"MindNode-5\"><a href=\"#MindNode-5\" class=\"headerlink\" title=\"MindNode 5\"></a>MindNode 5</h3><p><a href=\"https://itunes.apple.com/cn/app/mindnode-5/id1289197285?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/1er4hI3.jpg\" alt=\"MindNode 5\"></p>\n<h2 id=\"阅读\"><a href=\"#阅读\" class=\"headerlink\" title=\"阅读\"></a>阅读</h2><h3 id=\"DEVONThink-Pro-Office\"><a href=\"#DEVONThink-Pro-Office\" class=\"headerlink\" title=\"DEVONThink Pro Office\"></a>DEVONThink Pro Office</h3><p><a href=\"https://www.devontechnologies.com/download/products.html\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-42007085dd.png\" alt=\"DEVONThink Pro Office\"></p>\n<p>已经完全把 DENONThink 家的产品作为构建我知识图谱的工具了。必备。</p>\n<h3 id=\"Reeder-3\"><a href=\"#Reeder-3\" class=\"headerlink\" title=\"Reeder 3\"></a>Reeder 3</h3><p><a href=\"https://itunes.apple.com/us/app/reeder-3/id880001334?mt=12&amp;uo=4&amp;at=1001lsTF&amp;ct=iOS_detail_share_880001334\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/NPLz9Wl.jpg\" alt=\"Reeder 3\"></p>\n<h3 id=\"MarginNote-3\"><a href=\"#MarginNote-3\" class=\"headerlink\" title=\"MarginNote 3\"></a>MarginNote 3</h3><p><a href=\"https://marginnote.com/?lang=zh-hans\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/kPu5B0k.jpg\" alt=\"MarginNote 3\"></p>\n<h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><h3 id=\"IDE\"><a href=\"#IDE\" class=\"headerlink\" title=\"IDE\"></a>IDE</h3><h4 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h4><p>话不多说，老老实实的从 App Store 下载吧。</p>\n<p><img src=\"https://i.imgur.com/NSW9lFo.jpg\" alt=\"Xcode\"></p>\n<h4 id=\"AppCode\"><a href=\"#AppCode\" class=\"headerlink\" title=\"AppCode\"></a>AppCode</h4><p><a href=\"https://www.jetbrains.com/objc/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/pdXy6FK.png\" alt=\"AppCode\"></p>\n<p>AppCode 强大就强大在 Jetbrain 团队一贯的 Refactor 功能。不过在 15寸 中配 MacBook Pro 上依然会时不时卡顿，不清楚时不时因为其基于 JVM 那一套所致。推荐个人开发者或者项目不太庞大的团队或者个人使用。</p>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><h4 id=\"Visual-Studio-Code\"><a href=\"#Visual-Studio-Code\" class=\"headerlink\" title=\"Visual Studio Code\"></a>Visual Studio Code</h4><p><a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/ExXn0QN.png\" alt=\"Visual Studio Code\"></p>\n<p>目前当之无愧最好使的编辑器了，当然可以作为大量脚本语言的轻量 IDE 使用了。</p>\n<h3 id=\"代码管理\"><a href=\"#代码管理\" class=\"headerlink\" title=\"代码管理\"></a>代码管理</h3><h4 id=\"Tower\"><a href=\"#Tower\" class=\"headerlink\" title=\"Tower\"></a>Tower</h4><p>Tower 是一款多平台支持的 Git GUI，使用命令行虽然某些程度上比较快，也显得 Geek 范儿，但是在查看 Diff 等功能上确实不太直观，因此一款 Git 的 UI 工具显得很重要。Tower 是一款收费软件，最近 3.0 转为了订阅式。刚订阅了一年基础版再接着用，毕竟切换工具的代价有时候蛮大的。</p>\n<p><a href=\"https://www.git-tower.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/r4FdJaF.jpg\" alt=\"Microsoft.VisualStudio.Services.Screenshots\"></p>\n<h4 id=\"OhMyStar\"><a href=\"#OhMyStar\" class=\"headerlink\" title=\"OhMyStar\"></a>OhMyStar</h4><p><a href=\"https://itunes.apple.com/us/app/ohmystar2/id1218642292?ls=1&amp;mt=8\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/3NNd0ct.jpg\" alt=\"OhMyStar 2\"></p>\n<h4 id=\"SnippetsLab\"><a href=\"#SnippetsLab\" class=\"headerlink\" title=\"SnippetsLab\"></a>SnippetsLab</h4><p><a href=\"https://itunes.apple.com/cn/app/snippetslab/id1006087419?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/qd4LQGz.jpg\" alt=\"SnippetsLab\"></p>\n<h3 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h3><h4 id=\"Sketch\"><a href=\"#Sketch\" class=\"headerlink\" title=\"Sketch\"></a>Sketch</h4><p><a href=\"https://www.sketchapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/NXGXH8X.jpg\" alt=\"Sketch\"></p>\n<h4 id=\"Sip-for-Mac\"><a href=\"#Sip-for-Mac\" class=\"headerlink\" title=\"Sip for Mac\"></a>Sip for Mac</h4><p><a href=\"https://sipapp.io/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/f3NUIHy.jpg\" alt=\"sip-color-format-mac-2016\"></p>\n<h4 id=\"PaintCode\"><a href=\"#PaintCode\" class=\"headerlink\" title=\"PaintCode\"></a>PaintCode</h4><p><a href=\"https://www.paintcodeapp.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/E7UILLI.png\" alt=\"PaintCode 3\"></p>\n<p>主要针对一些复杂的设计图形，用代码绘制会非常复杂，比如一个需要使用 Bezier 绘制复杂的图形，如果人工画，费时费力。使用 PaintCode 能够解决这个痛点，支持 Objective-C 和 Swift 两种语言。</p>\n<p>结合 Playground 的话你感受一下。</p>\n<h4 id=\"Eagle\"><a href=\"#Eagle\" class=\"headerlink\" title=\"Eagle\"></a>Eagle</h4><p><img src=\"https://i.imgur.com/4kEFUi4.png\" alt=\"Eagle\"></p>\n<p>设计师用来收集素材所用</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><h4 id=\"Charles\"><a href=\"#Charles\" class=\"headerlink\" title=\"Charles\"></a>Charles</h4><p><a href=\"https://www.charlesproxy.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/s7LX5NO.png\" alt=\"Charles\"></p>\n<p>使用公司的序列号，手机版本我也入了，不过在 iOS 生态里其并没有 Mac 上在同等功能上的地位，在 iOS 上我更喜欢使用 surge 或者 Thor 来抓包，而后者的功能基本上目前是市面上最完整的 App 了。 但是在 Mac 平台，Charles 的地位依然无人撼动。</p>\n<h4 id=\"Paw\"><a href=\"#Paw\" class=\"headerlink\" title=\"Paw\"></a>Paw</h4><p><a href=\"https://paw.cloud/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/zt7Up5u.jpg\" alt=\"paw-lg\"></p>\n<p>强大的 API 调试工具</p>\n<h4 id=\"Reveal\"><a href=\"#Reveal\" class=\"headerlink\" title=\"Reveal\"></a>Reveal</h4><p><a href=\"https://revealapp.com/features/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/ITkfXe6.jpg\" alt=\"Reveal\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"Monodraw\"><a href=\"#Monodraw\" class=\"headerlink\" title=\"Monodraw\"></a>Monodraw</h4><p><a href=\"https://monodraw.helftone.com/\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/M20TPBn.jpg\" alt=\"Monodraw\"></p>\n<p>代码注释加强工具，可以用来对代码进行注释。</p>\n<h4 id=\"CuteBaby\"><a href=\"#CuteBaby\" class=\"headerlink\" title=\"CuteBaby\"></a>CuteBaby</h4><p><img src=\"https://i.imgur.com/GyIzViM.jpg\" alt=\"CuteBaby\"></p>\n<p>Model 序列化工具，解决的痛点就是后端给你一个 JSON 结构，你需要自行映射成工程中的类，这个重复工作有时候会让您炸掉，因为有的接口返回的结构复杂，字段繁杂。不过网络上有很多开源的项目其实也可以做到一定程度。</p>\n<h2 id=\"社交\"><a href=\"#社交\" class=\"headerlink\" title=\"社交\"></a>社交</h2><h4 id=\"Telegram\"><a href=\"#Telegram\" class=\"headerlink\" title=\"Telegram\"></a>Telegram</h4><p><a href=\"https://telegram.org/dl/macos\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/cWw9qpK.jpg\" alt=\"Telegram\"></p>\n<h4 id=\"Tweetbot-3\"><a href=\"#Tweetbot-3\" class=\"headerlink\" title=\"Tweetbot 3\"></a>Tweetbot 3</h4><p><a href=\"https://itunes.apple.com/cn/app/tweetbot-3-for-twitter/id1384080005?l=en&amp;mt=12\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p><img src=\"https://i.imgur.com/yK4hhTr.jpg\" alt=\"Tweetbot\"></p>\n<h2 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h4 id=\"RescueTime\"><a href=\"#RescueTime\" class=\"headerlink\" title=\"RescueTime\"></a>RescueTime</h4><p>买了 Premium 会员，记录我日常在 Mac 上的工作记录。已经记录了大概有 2 年多的数据了，很直观。</p>\n<h4 id=\"PCalc\"><a href=\"#PCalc\" class=\"headerlink\" title=\"PCalc\"></a>PCalc</h4><p><img src=\"https://i.imgur.com/PRMDseI.jpg\" alt=\"PCalc\"></p>\n<p>也算是老牌的计算器了</p>"},{"title":"Objective-C中Category的一点东西","date":"2015-09-14T07:36:07.000Z","photos":["http://7xilk1.com1.z0.glb.clouddn.com/14953702759985.png"],"_content":"\nObjective-C中的分类（category）是一种编译时的手段，其允许我们通过给某个已知类添加方法来扩充该类的一种方式。当然这其中是有限制的，就是不能给已知类添加新的实例变量。\n\n<!-- more -->\n\n\n如下代码展示：\n\n类`MyClass`为一个简单的类，其中有实例方法 `-print` \n\n``` objc\n#import <Foundation/Foundation.h>\n@interface MyClass : NSObject\n\n- (void)print;\n\n@end\n```\n\n``` MyClass.m\n#import \"MyClass.h\"\n@implementation MyClass\n\n- (void)print\n{\n\tNSLog(@\"MyClass...\");\n}\n\n@end\n```\n\n我们向为MyClass再添加一个方法Hello，那我们就可以用分类的方法实现，我们为其添加分类MyAddition1和MyAddition2，如下所示：\n\n``` objc\n#import \"MyClass.h\"\n@interface MyClass (MyAddition1)\n\n@property (nonatomic, copy) NSString *name;\n- (void)hello;\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n\n@implementation MyClass (MyAddition1)\n\n- (void)hello\n{\n\tNSLog(@\"hello!!!\");\n}\n\n@end\n```\n其中MyAddition为分类的名称，而文件名字约定俗成用“类名+扩展名”的形式。这样，我们就能够为MyClass类添加hello方法了，如下调用：\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n\nint main() {\n\t//...\n\tMyClass my = [MyClass new];\n\t[my hello];\n\t//...\n}\n```\n \nCategory 的使用场景主要有以下几种：\n1. 需求变更，需要为已知类添加方法；\n2. 将类的不同模块实现划分: a)具体可以将类的实现分开到不同的文件里面； b)将不同功能的分类文件交由不同的开发者实现；\n3. 想为Apple基础类库添加自己需要的方法，实际上和1相似；\n\n但是分类的使用目前也有需要注意的地方：\n1. Category可以访问原有类的实例变量，但不能添加实例变量；\n2. Category中实现和原有类中相同签名的方法时，会覆盖原有类的方法；\n\n但是这两点均可以通过其他方式实现：\n\n### 为分类添加实例变量\n为分类添加实例变量主要通过关联对象的方法。如下所示：\n\n``` objc\n#import \"MyClass.h\"\n@interface MyClass (MyAddition1)\n\n@property (nonatomic, copy) NSString *name;\n\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n#import <objc/objc-runtime.h>\n\n@implementation MyClass (MyAddition1)\n\n- (void)setName:(NSString *)name {\n    objc_setAssociatedObject(self, \"key\", name, OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString *)name {\n    NSString *name = objc_getAssociatedObject(self, \"key\");\n    return name;\n}\n\n@end\n```\n\n#### 如果调用被分类覆盖掉的原方法\n实际上，通过查看Objc runtime源码可以获知，分类方法并不是绝对意义上的覆盖原有类的方法，只是在调用的时候调用顺序导致而已，这涉及到Objc runtime的一些内容。\n\n在下载到的运行时源码中objc-runtime-new.mm文件中有attachCategoryMethods方法，其就是将类的分类方法添加到类的方法列表中去的：\n\n``` objc\n// objc-runtime-new.mm\nstatic void \nattachCategoryMethods(Class cls, category_list *cats, bool flushCaches) {\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, flushCaches);\n\n    _free_internal(mlists);\n}\n```\n\n那`attachCategoryMethods`的工作就是将所有分类的实例方法列表进行拼接，形成更大的`mlists`表，然后转交给`attachMethodLists`方法来执行。\n\n``` objc\nstatic void \nattachMethodLists(Class cls, method_list_t **addedLists, int addedCount, \n                  bool baseMethods, bool methodsFromBundle, \n                  bool flushCaches) {\n    rwlock_assert_writing(&runtimeLock);\n\n    // Don't scan redundantly\n    bool scanForCustomRR = !UseGC && !cls->hasCustomRR();\n    bool scanForCustomAWZ = !UseGC && !cls->hasCustomAWZ();\n\n    // There exist RR/AWZ special cases for some class's base methods. \n    // But this code should never need to scan base methods for RR/AWZ: \n    // default RR/AWZ cannot be set before setInitialized().\n    // Therefore we need not handle any special cases here.\n    if (baseMethods) {\n        assert(!scanForCustomRR  &&  !scanForCustomAWZ);\n    }\n\n    // Method list array is nil-terminated.\n    // Some elements of lists are nil; we must filter them out.\n\n    method_list_t *oldBuf[2];\n    method_list_t **oldLists;\n    int oldCount = 0;\n    if (cls->data()->flags & RW_METHOD_ARRAY) {\n        oldLists = cls->data()->method_lists;\n    } else {\n        oldBuf[0] = cls->data()->method_list;\n        oldBuf[1] = nil;\n        oldLists = oldBuf;\n    }\n    if (oldLists) {\n        while (oldLists[oldCount]) oldCount++;\n    }\n        \n    int newCount = oldCount;\n    for (int i = 0; i < addedCount; i++) {\n        if (addedLists[i]) newCount++;  // only non-nil entries get added\n    }\n\n    method_list_t *newBuf[2];\n    method_list_t **newLists;\n    if (newCount > 1) {\n        newLists = (method_list_t **)\n            _malloc_internal((1 + newCount) * sizeof(*newLists));\n    } else {\n        newLists = newBuf;\n    }\n\n    // Add method lists to array.\n    // Reallocate un-fixed method lists.\n    // The new methods are PREPENDED to the method list array.\n\n    newCount = 0;\n    int i;\n    for (i = 0; i < addedCount; i++) {\n        method_list_t *mlist = addedLists[i];\n        if (!mlist) continue;\n\n        // Fixup selectors if necessary\n        if (!isMethodListFixedUp(mlist)) {\n            mlist = fixupMethodList(mlist, methodsFromBundle, true/*sort*/);\n        }\n\n        // Scan for method implementations tracked by the class's flags\n        if (scanForCustomRR  &&  methodListImplementsRR(mlist)) {\n            cls->setHasCustomRR();\n            scanForCustomRR = false;\n        }\n        if (scanForCustomAWZ  &&  methodListImplementsAWZ(mlist)) {\n            cls->setHasCustomAWZ();\n            scanForCustomAWZ = false;\n        }\n\n        // Update method caches\n        if (flushCaches) {\n            cache_eraseMethods(cls, mlist);\n        }\n        \n        // Fill method list array\n        newLists[newCount++] = mlist;\n    }\n\n    // Copy old methods to the method list array\n    for (i = 0; i < oldCount; i++) {\n        newLists[newCount++] = oldLists[i];\n    }\n    if (oldLists  &&  oldLists != oldBuf) free(oldLists);\n\n    // nil-terminate\n    newLists[newCount] = nil;\n\n    if (newCount > 1) {\n        assert(newLists != newBuf);\n        cls->data()->method_lists = newLists;\n        cls->setInfo(RW_METHOD_ARRAY);\n    } else {\n        assert(newLists == newBuf);\n        cls->data()->method_list = newLists[0];\n        assert(!(cls->data()->flags & RW_METHOD_ARRAY));\n    }\n}\n```\n\n注意上面代码中注释copy old methods to the method list array，可以获知该类原有的方法被追加到了新方法列表的后面，因此可以了解如果category和原来的都由methodA方法，那newLists中肯定存在两个methodA方法。而运行时在查找类方法的时候是在方法列表中按序查找的，一旦发现对应签名的方法则就返回，因此被后置的原有方法自然而然就被方法列表前面的同签名方法所覆盖了。\n\n当然，如果还有一个分类也覆盖了同样的方法，顺序又是什么样子呢？根据文件的编译顺序，有兴趣的童鞋可以尝试一下，关于编译顺序。。。\n\n![XCode文件编译顺序调整](http://7xilk1.com1.z0.glb.clouddn.com/iosXCode编译顺序调整.png)\n\n\n明白了这种情况，如果我们需要调用类的被覆盖的方法，则通过查找类的实例方法列表中对应签名的方法，在方法列表前面的自然就是分类所对应的方法，而最后一个则是MyClass的原有方法了。\n\n``` objc\n#import <Foundation/Foundation.h>\n@interface MyClass : NSObject\n\n- (void)print;\n\n@end\n```\n\n``` objc\n#import \"MyClass.h\"\n\n@implementation MyClass\n\n- (void)print {\n    NSLog(@\"MyClass\");\n}\n\n@end\n```\n\n为MyClass添加分类MyAddition1，代码如下：\n\n``` objc\n#import \"MyClass.h\"\n\n@interface MyClass (MyAddition1)\n\n- (void) print;\n\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n\n@implementation MyClass (MyAddition1)\n\n- (void)print {\n    NSLog(@\"MyAddition1\");\n}\n\n@end\n```\n\n然后再添加`MyAddition2`分类，\n\n``` objc\n#import \"MyClass.h\"\n\n@interface MyClass (MyAddition2)\n\n- (void) print;\n\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition2.h\"\n\n@implementation MyClass (MyAddition2)\n\n- (void)print {\n    NSLog(@\"MyAddition2\");\n}\n\n@end\n```\n\n当我们将整个文件编译之后我们就可以获得MyClass所有的方法了，如下代码所示：\n\n``` objc\n#import \"MyClass.h\"\n#import <objc/objc-runtime.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Class cls = [MyClass class];\n        MyClass *my = [MyClass new];\n        \n        [my print];\n        \n        if(cls) {\n            unsigned int methodCount;\n            Method *methodList = class_copyMethodList(cls, &methodCount);\n            \n            IMP lastImp = NULL;\n            SEL lastSel = NULL;\n            for (NSInteger i = 0; i < methodCount; i++) {\n                Method method = methodList[i];\n                NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding];\n\t\t\t\tNSLog(@\"methodName: %@\", methodName);\n\n                if([methodName isEqualToString:@\"print\"]) {\n                    lastImp = method_getImplementation(method);\n                    lastSel = method_getName(method);\n                }\n            }\n        \n            typedef void(*fn)(id, SEL);\n            \n            if(lastImp != NULL) {\n                fn f = (fn)(lastImp);\n                f(my, lastSel);\n            }\n            \n            free(methodList);\n        }\n    }\n    return 0;\n}\n```\n\n代码内容就是将类所对应的方法列表取出，找到最后一个对应名称的方法，取得函数指针，然后传入参数执行。\n\n输出结果如下：\n\n``` objc\n2015-09-14 15:26:59.793 ObjMessage[88888:10428876] MyAddition2\n2015-09-14 15:26:59.794 ObjMessage[88888:10428876] methodName: print\n2015-09-14 15:26:59.795 ObjMessage[88888:10428876] methodName: print\n2015-09-14 15:26:59.795 ObjMessage[88888:10428876] methodName: print\n2015-09-14 15:30:38.941 ObjMessage[88888:10428876] MyClass\n```\n\n当我们使用print方法时，打印为MyAddition2中的实现，并且MyClass类方法列表中有三个方法，并且均为print，取出列表中最后一个print并调用打印结果为MyClass类原有类中的实现。此时就达到了我们的目的。\n当然，你也可以调整下MyClass+MyAddition1.m文件和MyClass+MyAddition2.m文件的顺序验证下，结果MyClass默认输出为MyAddition1.\n\n","source":"_posts/Objective-C中Category的一点东西.md","raw":"title: \"Objective-C中Category的一点东西\"\ndate: 2015-09-14 15:36:07\ncategories: iOS\nphotos: http://7xilk1.com1.z0.glb.clouddn.com/14953702759985.png\ntags: [iOS,Category]\n---\n\nObjective-C中的分类（category）是一种编译时的手段，其允许我们通过给某个已知类添加方法来扩充该类的一种方式。当然这其中是有限制的，就是不能给已知类添加新的实例变量。\n\n<!-- more -->\n\n\n如下代码展示：\n\n类`MyClass`为一个简单的类，其中有实例方法 `-print` \n\n``` objc\n#import <Foundation/Foundation.h>\n@interface MyClass : NSObject\n\n- (void)print;\n\n@end\n```\n\n``` MyClass.m\n#import \"MyClass.h\"\n@implementation MyClass\n\n- (void)print\n{\n\tNSLog(@\"MyClass...\");\n}\n\n@end\n```\n\n我们向为MyClass再添加一个方法Hello，那我们就可以用分类的方法实现，我们为其添加分类MyAddition1和MyAddition2，如下所示：\n\n``` objc\n#import \"MyClass.h\"\n@interface MyClass (MyAddition1)\n\n@property (nonatomic, copy) NSString *name;\n- (void)hello;\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n\n@implementation MyClass (MyAddition1)\n\n- (void)hello\n{\n\tNSLog(@\"hello!!!\");\n}\n\n@end\n```\n其中MyAddition为分类的名称，而文件名字约定俗成用“类名+扩展名”的形式。这样，我们就能够为MyClass类添加hello方法了，如下调用：\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n\nint main() {\n\t//...\n\tMyClass my = [MyClass new];\n\t[my hello];\n\t//...\n}\n```\n \nCategory 的使用场景主要有以下几种：\n1. 需求变更，需要为已知类添加方法；\n2. 将类的不同模块实现划分: a)具体可以将类的实现分开到不同的文件里面； b)将不同功能的分类文件交由不同的开发者实现；\n3. 想为Apple基础类库添加自己需要的方法，实际上和1相似；\n\n但是分类的使用目前也有需要注意的地方：\n1. Category可以访问原有类的实例变量，但不能添加实例变量；\n2. Category中实现和原有类中相同签名的方法时，会覆盖原有类的方法；\n\n但是这两点均可以通过其他方式实现：\n\n### 为分类添加实例变量\n为分类添加实例变量主要通过关联对象的方法。如下所示：\n\n``` objc\n#import \"MyClass.h\"\n@interface MyClass (MyAddition1)\n\n@property (nonatomic, copy) NSString *name;\n\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n#import <objc/objc-runtime.h>\n\n@implementation MyClass (MyAddition1)\n\n- (void)setName:(NSString *)name {\n    objc_setAssociatedObject(self, \"key\", name, OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString *)name {\n    NSString *name = objc_getAssociatedObject(self, \"key\");\n    return name;\n}\n\n@end\n```\n\n#### 如果调用被分类覆盖掉的原方法\n实际上，通过查看Objc runtime源码可以获知，分类方法并不是绝对意义上的覆盖原有类的方法，只是在调用的时候调用顺序导致而已，这涉及到Objc runtime的一些内容。\n\n在下载到的运行时源码中objc-runtime-new.mm文件中有attachCategoryMethods方法，其就是将类的分类方法添加到类的方法列表中去的：\n\n``` objc\n// objc-runtime-new.mm\nstatic void \nattachCategoryMethods(Class cls, category_list *cats, bool flushCaches) {\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    bool isMeta = cls->isMetaClass();\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, flushCaches);\n\n    _free_internal(mlists);\n}\n```\n\n那`attachCategoryMethods`的工作就是将所有分类的实例方法列表进行拼接，形成更大的`mlists`表，然后转交给`attachMethodLists`方法来执行。\n\n``` objc\nstatic void \nattachMethodLists(Class cls, method_list_t **addedLists, int addedCount, \n                  bool baseMethods, bool methodsFromBundle, \n                  bool flushCaches) {\n    rwlock_assert_writing(&runtimeLock);\n\n    // Don't scan redundantly\n    bool scanForCustomRR = !UseGC && !cls->hasCustomRR();\n    bool scanForCustomAWZ = !UseGC && !cls->hasCustomAWZ();\n\n    // There exist RR/AWZ special cases for some class's base methods. \n    // But this code should never need to scan base methods for RR/AWZ: \n    // default RR/AWZ cannot be set before setInitialized().\n    // Therefore we need not handle any special cases here.\n    if (baseMethods) {\n        assert(!scanForCustomRR  &&  !scanForCustomAWZ);\n    }\n\n    // Method list array is nil-terminated.\n    // Some elements of lists are nil; we must filter them out.\n\n    method_list_t *oldBuf[2];\n    method_list_t **oldLists;\n    int oldCount = 0;\n    if (cls->data()->flags & RW_METHOD_ARRAY) {\n        oldLists = cls->data()->method_lists;\n    } else {\n        oldBuf[0] = cls->data()->method_list;\n        oldBuf[1] = nil;\n        oldLists = oldBuf;\n    }\n    if (oldLists) {\n        while (oldLists[oldCount]) oldCount++;\n    }\n        \n    int newCount = oldCount;\n    for (int i = 0; i < addedCount; i++) {\n        if (addedLists[i]) newCount++;  // only non-nil entries get added\n    }\n\n    method_list_t *newBuf[2];\n    method_list_t **newLists;\n    if (newCount > 1) {\n        newLists = (method_list_t **)\n            _malloc_internal((1 + newCount) * sizeof(*newLists));\n    } else {\n        newLists = newBuf;\n    }\n\n    // Add method lists to array.\n    // Reallocate un-fixed method lists.\n    // The new methods are PREPENDED to the method list array.\n\n    newCount = 0;\n    int i;\n    for (i = 0; i < addedCount; i++) {\n        method_list_t *mlist = addedLists[i];\n        if (!mlist) continue;\n\n        // Fixup selectors if necessary\n        if (!isMethodListFixedUp(mlist)) {\n            mlist = fixupMethodList(mlist, methodsFromBundle, true/*sort*/);\n        }\n\n        // Scan for method implementations tracked by the class's flags\n        if (scanForCustomRR  &&  methodListImplementsRR(mlist)) {\n            cls->setHasCustomRR();\n            scanForCustomRR = false;\n        }\n        if (scanForCustomAWZ  &&  methodListImplementsAWZ(mlist)) {\n            cls->setHasCustomAWZ();\n            scanForCustomAWZ = false;\n        }\n\n        // Update method caches\n        if (flushCaches) {\n            cache_eraseMethods(cls, mlist);\n        }\n        \n        // Fill method list array\n        newLists[newCount++] = mlist;\n    }\n\n    // Copy old methods to the method list array\n    for (i = 0; i < oldCount; i++) {\n        newLists[newCount++] = oldLists[i];\n    }\n    if (oldLists  &&  oldLists != oldBuf) free(oldLists);\n\n    // nil-terminate\n    newLists[newCount] = nil;\n\n    if (newCount > 1) {\n        assert(newLists != newBuf);\n        cls->data()->method_lists = newLists;\n        cls->setInfo(RW_METHOD_ARRAY);\n    } else {\n        assert(newLists == newBuf);\n        cls->data()->method_list = newLists[0];\n        assert(!(cls->data()->flags & RW_METHOD_ARRAY));\n    }\n}\n```\n\n注意上面代码中注释copy old methods to the method list array，可以获知该类原有的方法被追加到了新方法列表的后面，因此可以了解如果category和原来的都由methodA方法，那newLists中肯定存在两个methodA方法。而运行时在查找类方法的时候是在方法列表中按序查找的，一旦发现对应签名的方法则就返回，因此被后置的原有方法自然而然就被方法列表前面的同签名方法所覆盖了。\n\n当然，如果还有一个分类也覆盖了同样的方法，顺序又是什么样子呢？根据文件的编译顺序，有兴趣的童鞋可以尝试一下，关于编译顺序。。。\n\n![XCode文件编译顺序调整](http://7xilk1.com1.z0.glb.clouddn.com/iosXCode编译顺序调整.png)\n\n\n明白了这种情况，如果我们需要调用类的被覆盖的方法，则通过查找类的实例方法列表中对应签名的方法，在方法列表前面的自然就是分类所对应的方法，而最后一个则是MyClass的原有方法了。\n\n``` objc\n#import <Foundation/Foundation.h>\n@interface MyClass : NSObject\n\n- (void)print;\n\n@end\n```\n\n``` objc\n#import \"MyClass.h\"\n\n@implementation MyClass\n\n- (void)print {\n    NSLog(@\"MyClass\");\n}\n\n@end\n```\n\n为MyClass添加分类MyAddition1，代码如下：\n\n``` objc\n#import \"MyClass.h\"\n\n@interface MyClass (MyAddition1)\n\n- (void) print;\n\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition1.h\"\n\n@implementation MyClass (MyAddition1)\n\n- (void)print {\n    NSLog(@\"MyAddition1\");\n}\n\n@end\n```\n\n然后再添加`MyAddition2`分类，\n\n``` objc\n#import \"MyClass.h\"\n\n@interface MyClass (MyAddition2)\n\n- (void) print;\n\n@end\n```\n\n``` objc\n#import \"MyClass+MyAddition2.h\"\n\n@implementation MyClass (MyAddition2)\n\n- (void)print {\n    NSLog(@\"MyAddition2\");\n}\n\n@end\n```\n\n当我们将整个文件编译之后我们就可以获得MyClass所有的方法了，如下代码所示：\n\n``` objc\n#import \"MyClass.h\"\n#import <objc/objc-runtime.h>\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        Class cls = [MyClass class];\n        MyClass *my = [MyClass new];\n        \n        [my print];\n        \n        if(cls) {\n            unsigned int methodCount;\n            Method *methodList = class_copyMethodList(cls, &methodCount);\n            \n            IMP lastImp = NULL;\n            SEL lastSel = NULL;\n            for (NSInteger i = 0; i < methodCount; i++) {\n                Method method = methodList[i];\n                NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding];\n\t\t\t\tNSLog(@\"methodName: %@\", methodName);\n\n                if([methodName isEqualToString:@\"print\"]) {\n                    lastImp = method_getImplementation(method);\n                    lastSel = method_getName(method);\n                }\n            }\n        \n            typedef void(*fn)(id, SEL);\n            \n            if(lastImp != NULL) {\n                fn f = (fn)(lastImp);\n                f(my, lastSel);\n            }\n            \n            free(methodList);\n        }\n    }\n    return 0;\n}\n```\n\n代码内容就是将类所对应的方法列表取出，找到最后一个对应名称的方法，取得函数指针，然后传入参数执行。\n\n输出结果如下：\n\n``` objc\n2015-09-14 15:26:59.793 ObjMessage[88888:10428876] MyAddition2\n2015-09-14 15:26:59.794 ObjMessage[88888:10428876] methodName: print\n2015-09-14 15:26:59.795 ObjMessage[88888:10428876] methodName: print\n2015-09-14 15:26:59.795 ObjMessage[88888:10428876] methodName: print\n2015-09-14 15:30:38.941 ObjMessage[88888:10428876] MyClass\n```\n\n当我们使用print方法时，打印为MyAddition2中的实现，并且MyClass类方法列表中有三个方法，并且均为print，取出列表中最后一个print并调用打印结果为MyClass类原有类中的实现。此时就达到了我们的目的。\n当然，你也可以调整下MyClass+MyAddition1.m文件和MyClass+MyAddition2.m文件的顺序验证下，结果MyClass默认输出为MyAddition1.\n\n","slug":"Objective-C中Category的一点东西","published":1,"updated":"2017-05-21T12:40:36.000Z","comments":1,"layout":"post","link":"","_id":"cjrk2ftbn004o79pognji6y17","content":"<p>Objective-C中的分类（category）是一种编译时的手段，其允许我们通过给某个已知类添加方法来扩充该类的一种方式。当然这其中是有限制的，就是不能给已知类添加新的实例变量。</p>\n<a id=\"more\"></a>\n<p>如下代码展示：</p>\n<p>类<code>MyClass</code>为一个简单的类，其中有实例方法 <code>-print</code> </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#import &quot;MyClass.h&quot;</span><br><span class=\"line\">@implementation MyClass</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;MyClass...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>我们向为MyClass再添加一个方法Hello，那我们就可以用分类的方法实现，我们为其添加分类MyAddition1和MyAddition2，如下所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hello</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello!!!\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>其中MyAddition为分类的名称，而文件名字约定俗成用“类名+扩展名”的形式。这样，我们就能够为MyClass类添加hello方法了，如下调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\tMyClass my = [MyClass new];</span><br><span class=\"line\">\t[my hello];</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Category 的使用场景主要有以下几种：</p>\n<ol>\n<li>需求变更，需要为已知类添加方法；</li>\n<li>将类的不同模块实现划分: a)具体可以将类的实现分开到不同的文件里面； b)将不同功能的分类文件交由不同的开发者实现；</li>\n<li>想为Apple基础类库添加自己需要的方法，实际上和1相似；</li>\n</ol>\n<p>但是分类的使用目前也有需要注意的地方：</p>\n<ol>\n<li>Category可以访问原有类的实例变量，但不能添加实例变量；</li>\n<li>Category中实现和原有类中相同签名的方法时，会覆盖原有类的方法；</li>\n</ol>\n<p>但是这两点均可以通过其他方式实现：</p>\n<h3 id=\"为分类添加实例变量\"><a href=\"#为分类添加实例变量\" class=\"headerlink\" title=\"为分类添加实例变量\"></a>为分类添加实例变量</h3><p>为分类添加实例变量主要通过关联对象的方法。如下所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/objc-runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">\"key\"</span>, name, OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *name = objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"如果调用被分类覆盖掉的原方法\"><a href=\"#如果调用被分类覆盖掉的原方法\" class=\"headerlink\" title=\"如果调用被分类覆盖掉的原方法\"></a>如果调用被分类覆盖掉的原方法</h4><p>实际上，通过查看Objc runtime源码可以获知，分类方法并不是绝对意义上的覆盖原有类的方法，只是在调用的时候调用顺序导致而已，这涉及到Objc runtime的一些内容。</p>\n<p>在下载到的运行时源码中objc-runtime-new.mm文件中有attachCategoryMethods方法，其就是将类的分类方法添加到类的方法列表中去的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc-runtime-new.mm</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">attachCategoryMethods(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flushCaches) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class=\"line\">    method_list_t **mlists = (method_list_t **)</span><br><span class=\"line\">        _malloc_internal(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> fromBundle = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</span><br><span class=\"line\">            mlists[mcount++] = mlist;</span><br><span class=\"line\">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    attachMethodLists(cls, mlists, mcount, <span class=\"literal\">NO</span>, fromBundle, flushCaches);</span><br><span class=\"line\"></span><br><span class=\"line\">    _free_internal(mlists);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那<code>attachCategoryMethods</code>的工作就是将所有分类的实例方法列表进行拼接，形成更大的<code>mlists</code>表，然后转交给<code>attachMethodLists</code>方法来执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">attachMethodLists(Class cls, method_list_t **addedLists, <span class=\"keyword\">int</span> addedCount, </span><br><span class=\"line\">                  <span class=\"keyword\">bool</span> baseMethods, <span class=\"keyword\">bool</span> methodsFromBundle, </span><br><span class=\"line\">                  <span class=\"keyword\">bool</span> flushCaches) &#123;</span><br><span class=\"line\">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don't scan redundantly</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> scanForCustomRR = !UseGC &amp;&amp; !cls-&gt;hasCustomRR();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> scanForCustomAWZ = !UseGC &amp;&amp; !cls-&gt;hasCustomAWZ();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// There exist RR/AWZ special cases for some class's base methods. </span></span><br><span class=\"line\">    <span class=\"comment\">// But this code should never need to scan base methods for RR/AWZ: </span></span><br><span class=\"line\">    <span class=\"comment\">// default RR/AWZ cannot be set before setInitialized().</span></span><br><span class=\"line\">    <span class=\"comment\">// Therefore we need not handle any special cases here.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (baseMethods) &#123;</span><br><span class=\"line\">        assert(!scanForCustomRR  &amp;&amp;  !scanForCustomAWZ);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Method list array is nil-terminated.</span></span><br><span class=\"line\">    <span class=\"comment\">// Some elements of lists are nil; we must filter them out.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    method_list_t *oldBuf[<span class=\"number\">2</span>];</span><br><span class=\"line\">    method_list_t **oldLists;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY) &#123;</span><br><span class=\"line\">        oldLists = cls-&gt;data()-&gt;method_lists;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        oldBuf[<span class=\"number\">0</span>] = cls-&gt;data()-&gt;method_list;</span><br><span class=\"line\">        oldBuf[<span class=\"number\">1</span>] = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        oldLists = oldBuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (oldLists[oldCount]) oldCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCount = oldCount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addedLists[i]) newCount++;  <span class=\"comment\">// only non-nil entries get added</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    method_list_t *newBuf[<span class=\"number\">2</span>];</span><br><span class=\"line\">    method_list_t **newLists;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCount &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        newLists = (method_list_t **)</span><br><span class=\"line\">            _malloc_internal((<span class=\"number\">1</span> + newCount) * <span class=\"keyword\">sizeof</span>(*newLists));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newLists = newBuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Add method lists to array.</span></span><br><span class=\"line\">    <span class=\"comment\">// Reallocate un-fixed method lists.</span></span><br><span class=\"line\">    <span class=\"comment\">// The new methods are PREPENDED to the method list array.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    newCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class=\"line\">        method_list_t *mlist = addedLists[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mlist) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Fixup selectors if necessary</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isMethodListFixedUp(mlist)) &#123;</span><br><span class=\"line\">            mlist = fixupMethodList(mlist, methodsFromBundle, <span class=\"literal\">true</span><span class=\"comment\">/*sort*/</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Scan for method implementations tracked by the class's flags</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scanForCustomRR  &amp;&amp;  methodListImplementsRR(mlist)) &#123;</span><br><span class=\"line\">            cls-&gt;setHasCustomRR();</span><br><span class=\"line\">            scanForCustomRR = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scanForCustomAWZ  &amp;&amp;  methodListImplementsAWZ(mlist)) &#123;</span><br><span class=\"line\">            cls-&gt;setHasCustomAWZ();</span><br><span class=\"line\">            scanForCustomAWZ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Update method caches</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flushCaches) &#123;</span><br><span class=\"line\">            cache_eraseMethods(cls, mlist);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Fill method list array</span></span><br><span class=\"line\">        newLists[newCount++] = mlist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Copy old methods to the method list array</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class=\"line\">        newLists[newCount++] = oldLists[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLists  &amp;&amp;  oldLists != oldBuf) free(oldLists);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nil-terminate</span></span><br><span class=\"line\">    newLists[newCount] = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCount &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        assert(newLists != newBuf);</span><br><span class=\"line\">        cls-&gt;data()-&gt;method_lists = newLists;</span><br><span class=\"line\">        cls-&gt;setInfo(RW_METHOD_ARRAY);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        assert(newLists == newBuf);</span><br><span class=\"line\">        cls-&gt;data()-&gt;method_list = newLists[<span class=\"number\">0</span>];</span><br><span class=\"line\">        assert(!(cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意上面代码中注释copy old methods to the method list array，可以获知该类原有的方法被追加到了新方法列表的后面，因此可以了解如果category和原来的都由methodA方法，那newLists中肯定存在两个methodA方法。而运行时在查找类方法的时候是在方法列表中按序查找的，一旦发现对应签名的方法则就返回，因此被后置的原有方法自然而然就被方法列表前面的同签名方法所覆盖了。</p>\n<p>当然，如果还有一个分类也覆盖了同样的方法，顺序又是什么样子呢？根据文件的编译顺序，有兴趣的童鞋可以尝试一下，关于编译顺序。。。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosXCode编译顺序调整.png\" alt=\"XCode文件编译顺序调整\"></p>\n<p>明白了这种情况，如果我们需要调用类的被覆盖的方法，则通过查找类的实例方法列表中对应签名的方法，在方法列表前面的自然就是分类所对应的方法，而最后一个则是MyClass的原有方法了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyClass\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>为MyClass添加分类MyAddition1，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>) print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyAddition1\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>然后再添加<code>MyAddition2</code>分类，</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition2</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>) print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition2.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition2</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyAddition2\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当我们将整个文件编译之后我们就可以获得MyClass所有的方法了，如下代码所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/objc-runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Class cls = [MyClass <span class=\"keyword\">class</span>];</span><br><span class=\"line\">        MyClass *my = [MyClass new];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [my print];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cls) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> methodCount;</span><br><span class=\"line\">            Method *methodList = class_copyMethodList(cls, &amp;methodCount);</span><br><span class=\"line\">            </span><br><span class=\"line\">            IMP lastImp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            SEL lastSel = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class=\"line\">                Method method = methodList[i];</span><br><span class=\"line\">                <span class=\"built_in\">NSString</span> *methodName = [<span class=\"built_in\">NSString</span> stringWithCString:sel_getName(method_getName(method)) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"methodName: %@\"</span>, methodName);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>([methodName isEqualToString:<span class=\"string\">@\"print\"</span>]) &#123;</span><br><span class=\"line\">                    lastImp = method_getImplementation(method);</span><br><span class=\"line\">                    lastSel = method_getName(method);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(*fn)(<span class=\"keyword\">id</span>, SEL);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lastImp != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                fn f = (fn)(lastImp);</span><br><span class=\"line\">                f(my, lastSel);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            free(methodList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码内容就是将类所对应的方法列表取出，找到最后一个对应名称的方法，取得函数指针，然后传入参数执行。</p>\n<p>输出结果如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.793</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] MyAddition2</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.794</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] methodName: print</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.795</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] methodName: print</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.795</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] methodName: print</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">30</span>:<span class=\"number\">38.941</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] MyClass</span><br></pre></td></tr></table></figure>\n<p>当我们使用print方法时，打印为MyAddition2中的实现，并且MyClass类方法列表中有三个方法，并且均为print，取出列表中最后一个print并调用打印结果为MyClass类原有类中的实现。此时就达到了我们的目的。<br>当然，你也可以调整下MyClass+MyAddition1.m文件和MyClass+MyAddition2.m文件的顺序验证下，结果MyClass默认输出为MyAddition1.</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>Objective-C中的分类（category）是一种编译时的手段，其允许我们通过给某个已知类添加方法来扩充该类的一种方式。当然这其中是有限制的，就是不能给已知类添加新的实例变量。</p>","more":"<p>如下代码展示：</p>\n<p>类<code>MyClass</code>为一个简单的类，其中有实例方法 <code>-print</code> </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#import &quot;MyClass.h&quot;</span><br><span class=\"line\">@implementation MyClass</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;MyClass...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>我们向为MyClass再添加一个方法Hello，那我们就可以用分类的方法实现，我们为其添加分类MyAddition1和MyAddition2，如下所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hello;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)hello</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello!!!\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>其中MyAddition为分类的名称，而文件名字约定俗成用“类名+扩展名”的形式。这样，我们就能够为MyClass类添加hello方法了，如下调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\tMyClass my = [MyClass new];</span><br><span class=\"line\">\t[my hello];</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Category 的使用场景主要有以下几种：</p>\n<ol>\n<li>需求变更，需要为已知类添加方法；</li>\n<li>将类的不同模块实现划分: a)具体可以将类的实现分开到不同的文件里面； b)将不同功能的分类文件交由不同的开发者实现；</li>\n<li>想为Apple基础类库添加自己需要的方法，实际上和1相似；</li>\n</ol>\n<p>但是分类的使用目前也有需要注意的地方：</p>\n<ol>\n<li>Category可以访问原有类的实例变量，但不能添加实例变量；</li>\n<li>Category中实现和原有类中相同签名的方法时，会覆盖原有类的方法；</li>\n</ol>\n<p>但是这两点均可以通过其他方式实现：</p>\n<h3 id=\"为分类添加实例变量\"><a href=\"#为分类添加实例变量\" class=\"headerlink\" title=\"为分类添加实例变量\"></a>为分类添加实例变量</h3><p>为分类添加实例变量主要通过关联对象的方法。如下所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/objc-runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">\"key\"</span>, name, OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *name = objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"如果调用被分类覆盖掉的原方法\"><a href=\"#如果调用被分类覆盖掉的原方法\" class=\"headerlink\" title=\"如果调用被分类覆盖掉的原方法\"></a>如果调用被分类覆盖掉的原方法</h4><p>实际上，通过查看Objc runtime源码可以获知，分类方法并不是绝对意义上的覆盖原有类的方法，只是在调用的时候调用顺序导致而已，这涉及到Objc runtime的一些内容。</p>\n<p>在下载到的运行时源码中objc-runtime-new.mm文件中有attachCategoryMethods方法，其就是将类的分类方法添加到类的方法列表中去的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc-runtime-new.mm</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">attachCategoryMethods(Class cls, category_list *cats, <span class=\"keyword\">bool</span> flushCaches) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cats) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class=\"line\">    method_list_t **mlists = (method_list_t **)</span><br><span class=\"line\">        _malloc_internal(cats-&gt;count * <span class=\"keyword\">sizeof</span>(*mlists));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Count backwards through cats to get newest categories first</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = cats-&gt;count;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> fromBundle = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mlist) &#123;</span><br><span class=\"line\">            mlists[mcount++] = mlist;</span><br><span class=\"line\">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    attachMethodLists(cls, mlists, mcount, <span class=\"literal\">NO</span>, fromBundle, flushCaches);</span><br><span class=\"line\"></span><br><span class=\"line\">    _free_internal(mlists);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那<code>attachCategoryMethods</code>的工作就是将所有分类的实例方法列表进行拼接，形成更大的<code>mlists</code>表，然后转交给<code>attachMethodLists</code>方法来执行。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">attachMethodLists(Class cls, method_list_t **addedLists, <span class=\"keyword\">int</span> addedCount, </span><br><span class=\"line\">                  <span class=\"keyword\">bool</span> baseMethods, <span class=\"keyword\">bool</span> methodsFromBundle, </span><br><span class=\"line\">                  <span class=\"keyword\">bool</span> flushCaches) &#123;</span><br><span class=\"line\">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Don't scan redundantly</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> scanForCustomRR = !UseGC &amp;&amp; !cls-&gt;hasCustomRR();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> scanForCustomAWZ = !UseGC &amp;&amp; !cls-&gt;hasCustomAWZ();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// There exist RR/AWZ special cases for some class's base methods. </span></span><br><span class=\"line\">    <span class=\"comment\">// But this code should never need to scan base methods for RR/AWZ: </span></span><br><span class=\"line\">    <span class=\"comment\">// default RR/AWZ cannot be set before setInitialized().</span></span><br><span class=\"line\">    <span class=\"comment\">// Therefore we need not handle any special cases here.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (baseMethods) &#123;</span><br><span class=\"line\">        assert(!scanForCustomRR  &amp;&amp;  !scanForCustomAWZ);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Method list array is nil-terminated.</span></span><br><span class=\"line\">    <span class=\"comment\">// Some elements of lists are nil; we must filter them out.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    method_list_t *oldBuf[<span class=\"number\">2</span>];</span><br><span class=\"line\">    method_list_t **oldLists;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY) &#123;</span><br><span class=\"line\">        oldLists = cls-&gt;data()-&gt;method_lists;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        oldBuf[<span class=\"number\">0</span>] = cls-&gt;data()-&gt;method_list;</span><br><span class=\"line\">        oldBuf[<span class=\"number\">1</span>] = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">        oldLists = oldBuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (oldLists[oldCount]) oldCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCount = oldCount;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addedLists[i]) newCount++;  <span class=\"comment\">// only non-nil entries get added</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    method_list_t *newBuf[<span class=\"number\">2</span>];</span><br><span class=\"line\">    method_list_t **newLists;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCount &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        newLists = (method_list_t **)</span><br><span class=\"line\">            _malloc_internal((<span class=\"number\">1</span> + newCount) * <span class=\"keyword\">sizeof</span>(*newLists));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newLists = newBuf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Add method lists to array.</span></span><br><span class=\"line\">    <span class=\"comment\">// Reallocate un-fixed method lists.</span></span><br><span class=\"line\">    <span class=\"comment\">// The new methods are PREPENDED to the method list array.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    newCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class=\"line\">        method_list_t *mlist = addedLists[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mlist) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Fixup selectors if necessary</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isMethodListFixedUp(mlist)) &#123;</span><br><span class=\"line\">            mlist = fixupMethodList(mlist, methodsFromBundle, <span class=\"literal\">true</span><span class=\"comment\">/*sort*/</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Scan for method implementations tracked by the class's flags</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scanForCustomRR  &amp;&amp;  methodListImplementsRR(mlist)) &#123;</span><br><span class=\"line\">            cls-&gt;setHasCustomRR();</span><br><span class=\"line\">            scanForCustomRR = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scanForCustomAWZ  &amp;&amp;  methodListImplementsAWZ(mlist)) &#123;</span><br><span class=\"line\">            cls-&gt;setHasCustomAWZ();</span><br><span class=\"line\">            scanForCustomAWZ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Update method caches</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flushCaches) &#123;</span><br><span class=\"line\">            cache_eraseMethods(cls, mlist);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Fill method list array</span></span><br><span class=\"line\">        newLists[newCount++] = mlist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Copy old methods to the method list array</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class=\"line\">        newLists[newCount++] = oldLists[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLists  &amp;&amp;  oldLists != oldBuf) free(oldLists);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// nil-terminate</span></span><br><span class=\"line\">    newLists[newCount] = <span class=\"literal\">nil</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCount &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        assert(newLists != newBuf);</span><br><span class=\"line\">        cls-&gt;data()-&gt;method_lists = newLists;</span><br><span class=\"line\">        cls-&gt;setInfo(RW_METHOD_ARRAY);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        assert(newLists == newBuf);</span><br><span class=\"line\">        cls-&gt;data()-&gt;method_list = newLists[<span class=\"number\">0</span>];</span><br><span class=\"line\">        assert(!(cls-&gt;data()-&gt;flags &amp; RW_METHOD_ARRAY));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意上面代码中注释copy old methods to the method list array，可以获知该类原有的方法被追加到了新方法列表的后面，因此可以了解如果category和原来的都由methodA方法，那newLists中肯定存在两个methodA方法。而运行时在查找类方法的时候是在方法列表中按序查找的，一旦发现对应签名的方法则就返回，因此被后置的原有方法自然而然就被方法列表前面的同签名方法所覆盖了。</p>\n<p>当然，如果还有一个分类也覆盖了同样的方法，顺序又是什么样子呢？根据文件的编译顺序，有兴趣的童鞋可以尝试一下，关于编译顺序。。。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosXCode编译顺序调整.png\" alt=\"XCode文件编译顺序调整\"></p>\n<p>明白了这种情况，如果我们需要调用类的被覆盖的方法，则通过查找类的实例方法列表中对应签名的方法，在方法列表前面的自然就是分类所对应的方法，而最后一个则是MyClass的原有方法了。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyClass\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>为MyClass添加分类MyAddition1，代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>) print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition1.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition1</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyAddition1\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>然后再添加<code>MyAddition2</code>分类，</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition2</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>) print;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass+MyAddition2.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyClass</span> (<span class=\"title\">MyAddition2</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)print &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"MyAddition2\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当我们将整个文件编译之后我们就可以获得MyClass所有的方法了，如下代码所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"MyClass.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/objc-runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Class cls = [MyClass <span class=\"keyword\">class</span>];</span><br><span class=\"line\">        MyClass *my = [MyClass new];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [my print];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cls) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> methodCount;</span><br><span class=\"line\">            Method *methodList = class_copyMethodList(cls, &amp;methodCount);</span><br><span class=\"line\">            </span><br><span class=\"line\">            IMP lastImp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            SEL lastSel = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class=\"line\">                Method method = methodList[i];</span><br><span class=\"line\">                <span class=\"built_in\">NSString</span> *methodName = [<span class=\"built_in\">NSString</span> stringWithCString:sel_getName(method_getName(method)) encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"methodName: %@\"</span>, methodName);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span>([methodName isEqualToString:<span class=\"string\">@\"print\"</span>]) &#123;</span><br><span class=\"line\">                    lastImp = method_getImplementation(method);</span><br><span class=\"line\">                    lastSel = method_getName(method);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(*fn)(<span class=\"keyword\">id</span>, SEL);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lastImp != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                fn f = (fn)(lastImp);</span><br><span class=\"line\">                f(my, lastSel);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            free(methodList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码内容就是将类所对应的方法列表取出，找到最后一个对应名称的方法，取得函数指针，然后传入参数执行。</p>\n<p>输出结果如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.793</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] MyAddition2</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.794</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] methodName: print</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.795</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] methodName: print</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">26</span>:<span class=\"number\">59.795</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] methodName: print</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-14</span> <span class=\"number\">15</span>:<span class=\"number\">30</span>:<span class=\"number\">38.941</span> ObjMessage[<span class=\"number\">88888</span>:<span class=\"number\">10428876</span>] MyClass</span><br></pre></td></tr></table></figure>\n<p>当我们使用print方法时，打印为MyAddition2中的实现，并且MyClass类方法列表中有三个方法，并且均为print，取出列表中最后一个print并调用打印结果为MyClass类原有类中的实现。此时就达到了我们的目的。<br>当然，你也可以调整下MyClass+MyAddition1.m文件和MyClass+MyAddition2.m文件的顺序验证下，结果MyClass默认输出为MyAddition1.</p>"},{"title":"Swift 中几种不同的依赖注入方式","date":"2018-07-16T05:57:24.000Z","_content":"\n> 原文：[Different flavors of dependency injection in Swift](https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift)\n> 原作者 & Copyright [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n在之前的几篇博客中，我们已经了解了几种使用依赖注入方式使得某个 swift app 拥有一个更加解耦可测试的架构。比如在 [在 Swift 中使用工厂模式进行依赖注入](http://hechen.xyz/2017/11/19/Dependency-injection-using-factories-in-Swift/) 中和工厂模式结合，以及在[避免在 Swift 中使用单例](http://hechen.xyz/2018/07/16/Avoiding-singletons-in-Swift/)中替换程序中的单例对象等方式进行依赖注入。\n\n到目前为止，大部分我的博文以及例子中都使用了基于初始化的依赖注入方式。然而，就像大部分的编程技巧一样，还有很多 “口味” 的进行依赖注入的方式 ── 每一种都有其优缺点。 这周，让我们来看看其中三种方式以及如何在 Swift 中使用它们。\n\n### 基于初始化方法\n\n让我们快速回顾一下用的最为广泛的依赖注入方式 ── initializer-based。这个想法是在某个类被初始化的时候传入其所需的依赖的方式。这种形式最大的好处就是，它保证了能够立即满足该类完成其功能所需要的所有东西。\n\n让我们建一个类 ── FileLoader 来从磁盘加载文件。为了实现该 Loader 的功能，需要两个依赖项，系统所提供的实例对象 ── **FileManager** 和 **Cache**。使用基于初始化的依赖注入的执行代码如下所示：\n\n\n``` Swift\n\nclass FileLoader {\n    private let fileManager: FileManager\n    private let cache: Cache\n\n    init(fileManager: FileManager = .default,\n         cache: Cache = .init()) {\n        self.fileManager = fileManager\n        self.cache = cache\n    }\n}\n\n```\n\n可以关注下初始化方法里默认参数的设置，其可以避免每次都需要自行创建的问题。这样能够简化我们在生产环境下使用 **FileLoader** 类创建文件加载器的工作，而且也能够能够传入 mock 数据或者我们的测试代码中的创建的实例进行测试。\n\n\n### 基于属性\n\n虽然前一种基于初始化的依赖注入形式常常给我们自定义类带来很多好处，但是有时候，当你不得不继承自某个系统类的时候会遇到一些困难。其中一个例子就是，当我们构建 view controller，尤其是你在使用 XIB 以及 Storyboard 类定义它们的时候，因为此时你不再能够掌控它们的初始化方法了。\n\n对于这些情况，基于属性的依赖注入方式是一个更好的选择。相对于初始化的时候进行对象的依赖项注入，基于属性的形式可以在之后通过简单的赋值来做到，其能够让你减少模板代码的书写，尤其是在你确实没有必要进行注入的时候能够有更好的默认实现。\n\n让我们再来看一个例子，在这个例子中，我们在构建一个 **PhotoEditorViewController** ，这个视图控制器使得用户编辑它们照片库中的图片。为了达到这个功能，该视图控制器需要用到系统提供的 PHPhotoLibrary 类型的一个实例（该类本身是一个单例）以及我们自己实现的类 **PhotoEditorEngine** 的一个实例。那为了不通过自定义初始化方法进行依赖注入的话，我们可以创建一些具有默认值的可变属性，例如下面这样：\n\n\n``` Swift\n\nclass PhotoEditorViewController: UIViewController {\n    var library: PhotoLibrary = PHPhotoLibrary.shared()\n    var engine = PhotoEditorEngine()\n}\n\n```\n\n使用 [Testing Swift code that uses system singletons in 3 easy steps](https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps) 这篇文章中的手法，通过使用一个协议提供一个更为抽象的 **PhotoLibrary** 接口来获取系统的图片库。这样会使得测试和 Mock 数据特别的容易。\n\n上面这些工作比较好的是我们依然能够通过简单的给视图控制器来赋值，从而在我们的测试中简单的注入 Mock 代码：\n\n\n``` Swift\n\nclass PhotoEditorViewControllerTests: XCTestCase {\n    func testApplyingBlackAndWhiteFilter() {\n        let viewController = PhotoEditorViewController()\n\n        // Assign a mock photo library to gain complete control over\n        // what photos are stored in it\n        let library = PhotoLibraryMock()\n        library.photos = [TestPhotoFactory.photoWithColor(.red)]\n        viewController.library = library\n\n        // Run our testing commands\n        viewController.selectPhoto(atIndex: 0)\n        viewController.apply(filter: .blackAndWhite)\n        viewController.savePhoto()\n\n        // Assert that the outcome is correct\n        XCTAssertTrue(photoIsBlackAndWhite(library.photos[0]))\n    }   \n}\n\n```\n\n### 基于参数\n\n最后一种，让我们来看下基于参数的依赖注入形式。这种方式尤其在你想让旧有代码更加可测试，而不需要对现存的结构进行更多改动的时候尤其有效。\n\n许多时候，我们仅需要某个特定的依赖项一次，或者我们仅仅需要在某些特定条件下进行 mock。不需要改变某个对象的初始化方法或者暴露可变属性（通常都不是一个好主意），我们可以开发出一个接受一个依赖项作为参数的特定 API。\n\n让我们看一个 **NoteManager** 类，该类是某个笔记类应用的一部分。它的工作就是管理所有用户已经书写的笔记，提供一个 API 让用户能够查询笔记。考虑到这个操作可能耗时（\u0010如果用户有许多笔记，通常情况下是这样），我们把该动作正常放置于一个后台线程执行，如下：\n\n``` Swift\n\nclass NoteManager {\n    func loadNotes(matching query: String,\n                   completionHandler: @escaping ([Note]) -> Void) {\n        DispatchQueue.global(qos: .userInitiated).async {\n            let database = self.loadDatabase()\n            let notes = database.filter { note in\n                return note.matches(query: query)\n            }\n\n            completionHandler(notes)\n        }\n    }\n}\n\n```\n\n尽管上面的代码在我们的生产环境里也算是一个很好的解决方案，但在测试中我们正常情况下是想避免一些异步代码的，尽可能的平行化以避免 [flakiness](https://www.swiftbysundell.com/posts/reducing-flakiness-in-swift-tests). 如果要类似于基于初始化或者基于属性的依赖注入能够指定一个显式的队列提供给 NoteManager 来用的方式，需要对该类进行很多改变，这是我们在当下无法做或者不愿意做的。\n\n这时候，基于参数的依赖注入方式的实现就能够达到。相对于不得不对整个类进行重构，我们通过插入队列相关代码使得 `loadNotes` 方法在该队列上执行：\n\n\n``` Swift\n\nclass NoteManager {\n    func loadNotes(matching query: String,\n                   on queue: DispatchQueue = .global(qos: .userInitiated),\n                   completionHandler: @escaping ([Note]) -> Void) {\n        queue.async {\n            let database = self.loadDatabase()\n            let notes = database.filter { note in\n                return note.matches(query: query)\n            }\n\n            completionHandler(notes)\n        }\n    }\n}\n\n```\n\n这样就使得我们能够很容易的在测试代码中使用某个定制的我们可等待的队列。这样也几乎使得我们把上面的接口转变成了一个同步接口，使得一切变得更加容易和可预测。\n\n另外一个基于参数的依赖注入的使用案例是当你想测试某个静态的 API 的时候。因为静态的 API 我们是不存在初始化方法的，同时我们理想情况下也是不应该维护任何静态的状态的，那基于参数的依赖注入方式就是一个很好的选择。让我们看一个静态的类 **MessageSender**， 该类当前依赖某个单例：\n\n\n``` Swift\n\nclass MessageSender {\n    static func send(_ message: Message, to user: User) throws {\n        Database.shared.insert(message)\n\n        let data: Data = try wrap(message)\n        let endpoint = Endpoint.sendMessage(to: user)\n        NetworkManager.shared.post(data, to: endpoint.url)\n    }\n}\n\n```\n\n当然，一个长远的解决方案更可能是重构 **MessageSender** 这个类，让它变成一个非静态的，能够在其所有被使用的地方被正确的注入依赖。但是基于我们能够更容易的测试它（比如，重现或者验证某个 Bug），我们能简单的使用参数作为依赖项进行注入，而不是基于某个单例：\n\n\n\n``` Swift\n\nclass MessageSender {\n    static func send(_ message: Message,\n                     to user: User,\n                     database: Database = .shared,\n                     networkManager: NetworkManager = .shared) throws {\n        database.insert(message)\n\n        let data: Data = try wrap(message)\n        let endpoint = Endpoint.sendMessage(to: user)\n        networkManager.post(data, to: endpoint.url)\n    }\n}\n\n```\n\n我们又再次使用了缺省的参数，不仅仅更加方便而已，更重要的是，能够在 100% 向后兼容的情况下为我们的代码增加测试支持。\n\n\n## 结论\n\n所以，哪一种依赖注入的方案是最好的呢？就像大部分时候一样，我的答案很无聊的： 看情况！我在该博客中所视图去做的一件事情就是针对某个特定问题给出需要不同的解决方案。原因很简单，我真的不相信又所谓银弹的存在。我认为，按照我们意愿具备多个工具或者对于特定技巧的多种解决方案能够使我们变得更好，在写代码的时候也能够游刃有余。\n","source":"_posts/Different-flavors-of-dependency-injection-in-Swift.md","raw":"---\ntitle: Swift 中几种不同的依赖注入方式\ndate: 2018-07-16 13:57:24\ncategories: 翻译\ntags: [iOS,XCode,Swift]\n---\n\n> 原文：[Different flavors of dependency injection in Swift](https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift)\n> 原作者 & Copyright [@johnsundell](https://twitter.com/johnsundell)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n在之前的几篇博客中，我们已经了解了几种使用依赖注入方式使得某个 swift app 拥有一个更加解耦可测试的架构。比如在 [在 Swift 中使用工厂模式进行依赖注入](http://hechen.xyz/2017/11/19/Dependency-injection-using-factories-in-Swift/) 中和工厂模式结合，以及在[避免在 Swift 中使用单例](http://hechen.xyz/2018/07/16/Avoiding-singletons-in-Swift/)中替换程序中的单例对象等方式进行依赖注入。\n\n到目前为止，大部分我的博文以及例子中都使用了基于初始化的依赖注入方式。然而，就像大部分的编程技巧一样，还有很多 “口味” 的进行依赖注入的方式 ── 每一种都有其优缺点。 这周，让我们来看看其中三种方式以及如何在 Swift 中使用它们。\n\n### 基于初始化方法\n\n让我们快速回顾一下用的最为广泛的依赖注入方式 ── initializer-based。这个想法是在某个类被初始化的时候传入其所需的依赖的方式。这种形式最大的好处就是，它保证了能够立即满足该类完成其功能所需要的所有东西。\n\n让我们建一个类 ── FileLoader 来从磁盘加载文件。为了实现该 Loader 的功能，需要两个依赖项，系统所提供的实例对象 ── **FileManager** 和 **Cache**。使用基于初始化的依赖注入的执行代码如下所示：\n\n\n``` Swift\n\nclass FileLoader {\n    private let fileManager: FileManager\n    private let cache: Cache\n\n    init(fileManager: FileManager = .default,\n         cache: Cache = .init()) {\n        self.fileManager = fileManager\n        self.cache = cache\n    }\n}\n\n```\n\n可以关注下初始化方法里默认参数的设置，其可以避免每次都需要自行创建的问题。这样能够简化我们在生产环境下使用 **FileLoader** 类创建文件加载器的工作，而且也能够能够传入 mock 数据或者我们的测试代码中的创建的实例进行测试。\n\n\n### 基于属性\n\n虽然前一种基于初始化的依赖注入形式常常给我们自定义类带来很多好处，但是有时候，当你不得不继承自某个系统类的时候会遇到一些困难。其中一个例子就是，当我们构建 view controller，尤其是你在使用 XIB 以及 Storyboard 类定义它们的时候，因为此时你不再能够掌控它们的初始化方法了。\n\n对于这些情况，基于属性的依赖注入方式是一个更好的选择。相对于初始化的时候进行对象的依赖项注入，基于属性的形式可以在之后通过简单的赋值来做到，其能够让你减少模板代码的书写，尤其是在你确实没有必要进行注入的时候能够有更好的默认实现。\n\n让我们再来看一个例子，在这个例子中，我们在构建一个 **PhotoEditorViewController** ，这个视图控制器使得用户编辑它们照片库中的图片。为了达到这个功能，该视图控制器需要用到系统提供的 PHPhotoLibrary 类型的一个实例（该类本身是一个单例）以及我们自己实现的类 **PhotoEditorEngine** 的一个实例。那为了不通过自定义初始化方法进行依赖注入的话，我们可以创建一些具有默认值的可变属性，例如下面这样：\n\n\n``` Swift\n\nclass PhotoEditorViewController: UIViewController {\n    var library: PhotoLibrary = PHPhotoLibrary.shared()\n    var engine = PhotoEditorEngine()\n}\n\n```\n\n使用 [Testing Swift code that uses system singletons in 3 easy steps](https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps) 这篇文章中的手法，通过使用一个协议提供一个更为抽象的 **PhotoLibrary** 接口来获取系统的图片库。这样会使得测试和 Mock 数据特别的容易。\n\n上面这些工作比较好的是我们依然能够通过简单的给视图控制器来赋值，从而在我们的测试中简单的注入 Mock 代码：\n\n\n``` Swift\n\nclass PhotoEditorViewControllerTests: XCTestCase {\n    func testApplyingBlackAndWhiteFilter() {\n        let viewController = PhotoEditorViewController()\n\n        // Assign a mock photo library to gain complete control over\n        // what photos are stored in it\n        let library = PhotoLibraryMock()\n        library.photos = [TestPhotoFactory.photoWithColor(.red)]\n        viewController.library = library\n\n        // Run our testing commands\n        viewController.selectPhoto(atIndex: 0)\n        viewController.apply(filter: .blackAndWhite)\n        viewController.savePhoto()\n\n        // Assert that the outcome is correct\n        XCTAssertTrue(photoIsBlackAndWhite(library.photos[0]))\n    }   \n}\n\n```\n\n### 基于参数\n\n最后一种，让我们来看下基于参数的依赖注入形式。这种方式尤其在你想让旧有代码更加可测试，而不需要对现存的结构进行更多改动的时候尤其有效。\n\n许多时候，我们仅需要某个特定的依赖项一次，或者我们仅仅需要在某些特定条件下进行 mock。不需要改变某个对象的初始化方法或者暴露可变属性（通常都不是一个好主意），我们可以开发出一个接受一个依赖项作为参数的特定 API。\n\n让我们看一个 **NoteManager** 类，该类是某个笔记类应用的一部分。它的工作就是管理所有用户已经书写的笔记，提供一个 API 让用户能够查询笔记。考虑到这个操作可能耗时（\u0010如果用户有许多笔记，通常情况下是这样），我们把该动作正常放置于一个后台线程执行，如下：\n\n``` Swift\n\nclass NoteManager {\n    func loadNotes(matching query: String,\n                   completionHandler: @escaping ([Note]) -> Void) {\n        DispatchQueue.global(qos: .userInitiated).async {\n            let database = self.loadDatabase()\n            let notes = database.filter { note in\n                return note.matches(query: query)\n            }\n\n            completionHandler(notes)\n        }\n    }\n}\n\n```\n\n尽管上面的代码在我们的生产环境里也算是一个很好的解决方案，但在测试中我们正常情况下是想避免一些异步代码的，尽可能的平行化以避免 [flakiness](https://www.swiftbysundell.com/posts/reducing-flakiness-in-swift-tests). 如果要类似于基于初始化或者基于属性的依赖注入能够指定一个显式的队列提供给 NoteManager 来用的方式，需要对该类进行很多改变，这是我们在当下无法做或者不愿意做的。\n\n这时候，基于参数的依赖注入方式的实现就能够达到。相对于不得不对整个类进行重构，我们通过插入队列相关代码使得 `loadNotes` 方法在该队列上执行：\n\n\n``` Swift\n\nclass NoteManager {\n    func loadNotes(matching query: String,\n                   on queue: DispatchQueue = .global(qos: .userInitiated),\n                   completionHandler: @escaping ([Note]) -> Void) {\n        queue.async {\n            let database = self.loadDatabase()\n            let notes = database.filter { note in\n                return note.matches(query: query)\n            }\n\n            completionHandler(notes)\n        }\n    }\n}\n\n```\n\n这样就使得我们能够很容易的在测试代码中使用某个定制的我们可等待的队列。这样也几乎使得我们把上面的接口转变成了一个同步接口，使得一切变得更加容易和可预测。\n\n另外一个基于参数的依赖注入的使用案例是当你想测试某个静态的 API 的时候。因为静态的 API 我们是不存在初始化方法的，同时我们理想情况下也是不应该维护任何静态的状态的，那基于参数的依赖注入方式就是一个很好的选择。让我们看一个静态的类 **MessageSender**， 该类当前依赖某个单例：\n\n\n``` Swift\n\nclass MessageSender {\n    static func send(_ message: Message, to user: User) throws {\n        Database.shared.insert(message)\n\n        let data: Data = try wrap(message)\n        let endpoint = Endpoint.sendMessage(to: user)\n        NetworkManager.shared.post(data, to: endpoint.url)\n    }\n}\n\n```\n\n当然，一个长远的解决方案更可能是重构 **MessageSender** 这个类，让它变成一个非静态的，能够在其所有被使用的地方被正确的注入依赖。但是基于我们能够更容易的测试它（比如，重现或者验证某个 Bug），我们能简单的使用参数作为依赖项进行注入，而不是基于某个单例：\n\n\n\n``` Swift\n\nclass MessageSender {\n    static func send(_ message: Message,\n                     to user: User,\n                     database: Database = .shared,\n                     networkManager: NetworkManager = .shared) throws {\n        database.insert(message)\n\n        let data: Data = try wrap(message)\n        let endpoint = Endpoint.sendMessage(to: user)\n        networkManager.post(data, to: endpoint.url)\n    }\n}\n\n```\n\n我们又再次使用了缺省的参数，不仅仅更加方便而已，更重要的是，能够在 100% 向后兼容的情况下为我们的代码增加测试支持。\n\n\n## 结论\n\n所以，哪一种依赖注入的方案是最好的呢？就像大部分时候一样，我的答案很无聊的： 看情况！我在该博客中所视图去做的一件事情就是针对某个特定问题给出需要不同的解决方案。原因很简单，我真的不相信又所谓银弹的存在。我认为，按照我们意愿具备多个工具或者对于特定技巧的多种解决方案能够使我们变得更好，在写代码的时候也能够游刃有余。\n","slug":"Different-flavors-of-dependency-injection-in-Swift","published":1,"updated":"2018-07-17T04:01:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftbt004t79pokb7sn0ef","content":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift\" target=\"_blank\" rel=\"noopener\">Different flavors of dependency injection in Swift</a><br>原作者 &amp; Copyright <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>在之前的几篇博客中，我们已经了解了几种使用依赖注入方式使得某个 swift app 拥有一个更加解耦可测试的架构。比如在 <a href=\"http://hechen.xyz/2017/11/19/Dependency-injection-using-factories-in-Swift/\">在 Swift 中使用工厂模式进行依赖注入</a> 中和工厂模式结合，以及在<a href=\"http://hechen.xyz/2018/07/16/Avoiding-singletons-in-Swift/\">避免在 Swift 中使用单例</a>中替换程序中的单例对象等方式进行依赖注入。</p>\n<p>到目前为止，大部分我的博文以及例子中都使用了基于初始化的依赖注入方式。然而，就像大部分的编程技巧一样，还有很多 “口味” 的进行依赖注入的方式 ── 每一种都有其优缺点。 这周，让我们来看看其中三种方式以及如何在 Swift 中使用它们。</p>\n<h3 id=\"基于初始化方法\"><a href=\"#基于初始化方法\" class=\"headerlink\" title=\"基于初始化方法\"></a>基于初始化方法</h3><p>让我们快速回顾一下用的最为广泛的依赖注入方式 ── initializer-based。这个想法是在某个类被初始化的时候传入其所需的依赖的方式。这种形式最大的好处就是，它保证了能够立即满足该类完成其功能所需要的所有东西。</p>\n<p>让我们建一个类 ── FileLoader 来从磁盘加载文件。为了实现该 Loader 的功能，需要两个依赖项，系统所提供的实例对象 ── <strong>FileManager</strong> 和 <strong>Cache</strong>。使用基于初始化的依赖注入的执行代码如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> fileManager: <span class=\"type\">FileManager</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> cache: <span class=\"type\">Cache</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(fileManager: <span class=\"type\">FileManager</span> = .<span class=\"keyword\">default</span>,</span><br><span class=\"line\">         cache: <span class=\"type\">Cache</span> = .<span class=\"keyword\">init</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.fileManager = fileManager</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.cache = cache</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以关注下初始化方法里默认参数的设置，其可以避免每次都需要自行创建的问题。这样能够简化我们在生产环境下使用 <strong>FileLoader</strong> 类创建文件加载器的工作，而且也能够能够传入 mock 数据或者我们的测试代码中的创建的实例进行测试。</p>\n<h3 id=\"基于属性\"><a href=\"#基于属性\" class=\"headerlink\" title=\"基于属性\"></a>基于属性</h3><p>虽然前一种基于初始化的依赖注入形式常常给我们自定义类带来很多好处，但是有时候，当你不得不继承自某个系统类的时候会遇到一些困难。其中一个例子就是，当我们构建 view controller，尤其是你在使用 XIB 以及 Storyboard 类定义它们的时候，因为此时你不再能够掌控它们的初始化方法了。</p>\n<p>对于这些情况，基于属性的依赖注入方式是一个更好的选择。相对于初始化的时候进行对象的依赖项注入，基于属性的形式可以在之后通过简单的赋值来做到，其能够让你减少模板代码的书写，尤其是在你确实没有必要进行注入的时候能够有更好的默认实现。</p>\n<p>让我们再来看一个例子，在这个例子中，我们在构建一个 <strong>PhotoEditorViewController</strong> ，这个视图控制器使得用户编辑它们照片库中的图片。为了达到这个功能，该视图控制器需要用到系统提供的 PHPhotoLibrary 类型的一个实例（该类本身是一个单例）以及我们自己实现的类 <strong>PhotoEditorEngine</strong> 的一个实例。那为了不通过自定义初始化方法进行依赖注入的话，我们可以创建一些具有默认值的可变属性，例如下面这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhotoEditorViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> library: <span class=\"type\">PhotoLibrary</span> = <span class=\"type\">PHPhotoLibrary</span>.shared()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> engine = <span class=\"type\">PhotoEditorEngine</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <a href=\"https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps\" target=\"_blank\" rel=\"noopener\">Testing Swift code that uses system singletons in 3 easy steps</a> 这篇文章中的手法，通过使用一个协议提供一个更为抽象的 <strong>PhotoLibrary</strong> 接口来获取系统的图片库。这样会使得测试和 Mock 数据特别的容易。</p>\n<p>上面这些工作比较好的是我们依然能够通过简单的给视图控制器来赋值，从而在我们的测试中简单的注入 Mock 代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhotoEditorViewControllerTests</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testApplyingBlackAndWhiteFilter</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> viewController = <span class=\"type\">PhotoEditorViewController</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Assign a mock photo library to gain complete control over</span></span><br><span class=\"line\">        <span class=\"comment\">// what photos are stored in it</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> library = <span class=\"type\">PhotoLibraryMock</span>()</span><br><span class=\"line\">        library.photos = [<span class=\"type\">TestPhotoFactory</span>.photoWithColor(.red)]</span><br><span class=\"line\">        viewController.library = library</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run our testing commands</span></span><br><span class=\"line\">        viewController.selectPhoto(atIndex: <span class=\"number\">0</span>)</span><br><span class=\"line\">        viewController.apply(<span class=\"built_in\">filter</span>: .blackAndWhite)</span><br><span class=\"line\">        viewController.savePhoto()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Assert that the outcome is correct</span></span><br><span class=\"line\">        <span class=\"type\">XCTAssertTrue</span>(photoIsBlackAndWhite(library.photos[<span class=\"number\">0</span>]))</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基于参数\"><a href=\"#基于参数\" class=\"headerlink\" title=\"基于参数\"></a>基于参数</h3><p>最后一种，让我们来看下基于参数的依赖注入形式。这种方式尤其在你想让旧有代码更加可测试，而不需要对现存的结构进行更多改动的时候尤其有效。</p>\n<p>许多时候，我们仅需要某个特定的依赖项一次，或者我们仅仅需要在某些特定条件下进行 mock。不需要改变某个对象的初始化方法或者暴露可变属性（通常都不是一个好主意），我们可以开发出一个接受一个依赖项作为参数的特定 API。</p>\n<p>让我们看一个 <strong>NoteManager</strong> 类，该类是某个笔记类应用的一部分。它的工作就是管理所有用户已经书写的笔记，提供一个 API 让用户能够查询笔记。考虑到这个操作可能耗时（\u0010如果用户有许多笔记，通常情况下是这样），我们把该动作正常放置于一个后台线程执行，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoteManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadNotes</span><span class=\"params\">(matching query: String,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   completionHandler: @escaping <span class=\"params\">([Note])</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> database = <span class=\"keyword\">self</span>.loadDatabase()</span><br><span class=\"line\">            <span class=\"keyword\">let</span> notes = database.<span class=\"built_in\">filter</span> &#123; note <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> note.matches(query: query)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(notes)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管上面的代码在我们的生产环境里也算是一个很好的解决方案，但在测试中我们正常情况下是想避免一些异步代码的，尽可能的平行化以避免 <a href=\"https://www.swiftbysundell.com/posts/reducing-flakiness-in-swift-tests\" target=\"_blank\" rel=\"noopener\">flakiness</a>. 如果要类似于基于初始化或者基于属性的依赖注入能够指定一个显式的队列提供给 NoteManager 来用的方式，需要对该类进行很多改变，这是我们在当下无法做或者不愿意做的。</p>\n<p>这时候，基于参数的依赖注入方式的实现就能够达到。相对于不得不对整个类进行重构，我们通过插入队列相关代码使得 <code>loadNotes</code> 方法在该队列上执行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoteManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadNotes</span><span class=\"params\">(matching query: String,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   on queue: DispatchQueue = .global<span class=\"params\">(qos: .userInitiated)</span></span></span>,</span><br><span class=\"line\">                   completionHandler: @escaping ([<span class=\"type\">Note</span>]) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        queue.async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> database = <span class=\"keyword\">self</span>.loadDatabase()</span><br><span class=\"line\">            <span class=\"keyword\">let</span> notes = database.<span class=\"built_in\">filter</span> &#123; note <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> note.matches(query: query)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(notes)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就使得我们能够很容易的在测试代码中使用某个定制的我们可等待的队列。这样也几乎使得我们把上面的接口转变成了一个同步接口，使得一切变得更加容易和可预测。</p>\n<p>另外一个基于参数的依赖注入的使用案例是当你想测试某个静态的 API 的时候。因为静态的 API 我们是不存在初始化方法的，同时我们理想情况下也是不应该维护任何静态的状态的，那基于参数的依赖注入方式就是一个很好的选择。让我们看一个静态的类 <strong>MessageSender</strong>， 该类当前依赖某个单例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"number\">_</span> message: Message, to user: User)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Database</span>.shared.insert(message)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> data: <span class=\"type\">Data</span> = <span class=\"keyword\">try</span> wrap(message)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> endpoint = <span class=\"type\">Endpoint</span>.sendMessage(to: user)</span><br><span class=\"line\">        <span class=\"type\">NetworkManager</span>.shared.post(data, to: endpoint.url)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，一个长远的解决方案更可能是重构 <strong>MessageSender</strong> 这个类，让它变成一个非静态的，能够在其所有被使用的地方被正确的注入依赖。但是基于我们能够更容易的测试它（比如，重现或者验证某个 Bug），我们能简单的使用参数作为依赖项进行注入，而不是基于某个单例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"number\">_</span> message: Message,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     to user: User,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     database: Database = .shared,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     networkManager: NetworkManager = .shared)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        database.insert(message)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> data: <span class=\"type\">Data</span> = <span class=\"keyword\">try</span> wrap(message)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> endpoint = <span class=\"type\">Endpoint</span>.sendMessage(to: user)</span><br><span class=\"line\">        networkManager.post(data, to: endpoint.url)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们又再次使用了缺省的参数，不仅仅更加方便而已，更重要的是，能够在 100% 向后兼容的情况下为我们的代码增加测试支持。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>所以，哪一种依赖注入的方案是最好的呢？就像大部分时候一样，我的答案很无聊的： 看情况！我在该博客中所视图去做的一件事情就是针对某个特定问题给出需要不同的解决方案。原因很简单，我真的不相信又所谓银弹的存在。我认为，按照我们意愿具备多个工具或者对于特定技巧的多种解决方案能够使我们变得更好，在写代码的时候也能够游刃有余。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift\" target=\"_blank\" rel=\"noopener\">Different flavors of dependency injection in Swift</a><br>原作者 &amp; Copyright <a href=\"https://twitter.com/johnsundell\" target=\"_blank\" rel=\"noopener\">@johnsundell</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>在之前的几篇博客中，我们已经了解了几种使用依赖注入方式使得某个 swift app 拥有一个更加解耦可测试的架构。比如在 <a href=\"http://hechen.xyz/2017/11/19/Dependency-injection-using-factories-in-Swift/\">在 Swift 中使用工厂模式进行依赖注入</a> 中和工厂模式结合，以及在<a href=\"http://hechen.xyz/2018/07/16/Avoiding-singletons-in-Swift/\">避免在 Swift 中使用单例</a>中替换程序中的单例对象等方式进行依赖注入。</p>\n<p>到目前为止，大部分我的博文以及例子中都使用了基于初始化的依赖注入方式。然而，就像大部分的编程技巧一样，还有很多 “口味” 的进行依赖注入的方式 ── 每一种都有其优缺点。 这周，让我们来看看其中三种方式以及如何在 Swift 中使用它们。</p>\n<h3 id=\"基于初始化方法\"><a href=\"#基于初始化方法\" class=\"headerlink\" title=\"基于初始化方法\"></a>基于初始化方法</h3><p>让我们快速回顾一下用的最为广泛的依赖注入方式 ── initializer-based。这个想法是在某个类被初始化的时候传入其所需的依赖的方式。这种形式最大的好处就是，它保证了能够立即满足该类完成其功能所需要的所有东西。</p>\n<p>让我们建一个类 ── FileLoader 来从磁盘加载文件。为了实现该 Loader 的功能，需要两个依赖项，系统所提供的实例对象 ── <strong>FileManager</strong> 和 <strong>Cache</strong>。使用基于初始化的依赖注入的执行代码如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileLoader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> fileManager: <span class=\"type\">FileManager</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> cache: <span class=\"type\">Cache</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(fileManager: <span class=\"type\">FileManager</span> = .<span class=\"keyword\">default</span>,</span><br><span class=\"line\">         cache: <span class=\"type\">Cache</span> = .<span class=\"keyword\">init</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.fileManager = fileManager</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.cache = cache</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以关注下初始化方法里默认参数的设置，其可以避免每次都需要自行创建的问题。这样能够简化我们在生产环境下使用 <strong>FileLoader</strong> 类创建文件加载器的工作，而且也能够能够传入 mock 数据或者我们的测试代码中的创建的实例进行测试。</p>\n<h3 id=\"基于属性\"><a href=\"#基于属性\" class=\"headerlink\" title=\"基于属性\"></a>基于属性</h3><p>虽然前一种基于初始化的依赖注入形式常常给我们自定义类带来很多好处，但是有时候，当你不得不继承自某个系统类的时候会遇到一些困难。其中一个例子就是，当我们构建 view controller，尤其是你在使用 XIB 以及 Storyboard 类定义它们的时候，因为此时你不再能够掌控它们的初始化方法了。</p>\n<p>对于这些情况，基于属性的依赖注入方式是一个更好的选择。相对于初始化的时候进行对象的依赖项注入，基于属性的形式可以在之后通过简单的赋值来做到，其能够让你减少模板代码的书写，尤其是在你确实没有必要进行注入的时候能够有更好的默认实现。</p>\n<p>让我们再来看一个例子，在这个例子中，我们在构建一个 <strong>PhotoEditorViewController</strong> ，这个视图控制器使得用户编辑它们照片库中的图片。为了达到这个功能，该视图控制器需要用到系统提供的 PHPhotoLibrary 类型的一个实例（该类本身是一个单例）以及我们自己实现的类 <strong>PhotoEditorEngine</strong> 的一个实例。那为了不通过自定义初始化方法进行依赖注入的话，我们可以创建一些具有默认值的可变属性，例如下面这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhotoEditorViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> library: <span class=\"type\">PhotoLibrary</span> = <span class=\"type\">PHPhotoLibrary</span>.shared()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> engine = <span class=\"type\">PhotoEditorEngine</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <a href=\"https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps\" target=\"_blank\" rel=\"noopener\">Testing Swift code that uses system singletons in 3 easy steps</a> 这篇文章中的手法，通过使用一个协议提供一个更为抽象的 <strong>PhotoLibrary</strong> 接口来获取系统的图片库。这样会使得测试和 Mock 数据特别的容易。</p>\n<p>上面这些工作比较好的是我们依然能够通过简单的给视图控制器来赋值，从而在我们的测试中简单的注入 Mock 代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhotoEditorViewControllerTests</span>: <span class=\"title\">XCTestCase</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testApplyingBlackAndWhiteFilter</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> viewController = <span class=\"type\">PhotoEditorViewController</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Assign a mock photo library to gain complete control over</span></span><br><span class=\"line\">        <span class=\"comment\">// what photos are stored in it</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> library = <span class=\"type\">PhotoLibraryMock</span>()</span><br><span class=\"line\">        library.photos = [<span class=\"type\">TestPhotoFactory</span>.photoWithColor(.red)]</span><br><span class=\"line\">        viewController.library = library</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run our testing commands</span></span><br><span class=\"line\">        viewController.selectPhoto(atIndex: <span class=\"number\">0</span>)</span><br><span class=\"line\">        viewController.apply(<span class=\"built_in\">filter</span>: .blackAndWhite)</span><br><span class=\"line\">        viewController.savePhoto()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Assert that the outcome is correct</span></span><br><span class=\"line\">        <span class=\"type\">XCTAssertTrue</span>(photoIsBlackAndWhite(library.photos[<span class=\"number\">0</span>]))</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"基于参数\"><a href=\"#基于参数\" class=\"headerlink\" title=\"基于参数\"></a>基于参数</h3><p>最后一种，让我们来看下基于参数的依赖注入形式。这种方式尤其在你想让旧有代码更加可测试，而不需要对现存的结构进行更多改动的时候尤其有效。</p>\n<p>许多时候，我们仅需要某个特定的依赖项一次，或者我们仅仅需要在某些特定条件下进行 mock。不需要改变某个对象的初始化方法或者暴露可变属性（通常都不是一个好主意），我们可以开发出一个接受一个依赖项作为参数的特定 API。</p>\n<p>让我们看一个 <strong>NoteManager</strong> 类，该类是某个笔记类应用的一部分。它的工作就是管理所有用户已经书写的笔记，提供一个 API 让用户能够查询笔记。考虑到这个操作可能耗时（\u0010如果用户有许多笔记，通常情况下是这样），我们把该动作正常放置于一个后台线程执行，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoteManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadNotes</span><span class=\"params\">(matching query: String,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   completionHandler: @escaping <span class=\"params\">([Note])</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> database = <span class=\"keyword\">self</span>.loadDatabase()</span><br><span class=\"line\">            <span class=\"keyword\">let</span> notes = database.<span class=\"built_in\">filter</span> &#123; note <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> note.matches(query: query)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(notes)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管上面的代码在我们的生产环境里也算是一个很好的解决方案，但在测试中我们正常情况下是想避免一些异步代码的，尽可能的平行化以避免 <a href=\"https://www.swiftbysundell.com/posts/reducing-flakiness-in-swift-tests\" target=\"_blank\" rel=\"noopener\">flakiness</a>. 如果要类似于基于初始化或者基于属性的依赖注入能够指定一个显式的队列提供给 NoteManager 来用的方式，需要对该类进行很多改变，这是我们在当下无法做或者不愿意做的。</p>\n<p>这时候，基于参数的依赖注入方式的实现就能够达到。相对于不得不对整个类进行重构，我们通过插入队列相关代码使得 <code>loadNotes</code> 方法在该队列上执行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoteManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadNotes</span><span class=\"params\">(matching query: String,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                   on queue: DispatchQueue = .global<span class=\"params\">(qos: .userInitiated)</span></span></span>,</span><br><span class=\"line\">                   completionHandler: @escaping ([<span class=\"type\">Note</span>]) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        queue.async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> database = <span class=\"keyword\">self</span>.loadDatabase()</span><br><span class=\"line\">            <span class=\"keyword\">let</span> notes = database.<span class=\"built_in\">filter</span> &#123; note <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> note.matches(query: query)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            completionHandler(notes)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就使得我们能够很容易的在测试代码中使用某个定制的我们可等待的队列。这样也几乎使得我们把上面的接口转变成了一个同步接口，使得一切变得更加容易和可预测。</p>\n<p>另外一个基于参数的依赖注入的使用案例是当你想测试某个静态的 API 的时候。因为静态的 API 我们是不存在初始化方法的，同时我们理想情况下也是不应该维护任何静态的状态的，那基于参数的依赖注入方式就是一个很好的选择。让我们看一个静态的类 <strong>MessageSender</strong>， 该类当前依赖某个单例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"number\">_</span> message: Message, to user: User)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Database</span>.shared.insert(message)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> data: <span class=\"type\">Data</span> = <span class=\"keyword\">try</span> wrap(message)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> endpoint = <span class=\"type\">Endpoint</span>.sendMessage(to: user)</span><br><span class=\"line\">        <span class=\"type\">NetworkManager</span>.shared.post(data, to: endpoint.url)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，一个长远的解决方案更可能是重构 <strong>MessageSender</strong> 这个类，让它变成一个非静态的，能够在其所有被使用的地方被正确的注入依赖。但是基于我们能够更容易的测试它（比如，重现或者验证某个 Bug），我们能简单的使用参数作为依赖项进行注入，而不是基于某个单例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"number\">_</span> message: Message,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     to user: User,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     database: Database = .shared,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     networkManager: NetworkManager = .shared)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        database.insert(message)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> data: <span class=\"type\">Data</span> = <span class=\"keyword\">try</span> wrap(message)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> endpoint = <span class=\"type\">Endpoint</span>.sendMessage(to: user)</span><br><span class=\"line\">        networkManager.post(data, to: endpoint.url)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们又再次使用了缺省的参数，不仅仅更加方便而已，更重要的是，能够在 100% 向后兼容的情况下为我们的代码增加测试支持。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>所以，哪一种依赖注入的方案是最好的呢？就像大部分时候一样，我的答案很无聊的： 看情况！我在该博客中所视图去做的一件事情就是针对某个特定问题给出需要不同的解决方案。原因很简单，我真的不相信又所谓银弹的存在。我认为，按照我们意愿具备多个工具或者对于特定技巧的多种解决方案能够使我们变得更好，在写代码的时候也能够游刃有余。</p>\n"},{"title":"What is LLVM","date":"2018-07-10T04:05:58.000Z","top_img":"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-cw_scary_tech_12-100740223-large.jpg","_content":"\n> 原文：[What is LLVM? The power behind Swift, Rust, Clang, and more](https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n# 什么是 LLVM？隐藏在 Swift，Rust，Clang 等语言背后的奥秘\n\n> 了解编译器是如何生成机器原生代码会使得倒腾新语言或者加强已经存在的编程语言变得比以往更加容易了。\n\n新的编程语言，针对现存语言的优化如同雨后春笋般产生。 Mozilla 的 **Rust**， Apple 的 **Swift**，JetBrain 的 **Kotlin**等语言给开发者提供了在速度，安全性，便捷性，可移植性以及性能等方面更多的选择。\n\n为什么是这个时间点呢？一个重大的原因是那些构建具体语言相关的新式工具的出现。在这一堆工具中，最重要的就是 LLVM，其全称是 Low-Level Virtual Machine，它是一个开源项目，其最早是由 Swift 语言的发明人 Chris Lattner 在伊利诺斯州州立大学期间的一个研究项目而来。\n\nLLVM 不仅仅使得创建新式语言更加容易，也使得针对现存编程语言进行增强完善更加便捷。它提供了一堆工具使得创造语言的过程中需要的那些令人头疼的事情变得自动化：创建一个编译器，输出代码需要适配多平台和架构，编写代码处理语言当中通常都存在的那些比较晦涩的部分，比如异常。LLVM 的自由开发许可使得它可以被自由的作为一个软件组件或者被部署成服务来使用。\n\n使用了 LLVM 的编程语言花名册种有很多熟悉的名字。Apple 的 Swift 语言使用 LLVM 作为其编译器框架，Rust 语言使用 LLVM 作为其工具链中的一个核心组件。同样，许多编译器也有其 LLVM 版本，例如 Clang，一个 C/C++ 编译器，它是和 LLVM 功能特别相近的一个项目。还有 Kotlin 语言，其名义上是一门 JVM 语言，也正在开发该语言的一个版本： [Kotlin Native](https://www.infoworld.com/article/3187370/application-development/kotlin-compiles-directly-to-native-code-via-llvm.html)，其使用 LLVM 编译成机器原生代码。\n\n## LLVM 是什么\n\nLLVM 最核心的功能就是，可以通过编码方式创造机器原生代码。一个开发者可以使用其 API 创造指令，该指令是一种 intermediate representation 格式，简称 IR。之后，LLVM 能够将 IR 编译成独立的二进制文件，或者对其执行即时编译以运行在另外一个程序，例如某编程语言的解释器的上下文中。\n\n很多编程语言中很常见的结构体或者模式，LLVM 的 API 都提供了原始语义的支持。例如，几乎所有的语言都有函数或者全局变量的概念，LLVM 在其 IR 中把函数和全局变量作为独立元素定义出来，因此你不需要花太多时间和精力来重复造这些特定的轮子，你只需要使用 LLVM 的实现，专注于你的语言最需要关注的地方即可。\n\n![一个 LLVM 的 IR 的例证. 右侧是一个简单的 C 程序; 左侧是同样的代码被 Clang 编译器翻译成的 LLVM IR](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-direct.jpeg)\n\n\n## LLVM: 专为移植性而设计\n\n涉及 LLVM 的一点就是，经常在讨论 C 语言的时候被提及： C 语言有时候会被描述为一门可移植的高阶汇编语言，就是因为其具备能被映射成很接近硬件设备的指令，而且它已经被移植到几乎所有的系统架构上。但是 C 语言只能作为一种可移植的汇编语言实际上也有其副作用，这个确实也不是其设计目标。\n\n作为对比，LLVM 的 IR 从最初就是被设计作为一个可移植的汇编。体现的第一点就是其提供独立于特定机器架构的语义，例如，integer 类型并不会被限制在特定硬件设备上的最大位数（比如 32 位 或者 64 位）。你可以按照你的需要的位数来创建你所需要的 integer 类型，比如 一个 128 位的 integer。你也不需要担心针对特定处理器指令集来再加工，LLVM 已经为了考虑了这些。\n\n如果你想看到 LLVM IR 长的什么样子，可以去看一下 [ELLCC 项目](http://ellcc.org/)，尝试一下 [Demo](http://ellcc.org/demo/index.cgi) 直接使用浏览器将 C 代码转换为 LLVM IR。\n\n## 编程语言是如何使用 LLVM 的\n\n最常用的场景就是作为某一种语言的编译器前端（ahead-of-time (AOT) compiler），除了如此，LLVM 还有其他很多可能性。\n\n### 使用 LLVM 进行即时编译\n\n一些情形需要我们的代码在运行时即时生成，而不是提前编译好。比如 [Julia 语言](https://www.infoworld.com/article/3241107/python/julia-vs-python-julia-language-rises-for-data-science.html?nsdr=true)，JIT 编译其代码，因为其需要运行很快，能够使得用户通过交互式解析器（[REPL](https://en.wikipedia.org/wiki/Read–eval–print_loop)）或者可交互弹窗来交互。Mono，使用 .Net 实现，能够利用 [LLVM 后端编译为机器原生代码](http://www.mono-project.com/docs/advanced/runtime/docs/llvm-backend/)。\n\n[Numba](https://www.infoworld.com/article/2880767/python/5-projects-push-python-performance.html)，一个为 Python 提供的数学计算加速包，JIT 将选择的 Python 函数编译为机器代码。它也能提前编译 Numba 修饰的代码，但是（例如 Julia），Python 由于其解释性语言的特性能够提供快速的开发工作。使用 JIT 编译能够产出比提前编译更好的 Python 的交互工作流。\n\n其他的语言还有用非传统方式把 LLVM 作为 JIT 来实验的语言，比如 [JIT-Compiling SQL Queries in PostgreSQL Using LLVM](https://www.pgcon.org/2017/schedule/events/1092.en.html)，能够达到高达 5 倍的性能提升。\n\n![Numba 使用 LLVM 即时编译其数值代码从而加速其执行速度。JIT 加速的 sum2d 函数完成执行比使用常规 Python 代码的实现快大约 139 倍](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-numba-llvm-100747598-large.jpg)\n\n\n\n### 利用 LLVM 进行自动化的代码优化\n\nLLVM 不仅仅是将 IR 编译成原生机器代码。你也可以通过编码引导其进行更大粒度的优化工作，整个工作会贯穿整个链接过程。优化工作可以非常激进，包括对函数进行内联，移除死代码（包含无用的类型声明以及函数参数）或者[展开循环](https://en.wikipedia.org/wiki/Loop_unrolling)等。\n\n这次依然，上面这些你并不需要都自己来做。 LLVM 能够帮你处理这些事情，你也可以按需关闭这些功能。举例来讲，如果你想牺牲一部分性能来减小二进制的大小，你可以使用自己的编译器前端来告知 LLVM 来关闭循环展开。\n\n### 使用 LLVM 的领域特定语言\n\nLLVM 已经被用以为许多跨领域通用计算机语言产生编译器，但是它在生成非常垂直或者解决某些具体问题的语言方面也非常有用。在某些程度上，这才是 LLVM 最闪光的点所在，因为它移除了一大堆创建该语言过程中的单调烦躁的工作，并且使得它表现的更好。\n\n比如，[Emscripten](https://github.com/kripken/emscripten) 项目，采用了 LLVM IR 代码，将其转换成 JavaScript，理论上允许任何具备 LLVM 后端的语言可以导出在浏览器中运行的代码。虽然 Emscripten 的长期计划是能够拥有可生成 WebAssembly 的基于 LLVM 的后端，但是它是一个展示 LLVM 灵活性的很好的例证。\n\n另外一种 LLVM 可以被使用的方式就是为已存在的编程语言增加特定领域的扩展。Nvidia 使用 LLVM 创造了[Nvidia CUDA Compiler](https://developer.nvidia.com/cuda-llvm-compiler)，其能够让编程语言增加针对 CUDA 的原生支持，而不是通过加载某个库来唤起。\n\n## 在多种语言中使用 LLVM\n\n和 LLVM 打交道的一种典型方式就是找到你很舒服的一种编程语言的代码来体会，当然，这种编程语言要支持 LLVM。\n\n两种常见选择的语言是 C 和 C++。许多 LLVM 的开发者默认选择这二者之一有以下几个原因：\n\n1. LLVM 本身就是 C++ 写的；\n2. LLVM 的 API 能够在 C 和 C++ 中无缝使用；\n3. 需要语言都倾向于基于 C 和 C++ 进行开发。\n\n尽管，这两种语言并不是唯一的选择。许多语言能够原生调用 C 库的方法，所以理论上是可以使用这些语言来进行 LLVM 开发的，但是其也有助于在某种语言中实际存在一个库，能够优雅的封装 LLVM 的 API。幸运的是，许多语言和运行时都有这些库，包括 [C#/.Net/Mono](https://github.com/Microsoft/LLVMSharp), [Rust](https://crates.io/crates/llvm-sys), [Haskell](https://hackage.haskell.org/package/llvm), [OCAML](https://opam.ocaml.org/packages/llvm/), [Node.js](https://www.npmjs.com/package/llvm-node), [Go](https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT), 和 [Python](https://github.com/numba/llvmlite)。\n\n不过，你需要注意的一点是，这些语言中有一些针对 LLVM 的绑定支持并不完整。以 Python 语言举例，虽然存在多种选择，但是它们都会在完整性和功效性上有差别：\n\n- LLVM 项目下[维护有针对 LLVM 的 C 版 API 的绑定集合](https://github.com/llvm-mirror/llvm/tree/master/bindings/python)，但是它们已经不再被维护了；\n\n- [llvmpy](https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html) 在 2015 年停止的维护，这对于任何的软件项目来讲都不是一件好事。在使用 LLVM 的时候更是如此，考虑到每一个版本的 LLVM 所带来的变化数量。\n\n- [llvmlite](https://github.com/numba/llvmlite) 是由 Numba 的开发团队创建的，已经成为了当下在 Python 中做 LLVM 开发的有力竞争者。它基于 Numba 项目的需求，只实现了一小部分 LLVM 的功能。但是这个功能子集已经能够满足大部分 LLVM 开发者使用了。\n\n- [llvmcpy](https://github.com/revng/llvmcpy) 旨在更新 Python 为 C 库提供的绑定，使得它们能够以自动化的形式保持更新，并且 Python 的原生语法使得它们能够很方便的使用。llvmcpy 依然处于初级阶段，但是已经做了很多和 LLVM API 打交道的基础工作。\n\nIf you’re curious about how to use LLVM libraries to build a language, LLVM’s own creators have a tutorial, using either C++ or OCAML, that steps you through creating a simple language called Kaleidoscope. It’s since been ported to other languages:\n\n如果你很好奇如何使用 LLVM 库构建一门语言的话，LLVM 的原创者们提供了[教程](https://llvm.org/docs/tutorial/index.html)，该教程使用 C++ 或者 OCAML ，指导你从头到尾创造一门简单的语言 **Kaleidoscope**，而这个示例已经被移植到其他语言上了：\n\n- [Haskell](http://www.stephendiehl.com/llvm/): 和原始教程最接近的移植；\n\n- Python：[一个版本](https://github.com/eliben/pykaleidoscope)和该教程非常接近，[另外一个版本](https://github.com/frederickjeanguerin/pykaleidoscope) 更激进一些，重写了一个交互命令行。两者都使用了 llvmlite 作为和 LLVM 的绑定；\n\n- [\u0010Rust](https://github.com/jauhien/iron-kaleidoscope) 和 [Swift](https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html)：似乎不可避免，我们会得到这两个语言版本的移植版本教程，因为 LLVM 本身更就是因为这二者才得以创造的。\n\n\n最后，这个教程也有其他人类语言的版本。它已经被翻译成中文了，有使用 [C++](https://github.com/liancheng/llvm-tutorial-cn) 的，也有 [Python](https://github.com/moevis/Kaleidoscope-LLVM-tutorial-zh-cn)。\n\n\n## LLVM 做不到哪些\n\n以上提到的都是 LLVM 能够提供的功能，它还有一些无法做到的事情，了解一下会比较有用。\n\n举例而言，LLVM 不会进行语法解析。许多工具，比如 [lex/yacc](http://dinosaur.compilertools.net/)，[ﬂex/bison](http://aquamentus.com/flex_bison.html) 以及 [ANTLR](http://www.antlr.org/) 等都已经做了这些工作。解析语法就意味着要和编译行为进行解耦，所以，LLVM 没有试图去做这部分工作也不意外。\n\nLLVM 也不会试图解决围绕某种特定语言更大范围的周边行为。你需要自行安装编译器二进制，管理安装过程中的包以及升级工具链。\n\n最后一点，也是最重要的是，依然又很多语言通用的部分 LLVM 没有原生支持的。许多编程语言都存在垃圾回收内存管理的行为，要么作为管理内存的主要方式，要么作为某种策略，例如 RAII（C++ 和 Rust 语言中使用的）的辅助。LLVM 不提供垃圾回收机制，但是它确实[提供一些工具](https://llvm.org/docs/GarbageCollection.html)，能够允许代码可以使用元数据来做标记使得编写垃圾收集器更加容易。\n\n尽管如此，LLVM 还是存在最终添加原生支持执行垃圾回收机制的可能性。LLVM 正在以每 6 个月一个大版本更新在快速发展。而这个发展步速很大程度上因为目前很多主流编程语言已经把其作为它们开发过程的核心一环。","source":"_posts/What-is-LLVM.md","raw":"---\ntitle: What is LLVM\ndate: 2018-07-10 12:05:58\ntop_img: http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-cw_scary_tech_12-100740223-large.jpg\ncategories: 翻译\ntags: [LLVM,Compiler,Swfit,IR]\n---\n\n> 原文：[What is LLVM? The power behind Swift, Rust, Clang, and more](https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n# 什么是 LLVM？隐藏在 Swift，Rust，Clang 等语言背后的奥秘\n\n> 了解编译器是如何生成机器原生代码会使得倒腾新语言或者加强已经存在的编程语言变得比以往更加容易了。\n\n新的编程语言，针对现存语言的优化如同雨后春笋般产生。 Mozilla 的 **Rust**， Apple 的 **Swift**，JetBrain 的 **Kotlin**等语言给开发者提供了在速度，安全性，便捷性，可移植性以及性能等方面更多的选择。\n\n为什么是这个时间点呢？一个重大的原因是那些构建具体语言相关的新式工具的出现。在这一堆工具中，最重要的就是 LLVM，其全称是 Low-Level Virtual Machine，它是一个开源项目，其最早是由 Swift 语言的发明人 Chris Lattner 在伊利诺斯州州立大学期间的一个研究项目而来。\n\nLLVM 不仅仅使得创建新式语言更加容易，也使得针对现存编程语言进行增强完善更加便捷。它提供了一堆工具使得创造语言的过程中需要的那些令人头疼的事情变得自动化：创建一个编译器，输出代码需要适配多平台和架构，编写代码处理语言当中通常都存在的那些比较晦涩的部分，比如异常。LLVM 的自由开发许可使得它可以被自由的作为一个软件组件或者被部署成服务来使用。\n\n使用了 LLVM 的编程语言花名册种有很多熟悉的名字。Apple 的 Swift 语言使用 LLVM 作为其编译器框架，Rust 语言使用 LLVM 作为其工具链中的一个核心组件。同样，许多编译器也有其 LLVM 版本，例如 Clang，一个 C/C++ 编译器，它是和 LLVM 功能特别相近的一个项目。还有 Kotlin 语言，其名义上是一门 JVM 语言，也正在开发该语言的一个版本： [Kotlin Native](https://www.infoworld.com/article/3187370/application-development/kotlin-compiles-directly-to-native-code-via-llvm.html)，其使用 LLVM 编译成机器原生代码。\n\n## LLVM 是什么\n\nLLVM 最核心的功能就是，可以通过编码方式创造机器原生代码。一个开发者可以使用其 API 创造指令，该指令是一种 intermediate representation 格式，简称 IR。之后，LLVM 能够将 IR 编译成独立的二进制文件，或者对其执行即时编译以运行在另外一个程序，例如某编程语言的解释器的上下文中。\n\n很多编程语言中很常见的结构体或者模式，LLVM 的 API 都提供了原始语义的支持。例如，几乎所有的语言都有函数或者全局变量的概念，LLVM 在其 IR 中把函数和全局变量作为独立元素定义出来，因此你不需要花太多时间和精力来重复造这些特定的轮子，你只需要使用 LLVM 的实现，专注于你的语言最需要关注的地方即可。\n\n![一个 LLVM 的 IR 的例证. 右侧是一个简单的 C 程序; 左侧是同样的代码被 Clang 编译器翻译成的 LLVM IR](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-direct.jpeg)\n\n\n## LLVM: 专为移植性而设计\n\n涉及 LLVM 的一点就是，经常在讨论 C 语言的时候被提及： C 语言有时候会被描述为一门可移植的高阶汇编语言，就是因为其具备能被映射成很接近硬件设备的指令，而且它已经被移植到几乎所有的系统架构上。但是 C 语言只能作为一种可移植的汇编语言实际上也有其副作用，这个确实也不是其设计目标。\n\n作为对比，LLVM 的 IR 从最初就是被设计作为一个可移植的汇编。体现的第一点就是其提供独立于特定机器架构的语义，例如，integer 类型并不会被限制在特定硬件设备上的最大位数（比如 32 位 或者 64 位）。你可以按照你的需要的位数来创建你所需要的 integer 类型，比如 一个 128 位的 integer。你也不需要担心针对特定处理器指令集来再加工，LLVM 已经为了考虑了这些。\n\n如果你想看到 LLVM IR 长的什么样子，可以去看一下 [ELLCC 项目](http://ellcc.org/)，尝试一下 [Demo](http://ellcc.org/demo/index.cgi) 直接使用浏览器将 C 代码转换为 LLVM IR。\n\n## 编程语言是如何使用 LLVM 的\n\n最常用的场景就是作为某一种语言的编译器前端（ahead-of-time (AOT) compiler），除了如此，LLVM 还有其他很多可能性。\n\n### 使用 LLVM 进行即时编译\n\n一些情形需要我们的代码在运行时即时生成，而不是提前编译好。比如 [Julia 语言](https://www.infoworld.com/article/3241107/python/julia-vs-python-julia-language-rises-for-data-science.html?nsdr=true)，JIT 编译其代码，因为其需要运行很快，能够使得用户通过交互式解析器（[REPL](https://en.wikipedia.org/wiki/Read–eval–print_loop)）或者可交互弹窗来交互。Mono，使用 .Net 实现，能够利用 [LLVM 后端编译为机器原生代码](http://www.mono-project.com/docs/advanced/runtime/docs/llvm-backend/)。\n\n[Numba](https://www.infoworld.com/article/2880767/python/5-projects-push-python-performance.html)，一个为 Python 提供的数学计算加速包，JIT 将选择的 Python 函数编译为机器代码。它也能提前编译 Numba 修饰的代码，但是（例如 Julia），Python 由于其解释性语言的特性能够提供快速的开发工作。使用 JIT 编译能够产出比提前编译更好的 Python 的交互工作流。\n\n其他的语言还有用非传统方式把 LLVM 作为 JIT 来实验的语言，比如 [JIT-Compiling SQL Queries in PostgreSQL Using LLVM](https://www.pgcon.org/2017/schedule/events/1092.en.html)，能够达到高达 5 倍的性能提升。\n\n![Numba 使用 LLVM 即时编译其数值代码从而加速其执行速度。JIT 加速的 sum2d 函数完成执行比使用常规 Python 代码的实现快大约 139 倍](http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-numba-llvm-100747598-large.jpg)\n\n\n\n### 利用 LLVM 进行自动化的代码优化\n\nLLVM 不仅仅是将 IR 编译成原生机器代码。你也可以通过编码引导其进行更大粒度的优化工作，整个工作会贯穿整个链接过程。优化工作可以非常激进，包括对函数进行内联，移除死代码（包含无用的类型声明以及函数参数）或者[展开循环](https://en.wikipedia.org/wiki/Loop_unrolling)等。\n\n这次依然，上面这些你并不需要都自己来做。 LLVM 能够帮你处理这些事情，你也可以按需关闭这些功能。举例来讲，如果你想牺牲一部分性能来减小二进制的大小，你可以使用自己的编译器前端来告知 LLVM 来关闭循环展开。\n\n### 使用 LLVM 的领域特定语言\n\nLLVM 已经被用以为许多跨领域通用计算机语言产生编译器，但是它在生成非常垂直或者解决某些具体问题的语言方面也非常有用。在某些程度上，这才是 LLVM 最闪光的点所在，因为它移除了一大堆创建该语言过程中的单调烦躁的工作，并且使得它表现的更好。\n\n比如，[Emscripten](https://github.com/kripken/emscripten) 项目，采用了 LLVM IR 代码，将其转换成 JavaScript，理论上允许任何具备 LLVM 后端的语言可以导出在浏览器中运行的代码。虽然 Emscripten 的长期计划是能够拥有可生成 WebAssembly 的基于 LLVM 的后端，但是它是一个展示 LLVM 灵活性的很好的例证。\n\n另外一种 LLVM 可以被使用的方式就是为已存在的编程语言增加特定领域的扩展。Nvidia 使用 LLVM 创造了[Nvidia CUDA Compiler](https://developer.nvidia.com/cuda-llvm-compiler)，其能够让编程语言增加针对 CUDA 的原生支持，而不是通过加载某个库来唤起。\n\n## 在多种语言中使用 LLVM\n\n和 LLVM 打交道的一种典型方式就是找到你很舒服的一种编程语言的代码来体会，当然，这种编程语言要支持 LLVM。\n\n两种常见选择的语言是 C 和 C++。许多 LLVM 的开发者默认选择这二者之一有以下几个原因：\n\n1. LLVM 本身就是 C++ 写的；\n2. LLVM 的 API 能够在 C 和 C++ 中无缝使用；\n3. 需要语言都倾向于基于 C 和 C++ 进行开发。\n\n尽管，这两种语言并不是唯一的选择。许多语言能够原生调用 C 库的方法，所以理论上是可以使用这些语言来进行 LLVM 开发的，但是其也有助于在某种语言中实际存在一个库，能够优雅的封装 LLVM 的 API。幸运的是，许多语言和运行时都有这些库，包括 [C#/.Net/Mono](https://github.com/Microsoft/LLVMSharp), [Rust](https://crates.io/crates/llvm-sys), [Haskell](https://hackage.haskell.org/package/llvm), [OCAML](https://opam.ocaml.org/packages/llvm/), [Node.js](https://www.npmjs.com/package/llvm-node), [Go](https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT), 和 [Python](https://github.com/numba/llvmlite)。\n\n不过，你需要注意的一点是，这些语言中有一些针对 LLVM 的绑定支持并不完整。以 Python 语言举例，虽然存在多种选择，但是它们都会在完整性和功效性上有差别：\n\n- LLVM 项目下[维护有针对 LLVM 的 C 版 API 的绑定集合](https://github.com/llvm-mirror/llvm/tree/master/bindings/python)，但是它们已经不再被维护了；\n\n- [llvmpy](https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html) 在 2015 年停止的维护，这对于任何的软件项目来讲都不是一件好事。在使用 LLVM 的时候更是如此，考虑到每一个版本的 LLVM 所带来的变化数量。\n\n- [llvmlite](https://github.com/numba/llvmlite) 是由 Numba 的开发团队创建的，已经成为了当下在 Python 中做 LLVM 开发的有力竞争者。它基于 Numba 项目的需求，只实现了一小部分 LLVM 的功能。但是这个功能子集已经能够满足大部分 LLVM 开发者使用了。\n\n- [llvmcpy](https://github.com/revng/llvmcpy) 旨在更新 Python 为 C 库提供的绑定，使得它们能够以自动化的形式保持更新，并且 Python 的原生语法使得它们能够很方便的使用。llvmcpy 依然处于初级阶段，但是已经做了很多和 LLVM API 打交道的基础工作。\n\nIf you’re curious about how to use LLVM libraries to build a language, LLVM’s own creators have a tutorial, using either C++ or OCAML, that steps you through creating a simple language called Kaleidoscope. It’s since been ported to other languages:\n\n如果你很好奇如何使用 LLVM 库构建一门语言的话，LLVM 的原创者们提供了[教程](https://llvm.org/docs/tutorial/index.html)，该教程使用 C++ 或者 OCAML ，指导你从头到尾创造一门简单的语言 **Kaleidoscope**，而这个示例已经被移植到其他语言上了：\n\n- [Haskell](http://www.stephendiehl.com/llvm/): 和原始教程最接近的移植；\n\n- Python：[一个版本](https://github.com/eliben/pykaleidoscope)和该教程非常接近，[另外一个版本](https://github.com/frederickjeanguerin/pykaleidoscope) 更激进一些，重写了一个交互命令行。两者都使用了 llvmlite 作为和 LLVM 的绑定；\n\n- [\u0010Rust](https://github.com/jauhien/iron-kaleidoscope) 和 [Swift](https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html)：似乎不可避免，我们会得到这两个语言版本的移植版本教程，因为 LLVM 本身更就是因为这二者才得以创造的。\n\n\n最后，这个教程也有其他人类语言的版本。它已经被翻译成中文了，有使用 [C++](https://github.com/liancheng/llvm-tutorial-cn) 的，也有 [Python](https://github.com/moevis/Kaleidoscope-LLVM-tutorial-zh-cn)。\n\n\n## LLVM 做不到哪些\n\n以上提到的都是 LLVM 能够提供的功能，它还有一些无法做到的事情，了解一下会比较有用。\n\n举例而言，LLVM 不会进行语法解析。许多工具，比如 [lex/yacc](http://dinosaur.compilertools.net/)，[ﬂex/bison](http://aquamentus.com/flex_bison.html) 以及 [ANTLR](http://www.antlr.org/) 等都已经做了这些工作。解析语法就意味着要和编译行为进行解耦，所以，LLVM 没有试图去做这部分工作也不意外。\n\nLLVM 也不会试图解决围绕某种特定语言更大范围的周边行为。你需要自行安装编译器二进制，管理安装过程中的包以及升级工具链。\n\n最后一点，也是最重要的是，依然又很多语言通用的部分 LLVM 没有原生支持的。许多编程语言都存在垃圾回收内存管理的行为，要么作为管理内存的主要方式，要么作为某种策略，例如 RAII（C++ 和 Rust 语言中使用的）的辅助。LLVM 不提供垃圾回收机制，但是它确实[提供一些工具](https://llvm.org/docs/GarbageCollection.html)，能够允许代码可以使用元数据来做标记使得编写垃圾收集器更加容易。\n\n尽管如此，LLVM 还是存在最终添加原生支持执行垃圾回收机制的可能性。LLVM 正在以每 6 个月一个大版本更新在快速发展。而这个发展步速很大程度上因为目前很多主流编程语言已经把其作为它们开发过程的核心一环。","slug":"What-is-LLVM","published":1,"updated":"2018-07-17T04:08:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftbv004w79pohzr25buw","content":"<blockquote>\n<p>原文：<a href=\"https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html\" target=\"_blank\" rel=\"noopener\">What is LLVM? The power behind Swift, Rust, Clang, and more</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<h1 id=\"什么是-LLVM？隐藏在-Swift，Rust，Clang-等语言背后的奥秘\"><a href=\"#什么是-LLVM？隐藏在-Swift，Rust，Clang-等语言背后的奥秘\" class=\"headerlink\" title=\"什么是 LLVM？隐藏在 Swift，Rust，Clang 等语言背后的奥秘\"></a>什么是 LLVM？隐藏在 Swift，Rust，Clang 等语言背后的奥秘</h1><blockquote>\n<p>了解编译器是如何生成机器原生代码会使得倒腾新语言或者加强已经存在的编程语言变得比以往更加容易了。</p>\n</blockquote>\n<p>新的编程语言，针对现存语言的优化如同雨后春笋般产生。 Mozilla 的 <strong>Rust</strong>， Apple 的 <strong>Swift</strong>，JetBrain 的 <strong>Kotlin</strong>等语言给开发者提供了在速度，安全性，便捷性，可移植性以及性能等方面更多的选择。</p>\n<p>为什么是这个时间点呢？一个重大的原因是那些构建具体语言相关的新式工具的出现。在这一堆工具中，最重要的就是 LLVM，其全称是 Low-Level Virtual Machine，它是一个开源项目，其最早是由 Swift 语言的发明人 Chris Lattner 在伊利诺斯州州立大学期间的一个研究项目而来。</p>\n<p>LLVM 不仅仅使得创建新式语言更加容易，也使得针对现存编程语言进行增强完善更加便捷。它提供了一堆工具使得创造语言的过程中需要的那些令人头疼的事情变得自动化：创建一个编译器，输出代码需要适配多平台和架构，编写代码处理语言当中通常都存在的那些比较晦涩的部分，比如异常。LLVM 的自由开发许可使得它可以被自由的作为一个软件组件或者被部署成服务来使用。</p>\n<p>使用了 LLVM 的编程语言花名册种有很多熟悉的名字。Apple 的 Swift 语言使用 LLVM 作为其编译器框架，Rust 语言使用 LLVM 作为其工具链中的一个核心组件。同样，许多编译器也有其 LLVM 版本，例如 Clang，一个 C/C++ 编译器，它是和 LLVM 功能特别相近的一个项目。还有 Kotlin 语言，其名义上是一门 JVM 语言，也正在开发该语言的一个版本： <a href=\"https://www.infoworld.com/article/3187370/application-development/kotlin-compiles-directly-to-native-code-via-llvm.html\" target=\"_blank\" rel=\"noopener\">Kotlin Native</a>，其使用 LLVM 编译成机器原生代码。</p>\n<h2 id=\"LLVM-是什么\"><a href=\"#LLVM-是什么\" class=\"headerlink\" title=\"LLVM 是什么\"></a>LLVM 是什么</h2><p>LLVM 最核心的功能就是，可以通过编码方式创造机器原生代码。一个开发者可以使用其 API 创造指令，该指令是一种 intermediate representation 格式，简称 IR。之后，LLVM 能够将 IR 编译成独立的二进制文件，或者对其执行即时编译以运行在另外一个程序，例如某编程语言的解释器的上下文中。</p>\n<p>很多编程语言中很常见的结构体或者模式，LLVM 的 API 都提供了原始语义的支持。例如，几乎所有的语言都有函数或者全局变量的概念，LLVM 在其 IR 中把函数和全局变量作为独立元素定义出来，因此你不需要花太多时间和精力来重复造这些特定的轮子，你只需要使用 LLVM 的实现，专注于你的语言最需要关注的地方即可。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-direct.jpeg\" alt=\"一个 LLVM 的 IR 的例证. 右侧是一个简单的 C 程序; 左侧是同样的代码被 Clang 编译器翻译成的 LLVM IR\"></p>\n<h2 id=\"LLVM-专为移植性而设计\"><a href=\"#LLVM-专为移植性而设计\" class=\"headerlink\" title=\"LLVM: 专为移植性而设计\"></a>LLVM: 专为移植性而设计</h2><p>涉及 LLVM 的一点就是，经常在讨论 C 语言的时候被提及： C 语言有时候会被描述为一门可移植的高阶汇编语言，就是因为其具备能被映射成很接近硬件设备的指令，而且它已经被移植到几乎所有的系统架构上。但是 C 语言只能作为一种可移植的汇编语言实际上也有其副作用，这个确实也不是其设计目标。</p>\n<p>作为对比，LLVM 的 IR 从最初就是被设计作为一个可移植的汇编。体现的第一点就是其提供独立于特定机器架构的语义，例如，integer 类型并不会被限制在特定硬件设备上的最大位数（比如 32 位 或者 64 位）。你可以按照你的需要的位数来创建你所需要的 integer 类型，比如 一个 128 位的 integer。你也不需要担心针对特定处理器指令集来再加工，LLVM 已经为了考虑了这些。</p>\n<p>如果你想看到 LLVM IR 长的什么样子，可以去看一下 <a href=\"http://ellcc.org/\" target=\"_blank\" rel=\"noopener\">ELLCC 项目</a>，尝试一下 <a href=\"http://ellcc.org/demo/index.cgi\" target=\"_blank\" rel=\"noopener\">Demo</a> 直接使用浏览器将 C 代码转换为 LLVM IR。</p>\n<h2 id=\"编程语言是如何使用-LLVM-的\"><a href=\"#编程语言是如何使用-LLVM-的\" class=\"headerlink\" title=\"编程语言是如何使用 LLVM 的\"></a>编程语言是如何使用 LLVM 的</h2><p>最常用的场景就是作为某一种语言的编译器前端（ahead-of-time (AOT) compiler），除了如此，LLVM 还有其他很多可能性。</p>\n<h3 id=\"使用-LLVM-进行即时编译\"><a href=\"#使用-LLVM-进行即时编译\" class=\"headerlink\" title=\"使用 LLVM 进行即时编译\"></a>使用 LLVM 进行即时编译</h3><p>一些情形需要我们的代码在运行时即时生成，而不是提前编译好。比如 <a href=\"https://www.infoworld.com/article/3241107/python/julia-vs-python-julia-language-rises-for-data-science.html?nsdr=true\" target=\"_blank\" rel=\"noopener\">Julia 语言</a>，JIT 编译其代码，因为其需要运行很快，能够使得用户通过交互式解析器（<a href=\"https://en.wikipedia.org/wiki/Read–eval–print_loop\" target=\"_blank\" rel=\"noopener\">REPL</a>）或者可交互弹窗来交互。Mono，使用 .Net 实现，能够利用 <a href=\"http://www.mono-project.com/docs/advanced/runtime/docs/llvm-backend/\" target=\"_blank\" rel=\"noopener\">LLVM 后端编译为机器原生代码</a>。</p>\n<p><a href=\"https://www.infoworld.com/article/2880767/python/5-projects-push-python-performance.html\" target=\"_blank\" rel=\"noopener\">Numba</a>，一个为 Python 提供的数学计算加速包，JIT 将选择的 Python 函数编译为机器代码。它也能提前编译 Numba 修饰的代码，但是（例如 Julia），Python 由于其解释性语言的特性能够提供快速的开发工作。使用 JIT 编译能够产出比提前编译更好的 Python 的交互工作流。</p>\n<p>其他的语言还有用非传统方式把 LLVM 作为 JIT 来实验的语言，比如 <a href=\"https://www.pgcon.org/2017/schedule/events/1092.en.html\" target=\"_blank\" rel=\"noopener\">JIT-Compiling SQL Queries in PostgreSQL Using LLVM</a>，能够达到高达 5 倍的性能提升。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-numba-llvm-100747598-large.jpg\" alt=\"Numba 使用 LLVM 即时编译其数值代码从而加速其执行速度。JIT 加速的 sum2d 函数完成执行比使用常规 Python 代码的实现快大约 139 倍\"></p>\n<h3 id=\"利用-LLVM-进行自动化的代码优化\"><a href=\"#利用-LLVM-进行自动化的代码优化\" class=\"headerlink\" title=\"利用 LLVM 进行自动化的代码优化\"></a>利用 LLVM 进行自动化的代码优化</h3><p>LLVM 不仅仅是将 IR 编译成原生机器代码。你也可以通过编码引导其进行更大粒度的优化工作，整个工作会贯穿整个链接过程。优化工作可以非常激进，包括对函数进行内联，移除死代码（包含无用的类型声明以及函数参数）或者<a href=\"https://en.wikipedia.org/wiki/Loop_unrolling\" target=\"_blank\" rel=\"noopener\">展开循环</a>等。</p>\n<p>这次依然，上面这些你并不需要都自己来做。 LLVM 能够帮你处理这些事情，你也可以按需关闭这些功能。举例来讲，如果你想牺牲一部分性能来减小二进制的大小，你可以使用自己的编译器前端来告知 LLVM 来关闭循环展开。</p>\n<h3 id=\"使用-LLVM-的领域特定语言\"><a href=\"#使用-LLVM-的领域特定语言\" class=\"headerlink\" title=\"使用 LLVM 的领域特定语言\"></a>使用 LLVM 的领域特定语言</h3><p>LLVM 已经被用以为许多跨领域通用计算机语言产生编译器，但是它在生成非常垂直或者解决某些具体问题的语言方面也非常有用。在某些程度上，这才是 LLVM 最闪光的点所在，因为它移除了一大堆创建该语言过程中的单调烦躁的工作，并且使得它表现的更好。</p>\n<p>比如，<a href=\"https://github.com/kripken/emscripten\" target=\"_blank\" rel=\"noopener\">Emscripten</a> 项目，采用了 LLVM IR 代码，将其转换成 JavaScript，理论上允许任何具备 LLVM 后端的语言可以导出在浏览器中运行的代码。虽然 Emscripten 的长期计划是能够拥有可生成 WebAssembly 的基于 LLVM 的后端，但是它是一个展示 LLVM 灵活性的很好的例证。</p>\n<p>另外一种 LLVM 可以被使用的方式就是为已存在的编程语言增加特定领域的扩展。Nvidia 使用 LLVM 创造了<a href=\"https://developer.nvidia.com/cuda-llvm-compiler\" target=\"_blank\" rel=\"noopener\">Nvidia CUDA Compiler</a>，其能够让编程语言增加针对 CUDA 的原生支持，而不是通过加载某个库来唤起。</p>\n<h2 id=\"在多种语言中使用-LLVM\"><a href=\"#在多种语言中使用-LLVM\" class=\"headerlink\" title=\"在多种语言中使用 LLVM\"></a>在多种语言中使用 LLVM</h2><p>和 LLVM 打交道的一种典型方式就是找到你很舒服的一种编程语言的代码来体会，当然，这种编程语言要支持 LLVM。</p>\n<p>两种常见选择的语言是 C 和 C++。许多 LLVM 的开发者默认选择这二者之一有以下几个原因：</p>\n<ol>\n<li>LLVM 本身就是 C++ 写的；</li>\n<li>LLVM 的 API 能够在 C 和 C++ 中无缝使用；</li>\n<li>需要语言都倾向于基于 C 和 C++ 进行开发。</li>\n</ol>\n<p>尽管，这两种语言并不是唯一的选择。许多语言能够原生调用 C 库的方法，所以理论上是可以使用这些语言来进行 LLVM 开发的，但是其也有助于在某种语言中实际存在一个库，能够优雅的封装 LLVM 的 API。幸运的是，许多语言和运行时都有这些库，包括 <a href=\"https://github.com/Microsoft/LLVMSharp\" target=\"_blank\" rel=\"noopener\">C#/.Net/Mono</a>, <a href=\"https://crates.io/crates/llvm-sys\" target=\"_blank\" rel=\"noopener\">Rust</a>, <a href=\"https://hackage.haskell.org/package/llvm\" target=\"_blank\" rel=\"noopener\">Haskell</a>, <a href=\"https://opam.ocaml.org/packages/llvm/\" target=\"_blank\" rel=\"noopener\">OCAML</a>, <a href=\"https://www.npmjs.com/package/llvm-node\" target=\"_blank\" rel=\"noopener\">Node.js</a>, <a href=\"https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT\" target=\"_blank\" rel=\"noopener\">Go</a>, 和 <a href=\"https://github.com/numba/llvmlite\" target=\"_blank\" rel=\"noopener\">Python</a>。</p>\n<p>不过，你需要注意的一点是，这些语言中有一些针对 LLVM 的绑定支持并不完整。以 Python 语言举例，虽然存在多种选择，但是它们都会在完整性和功效性上有差别：</p>\n<ul>\n<li><p>LLVM 项目下<a href=\"https://github.com/llvm-mirror/llvm/tree/master/bindings/python\" target=\"_blank\" rel=\"noopener\">维护有针对 LLVM 的 C 版 API 的绑定集合</a>，但是它们已经不再被维护了；</p>\n</li>\n<li><p><a href=\"https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html\" target=\"_blank\" rel=\"noopener\">llvmpy</a> 在 2015 年停止的维护，这对于任何的软件项目来讲都不是一件好事。在使用 LLVM 的时候更是如此，考虑到每一个版本的 LLVM 所带来的变化数量。</p>\n</li>\n<li><p><a href=\"https://github.com/numba/llvmlite\" target=\"_blank\" rel=\"noopener\">llvmlite</a> 是由 Numba 的开发团队创建的，已经成为了当下在 Python 中做 LLVM 开发的有力竞争者。它基于 Numba 项目的需求，只实现了一小部分 LLVM 的功能。但是这个功能子集已经能够满足大部分 LLVM 开发者使用了。</p>\n</li>\n<li><p><a href=\"https://github.com/revng/llvmcpy\" target=\"_blank\" rel=\"noopener\">llvmcpy</a> 旨在更新 Python 为 C 库提供的绑定，使得它们能够以自动化的形式保持更新，并且 Python 的原生语法使得它们能够很方便的使用。llvmcpy 依然处于初级阶段，但是已经做了很多和 LLVM API 打交道的基础工作。</p>\n</li>\n</ul>\n<p>If you’re curious about how to use LLVM libraries to build a language, LLVM’s own creators have a tutorial, using either C++ or OCAML, that steps you through creating a simple language called Kaleidoscope. It’s since been ported to other languages:</p>\n<p>如果你很好奇如何使用 LLVM 库构建一门语言的话，LLVM 的原创者们提供了<a href=\"https://llvm.org/docs/tutorial/index.html\" target=\"_blank\" rel=\"noopener\">教程</a>，该教程使用 C++ 或者 OCAML ，指导你从头到尾创造一门简单的语言 <strong>Kaleidoscope</strong>，而这个示例已经被移植到其他语言上了：</p>\n<ul>\n<li><p><a href=\"http://www.stephendiehl.com/llvm/\" target=\"_blank\" rel=\"noopener\">Haskell</a>: 和原始教程最接近的移植；</p>\n</li>\n<li><p>Python：<a href=\"https://github.com/eliben/pykaleidoscope\" target=\"_blank\" rel=\"noopener\">一个版本</a>和该教程非常接近，<a href=\"https://github.com/frederickjeanguerin/pykaleidoscope\" target=\"_blank\" rel=\"noopener\">另外一个版本</a> 更激进一些，重写了一个交互命令行。两者都使用了 llvmlite 作为和 LLVM 的绑定；</p>\n</li>\n<li><p><a href=\"https://github.com/jauhien/iron-kaleidoscope\" target=\"_blank\" rel=\"noopener\">\u0010Rust</a> 和 <a href=\"https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html\" target=\"_blank\" rel=\"noopener\">Swift</a>：似乎不可避免，我们会得到这两个语言版本的移植版本教程，因为 LLVM 本身更就是因为这二者才得以创造的。</p>\n</li>\n</ul>\n<p>最后，这个教程也有其他人类语言的版本。它已经被翻译成中文了，有使用 <a href=\"https://github.com/liancheng/llvm-tutorial-cn\" target=\"_blank\" rel=\"noopener\">C++</a> 的，也有 <a href=\"https://github.com/moevis/Kaleidoscope-LLVM-tutorial-zh-cn\" target=\"_blank\" rel=\"noopener\">Python</a>。</p>\n<h2 id=\"LLVM-做不到哪些\"><a href=\"#LLVM-做不到哪些\" class=\"headerlink\" title=\"LLVM 做不到哪些\"></a>LLVM 做不到哪些</h2><p>以上提到的都是 LLVM 能够提供的功能，它还有一些无法做到的事情，了解一下会比较有用。</p>\n<p>举例而言，LLVM 不会进行语法解析。许多工具，比如 <a href=\"http://dinosaur.compilertools.net/\" target=\"_blank\" rel=\"noopener\">lex/yacc</a>，<a href=\"http://aquamentus.com/flex_bison.html\" target=\"_blank\" rel=\"noopener\">ﬂex/bison</a> 以及 <a href=\"http://www.antlr.org/\" target=\"_blank\" rel=\"noopener\">ANTLR</a> 等都已经做了这些工作。解析语法就意味着要和编译行为进行解耦，所以，LLVM 没有试图去做这部分工作也不意外。</p>\n<p>LLVM 也不会试图解决围绕某种特定语言更大范围的周边行为。你需要自行安装编译器二进制，管理安装过程中的包以及升级工具链。</p>\n<p>最后一点，也是最重要的是，依然又很多语言通用的部分 LLVM 没有原生支持的。许多编程语言都存在垃圾回收内存管理的行为，要么作为管理内存的主要方式，要么作为某种策略，例如 RAII（C++ 和 Rust 语言中使用的）的辅助。LLVM 不提供垃圾回收机制，但是它确实<a href=\"https://llvm.org/docs/GarbageCollection.html\" target=\"_blank\" rel=\"noopener\">提供一些工具</a>，能够允许代码可以使用元数据来做标记使得编写垃圾收集器更加容易。</p>\n<p>尽管如此，LLVM 还是存在最终添加原生支持执行垃圾回收机制的可能性。LLVM 正在以每 6 个月一个大版本更新在快速发展。而这个发展步速很大程度上因为目前很多主流编程语言已经把其作为它们开发过程的核心一环。</p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<blockquote>\n<p>原文：<a href=\"https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html\" target=\"_blank\" rel=\"noopener\">What is LLVM? The power behind Swift, Rust, Clang, and more</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<h1 id=\"什么是-LLVM？隐藏在-Swift，Rust，Clang-等语言背后的奥秘\"><a href=\"#什么是-LLVM？隐藏在-Swift，Rust，Clang-等语言背后的奥秘\" class=\"headerlink\" title=\"什么是 LLVM？隐藏在 Swift，Rust，Clang 等语言背后的奥秘\"></a>什么是 LLVM？隐藏在 Swift，Rust，Clang 等语言背后的奥秘</h1><blockquote>\n<p>了解编译器是如何生成机器原生代码会使得倒腾新语言或者加强已经存在的编程语言变得比以往更加容易了。</p>\n</blockquote>\n<p>新的编程语言，针对现存语言的优化如同雨后春笋般产生。 Mozilla 的 <strong>Rust</strong>， Apple 的 <strong>Swift</strong>，JetBrain 的 <strong>Kotlin</strong>等语言给开发者提供了在速度，安全性，便捷性，可移植性以及性能等方面更多的选择。</p>\n<p>为什么是这个时间点呢？一个重大的原因是那些构建具体语言相关的新式工具的出现。在这一堆工具中，最重要的就是 LLVM，其全称是 Low-Level Virtual Machine，它是一个开源项目，其最早是由 Swift 语言的发明人 Chris Lattner 在伊利诺斯州州立大学期间的一个研究项目而来。</p>\n<p>LLVM 不仅仅使得创建新式语言更加容易，也使得针对现存编程语言进行增强完善更加便捷。它提供了一堆工具使得创造语言的过程中需要的那些令人头疼的事情变得自动化：创建一个编译器，输出代码需要适配多平台和架构，编写代码处理语言当中通常都存在的那些比较晦涩的部分，比如异常。LLVM 的自由开发许可使得它可以被自由的作为一个软件组件或者被部署成服务来使用。</p>\n<p>使用了 LLVM 的编程语言花名册种有很多熟悉的名字。Apple 的 Swift 语言使用 LLVM 作为其编译器框架，Rust 语言使用 LLVM 作为其工具链中的一个核心组件。同样，许多编译器也有其 LLVM 版本，例如 Clang，一个 C/C++ 编译器，它是和 LLVM 功能特别相近的一个项目。还有 Kotlin 语言，其名义上是一门 JVM 语言，也正在开发该语言的一个版本： <a href=\"https://www.infoworld.com/article/3187370/application-development/kotlin-compiles-directly-to-native-code-via-llvm.html\" target=\"_blank\" rel=\"noopener\">Kotlin Native</a>，其使用 LLVM 编译成机器原生代码。</p>\n<h2 id=\"LLVM-是什么\"><a href=\"#LLVM-是什么\" class=\"headerlink\" title=\"LLVM 是什么\"></a>LLVM 是什么</h2><p>LLVM 最核心的功能就是，可以通过编码方式创造机器原生代码。一个开发者可以使用其 API 创造指令，该指令是一种 intermediate representation 格式，简称 IR。之后，LLVM 能够将 IR 编译成独立的二进制文件，或者对其执行即时编译以运行在另外一个程序，例如某编程语言的解释器的上下文中。</p>\n<p>很多编程语言中很常见的结构体或者模式，LLVM 的 API 都提供了原始语义的支持。例如，几乎所有的语言都有函数或者全局变量的概念，LLVM 在其 IR 中把函数和全局变量作为独立元素定义出来，因此你不需要花太多时间和精力来重复造这些特定的轮子，你只需要使用 LLVM 的实现，专注于你的语言最需要关注的地方即可。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-direct.jpeg\" alt=\"一个 LLVM 的 IR 的例证. 右侧是一个简单的 C 程序; 左侧是同样的代码被 Clang 编译器翻译成的 LLVM IR\"></p>\n<h2 id=\"LLVM-专为移植性而设计\"><a href=\"#LLVM-专为移植性而设计\" class=\"headerlink\" title=\"LLVM: 专为移植性而设计\"></a>LLVM: 专为移植性而设计</h2><p>涉及 LLVM 的一点就是，经常在讨论 C 语言的时候被提及： C 语言有时候会被描述为一门可移植的高阶汇编语言，就是因为其具备能被映射成很接近硬件设备的指令，而且它已经被移植到几乎所有的系统架构上。但是 C 语言只能作为一种可移植的汇编语言实际上也有其副作用，这个确实也不是其设计目标。</p>\n<p>作为对比，LLVM 的 IR 从最初就是被设计作为一个可移植的汇编。体现的第一点就是其提供独立于特定机器架构的语义，例如，integer 类型并不会被限制在特定硬件设备上的最大位数（比如 32 位 或者 64 位）。你可以按照你的需要的位数来创建你所需要的 integer 类型，比如 一个 128 位的 integer。你也不需要担心针对特定处理器指令集来再加工，LLVM 已经为了考虑了这些。</p>\n<p>如果你想看到 LLVM IR 长的什么样子，可以去看一下 <a href=\"http://ellcc.org/\" target=\"_blank\" rel=\"noopener\">ELLCC 项目</a>，尝试一下 <a href=\"http://ellcc.org/demo/index.cgi\" target=\"_blank\" rel=\"noopener\">Demo</a> 直接使用浏览器将 C 代码转换为 LLVM IR。</p>\n<h2 id=\"编程语言是如何使用-LLVM-的\"><a href=\"#编程语言是如何使用-LLVM-的\" class=\"headerlink\" title=\"编程语言是如何使用 LLVM 的\"></a>编程语言是如何使用 LLVM 的</h2><p>最常用的场景就是作为某一种语言的编译器前端（ahead-of-time (AOT) compiler），除了如此，LLVM 还有其他很多可能性。</p>\n<h3 id=\"使用-LLVM-进行即时编译\"><a href=\"#使用-LLVM-进行即时编译\" class=\"headerlink\" title=\"使用 LLVM 进行即时编译\"></a>使用 LLVM 进行即时编译</h3><p>一些情形需要我们的代码在运行时即时生成，而不是提前编译好。比如 <a href=\"https://www.infoworld.com/article/3241107/python/julia-vs-python-julia-language-rises-for-data-science.html?nsdr=true\" target=\"_blank\" rel=\"noopener\">Julia 语言</a>，JIT 编译其代码，因为其需要运行很快，能够使得用户通过交互式解析器（<a href=\"https://en.wikipedia.org/wiki/Read–eval–print_loop\" target=\"_blank\" rel=\"noopener\">REPL</a>）或者可交互弹窗来交互。Mono，使用 .Net 实现，能够利用 <a href=\"http://www.mono-project.com/docs/advanced/runtime/docs/llvm-backend/\" target=\"_blank\" rel=\"noopener\">LLVM 后端编译为机器原生代码</a>。</p>\n<p><a href=\"https://www.infoworld.com/article/2880767/python/5-projects-push-python-performance.html\" target=\"_blank\" rel=\"noopener\">Numba</a>，一个为 Python 提供的数学计算加速包，JIT 将选择的 Python 函数编译为机器代码。它也能提前编译 Numba 修饰的代码，但是（例如 Julia），Python 由于其解释性语言的特性能够提供快速的开发工作。使用 JIT 编译能够产出比提前编译更好的 Python 的交互工作流。</p>\n<p>其他的语言还有用非传统方式把 LLVM 作为 JIT 来实验的语言，比如 <a href=\"https://www.pgcon.org/2017/schedule/events/1092.en.html\" target=\"_blank\" rel=\"noopener\">JIT-Compiling SQL Queries in PostgreSQL Using LLVM</a>，能够达到高达 5 倍的性能提升。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-numba-llvm-100747598-large.jpg\" alt=\"Numba 使用 LLVM 即时编译其数值代码从而加速其执行速度。JIT 加速的 sum2d 函数完成执行比使用常规 Python 代码的实现快大约 139 倍\"></p>\n<h3 id=\"利用-LLVM-进行自动化的代码优化\"><a href=\"#利用-LLVM-进行自动化的代码优化\" class=\"headerlink\" title=\"利用 LLVM 进行自动化的代码优化\"></a>利用 LLVM 进行自动化的代码优化</h3><p>LLVM 不仅仅是将 IR 编译成原生机器代码。你也可以通过编码引导其进行更大粒度的优化工作，整个工作会贯穿整个链接过程。优化工作可以非常激进，包括对函数进行内联，移除死代码（包含无用的类型声明以及函数参数）或者<a href=\"https://en.wikipedia.org/wiki/Loop_unrolling\" target=\"_blank\" rel=\"noopener\">展开循环</a>等。</p>\n<p>这次依然，上面这些你并不需要都自己来做。 LLVM 能够帮你处理这些事情，你也可以按需关闭这些功能。举例来讲，如果你想牺牲一部分性能来减小二进制的大小，你可以使用自己的编译器前端来告知 LLVM 来关闭循环展开。</p>\n<h3 id=\"使用-LLVM-的领域特定语言\"><a href=\"#使用-LLVM-的领域特定语言\" class=\"headerlink\" title=\"使用 LLVM 的领域特定语言\"></a>使用 LLVM 的领域特定语言</h3><p>LLVM 已经被用以为许多跨领域通用计算机语言产生编译器，但是它在生成非常垂直或者解决某些具体问题的语言方面也非常有用。在某些程度上，这才是 LLVM 最闪光的点所在，因为它移除了一大堆创建该语言过程中的单调烦躁的工作，并且使得它表现的更好。</p>\n<p>比如，<a href=\"https://github.com/kripken/emscripten\" target=\"_blank\" rel=\"noopener\">Emscripten</a> 项目，采用了 LLVM IR 代码，将其转换成 JavaScript，理论上允许任何具备 LLVM 后端的语言可以导出在浏览器中运行的代码。虽然 Emscripten 的长期计划是能够拥有可生成 WebAssembly 的基于 LLVM 的后端，但是它是一个展示 LLVM 灵活性的很好的例证。</p>\n<p>另外一种 LLVM 可以被使用的方式就是为已存在的编程语言增加特定领域的扩展。Nvidia 使用 LLVM 创造了<a href=\"https://developer.nvidia.com/cuda-llvm-compiler\" target=\"_blank\" rel=\"noopener\">Nvidia CUDA Compiler</a>，其能够让编程语言增加针对 CUDA 的原生支持，而不是通过加载某个库来唤起。</p>\n<h2 id=\"在多种语言中使用-LLVM\"><a href=\"#在多种语言中使用-LLVM\" class=\"headerlink\" title=\"在多种语言中使用 LLVM\"></a>在多种语言中使用 LLVM</h2><p>和 LLVM 打交道的一种典型方式就是找到你很舒服的一种编程语言的代码来体会，当然，这种编程语言要支持 LLVM。</p>\n<p>两种常见选择的语言是 C 和 C++。许多 LLVM 的开发者默认选择这二者之一有以下几个原因：</p>\n<ol>\n<li>LLVM 本身就是 C++ 写的；</li>\n<li>LLVM 的 API 能够在 C 和 C++ 中无缝使用；</li>\n<li>需要语言都倾向于基于 C 和 C++ 进行开发。</li>\n</ol>\n<p>尽管，这两种语言并不是唯一的选择。许多语言能够原生调用 C 库的方法，所以理论上是可以使用这些语言来进行 LLVM 开发的，但是其也有助于在某种语言中实际存在一个库，能够优雅的封装 LLVM 的 API。幸运的是，许多语言和运行时都有这些库，包括 <a href=\"https://github.com/Microsoft/LLVMSharp\" target=\"_blank\" rel=\"noopener\">C#/.Net/Mono</a>, <a href=\"https://crates.io/crates/llvm-sys\" target=\"_blank\" rel=\"noopener\">Rust</a>, <a href=\"https://hackage.haskell.org/package/llvm\" target=\"_blank\" rel=\"noopener\">Haskell</a>, <a href=\"https://opam.ocaml.org/packages/llvm/\" target=\"_blank\" rel=\"noopener\">OCAML</a>, <a href=\"https://www.npmjs.com/package/llvm-node\" target=\"_blank\" rel=\"noopener\">Node.js</a>, <a href=\"https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT\" target=\"_blank\" rel=\"noopener\">Go</a>, 和 <a href=\"https://github.com/numba/llvmlite\" target=\"_blank\" rel=\"noopener\">Python</a>。</p>\n<p>不过，你需要注意的一点是，这些语言中有一些针对 LLVM 的绑定支持并不完整。以 Python 语言举例，虽然存在多种选择，但是它们都会在完整性和功效性上有差别：</p>\n<ul>\n<li><p>LLVM 项目下<a href=\"https://github.com/llvm-mirror/llvm/tree/master/bindings/python\" target=\"_blank\" rel=\"noopener\">维护有针对 LLVM 的 C 版 API 的绑定集合</a>，但是它们已经不再被维护了；</p>\n</li>\n<li><p><a href=\"https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html\" target=\"_blank\" rel=\"noopener\">llvmpy</a> 在 2015 年停止的维护，这对于任何的软件项目来讲都不是一件好事。在使用 LLVM 的时候更是如此，考虑到每一个版本的 LLVM 所带来的变化数量。</p>\n</li>\n<li><p><a href=\"https://github.com/numba/llvmlite\" target=\"_blank\" rel=\"noopener\">llvmlite</a> 是由 Numba 的开发团队创建的，已经成为了当下在 Python 中做 LLVM 开发的有力竞争者。它基于 Numba 项目的需求，只实现了一小部分 LLVM 的功能。但是这个功能子集已经能够满足大部分 LLVM 开发者使用了。</p>\n</li>\n<li><p><a href=\"https://github.com/revng/llvmcpy\" target=\"_blank\" rel=\"noopener\">llvmcpy</a> 旨在更新 Python 为 C 库提供的绑定，使得它们能够以自动化的形式保持更新，并且 Python 的原生语法使得它们能够很方便的使用。llvmcpy 依然处于初级阶段，但是已经做了很多和 LLVM API 打交道的基础工作。</p>\n</li>\n</ul>\n<p>If you’re curious about how to use LLVM libraries to build a language, LLVM’s own creators have a tutorial, using either C++ or OCAML, that steps you through creating a simple language called Kaleidoscope. It’s since been ported to other languages:</p>\n<p>如果你很好奇如何使用 LLVM 库构建一门语言的话，LLVM 的原创者们提供了<a href=\"https://llvm.org/docs/tutorial/index.html\" target=\"_blank\" rel=\"noopener\">教程</a>，该教程使用 C++ 或者 OCAML ，指导你从头到尾创造一门简单的语言 <strong>Kaleidoscope</strong>，而这个示例已经被移植到其他语言上了：</p>\n<ul>\n<li><p><a href=\"http://www.stephendiehl.com/llvm/\" target=\"_blank\" rel=\"noopener\">Haskell</a>: 和原始教程最接近的移植；</p>\n</li>\n<li><p>Python：<a href=\"https://github.com/eliben/pykaleidoscope\" target=\"_blank\" rel=\"noopener\">一个版本</a>和该教程非常接近，<a href=\"https://github.com/frederickjeanguerin/pykaleidoscope\" target=\"_blank\" rel=\"noopener\">另外一个版本</a> 更激进一些，重写了一个交互命令行。两者都使用了 llvmlite 作为和 LLVM 的绑定；</p>\n</li>\n<li><p><a href=\"https://github.com/jauhien/iron-kaleidoscope\" target=\"_blank\" rel=\"noopener\">\u0010Rust</a> 和 <a href=\"https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html\" target=\"_blank\" rel=\"noopener\">Swift</a>：似乎不可避免，我们会得到这两个语言版本的移植版本教程，因为 LLVM 本身更就是因为这二者才得以创造的。</p>\n</li>\n</ul>\n<p>最后，这个教程也有其他人类语言的版本。它已经被翻译成中文了，有使用 <a href=\"https://github.com/liancheng/llvm-tutorial-cn\" target=\"_blank\" rel=\"noopener\">C++</a> 的，也有 <a href=\"https://github.com/moevis/Kaleidoscope-LLVM-tutorial-zh-cn\" target=\"_blank\" rel=\"noopener\">Python</a>。</p>\n<h2 id=\"LLVM-做不到哪些\"><a href=\"#LLVM-做不到哪些\" class=\"headerlink\" title=\"LLVM 做不到哪些\"></a>LLVM 做不到哪些</h2><p>以上提到的都是 LLVM 能够提供的功能，它还有一些无法做到的事情，了解一下会比较有用。</p>\n<p>举例而言，LLVM 不会进行语法解析。许多工具，比如 <a href=\"http://dinosaur.compilertools.net/\" target=\"_blank\" rel=\"noopener\">lex/yacc</a>，<a href=\"http://aquamentus.com/flex_bison.html\" target=\"_blank\" rel=\"noopener\">ﬂex/bison</a> 以及 <a href=\"http://www.antlr.org/\" target=\"_blank\" rel=\"noopener\">ANTLR</a> 等都已经做了这些工作。解析语法就意味着要和编译行为进行解耦，所以，LLVM 没有试图去做这部分工作也不意外。</p>\n<p>LLVM 也不会试图解决围绕某种特定语言更大范围的周边行为。你需要自行安装编译器二进制，管理安装过程中的包以及升级工具链。</p>\n<p>最后一点，也是最重要的是，依然又很多语言通用的部分 LLVM 没有原生支持的。许多编程语言都存在垃圾回收内存管理的行为，要么作为管理内存的主要方式，要么作为某种策略，例如 RAII（C++ 和 Rust 语言中使用的）的辅助。LLVM 不提供垃圾回收机制，但是它确实<a href=\"https://llvm.org/docs/GarbageCollection.html\" target=\"_blank\" rel=\"noopener\">提供一些工具</a>，能够允许代码可以使用元数据来做标记使得编写垃圾收集器更加容易。</p>\n<p>尽管如此，LLVM 还是存在最终添加原生支持执行垃圾回收机制的可能性。LLVM 正在以每 6 个月一个大版本更新在快速发展。而这个发展步速很大程度上因为目前很多主流编程语言已经把其作为它们开发过程的核心一环。</p>\n"},{"title":"scala Day2","date":"2015-04-16T10:43:00.000Z","_content":"\n因为这几天在学习Coursera公开课[Principles of Reactive Programming](https://class.coursera.org/reactive-002) ，因为之前木有木有注意到需要对至少一门函数式编程语言solid foundation，因此只能临时抱佛脚，恰好手头有一本七周七语言这本书一直木有看，借着这个课程的督促把这本书翻看下，当然内容仅包括Scala这一章，今天看到第二天的内容，重头戏是Collection。这篇blog主要记录关于这次自习题的解答。\n\n<!-- more -->\n\n\n## 找\n### 关于如何使用Scala文件的讨论\n既然Scala可以使用Java中任意的对象（Objects），因此可以使用Java中针对文件的操作，例如java.io.File就是其中之一，示例如下：\n``` scala\nimport java.io._\n\nobject Test {\n    def main(args: Array[String]) {\n        val writer = new PrintWriter(new File(\"test.txt\"))\n        writer.write(\"Hello Scala\")\n        writer.close()\n    }\n}\n```\n从本地读取文件，scala库自带文件读取，如下所示代码为一段示例，可以读取本地文件中得内容\n读取文件内容：\n``` scala\nimport scala.io.Source\n\nobject Test {\n   def main(args: Array[String]) {\n      println(\"Following is the content read:\" )\n\n      Source.fromFile(\"test.txt\" ).foreach{ \n         print \n      }\n   }\n}\n```\n\n### 闭包(closure)和代码块有何不同\n关于闭包的概念，只能从网路上查找资料加上自己理解写\n##### 闭包（closure）\n> 闭包是可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在 Scala、Scheme、Common Lisp、Smalltalk、Groovy、JavaScript、Ruby、 Python、Go、Lua、objective c 以及Java（Java8及以上）等语言中都能找到对闭包不同程度的支持。    —— [百度百科](http://baike.baidu.com/link?url=vlR71k-FJO5znXeaUghn2u7BXXLi9B4K0_l1i345azAKmXmU-q8TgLxPYxqQJHQaDQgnd8RvjImY1nS7rSH5g_)\n\n\n##### 代码块（Block）\n而代码块是语法上由一些逻辑性语句组成的一个一个单元：\n``` c\nif (Condition) {\n    // one Block\n} else {\n    // another Block\n}\n```\n\n## 做\n### 使用foldLeft方法计算一个列表中所有字符串的长度\n#### 关于foldLeft和foldRight\n##### foldLeft\nScala中foldLeft方法定义在[GenTraversableOnce.scala](https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/GenTraversableOnce.scala#L1)文件中\n``` scala\n/** Applies a binary operator to a start value and all elements of this $coll,\n *  going left to right.\n *\n *  $willNotTerminateInf\n *  $orderDependentFold\n *\n *  @param   z    the start value.\n *  @param   op   the binary operator.\n *  @tparam  B    the result type of the binary operator.\n *  @return  the result of inserting `op` between consecutive elements of this $coll,\n *           going left to right with the start value `z` on the left:\n *           {{{\n *             op(...op(z, x_1), x_2, ..., x_n)\n *           }}}\n *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.\n*/\n def foldLeft[B](z: B)(op: (B, A) => B): B\n```\n实现在[TraversableOnce.scala](https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/TraversableOnce.scala#L1)里：\n``` scala\n  def foldLeft[B](z: B)(op: (B, A) => B): B = {\n    var result = z\n    this foreach (x => result = op(result, x))\n    result\n  }\n```\n方法接受两个参数，z 和 op， 其中z是B类型，op是一个返回类型为B类型的方法。其实该方法还有一个版本需要用到:/操作符，如下所示：\n``` scala\n def /:[B](z: B)(op: (B, A) => B): B = foldLeft(z)(op)\n```\n该方法实际上是调用了foldLeft方法。举个例子：\n``` scala\n scala> val list= List(1, 2, 3)\n list: List[Int] = List(1, 2, 3)\n\n scala> list.foldLeft(0)((sum, value) => sum + value)\n res6: Int = 6\n```\nfoldLeft方法被传入一个初始值和一个代码块，这个代码块有两个参数sum 和 value，foldLeft将sum初始化为0，而value通过list遍历将list中每个元素累加到sum上，因此该行代码实现了对list中元素的累加。\n\n##### foldRight\nfoldRight的实现如下：\n``` scala\n   def :\\[B](z: B)(op: (A, B) => B): B = foldRight(z)(op)\n\n   def foldRight[B](z: B)(op: (A, B) => B): B =\n   reversed.foldLeft(z)((x, y) => op(y, x))\n```\n我们看到foleRight内部还是调用的foldLeft方法，不过多了一个reversed，它其实是该trait定义的内部方法，实现如下：\n\n``` scala\n  // @tparam A    the element type of the collection\n  ...\n  // for internal use\n  protected[this] def reversed = {\n    var elems: List[A] = Nil\n    self foreach (elems ::= _)\n    elems\n  }\n```\n\n看来foldRight使用list的逆序集合然后再进行foldLeft，需要注意的是foldRight方法中需要传入的block**参数顺序**发生了变化，前者是列表参数（自己理解，不知所以）。这样的话，foldRight相对foldLeft来讲效率肯定就差一点了。下面是一个例子：\n\n``` scala\nscala> val list = List(1, 2, 3, 4, 5)\nlist: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> list.foldRight(100)((elem, sum) => sum - elem)\nres10: Int = 85\n```\n\n**回归正题**\n  题目中要求计算一个列表中字符串的长度之和也就迎刃而解，关键是明白foldLeft方法的使用。\n``` scala\n scala> val numbers = List(\"one\",\"two\",\"three\")\n numbers: List[String] = List(one, two, three)\n\n scala> val length = (0 /: numbers){(sum, elem) => sum + elem.length}\n length: Int = 11\n\n scala> val length2 = numbers.foldLeft(0)((sum, value)=> sum + value.length)\n length2: Int = 11\n```\n\n运算符 /: 和foldLeft方法均能实现需求（本质上一样一样的）\n\n###编写一个Censor trait，包含一个可将Pucky和Beans替换为Shoot和Darn的方法。使用映射存储脏话和他们的替代品\n\n``` scala\nimport scala.collection.mutable.Map\n\ntrait Censor {\n  val curseWords = Map(\"Pucky\" -> \"Shoot\", \"Beans\" -> \"Darn\")\n \n  def censor(s: String) = curseWords.foldLeft(s)((prev, curr) => prev.replaceAll(curr._1, curr._2))\n}\n \nclass Text(words: String) extends Censor {\n  def origin = words\n \n  def transform = censor(words)\n}\n \nval text = new Text(\"Pucky && Beans\")\nprintln(\"Original String: \" + text.origin)\nprintln(\"Replaced String: \" + text.transform)\n\n输出结果：\n$ scala Censor.trait \nOriginal String: Pucky && Beans\nReplaced String: Shoot && Darn\n```\n\n###从一个文件中加载脏话或者它们的替代品\n通过针对scala对文件读写的讨论，就可以很轻松的写出这道题的答案，主要是需要将map中存储的映射关系存储下来进行读取。首先读取代码如下：\n\n``` scala\nimport scala.collection.mutable.Map\n\ntrait fileRead {\n  val curseWords = Map[String, String]()\n\n  io.Source.fromFile(\"./files/censor.txt\").getLines().foreach {\n    (line) => val subWords = line.split(\":\")\n    curseWords += (subWords(0) -> subWords(1))\n  }\n\n  println(\"After Read, curseWords are\")\n  curseWords.foreach(p => println(\">>> key=\" + p._1 + \", value=\" + p._2 + \" <<<\"))\n}\n\nclass tryFile extends fileRead\n\nval fileObj = new tryFile\n```\n\n 写入文件代码如下：\n``` scala\nimport scala.collection.mutable.Map\nimport java.io._\n\ntrait fileWrite {\n  val curseWords = Map(\"Pucky\"->\"Shoot\", \"Beans\"->\"Darn\")\n\n  def writeMapToFile {\n    println(\"Start to write map to file\")\n\n    val writer = new PrintWriter(new File(\"./files/curseToWrite.txt\"))\n    curseWords.foreach{\n      (elem) => writer.write(elem._1 + \":\" + elem._2)\n      writer.write(\"\\n\")\n    }\n    writer.close()\n\n      println(\"end to write map to file\")\n  }\n}\n\nclass tryFile extends fileWrite\n\nval fileObj = new tryFile\nfileObj.writeMapToFile\n```\n\nThat's all! 关于闭包的示例晚上回家补上~~~ 工作鸟\n\n\n参考链接：\n[http://www.tutorialspoint.com/scala/scala_file_io.htm](http://www.tutorialspoint.com/scala/scala_file_io.htm)\n[http://blog.csdn.net/oopsoom/article/details/23447317](http://blog.csdn.net/oopsoom/article/details/23447317)\n[http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html](http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html)\n\n","source":"_posts/scala第二天.md","raw":"title: \"scala Day2\"\ndate: 2015-04-16 18:43:00\ncategories: \"七周七语言\"\ntags: [scala]\n---\n\n因为这几天在学习Coursera公开课[Principles of Reactive Programming](https://class.coursera.org/reactive-002) ，因为之前木有木有注意到需要对至少一门函数式编程语言solid foundation，因此只能临时抱佛脚，恰好手头有一本七周七语言这本书一直木有看，借着这个课程的督促把这本书翻看下，当然内容仅包括Scala这一章，今天看到第二天的内容，重头戏是Collection。这篇blog主要记录关于这次自习题的解答。\n\n<!-- more -->\n\n\n## 找\n### 关于如何使用Scala文件的讨论\n既然Scala可以使用Java中任意的对象（Objects），因此可以使用Java中针对文件的操作，例如java.io.File就是其中之一，示例如下：\n``` scala\nimport java.io._\n\nobject Test {\n    def main(args: Array[String]) {\n        val writer = new PrintWriter(new File(\"test.txt\"))\n        writer.write(\"Hello Scala\")\n        writer.close()\n    }\n}\n```\n从本地读取文件，scala库自带文件读取，如下所示代码为一段示例，可以读取本地文件中得内容\n读取文件内容：\n``` scala\nimport scala.io.Source\n\nobject Test {\n   def main(args: Array[String]) {\n      println(\"Following is the content read:\" )\n\n      Source.fromFile(\"test.txt\" ).foreach{ \n         print \n      }\n   }\n}\n```\n\n### 闭包(closure)和代码块有何不同\n关于闭包的概念，只能从网路上查找资料加上自己理解写\n##### 闭包（closure）\n> 闭包是可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在 Scala、Scheme、Common Lisp、Smalltalk、Groovy、JavaScript、Ruby、 Python、Go、Lua、objective c 以及Java（Java8及以上）等语言中都能找到对闭包不同程度的支持。    —— [百度百科](http://baike.baidu.com/link?url=vlR71k-FJO5znXeaUghn2u7BXXLi9B4K0_l1i345azAKmXmU-q8TgLxPYxqQJHQaDQgnd8RvjImY1nS7rSH5g_)\n\n\n##### 代码块（Block）\n而代码块是语法上由一些逻辑性语句组成的一个一个单元：\n``` c\nif (Condition) {\n    // one Block\n} else {\n    // another Block\n}\n```\n\n## 做\n### 使用foldLeft方法计算一个列表中所有字符串的长度\n#### 关于foldLeft和foldRight\n##### foldLeft\nScala中foldLeft方法定义在[GenTraversableOnce.scala](https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/GenTraversableOnce.scala#L1)文件中\n``` scala\n/** Applies a binary operator to a start value and all elements of this $coll,\n *  going left to right.\n *\n *  $willNotTerminateInf\n *  $orderDependentFold\n *\n *  @param   z    the start value.\n *  @param   op   the binary operator.\n *  @tparam  B    the result type of the binary operator.\n *  @return  the result of inserting `op` between consecutive elements of this $coll,\n *           going left to right with the start value `z` on the left:\n *           {{{\n *             op(...op(z, x_1), x_2, ..., x_n)\n *           }}}\n *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.\n*/\n def foldLeft[B](z: B)(op: (B, A) => B): B\n```\n实现在[TraversableOnce.scala](https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/TraversableOnce.scala#L1)里：\n``` scala\n  def foldLeft[B](z: B)(op: (B, A) => B): B = {\n    var result = z\n    this foreach (x => result = op(result, x))\n    result\n  }\n```\n方法接受两个参数，z 和 op， 其中z是B类型，op是一个返回类型为B类型的方法。其实该方法还有一个版本需要用到:/操作符，如下所示：\n``` scala\n def /:[B](z: B)(op: (B, A) => B): B = foldLeft(z)(op)\n```\n该方法实际上是调用了foldLeft方法。举个例子：\n``` scala\n scala> val list= List(1, 2, 3)\n list: List[Int] = List(1, 2, 3)\n\n scala> list.foldLeft(0)((sum, value) => sum + value)\n res6: Int = 6\n```\nfoldLeft方法被传入一个初始值和一个代码块，这个代码块有两个参数sum 和 value，foldLeft将sum初始化为0，而value通过list遍历将list中每个元素累加到sum上，因此该行代码实现了对list中元素的累加。\n\n##### foldRight\nfoldRight的实现如下：\n``` scala\n   def :\\[B](z: B)(op: (A, B) => B): B = foldRight(z)(op)\n\n   def foldRight[B](z: B)(op: (A, B) => B): B =\n   reversed.foldLeft(z)((x, y) => op(y, x))\n```\n我们看到foleRight内部还是调用的foldLeft方法，不过多了一个reversed，它其实是该trait定义的内部方法，实现如下：\n\n``` scala\n  // @tparam A    the element type of the collection\n  ...\n  // for internal use\n  protected[this] def reversed = {\n    var elems: List[A] = Nil\n    self foreach (elems ::= _)\n    elems\n  }\n```\n\n看来foldRight使用list的逆序集合然后再进行foldLeft，需要注意的是foldRight方法中需要传入的block**参数顺序**发生了变化，前者是列表参数（自己理解，不知所以）。这样的话，foldRight相对foldLeft来讲效率肯定就差一点了。下面是一个例子：\n\n``` scala\nscala> val list = List(1, 2, 3, 4, 5)\nlist: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> list.foldRight(100)((elem, sum) => sum - elem)\nres10: Int = 85\n```\n\n**回归正题**\n  题目中要求计算一个列表中字符串的长度之和也就迎刃而解，关键是明白foldLeft方法的使用。\n``` scala\n scala> val numbers = List(\"one\",\"two\",\"three\")\n numbers: List[String] = List(one, two, three)\n\n scala> val length = (0 /: numbers){(sum, elem) => sum + elem.length}\n length: Int = 11\n\n scala> val length2 = numbers.foldLeft(0)((sum, value)=> sum + value.length)\n length2: Int = 11\n```\n\n运算符 /: 和foldLeft方法均能实现需求（本质上一样一样的）\n\n###编写一个Censor trait，包含一个可将Pucky和Beans替换为Shoot和Darn的方法。使用映射存储脏话和他们的替代品\n\n``` scala\nimport scala.collection.mutable.Map\n\ntrait Censor {\n  val curseWords = Map(\"Pucky\" -> \"Shoot\", \"Beans\" -> \"Darn\")\n \n  def censor(s: String) = curseWords.foldLeft(s)((prev, curr) => prev.replaceAll(curr._1, curr._2))\n}\n \nclass Text(words: String) extends Censor {\n  def origin = words\n \n  def transform = censor(words)\n}\n \nval text = new Text(\"Pucky && Beans\")\nprintln(\"Original String: \" + text.origin)\nprintln(\"Replaced String: \" + text.transform)\n\n输出结果：\n$ scala Censor.trait \nOriginal String: Pucky && Beans\nReplaced String: Shoot && Darn\n```\n\n###从一个文件中加载脏话或者它们的替代品\n通过针对scala对文件读写的讨论，就可以很轻松的写出这道题的答案，主要是需要将map中存储的映射关系存储下来进行读取。首先读取代码如下：\n\n``` scala\nimport scala.collection.mutable.Map\n\ntrait fileRead {\n  val curseWords = Map[String, String]()\n\n  io.Source.fromFile(\"./files/censor.txt\").getLines().foreach {\n    (line) => val subWords = line.split(\":\")\n    curseWords += (subWords(0) -> subWords(1))\n  }\n\n  println(\"After Read, curseWords are\")\n  curseWords.foreach(p => println(\">>> key=\" + p._1 + \", value=\" + p._2 + \" <<<\"))\n}\n\nclass tryFile extends fileRead\n\nval fileObj = new tryFile\n```\n\n 写入文件代码如下：\n``` scala\nimport scala.collection.mutable.Map\nimport java.io._\n\ntrait fileWrite {\n  val curseWords = Map(\"Pucky\"->\"Shoot\", \"Beans\"->\"Darn\")\n\n  def writeMapToFile {\n    println(\"Start to write map to file\")\n\n    val writer = new PrintWriter(new File(\"./files/curseToWrite.txt\"))\n    curseWords.foreach{\n      (elem) => writer.write(elem._1 + \":\" + elem._2)\n      writer.write(\"\\n\")\n    }\n    writer.close()\n\n      println(\"end to write map to file\")\n  }\n}\n\nclass tryFile extends fileWrite\n\nval fileObj = new tryFile\nfileObj.writeMapToFile\n```\n\nThat's all! 关于闭包的示例晚上回家补上~~~ 工作鸟\n\n\n参考链接：\n[http://www.tutorialspoint.com/scala/scala_file_io.htm](http://www.tutorialspoint.com/scala/scala_file_io.htm)\n[http://blog.csdn.net/oopsoom/article/details/23447317](http://blog.csdn.net/oopsoom/article/details/23447317)\n[http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html](http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html)\n\n","slug":"scala第二天","published":1,"updated":"2017-05-21T12:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftby004z79po8nt5gq3k","content":"<p>因为这几天在学习Coursera公开课<a href=\"https://class.coursera.org/reactive-002\" target=\"_blank\" rel=\"noopener\">Principles of Reactive Programming</a> ，因为之前木有木有注意到需要对至少一门函数式编程语言solid foundation，因此只能临时抱佛脚，恰好手头有一本七周七语言这本书一直木有看，借着这个课程的督促把这本书翻看下，当然内容仅包括Scala这一章，今天看到第二天的内容，重头戏是Collection。这篇blog主要记录关于这次自习题的解答。</p>\n<a id=\"more\"></a>\n<h2 id=\"找\"><a href=\"#找\" class=\"headerlink\" title=\"找\"></a>找</h2><h3 id=\"关于如何使用Scala文件的讨论\"><a href=\"#关于如何使用Scala文件的讨论\" class=\"headerlink\" title=\"关于如何使用Scala文件的讨论\"></a>关于如何使用Scala文件的讨论</h3><p>既然Scala可以使用Java中任意的对象（Objects），因此可以使用Java中针对文件的操作，例如java.io.File就是其中之一，示例如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> writer = <span class=\"keyword\">new</span> <span class=\"type\">PrintWriter</span>(<span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"test.txt\"</span>))</span><br><span class=\"line\">        writer.write(<span class=\"string\">\"Hello Scala\"</span>)</span><br><span class=\"line\">        writer.close()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从本地读取文件，scala库自带文件读取，如下所示代码为一段示例，可以读取本地文件中得内容<br>读取文件内容：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.io.<span class=\"type\">Source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"Following is the content read:\"</span> )</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"test.txt\"</span> ).foreach&#123; </span><br><span class=\"line\">         print </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"闭包-closure-和代码块有何不同\"><a href=\"#闭包-closure-和代码块有何不同\" class=\"headerlink\" title=\"闭包(closure)和代码块有何不同\"></a>闭包(closure)和代码块有何不同</h3><p>关于闭包的概念，只能从网路上查找资料加上自己理解写</p>\n<h5 id=\"闭包（closure）\"><a href=\"#闭包（closure）\" class=\"headerlink\" title=\"闭包（closure）\"></a>闭包（closure）</h5><blockquote>\n<p>闭包是可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在 Scala、Scheme、Common Lisp、Smalltalk、Groovy、JavaScript、Ruby、 Python、Go、Lua、objective c 以及Java（Java8及以上）等语言中都能找到对闭包不同程度的支持。    —— <a href=\"http://baike.baidu.com/link?url=vlR71k-FJO5znXeaUghn2u7BXXLi9B4K0_l1i345azAKmXmU-q8TgLxPYxqQJHQaDQgnd8RvjImY1nS7rSH5g_\" target=\"_blank\" rel=\"noopener\">百度百科</a></p>\n</blockquote>\n<h5 id=\"代码块（Block）\"><a href=\"#代码块（Block）\" class=\"headerlink\" title=\"代码块（Block）\"></a>代码块（Block）</h5><p>而代码块是语法上由一些逻辑性语句组成的一个一个单元：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (Condition) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// one Block</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// another Block</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"做\"><a href=\"#做\" class=\"headerlink\" title=\"做\"></a>做</h2><h3 id=\"使用foldLeft方法计算一个列表中所有字符串的长度\"><a href=\"#使用foldLeft方法计算一个列表中所有字符串的长度\" class=\"headerlink\" title=\"使用foldLeft方法计算一个列表中所有字符串的长度\"></a>使用foldLeft方法计算一个列表中所有字符串的长度</h3><h4 id=\"关于foldLeft和foldRight\"><a href=\"#关于foldLeft和foldRight\" class=\"headerlink\" title=\"关于foldLeft和foldRight\"></a>关于foldLeft和foldRight</h4><h5 id=\"foldLeft\"><a href=\"#foldLeft\" class=\"headerlink\" title=\"foldLeft\"></a>foldLeft</h5><p>Scala中foldLeft方法定义在<a href=\"https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/GenTraversableOnce.scala#L1\" target=\"_blank\" rel=\"noopener\">GenTraversableOnce.scala</a>文件中<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Applies a binary operator to a start value and all elements of this $coll,</span></span><br><span class=\"line\"><span class=\"comment\"> *  going left to right.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  $willNotTerminateInf</span></span><br><span class=\"line\"><span class=\"comment\"> *  $orderDependentFold</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param   z    the start value.</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param   op   the binary operator.</span></span><br><span class=\"line\"><span class=\"comment\"> *  @tparam  B    the result type of the binary operator.</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return  the result of inserting `op` between consecutive elements of this $coll,</span></span><br><span class=\"line\"><span class=\"comment\"> *           going left to right with the start value `z` on the left:</span></span><br><span class=\"line\"><span class=\"comment\"> *           &#123;&#123;&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *             op(...op(z, x_1), x_2, ..., x_n)</span></span><br><span class=\"line\"><span class=\"comment\"> *           &#125;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foldLeft</span></span>[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">B</span>, <span class=\"type\">A</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span></span><br></pre></td></tr></table></figure></p>\n<p>实现在<a href=\"https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/TraversableOnce.scala#L1\" target=\"_blank\" rel=\"noopener\">TraversableOnce.scala</a>里：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foldLeft</span></span>[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">B</span>, <span class=\"type\">A</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = z</span><br><span class=\"line\">  <span class=\"keyword\">this</span> foreach (x =&gt; result = op(result, x))</span><br><span class=\"line\">  result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法接受两个参数，z 和 op， 其中z是B类型，op是一个返回类型为B类型的方法。其实该方法还有一个版本需要用到:/操作符，如下所示：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">/</span></span>:[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">B</span>, <span class=\"type\">A</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> = foldLeft(z)(op)</span><br></pre></td></tr></table></figure></p>\n<p>该方法实际上是调用了foldLeft方法。举个例子：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list= <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list.foldLeft(<span class=\"number\">0</span>)((sum, value) =&gt; sum + value)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br></pre></td></tr></table></figure></p>\n<p>foldLeft方法被传入一个初始值和一个代码块，这个代码块有两个参数sum 和 value，foldLeft将sum初始化为0，而value通过list遍历将list中每个元素累加到sum上，因此该行代码实现了对list中元素的累加。</p>\n<h5 id=\"foldRight\"><a href=\"#foldRight\" class=\"headerlink\" title=\"foldRight\"></a>foldRight</h5><p>foldRight的实现如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> </span>:\\[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">A</span>, <span class=\"type\">B</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> = foldRight(z)(op)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foldRight</span></span>[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">A</span>, <span class=\"type\">B</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> =</span><br><span class=\"line\">reversed.foldLeft(z)((x, y) =&gt; op(y, x))</span><br></pre></td></tr></table></figure></p>\n<p>我们看到foleRight内部还是调用的foldLeft方法，不过多了一个reversed，它其实是该trait定义的内部方法，实现如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @tparam A    the element type of the collection</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// for internal use</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>[<span class=\"keyword\">this</span>] <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reversed</span> </span>= &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elems: <span class=\"type\">List</span>[<span class=\"type\">A</span>] = <span class=\"type\">Nil</span></span><br><span class=\"line\">  self foreach (elems ::= _)</span><br><span class=\"line\">  elems</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看来foldRight使用list的逆序集合然后再进行foldLeft，需要注意的是foldRight方法中需要传入的block<strong>参数顺序</strong>发生了变化，前者是列表参数（自己理解，不知所以）。这样的话，foldRight相对foldLeft来讲效率肯定就差一点了。下面是一个例子：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list.foldRight(<span class=\"number\">100</span>)((elem, sum) =&gt; sum - elem)</span><br><span class=\"line\">res10: <span class=\"type\">Int</span> = <span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n<p><strong>回归正题</strong><br>  题目中要求计算一个列表中字符串的长度之和也就迎刃而解，关键是明白foldLeft方法的使用。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> numbers = <span class=\"type\">List</span>(<span class=\"string\">\"one\"</span>,<span class=\"string\">\"two\"</span>,<span class=\"string\">\"three\"</span>)</span><br><span class=\"line\">numbers: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(one, two, three)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> length = (<span class=\"number\">0</span> /: numbers)&#123;(sum, elem) =&gt; sum + elem.length&#125;</span><br><span class=\"line\">length: <span class=\"type\">Int</span> = <span class=\"number\">11</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> length2 = numbers.foldLeft(<span class=\"number\">0</span>)((sum, value)=&gt; sum + value.length)</span><br><span class=\"line\">length2: <span class=\"type\">Int</span> = <span class=\"number\">11</span></span><br></pre></td></tr></table></figure></p>\n<p>运算符 /: 和foldLeft方法均能实现需求（本质上一样一样的）</p>\n<p>###编写一个Censor trait，包含一个可将Pucky和Beans替换为Shoot和Darn的方法。使用映射存储脏话和他们的替代品</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Censor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> curseWords = <span class=\"type\">Map</span>(<span class=\"string\">\"Pucky\"</span> -&gt; <span class=\"string\">\"Shoot\"</span>, <span class=\"string\">\"Beans\"</span> -&gt; <span class=\"string\">\"Darn\"</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">censor</span></span>(s: <span class=\"type\">String</span>) = curseWords.foldLeft(s)((prev, curr) =&gt; prev.replaceAll(curr._1, curr._2))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span>(<span class=\"params\">words: <span class=\"type\">String</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Censor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">origin</span> </span>= words</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span> </span>= censor(words)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">val</span> text = <span class=\"keyword\">new</span> <span class=\"type\">Text</span>(<span class=\"string\">\"Pucky &amp;&amp; Beans\"</span>)</span><br><span class=\"line\">println(<span class=\"string\">\"Original String: \"</span> + text.origin)</span><br><span class=\"line\">println(<span class=\"string\">\"Replaced String: \"</span> + text.transform)</span><br><span class=\"line\"></span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">$ scala <span class=\"type\">Censor</span>.<span class=\"keyword\">trait</span> </span><br><span class=\"line\"><span class=\"type\">Original</span> <span class=\"type\">String</span>: <span class=\"type\">Pucky</span> &amp;&amp; <span class=\"type\">Beans</span></span><br><span class=\"line\"><span class=\"type\">Replaced</span> <span class=\"type\">String</span>: <span class=\"type\">Shoot</span> &amp;&amp; <span class=\"type\">Darn</span></span><br></pre></td></tr></table></figure>\n<p>###从一个文件中加载脏话或者它们的替代品<br>通过针对scala对文件读写的讨论，就可以很轻松的写出这道题的答案，主要是需要将map中存储的映射关系存储下来进行读取。首先读取代码如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">fileRead</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> curseWords = <span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">String</span>]()</span><br><span class=\"line\"></span><br><span class=\"line\">  io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"./files/censor.txt\"</span>).getLines().foreach &#123;</span><br><span class=\"line\">    (line) =&gt; <span class=\"keyword\">val</span> subWords = line.split(<span class=\"string\">\":\"</span>)</span><br><span class=\"line\">    curseWords += (subWords(<span class=\"number\">0</span>) -&gt; subWords(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  println(<span class=\"string\">\"After Read, curseWords are\"</span>)</span><br><span class=\"line\">  curseWords.foreach(p =&gt; println(<span class=\"string\">\"&gt;&gt;&gt; key=\"</span> + p._1 + <span class=\"string\">\", value=\"</span> + p._2 + <span class=\"string\">\" &lt;&lt;&lt;\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tryFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">fileRead</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">fileObj</span> </span>= <span class=\"keyword\">new</span> tryFile</span><br></pre></td></tr></table></figure>\n<p> 写入文件代码如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Map</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">fileWrite</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> curseWords = <span class=\"type\">Map</span>(<span class=\"string\">\"Pucky\"</span>-&gt;<span class=\"string\">\"Shoot\"</span>, <span class=\"string\">\"Beans\"</span>-&gt;<span class=\"string\">\"Darn\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writeMapToFile</span> </span>&#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Start to write map to file\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> writer = <span class=\"keyword\">new</span> <span class=\"type\">PrintWriter</span>(<span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"./files/curseToWrite.txt\"</span>))</span><br><span class=\"line\">    curseWords.foreach&#123;</span><br><span class=\"line\">      (elem) =&gt; writer.write(elem._1 + <span class=\"string\">\":\"</span> + elem._2)</span><br><span class=\"line\">      writer.write(<span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    writer.close()</span><br><span class=\"line\"></span><br><span class=\"line\">      println(<span class=\"string\">\"end to write map to file\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tryFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">fileWrite</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">fileObj</span> </span>= <span class=\"keyword\">new</span> tryFile</span><br><span class=\"line\">fileObj.writeMapToFile</span><br></pre></td></tr></table></figure></p>\n<p>That’s all! 关于闭包的示例晚上回家补上~~~ 工作鸟</p>\n<p>参考链接：<br><a href=\"http://www.tutorialspoint.com/scala/scala_file_io.htm\" target=\"_blank\" rel=\"noopener\">http://www.tutorialspoint.com/scala/scala_file_io.htm</a><br><a href=\"http://blog.csdn.net/oopsoom/article/details/23447317\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/oopsoom/article/details/23447317</a><br><a href=\"http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html\" target=\"_blank\" rel=\"noopener\">http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>因为这几天在学习Coursera公开课<a href=\"https://class.coursera.org/reactive-002\" target=\"_blank\" rel=\"noopener\">Principles of Reactive Programming</a> ，因为之前木有木有注意到需要对至少一门函数式编程语言solid foundation，因此只能临时抱佛脚，恰好手头有一本七周七语言这本书一直木有看，借着这个课程的督促把这本书翻看下，当然内容仅包括Scala这一章，今天看到第二天的内容，重头戏是Collection。这篇blog主要记录关于这次自习题的解答。</p>","more":"<h2 id=\"找\"><a href=\"#找\" class=\"headerlink\" title=\"找\"></a>找</h2><h3 id=\"关于如何使用Scala文件的讨论\"><a href=\"#关于如何使用Scala文件的讨论\" class=\"headerlink\" title=\"关于如何使用Scala文件的讨论\"></a>关于如何使用Scala文件的讨论</h3><p>既然Scala可以使用Java中任意的对象（Objects），因此可以使用Java中针对文件的操作，例如java.io.File就是其中之一，示例如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> writer = <span class=\"keyword\">new</span> <span class=\"type\">PrintWriter</span>(<span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"test.txt\"</span>))</span><br><span class=\"line\">        writer.write(<span class=\"string\">\"Hello Scala\"</span>)</span><br><span class=\"line\">        writer.close()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从本地读取文件，scala库自带文件读取，如下所示代码为一段示例，可以读取本地文件中得内容<br>读取文件内容：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.io.<span class=\"type\">Source</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">      println(<span class=\"string\">\"Following is the content read:\"</span> )</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"test.txt\"</span> ).foreach&#123; </span><br><span class=\"line\">         print </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"闭包-closure-和代码块有何不同\"><a href=\"#闭包-closure-和代码块有何不同\" class=\"headerlink\" title=\"闭包(closure)和代码块有何不同\"></a>闭包(closure)和代码块有何不同</h3><p>关于闭包的概念，只能从网路上查找资料加上自己理解写</p>\n<h5 id=\"闭包（closure）\"><a href=\"#闭包（closure）\" class=\"headerlink\" title=\"闭包（closure）\"></a>闭包（closure）</h5><blockquote>\n<p>闭包是可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在 Scala、Scheme、Common Lisp、Smalltalk、Groovy、JavaScript、Ruby、 Python、Go、Lua、objective c 以及Java（Java8及以上）等语言中都能找到对闭包不同程度的支持。    —— <a href=\"http://baike.baidu.com/link?url=vlR71k-FJO5znXeaUghn2u7BXXLi9B4K0_l1i345azAKmXmU-q8TgLxPYxqQJHQaDQgnd8RvjImY1nS7rSH5g_\" target=\"_blank\" rel=\"noopener\">百度百科</a></p>\n</blockquote>\n<h5 id=\"代码块（Block）\"><a href=\"#代码块（Block）\" class=\"headerlink\" title=\"代码块（Block）\"></a>代码块（Block）</h5><p>而代码块是语法上由一些逻辑性语句组成的一个一个单元：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (Condition) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// one Block</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// another Block</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"做\"><a href=\"#做\" class=\"headerlink\" title=\"做\"></a>做</h2><h3 id=\"使用foldLeft方法计算一个列表中所有字符串的长度\"><a href=\"#使用foldLeft方法计算一个列表中所有字符串的长度\" class=\"headerlink\" title=\"使用foldLeft方法计算一个列表中所有字符串的长度\"></a>使用foldLeft方法计算一个列表中所有字符串的长度</h3><h4 id=\"关于foldLeft和foldRight\"><a href=\"#关于foldLeft和foldRight\" class=\"headerlink\" title=\"关于foldLeft和foldRight\"></a>关于foldLeft和foldRight</h4><h5 id=\"foldLeft\"><a href=\"#foldLeft\" class=\"headerlink\" title=\"foldLeft\"></a>foldLeft</h5><p>Scala中foldLeft方法定义在<a href=\"https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/GenTraversableOnce.scala#L1\" target=\"_blank\" rel=\"noopener\">GenTraversableOnce.scala</a>文件中<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Applies a binary operator to a start value and all elements of this $coll,</span></span><br><span class=\"line\"><span class=\"comment\"> *  going left to right.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  $willNotTerminateInf</span></span><br><span class=\"line\"><span class=\"comment\"> *  $orderDependentFold</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param   z    the start value.</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param   op   the binary operator.</span></span><br><span class=\"line\"><span class=\"comment\"> *  @tparam  B    the result type of the binary operator.</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return  the result of inserting `op` between consecutive elements of this $coll,</span></span><br><span class=\"line\"><span class=\"comment\"> *           going left to right with the start value `z` on the left:</span></span><br><span class=\"line\"><span class=\"comment\"> *           &#123;&#123;&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *             op(...op(z, x_1), x_2, ..., x_n)</span></span><br><span class=\"line\"><span class=\"comment\"> *           &#125;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *           where `x,,1,,, ..., x,,n,,` are the elements of this $coll.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foldLeft</span></span>[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">B</span>, <span class=\"type\">A</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span></span><br></pre></td></tr></table></figure></p>\n<p>实现在<a href=\"https://github.com/scala/scala/blob/v2.11.6/src/library/scala/collection/TraversableOnce.scala#L1\" target=\"_blank\" rel=\"noopener\">TraversableOnce.scala</a>里：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foldLeft</span></span>[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">B</span>, <span class=\"type\">A</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = z</span><br><span class=\"line\">  <span class=\"keyword\">this</span> foreach (x =&gt; result = op(result, x))</span><br><span class=\"line\">  result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法接受两个参数，z 和 op， 其中z是B类型，op是一个返回类型为B类型的方法。其实该方法还有一个版本需要用到:/操作符，如下所示：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">/</span></span>:[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">B</span>, <span class=\"type\">A</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> = foldLeft(z)(op)</span><br></pre></td></tr></table></figure></p>\n<p>该方法实际上是调用了foldLeft方法。举个例子：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list= <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list.foldLeft(<span class=\"number\">0</span>)((sum, value) =&gt; sum + value)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br></pre></td></tr></table></figure></p>\n<p>foldLeft方法被传入一个初始值和一个代码块，这个代码块有两个参数sum 和 value，foldLeft将sum初始化为0，而value通过list遍历将list中每个元素累加到sum上，因此该行代码实现了对list中元素的累加。</p>\n<h5 id=\"foldRight\"><a href=\"#foldRight\" class=\"headerlink\" title=\"foldRight\"></a>foldRight</h5><p>foldRight的实现如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> </span>:\\[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">A</span>, <span class=\"type\">B</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> = foldRight(z)(op)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foldRight</span></span>[<span class=\"type\">B</span>](z: <span class=\"type\">B</span>)(op: (<span class=\"type\">A</span>, <span class=\"type\">B</span>) =&gt; <span class=\"type\">B</span>): <span class=\"type\">B</span> =</span><br><span class=\"line\">reversed.foldLeft(z)((x, y) =&gt; op(y, x))</span><br></pre></td></tr></table></figure></p>\n<p>我们看到foleRight内部还是调用的foldLeft方法，不过多了一个reversed，它其实是该trait定义的内部方法，实现如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @tparam A    the element type of the collection</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// for internal use</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>[<span class=\"keyword\">this</span>] <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reversed</span> </span>= &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elems: <span class=\"type\">List</span>[<span class=\"type\">A</span>] = <span class=\"type\">Nil</span></span><br><span class=\"line\">  self foreach (elems ::= _)</span><br><span class=\"line\">  elems</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看来foldRight使用list的逆序集合然后再进行foldLeft，需要注意的是foldRight方法中需要传入的block<strong>参数顺序</strong>发生了变化，前者是列表参数（自己理解，不知所以）。这样的话，foldRight相对foldLeft来讲效率肯定就差一点了。下面是一个例子：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list.foldRight(<span class=\"number\">100</span>)((elem, sum) =&gt; sum - elem)</span><br><span class=\"line\">res10: <span class=\"type\">Int</span> = <span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n<p><strong>回归正题</strong><br>  题目中要求计算一个列表中字符串的长度之和也就迎刃而解，关键是明白foldLeft方法的使用。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> numbers = <span class=\"type\">List</span>(<span class=\"string\">\"one\"</span>,<span class=\"string\">\"two\"</span>,<span class=\"string\">\"three\"</span>)</span><br><span class=\"line\">numbers: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(one, two, three)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> length = (<span class=\"number\">0</span> /: numbers)&#123;(sum, elem) =&gt; sum + elem.length&#125;</span><br><span class=\"line\">length: <span class=\"type\">Int</span> = <span class=\"number\">11</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> length2 = numbers.foldLeft(<span class=\"number\">0</span>)((sum, value)=&gt; sum + value.length)</span><br><span class=\"line\">length2: <span class=\"type\">Int</span> = <span class=\"number\">11</span></span><br></pre></td></tr></table></figure></p>\n<p>运算符 /: 和foldLeft方法均能实现需求（本质上一样一样的）</p>\n<p>###编写一个Censor trait，包含一个可将Pucky和Beans替换为Shoot和Darn的方法。使用映射存储脏话和他们的替代品</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Censor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> curseWords = <span class=\"type\">Map</span>(<span class=\"string\">\"Pucky\"</span> -&gt; <span class=\"string\">\"Shoot\"</span>, <span class=\"string\">\"Beans\"</span> -&gt; <span class=\"string\">\"Darn\"</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">censor</span></span>(s: <span class=\"type\">String</span>) = curseWords.foldLeft(s)((prev, curr) =&gt; prev.replaceAll(curr._1, curr._2))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Text</span>(<span class=\"params\">words: <span class=\"type\">String</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Censor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">origin</span> </span>= words</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span> </span>= censor(words)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">val</span> text = <span class=\"keyword\">new</span> <span class=\"type\">Text</span>(<span class=\"string\">\"Pucky &amp;&amp; Beans\"</span>)</span><br><span class=\"line\">println(<span class=\"string\">\"Original String: \"</span> + text.origin)</span><br><span class=\"line\">println(<span class=\"string\">\"Replaced String: \"</span> + text.transform)</span><br><span class=\"line\"></span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">$ scala <span class=\"type\">Censor</span>.<span class=\"keyword\">trait</span> </span><br><span class=\"line\"><span class=\"type\">Original</span> <span class=\"type\">String</span>: <span class=\"type\">Pucky</span> &amp;&amp; <span class=\"type\">Beans</span></span><br><span class=\"line\"><span class=\"type\">Replaced</span> <span class=\"type\">String</span>: <span class=\"type\">Shoot</span> &amp;&amp; <span class=\"type\">Darn</span></span><br></pre></td></tr></table></figure>\n<p>###从一个文件中加载脏话或者它们的替代品<br>通过针对scala对文件读写的讨论，就可以很轻松的写出这道题的答案，主要是需要将map中存储的映射关系存储下来进行读取。首先读取代码如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">fileRead</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> curseWords = <span class=\"type\">Map</span>[<span class=\"type\">String</span>, <span class=\"type\">String</span>]()</span><br><span class=\"line\"></span><br><span class=\"line\">  io.<span class=\"type\">Source</span>.fromFile(<span class=\"string\">\"./files/censor.txt\"</span>).getLines().foreach &#123;</span><br><span class=\"line\">    (line) =&gt; <span class=\"keyword\">val</span> subWords = line.split(<span class=\"string\">\":\"</span>)</span><br><span class=\"line\">    curseWords += (subWords(<span class=\"number\">0</span>) -&gt; subWords(<span class=\"number\">1</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  println(<span class=\"string\">\"After Read, curseWords are\"</span>)</span><br><span class=\"line\">  curseWords.foreach(p =&gt; println(<span class=\"string\">\"&gt;&gt;&gt; key=\"</span> + p._1 + <span class=\"string\">\", value=\"</span> + p._2 + <span class=\"string\">\" &lt;&lt;&lt;\"</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tryFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">fileRead</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">fileObj</span> </span>= <span class=\"keyword\">new</span> tryFile</span><br></pre></td></tr></table></figure>\n<p> 写入文件代码如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">Map</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io._</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">fileWrite</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> curseWords = <span class=\"type\">Map</span>(<span class=\"string\">\"Pucky\"</span>-&gt;<span class=\"string\">\"Shoot\"</span>, <span class=\"string\">\"Beans\"</span>-&gt;<span class=\"string\">\"Darn\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writeMapToFile</span> </span>&#123;</span><br><span class=\"line\">    println(<span class=\"string\">\"Start to write map to file\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> writer = <span class=\"keyword\">new</span> <span class=\"type\">PrintWriter</span>(<span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">\"./files/curseToWrite.txt\"</span>))</span><br><span class=\"line\">    curseWords.foreach&#123;</span><br><span class=\"line\">      (elem) =&gt; writer.write(elem._1 + <span class=\"string\">\":\"</span> + elem._2)</span><br><span class=\"line\">      writer.write(<span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    writer.close()</span><br><span class=\"line\"></span><br><span class=\"line\">      println(<span class=\"string\">\"end to write map to file\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tryFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">fileWrite</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">val</span> <span class=\"title\">fileObj</span> </span>= <span class=\"keyword\">new</span> tryFile</span><br><span class=\"line\">fileObj.writeMapToFile</span><br></pre></td></tr></table></figure></p>\n<p>That’s all! 关于闭包的示例晚上回家补上~~~ 工作鸟</p>\n<p>参考链接：<br><a href=\"http://www.tutorialspoint.com/scala/scala_file_io.htm\" target=\"_blank\" rel=\"noopener\">http://www.tutorialspoint.com/scala/scala_file_io.htm</a><br><a href=\"http://blog.csdn.net/oopsoom/article/details/23447317\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/oopsoom/article/details/23447317</a><br><a href=\"http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html\" target=\"_blank\" rel=\"noopener\">http://zhangjunhd.github.io/2013/12/22/scala-note7-file.html</a></p>"},{"title":"模块化 Xcode 工程","date":"2017-11-19T10:17:15.000Z","_content":"\n> 原文：[Modular Xcode projects](https://ppinera.es/2017/09/29/modular-xcode-projects.html)\n> 原作者 & Copyright [@pepibumur](http://twitter.com/pepibumur)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n使用 Xcode 构建模块化的工程就需要对工程结构以及其基础概念有很好的理解才行。<!-- more --> 我们平时不怎么关注工程结构本身，只有在工程逐渐变大，要添加更多依赖的时候才会注意的到。而即使到了这个时候，我们大多数的工程都会使用  [CocoaPods](https://cocoapods.org/) 来设置那些依赖项，或者 [Carthage](https://github.com/carthage), 后者虽然没有帮我们做依赖性的设置，但是使得我们会更容易的，通过在工程的 build phase 选项中添加一些内容，达到同样的目的。当配置项越来越复杂，我们就很容易产生困惑，这是因为我们并没有完全掌握 Xcode 工程中所涉及的所有元素。我经常被问到的问题如下：\n\n* 我能不能在工程里同时使用 Carthage，Cocoapods 以及自己个人的依赖设置？\n* 我添加了依赖，但是当模拟器打开 App 的时候 Crash 了。\n* 为什么我需要只在某些 targets 里嵌入 framework？\n* 我的 framework 应该是静态的还是动态的？\n\n在这篇博文中，我会引导你遍历 Xcode Project 中的各个元素，指导你如何通过改变这些元素来模块化你的设置项。我希望下次你遇到上面这些问题的时候，你不需要再花大量时间取 Stack Overflow 上查这些确定的答案。\n\n### Elements ⚒\n\n#### Target\n\n工程（Projects）都是由多个更小的叫做 target 的单元组成的。这些 target 包含编译特定平台产品，比如 frameworks, libraries, apps, testing bundles, extensions 等所需要的配置。 你可以在[这里](https://github.com/xcodeswift/xcproj/blob/master/Sources/xcproj/PBXProductType.swift)看到 target 所有可用的类型。 Target 可以相互依赖，当一个 target A 依赖另外一个 target B 的时候，target B 就会被先构建出来以便 target A 使用其产出。而 target 的配置项会涉及以下几个地方：\n\n* **Info.plist 文件**: 该文件包含产出特定的设置项，比如 版本、App 的名字或者 App 的类型，你可以在[这里](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html)详细了解这个文件。\n* **Entitlements**: 其指定了应用的能力。如果在授权文件中指定的能力和开发者平台上设置的无法匹配，签名过程就会出错。\n* **Build settings**: 如其名字所描述的那样，这些都是构建 target 所必要的设置项。构建设置项要么在 target 自身定义或者在 `xcconfig` 文件中定义。一个 target 的配置项可以继承而来，首先是配置文件本身，其次是 target 的配置项，最后是 project 配置项。\n* **Build phases**: 构建流水线由 build phase 定义。当一个 target 被创建出来之后，其包含默认的构建阶段（包含 *构建源码、拷贝资源等*），但是你可以自行添加你需要的。举个例子，这些阶段里，有个 shell script phase 允许你在构建过程中执行一些脚本。这些脚本可以读取 Xcode 暴露出来的那些[构建参数](http://ppinera.es/2017/09/15/modular-xcode-projects.html)。\n\n基于`.xcconfig`文件的可组合性以及其可重用性的考虑，强烈建议你在这些文件中定义你那些编译设置。Target 的配置，比如 build setting 、build phase 等的变更都体现在 `.pbxproj` 文件中，这个文件是一种特殊的plist 文件，当我们使用 Git 管理我们的工程的时候，这个文件很容易出现冲突。当然，更新 `pbxproj` 文件中配置的最简单方式就是使用 Xcode，其了解如何从这些文件中读取配置和向其中写入配置。如果你对不使用 Xcode 更新 `pbxproj` 文件感兴趣的话，你可以试试 [Xcodeproj](https://github.com/cocoapods/xcodeproj) 或者 [xcproj](https://github.com/swift-xcode/xcodeproj)。\n\n构建这些 target 的输出要么是比如 app，extension 或者测试文件等 **bundles**，要么就是**intermediate products** ，例如 library 或者那些封装了代码和资源文件用来给别的 target 使用的 framework。这些 Target 的输出内容你可以在工程文件中的 `Products` 的 Group 下找到，如果有红色的文件引用表示没有 product 输出，很大可能是你还没有构建过这个 target。\n\n\n#### Scheme\n\nXcode 工程中另外一个要素是 scheme。 一个工程可以包含多个 scheme，他们可以被共享，作为工程的一部分被人们使用。这些 scheme 指定了 Xcode 中每个具体动作的配置，这些动作包括：**run**，**test**，**profile**，**analyze** 以及 **archive**。 细的来讲，可以指定哪些 target 需要被构建，以什么顺序构建甚至针对每一种动作指定不同的配置。\n\n关于 scheme 的编译配置有一些东西要讲。当我们指定针对哪些动作构建哪些 target 的时候，在下面两种情况下，我们不需要指定每个 target 的依赖项：\n\n1. 如果依赖项是是相同 project 中的一部分，并且已经在 `Target dependencies` 的 `Build Phases` 中定义过；\n2. 开启了 `Find implicit dependencies`。\n\n第 2 点中开启的标识，构建过程必须找到 target 的依赖项，并且先行构建。另外，如果你开启了`Parallelize build` 的话，一旦 target 相互之间没有依赖的话，就能够并行构建，因而会节省一部分时间。\n\n一个有问题的构建配置会导致你编译 target 的时候出现错误，比如 `Framework XXX not found`。如果你曾经或者当前遇到了类似的报错，检查一下在构建每个 scheme 的时候，你的 target 的所有依赖是否已经被构建。\n\nscheme 文件定义是存储在 `Project.xcodeproj/xcshareddata/xcodeproj.xcscheme` 路径下的一个标准的 XML 文本，因此你可以很容易的使用任意 XML 编辑器来修改它。\n\n#### Workspace\n\n多个 project 文件被组合成一个 workspace。当 project 被添加到一个 workspace 的时候：\n\n1. 其 schemes 会出现在 workspace 的 scheme 列表中；\n2. project 彼此可以产生依赖关系，后文会讲到。\n\n和 scheme 类似，workspace 也是普通的 XML 文件，修改起来很方便。\n\n![工程构建组合中的每一个基础元素： target、scheme、project 以及 workspace 是如何被组织起来的](https://i.imgur.com/wGXI5fy.png)\n\n\n#### Dependencies 🌱\n\n每个 target 都可以有依赖，这些依赖是 target 需要链接的那些 framework 以及 library等，其包含了能够被 target 共享的源代码以及资源。这些依赖项可以被静态或者动态的链接。\n\n**静态链接：**\n\n* 发生在编译阶段；\n* 库（Library）中的代码文件会被包含到应用的二进制文件中（会增大应用的二进制大小）；\n* 库使用 .a 作为文件后缀，其来自 (ar)chive file3 type；\n* 如果相同的库被多次链接，编译器会由于 duplicated symbols 编译失败。\n\n\n**动态链接：**\n\n* 模块在应用启动或者运行过程中被加载；\n* 应用或者扩展的 target 都可以共享相同的动态库（仅被复制一份）\n\n关于 framework 和 library（无论是静态链接还是动态链接）的区别在于前者可以在相同的 bundle 中包含多个版本，还可以包含额外的资源文件。\n\n> 一个 Library 是一个 .a 文件，其来源于 归档（archive）文件类型。一个单一的归档文件仅支持单一的架构。如果需要打包多个架构，则需要将其打包成胖Match-O二进制（**fat Match-O binary**），该二进制文件是一种容器格式，其将支持不同架构的Mach-O打包在一起。如果我们想生成、修改一个胖二进制文件或者从其中提取某个特定架构的库的话，可以使用命令行工具`lipo`。\n\n你可以在[这里](https://pewpewthespells.com/blog/static_and_dynamic_libraries.html)了解更多关于 frameworks/libraries 以及 static/dynamic 的内容。\n\n\n![动态链接和静态链接的区别](https://i.imgur.com/qKHdwhp.png)\n\n应用的依赖项分为预编译过的（**precompiled**）和未经编译过（**not-compiled**）两类。\n\n##### Precompiled dependencies\n\n[Carthage](https://github.com/carthage) 是这类型依赖的典型代表。某些 SDK，比如 [Firebase](https://github.com/CocoaPods/Specs/blob/master/Specs/0/3/5/Firebase/4.2.0/Firebase.podspec.json#L23) 就是作为编译过的依赖来发布的。当预编译过的依赖是库（library）的时候，这些依赖就包含 `.a` 的库及一个公共头文件，包含了该库所暴露出的公共接口。当这些依赖是 framework 的时候，这些依赖就以包含了库和资源文件的 `.framework` 文件发布。\n\n当我们的 app 依赖的是预编译依赖的时候，很重要的一点是，这些依赖也是依照我们 app 所构建架构来构建出来的。一旦其中缺失某个架构的代码，我们就会在编译 app 的时候收到编译错误。一会儿后文会看到，Carthage 使用 lipo 工具生成那些包含模拟器或者真机所必须的架构的 framework 的，同时根据构建配置来剔除掉那些不需要的 framework。\n\n\n##### Non-compiled dependencies\n\n[CocoaPods](https://cocoapods.org/) 是该种类型的典型代表。依赖项被定义在我们要链接的 frameworks/libraries 的 target 中。这里有多种方式在 Xcode 中指定我们的 target 依赖其他 target 的输出。\n\n* **如果这些 target 分布在同一个 project 中**，你可以在 Build Phase 的*Target dependencies* 中指定依赖。 Xcode 会在编译该 target 的时候首先编译这些指定的依赖项；\n* **如果这些 target 分布在不同的 project 中**，我们就可以使用*Scheme*来定义这些 target 之间的依赖关系。在 scheme 的 Build 部分，我们可以定义要被构建的 target 以及以什么顺序构建（基于他们之间的依赖关系）。如果你开启了*Find implicit dependencies*标识，Xcode 能够根据每个 target 的输入输出来猜测依赖。如果 scheme 中有错误配置，你就会得到类似`xxxx.framework not found`的错误。如果在 framework 之间出现了循环依赖也会报类似的错误。\n\n> 关于依赖项和配置项有个需要注意的地方：所有依赖项的配置一定要完全匹配。如果你在使用 Alpha 配置项构建你的 app，但是其依赖项中但凡出现了不包含这种配置，编译过程都会因为找不到某个 framework 而失败。当这种情况发生的时候，Xcode 不会编译该 framework 但是不报任何错误。\n\n![各个依赖项是如何基于 project 的配置得到编译的](https://i.imgur.com/TrXKUTJ.png)\n\n\n### Linking with Xcode\n\nTarget 本身可以链接其他 target 的输出，我们可以使用 Xcode 中的工具，比如 scheme 或者 target dependencies 来指定依赖，但是，我们是如何通过定义这些依赖的链接关系来将它们融为一体的？\n\n#### 1\\. 动态或者静态链接 libraries 和 frameworks\n\n我们可以通过以下的方式定义链接：\n\n* **一个构建阶段（build phase）：**，在所有可用的 build phase 中，有一个是定义链接的，*Link Binary With Libraries*。你可以在这里添加某个 target 的依赖项，这些依赖项可以来自于同一个 project，也可以来自同一个 workspace 中的其他 project。这个 build phase 被 Xcode 用来识别 target 被构建时所需的依赖项；\n* **编译器构建设置：**一个 build phase 中所定义的内容会被转换成编译器参数。其中某些内容你也可以通过定义编译设置项做到：\n* `FRAMEWORK_SEARCH_PATHS`：定义编译器所链接的 framework 所在路径\n* `LIBRARY_SEARCH_PATHS`：定义编译器所链接的 library 所在路径\n* `OTHER_LDFLAGS` *(Other Linker Flags)*：我们可以使用`-l`参数指定链接的 library，比如`-l\"1PasswordExtension\" -l\"Adjust\"`。如果需要链接一个 framework，就需要使用`-framework`参数，比如：`-framework \"GoogleSignIn\" -framework \"HockeySDK\"`。如果我们尝试链接一个无法在上方指定路径中找到的 framework 或者 library 的话，编译过程就会失败。\n\n\n#### 2\\. 暴露库的头文件\n\nLibrary 的头文件需要暴露给依赖该库的 targe。为了做到这个，有一个编译设置项：`HEADER_SEARCH_PATHS`用来指定头文件所在路径。如果我们链接某个库，但是忘记暴露该库的头文件，编译过程就会因为找不到其头文件而失败。\n\n#### 3\\. 将 Framework 嵌入到应用中\n\nApp 的 target 链接动态 framework，需要把这些依赖项复制到应用的 bundle 中。这个过程被称作 **framework embedding**。为了达到这个目的，我们需要使用 Xcode 的**Copy Files Phase**，其拷贝 这些 framework 到 `Frameworks`目录中。不仅仅需要把这些直接依赖项嵌入应用中，还包括直接依赖所依赖的项目。如果缺少任意的 framework，当我们尝试打开 app 的时候都会抛出错误。\n\n* * *\n\n\n### 案例学习 👨‍💻\n\n在这个部分，我们会分析以下 Cocopods 和 Carthage 是如何贯彻上面这些概念来管理你的工程依赖的。\n\n#### CocoaPods\n\n![CocoaPods](https://i.imgur.com/yYLLsbQ.png)\n\n\nCocoapods 解析你的工程依赖，并将它们融合到你的工程中。虽然直接修改你的工程配置是不太推荐的，但是它从最初的版本已经有了很大的提升，用这种方式，我们几乎不需要对 project 做很多改变。那么它底层到底是怎么做到的？\n\n* 它创建一个工程（project）*(*`*Pods.xcodeproj*`*)* ，其包含了所有的依赖项，每个依赖项以 target 的形式存在。每个 target 各自编译需要被链接到 app 中的依赖项；\n* 它创建一个额外的 target，其依赖于其他所有的依赖项。该 target 是一个 umbrella target，用来触发其他 target 的编译。这样做也最小程度的减少了你的 project 中所需要的改变。通过链接这个 target，Xcode 会先编译其所有依赖项，然后是你的 app；\n* 它创建了一个 workspace，包含了你的 project 以及 Pods project；\n* Frameworks 和 libraries 使用`.xcconfig`文件链接。这些文件被加到了你的 project 群组中，并且被设置为你 project 中 target 的配置项；\n* 嵌入过程是通过一个构建阶段脚本（build phase script）来做到的。类似的，所有的 framework 所需要的资源也通过一个构建阶段（build phase）来完成。\n\n下面这张图展示了整个设置过程：\n\n![CocoaPods 如何将依赖项融合到整个 Project 中](https://i.imgur.com/UARMUhl.png)\n\n\n#### Carthage\n\n![Carthage](https://i.imgur.com/IUXCxhQ.png)\n\n\nCarthage 的方式和 CocoaPods 比起来大不同。除了依赖项的解析，该工具是还一种去中心化的模式，其生成那些需要被链接或者嵌入到 app 的依赖项的预编译版本。\n\n* Carthage 解析依赖项，并且编译它们生成你能够链接到 app 中的动态 framework，或者为了调试所需要的符号。这些 framework 是 fat framework，支持模拟器和真机的架构；\n* 这些 framework 被用户使用 *Link Binary With Libraries* 的构建阶段（build phase）手动的链接；\n* 嵌入过程使用 Carthage 提供的脚本完成。这个脚本会剔除那些我们正在构建目标所不必要的架构版本；\n* 使用同样的脚本，复制符号到合适的文件夹，使得调试能够正常进行。\n\n\n![Carthage 是如何生成依赖项的 framework 和 symbol](https://i.imgur.com/HXqtoDl.png)\n\n\n### References\n\n* [Framework vs Library](http://www.knowstack.com/framework-vs-library-cocoa-ios/)\n* [Static and dynamic libraries](https://pewpewthespells.com/blog/static_and_dynamic_libraries.html)\n* [Xcode Build Settings Reference](https://pewpewthespells.com/blog/buildsettings.html)\n* [Embedding Frameworks in an App](https://developer.apple.com/library/content/technotes/tn2435/_index.html)\n* [Introduction to Framework Programming Guide](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html)\n* [Skippy Copy Phase Strip](https://www.cocoanetics.com/2015/04/skipping-copy-phase-strip/)\n\n\n\n","source":"_posts/Modular-Xcode-projects.md","raw":"title: 模块化 Xcode 工程\ndate: 2017-11-19 18:17:15\ncategories: 翻译\ntags: [iOS,XCode,CocoaPods,Carthage]\n\n---\n\n> 原文：[Modular Xcode projects](https://ppinera.es/2017/09/29/modular-xcode-projects.html)\n> 原作者 & Copyright [@pepibumur](http://twitter.com/pepibumur)\n> 翻译：[@OgreMergO](https://twitter.com/OgreMergO)\n\n\n使用 Xcode 构建模块化的工程就需要对工程结构以及其基础概念有很好的理解才行。<!-- more --> 我们平时不怎么关注工程结构本身，只有在工程逐渐变大，要添加更多依赖的时候才会注意的到。而即使到了这个时候，我们大多数的工程都会使用  [CocoaPods](https://cocoapods.org/) 来设置那些依赖项，或者 [Carthage](https://github.com/carthage), 后者虽然没有帮我们做依赖性的设置，但是使得我们会更容易的，通过在工程的 build phase 选项中添加一些内容，达到同样的目的。当配置项越来越复杂，我们就很容易产生困惑，这是因为我们并没有完全掌握 Xcode 工程中所涉及的所有元素。我经常被问到的问题如下：\n\n* 我能不能在工程里同时使用 Carthage，Cocoapods 以及自己个人的依赖设置？\n* 我添加了依赖，但是当模拟器打开 App 的时候 Crash 了。\n* 为什么我需要只在某些 targets 里嵌入 framework？\n* 我的 framework 应该是静态的还是动态的？\n\n在这篇博文中，我会引导你遍历 Xcode Project 中的各个元素，指导你如何通过改变这些元素来模块化你的设置项。我希望下次你遇到上面这些问题的时候，你不需要再花大量时间取 Stack Overflow 上查这些确定的答案。\n\n### Elements ⚒\n\n#### Target\n\n工程（Projects）都是由多个更小的叫做 target 的单元组成的。这些 target 包含编译特定平台产品，比如 frameworks, libraries, apps, testing bundles, extensions 等所需要的配置。 你可以在[这里](https://github.com/xcodeswift/xcproj/blob/master/Sources/xcproj/PBXProductType.swift)看到 target 所有可用的类型。 Target 可以相互依赖，当一个 target A 依赖另外一个 target B 的时候，target B 就会被先构建出来以便 target A 使用其产出。而 target 的配置项会涉及以下几个地方：\n\n* **Info.plist 文件**: 该文件包含产出特定的设置项，比如 版本、App 的名字或者 App 的类型，你可以在[这里](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html)详细了解这个文件。\n* **Entitlements**: 其指定了应用的能力。如果在授权文件中指定的能力和开发者平台上设置的无法匹配，签名过程就会出错。\n* **Build settings**: 如其名字所描述的那样，这些都是构建 target 所必要的设置项。构建设置项要么在 target 自身定义或者在 `xcconfig` 文件中定义。一个 target 的配置项可以继承而来，首先是配置文件本身，其次是 target 的配置项，最后是 project 配置项。\n* **Build phases**: 构建流水线由 build phase 定义。当一个 target 被创建出来之后，其包含默认的构建阶段（包含 *构建源码、拷贝资源等*），但是你可以自行添加你需要的。举个例子，这些阶段里，有个 shell script phase 允许你在构建过程中执行一些脚本。这些脚本可以读取 Xcode 暴露出来的那些[构建参数](http://ppinera.es/2017/09/15/modular-xcode-projects.html)。\n\n基于`.xcconfig`文件的可组合性以及其可重用性的考虑，强烈建议你在这些文件中定义你那些编译设置。Target 的配置，比如 build setting 、build phase 等的变更都体现在 `.pbxproj` 文件中，这个文件是一种特殊的plist 文件，当我们使用 Git 管理我们的工程的时候，这个文件很容易出现冲突。当然，更新 `pbxproj` 文件中配置的最简单方式就是使用 Xcode，其了解如何从这些文件中读取配置和向其中写入配置。如果你对不使用 Xcode 更新 `pbxproj` 文件感兴趣的话，你可以试试 [Xcodeproj](https://github.com/cocoapods/xcodeproj) 或者 [xcproj](https://github.com/swift-xcode/xcodeproj)。\n\n构建这些 target 的输出要么是比如 app，extension 或者测试文件等 **bundles**，要么就是**intermediate products** ，例如 library 或者那些封装了代码和资源文件用来给别的 target 使用的 framework。这些 Target 的输出内容你可以在工程文件中的 `Products` 的 Group 下找到，如果有红色的文件引用表示没有 product 输出，很大可能是你还没有构建过这个 target。\n\n\n#### Scheme\n\nXcode 工程中另外一个要素是 scheme。 一个工程可以包含多个 scheme，他们可以被共享，作为工程的一部分被人们使用。这些 scheme 指定了 Xcode 中每个具体动作的配置，这些动作包括：**run**，**test**，**profile**，**analyze** 以及 **archive**。 细的来讲，可以指定哪些 target 需要被构建，以什么顺序构建甚至针对每一种动作指定不同的配置。\n\n关于 scheme 的编译配置有一些东西要讲。当我们指定针对哪些动作构建哪些 target 的时候，在下面两种情况下，我们不需要指定每个 target 的依赖项：\n\n1. 如果依赖项是是相同 project 中的一部分，并且已经在 `Target dependencies` 的 `Build Phases` 中定义过；\n2. 开启了 `Find implicit dependencies`。\n\n第 2 点中开启的标识，构建过程必须找到 target 的依赖项，并且先行构建。另外，如果你开启了`Parallelize build` 的话，一旦 target 相互之间没有依赖的话，就能够并行构建，因而会节省一部分时间。\n\n一个有问题的构建配置会导致你编译 target 的时候出现错误，比如 `Framework XXX not found`。如果你曾经或者当前遇到了类似的报错，检查一下在构建每个 scheme 的时候，你的 target 的所有依赖是否已经被构建。\n\nscheme 文件定义是存储在 `Project.xcodeproj/xcshareddata/xcodeproj.xcscheme` 路径下的一个标准的 XML 文本，因此你可以很容易的使用任意 XML 编辑器来修改它。\n\n#### Workspace\n\n多个 project 文件被组合成一个 workspace。当 project 被添加到一个 workspace 的时候：\n\n1. 其 schemes 会出现在 workspace 的 scheme 列表中；\n2. project 彼此可以产生依赖关系，后文会讲到。\n\n和 scheme 类似，workspace 也是普通的 XML 文件，修改起来很方便。\n\n![工程构建组合中的每一个基础元素： target、scheme、project 以及 workspace 是如何被组织起来的](https://i.imgur.com/wGXI5fy.png)\n\n\n#### Dependencies 🌱\n\n每个 target 都可以有依赖，这些依赖是 target 需要链接的那些 framework 以及 library等，其包含了能够被 target 共享的源代码以及资源。这些依赖项可以被静态或者动态的链接。\n\n**静态链接：**\n\n* 发生在编译阶段；\n* 库（Library）中的代码文件会被包含到应用的二进制文件中（会增大应用的二进制大小）；\n* 库使用 .a 作为文件后缀，其来自 (ar)chive file3 type；\n* 如果相同的库被多次链接，编译器会由于 duplicated symbols 编译失败。\n\n\n**动态链接：**\n\n* 模块在应用启动或者运行过程中被加载；\n* 应用或者扩展的 target 都可以共享相同的动态库（仅被复制一份）\n\n关于 framework 和 library（无论是静态链接还是动态链接）的区别在于前者可以在相同的 bundle 中包含多个版本，还可以包含额外的资源文件。\n\n> 一个 Library 是一个 .a 文件，其来源于 归档（archive）文件类型。一个单一的归档文件仅支持单一的架构。如果需要打包多个架构，则需要将其打包成胖Match-O二进制（**fat Match-O binary**），该二进制文件是一种容器格式，其将支持不同架构的Mach-O打包在一起。如果我们想生成、修改一个胖二进制文件或者从其中提取某个特定架构的库的话，可以使用命令行工具`lipo`。\n\n你可以在[这里](https://pewpewthespells.com/blog/static_and_dynamic_libraries.html)了解更多关于 frameworks/libraries 以及 static/dynamic 的内容。\n\n\n![动态链接和静态链接的区别](https://i.imgur.com/qKHdwhp.png)\n\n应用的依赖项分为预编译过的（**precompiled**）和未经编译过（**not-compiled**）两类。\n\n##### Precompiled dependencies\n\n[Carthage](https://github.com/carthage) 是这类型依赖的典型代表。某些 SDK，比如 [Firebase](https://github.com/CocoaPods/Specs/blob/master/Specs/0/3/5/Firebase/4.2.0/Firebase.podspec.json#L23) 就是作为编译过的依赖来发布的。当预编译过的依赖是库（library）的时候，这些依赖就包含 `.a` 的库及一个公共头文件，包含了该库所暴露出的公共接口。当这些依赖是 framework 的时候，这些依赖就以包含了库和资源文件的 `.framework` 文件发布。\n\n当我们的 app 依赖的是预编译依赖的时候，很重要的一点是，这些依赖也是依照我们 app 所构建架构来构建出来的。一旦其中缺失某个架构的代码，我们就会在编译 app 的时候收到编译错误。一会儿后文会看到，Carthage 使用 lipo 工具生成那些包含模拟器或者真机所必须的架构的 framework 的，同时根据构建配置来剔除掉那些不需要的 framework。\n\n\n##### Non-compiled dependencies\n\n[CocoaPods](https://cocoapods.org/) 是该种类型的典型代表。依赖项被定义在我们要链接的 frameworks/libraries 的 target 中。这里有多种方式在 Xcode 中指定我们的 target 依赖其他 target 的输出。\n\n* **如果这些 target 分布在同一个 project 中**，你可以在 Build Phase 的*Target dependencies* 中指定依赖。 Xcode 会在编译该 target 的时候首先编译这些指定的依赖项；\n* **如果这些 target 分布在不同的 project 中**，我们就可以使用*Scheme*来定义这些 target 之间的依赖关系。在 scheme 的 Build 部分，我们可以定义要被构建的 target 以及以什么顺序构建（基于他们之间的依赖关系）。如果你开启了*Find implicit dependencies*标识，Xcode 能够根据每个 target 的输入输出来猜测依赖。如果 scheme 中有错误配置，你就会得到类似`xxxx.framework not found`的错误。如果在 framework 之间出现了循环依赖也会报类似的错误。\n\n> 关于依赖项和配置项有个需要注意的地方：所有依赖项的配置一定要完全匹配。如果你在使用 Alpha 配置项构建你的 app，但是其依赖项中但凡出现了不包含这种配置，编译过程都会因为找不到某个 framework 而失败。当这种情况发生的时候，Xcode 不会编译该 framework 但是不报任何错误。\n\n![各个依赖项是如何基于 project 的配置得到编译的](https://i.imgur.com/TrXKUTJ.png)\n\n\n### Linking with Xcode\n\nTarget 本身可以链接其他 target 的输出，我们可以使用 Xcode 中的工具，比如 scheme 或者 target dependencies 来指定依赖，但是，我们是如何通过定义这些依赖的链接关系来将它们融为一体的？\n\n#### 1\\. 动态或者静态链接 libraries 和 frameworks\n\n我们可以通过以下的方式定义链接：\n\n* **一个构建阶段（build phase）：**，在所有可用的 build phase 中，有一个是定义链接的，*Link Binary With Libraries*。你可以在这里添加某个 target 的依赖项，这些依赖项可以来自于同一个 project，也可以来自同一个 workspace 中的其他 project。这个 build phase 被 Xcode 用来识别 target 被构建时所需的依赖项；\n* **编译器构建设置：**一个 build phase 中所定义的内容会被转换成编译器参数。其中某些内容你也可以通过定义编译设置项做到：\n* `FRAMEWORK_SEARCH_PATHS`：定义编译器所链接的 framework 所在路径\n* `LIBRARY_SEARCH_PATHS`：定义编译器所链接的 library 所在路径\n* `OTHER_LDFLAGS` *(Other Linker Flags)*：我们可以使用`-l`参数指定链接的 library，比如`-l\"1PasswordExtension\" -l\"Adjust\"`。如果需要链接一个 framework，就需要使用`-framework`参数，比如：`-framework \"GoogleSignIn\" -framework \"HockeySDK\"`。如果我们尝试链接一个无法在上方指定路径中找到的 framework 或者 library 的话，编译过程就会失败。\n\n\n#### 2\\. 暴露库的头文件\n\nLibrary 的头文件需要暴露给依赖该库的 targe。为了做到这个，有一个编译设置项：`HEADER_SEARCH_PATHS`用来指定头文件所在路径。如果我们链接某个库，但是忘记暴露该库的头文件，编译过程就会因为找不到其头文件而失败。\n\n#### 3\\. 将 Framework 嵌入到应用中\n\nApp 的 target 链接动态 framework，需要把这些依赖项复制到应用的 bundle 中。这个过程被称作 **framework embedding**。为了达到这个目的，我们需要使用 Xcode 的**Copy Files Phase**，其拷贝 这些 framework 到 `Frameworks`目录中。不仅仅需要把这些直接依赖项嵌入应用中，还包括直接依赖所依赖的项目。如果缺少任意的 framework，当我们尝试打开 app 的时候都会抛出错误。\n\n* * *\n\n\n### 案例学习 👨‍💻\n\n在这个部分，我们会分析以下 Cocopods 和 Carthage 是如何贯彻上面这些概念来管理你的工程依赖的。\n\n#### CocoaPods\n\n![CocoaPods](https://i.imgur.com/yYLLsbQ.png)\n\n\nCocoapods 解析你的工程依赖，并将它们融合到你的工程中。虽然直接修改你的工程配置是不太推荐的，但是它从最初的版本已经有了很大的提升，用这种方式，我们几乎不需要对 project 做很多改变。那么它底层到底是怎么做到的？\n\n* 它创建一个工程（project）*(*`*Pods.xcodeproj*`*)* ，其包含了所有的依赖项，每个依赖项以 target 的形式存在。每个 target 各自编译需要被链接到 app 中的依赖项；\n* 它创建一个额外的 target，其依赖于其他所有的依赖项。该 target 是一个 umbrella target，用来触发其他 target 的编译。这样做也最小程度的减少了你的 project 中所需要的改变。通过链接这个 target，Xcode 会先编译其所有依赖项，然后是你的 app；\n* 它创建了一个 workspace，包含了你的 project 以及 Pods project；\n* Frameworks 和 libraries 使用`.xcconfig`文件链接。这些文件被加到了你的 project 群组中，并且被设置为你 project 中 target 的配置项；\n* 嵌入过程是通过一个构建阶段脚本（build phase script）来做到的。类似的，所有的 framework 所需要的资源也通过一个构建阶段（build phase）来完成。\n\n下面这张图展示了整个设置过程：\n\n![CocoaPods 如何将依赖项融合到整个 Project 中](https://i.imgur.com/UARMUhl.png)\n\n\n#### Carthage\n\n![Carthage](https://i.imgur.com/IUXCxhQ.png)\n\n\nCarthage 的方式和 CocoaPods 比起来大不同。除了依赖项的解析，该工具是还一种去中心化的模式，其生成那些需要被链接或者嵌入到 app 的依赖项的预编译版本。\n\n* Carthage 解析依赖项，并且编译它们生成你能够链接到 app 中的动态 framework，或者为了调试所需要的符号。这些 framework 是 fat framework，支持模拟器和真机的架构；\n* 这些 framework 被用户使用 *Link Binary With Libraries* 的构建阶段（build phase）手动的链接；\n* 嵌入过程使用 Carthage 提供的脚本完成。这个脚本会剔除那些我们正在构建目标所不必要的架构版本；\n* 使用同样的脚本，复制符号到合适的文件夹，使得调试能够正常进行。\n\n\n![Carthage 是如何生成依赖项的 framework 和 symbol](https://i.imgur.com/HXqtoDl.png)\n\n\n### References\n\n* [Framework vs Library](http://www.knowstack.com/framework-vs-library-cocoa-ios/)\n* [Static and dynamic libraries](https://pewpewthespells.com/blog/static_and_dynamic_libraries.html)\n* [Xcode Build Settings Reference](https://pewpewthespells.com/blog/buildsettings.html)\n* [Embedding Frameworks in an App](https://developer.apple.com/library/content/technotes/tn2435/_index.html)\n* [Introduction to Framework Programming Guide](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html)\n* [Skippy Copy Phase Strip](https://www.cocoanetics.com/2015/04/skipping-copy-phase-strip/)\n\n\n\n","slug":"Modular-Xcode-projects","published":1,"updated":"2018-10-07T11:19:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftcx006179poq5um46oo","content":"<blockquote>\n<p>原文：<a href=\"https://ppinera.es/2017/09/29/modular-xcode-projects.html\" target=\"_blank\" rel=\"noopener\">Modular Xcode projects</a><br>原作者 &amp; Copyright <a href=\"http://twitter.com/pepibumur\" target=\"_blank\" rel=\"noopener\">@pepibumur</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>使用 Xcode 构建模块化的工程就需要对工程结构以及其基础概念有很好的理解才行。<a id=\"more\"></a> 我们平时不怎么关注工程结构本身，只有在工程逐渐变大，要添加更多依赖的时候才会注意的到。而即使到了这个时候，我们大多数的工程都会使用  <a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"noopener\">CocoaPods</a> 来设置那些依赖项，或者 <a href=\"https://github.com/carthage\" target=\"_blank\" rel=\"noopener\">Carthage</a>, 后者虽然没有帮我们做依赖性的设置，但是使得我们会更容易的，通过在工程的 build phase 选项中添加一些内容，达到同样的目的。当配置项越来越复杂，我们就很容易产生困惑，这是因为我们并没有完全掌握 Xcode 工程中所涉及的所有元素。我经常被问到的问题如下：</p>\n<ul>\n<li>我能不能在工程里同时使用 Carthage，Cocoapods 以及自己个人的依赖设置？</li>\n<li>我添加了依赖，但是当模拟器打开 App 的时候 Crash 了。</li>\n<li>为什么我需要只在某些 targets 里嵌入 framework？</li>\n<li>我的 framework 应该是静态的还是动态的？</li>\n</ul>\n<p>在这篇博文中，我会引导你遍历 Xcode Project 中的各个元素，指导你如何通过改变这些元素来模块化你的设置项。我希望下次你遇到上面这些问题的时候，你不需要再花大量时间取 Stack Overflow 上查这些确定的答案。</p>\n<h3 id=\"Elements-⚒\"><a href=\"#Elements-⚒\" class=\"headerlink\" title=\"Elements ⚒\"></a>Elements ⚒</h3><h4 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h4><p>工程（Projects）都是由多个更小的叫做 target 的单元组成的。这些 target 包含编译特定平台产品，比如 frameworks, libraries, apps, testing bundles, extensions 等所需要的配置。 你可以在<a href=\"https://github.com/xcodeswift/xcproj/blob/master/Sources/xcproj/PBXProductType.swift\" target=\"_blank\" rel=\"noopener\">这里</a>看到 target 所有可用的类型。 Target 可以相互依赖，当一个 target A 依赖另外一个 target B 的时候，target B 就会被先构建出来以便 target A 使用其产出。而 target 的配置项会涉及以下几个地方：</p>\n<ul>\n<li><strong>Info.plist 文件</strong>: 该文件包含产出特定的设置项，比如 版本、App 的名字或者 App 的类型，你可以在<a href=\"https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">这里</a>详细了解这个文件。</li>\n<li><strong>Entitlements</strong>: 其指定了应用的能力。如果在授权文件中指定的能力和开发者平台上设置的无法匹配，签名过程就会出错。</li>\n<li><strong>Build settings</strong>: 如其名字所描述的那样，这些都是构建 target 所必要的设置项。构建设置项要么在 target 自身定义或者在 <code>xcconfig</code> 文件中定义。一个 target 的配置项可以继承而来，首先是配置文件本身，其次是 target 的配置项，最后是 project 配置项。</li>\n<li><strong>Build phases</strong>: 构建流水线由 build phase 定义。当一个 target 被创建出来之后，其包含默认的构建阶段（包含 <em>构建源码、拷贝资源等</em>），但是你可以自行添加你需要的。举个例子，这些阶段里，有个 shell script phase 允许你在构建过程中执行一些脚本。这些脚本可以读取 Xcode 暴露出来的那些<a href=\"http://ppinera.es/2017/09/15/modular-xcode-projects.html\" target=\"_blank\" rel=\"noopener\">构建参数</a>。</li>\n</ul>\n<p>基于<code>.xcconfig</code>文件的可组合性以及其可重用性的考虑，强烈建议你在这些文件中定义你那些编译设置。Target 的配置，比如 build setting 、build phase 等的变更都体现在 <code>.pbxproj</code> 文件中，这个文件是一种特殊的plist 文件，当我们使用 Git 管理我们的工程的时候，这个文件很容易出现冲突。当然，更新 <code>pbxproj</code> 文件中配置的最简单方式就是使用 Xcode，其了解如何从这些文件中读取配置和向其中写入配置。如果你对不使用 Xcode 更新 <code>pbxproj</code> 文件感兴趣的话，你可以试试 <a href=\"https://github.com/cocoapods/xcodeproj\" target=\"_blank\" rel=\"noopener\">Xcodeproj</a> 或者 <a href=\"https://github.com/swift-xcode/xcodeproj\" target=\"_blank\" rel=\"noopener\">xcproj</a>。</p>\n<p>构建这些 target 的输出要么是比如 app，extension 或者测试文件等 <strong>bundles</strong>，要么就是<strong>intermediate products</strong> ，例如 library 或者那些封装了代码和资源文件用来给别的 target 使用的 framework。这些 Target 的输出内容你可以在工程文件中的 <code>Products</code> 的 Group 下找到，如果有红色的文件引用表示没有 product 输出，很大可能是你还没有构建过这个 target。</p>\n<h4 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h4><p>Xcode 工程中另外一个要素是 scheme。 一个工程可以包含多个 scheme，他们可以被共享，作为工程的一部分被人们使用。这些 scheme 指定了 Xcode 中每个具体动作的配置，这些动作包括：<strong>run</strong>，<strong>test</strong>，<strong>profile</strong>，<strong>analyze</strong> 以及 <strong>archive</strong>。 细的来讲，可以指定哪些 target 需要被构建，以什么顺序构建甚至针对每一种动作指定不同的配置。</p>\n<p>关于 scheme 的编译配置有一些东西要讲。当我们指定针对哪些动作构建哪些 target 的时候，在下面两种情况下，我们不需要指定每个 target 的依赖项：</p>\n<ol>\n<li>如果依赖项是是相同 project 中的一部分，并且已经在 <code>Target dependencies</code> 的 <code>Build Phases</code> 中定义过；</li>\n<li>开启了 <code>Find implicit dependencies</code>。</li>\n</ol>\n<p>第 2 点中开启的标识，构建过程必须找到 target 的依赖项，并且先行构建。另外，如果你开启了<code>Parallelize build</code> 的话，一旦 target 相互之间没有依赖的话，就能够并行构建，因而会节省一部分时间。</p>\n<p>一个有问题的构建配置会导致你编译 target 的时候出现错误，比如 <code>Framework XXX not found</code>。如果你曾经或者当前遇到了类似的报错，检查一下在构建每个 scheme 的时候，你的 target 的所有依赖是否已经被构建。</p>\n<p>scheme 文件定义是存储在 <code>Project.xcodeproj/xcshareddata/xcodeproj.xcscheme</code> 路径下的一个标准的 XML 文本，因此你可以很容易的使用任意 XML 编辑器来修改它。</p>\n<h4 id=\"Workspace\"><a href=\"#Workspace\" class=\"headerlink\" title=\"Workspace\"></a>Workspace</h4><p>多个 project 文件被组合成一个 workspace。当 project 被添加到一个 workspace 的时候：</p>\n<ol>\n<li>其 schemes 会出现在 workspace 的 scheme 列表中；</li>\n<li>project 彼此可以产生依赖关系，后文会讲到。</li>\n</ol>\n<p>和 scheme 类似，workspace 也是普通的 XML 文件，修改起来很方便。</p>\n<p><img src=\"https://i.imgur.com/wGXI5fy.png\" alt=\"工程构建组合中的每一个基础元素： target、scheme、project 以及 workspace 是如何被组织起来的\"></p>\n<h4 id=\"Dependencies-🌱\"><a href=\"#Dependencies-🌱\" class=\"headerlink\" title=\"Dependencies 🌱\"></a>Dependencies 🌱</h4><p>每个 target 都可以有依赖，这些依赖是 target 需要链接的那些 framework 以及 library等，其包含了能够被 target 共享的源代码以及资源。这些依赖项可以被静态或者动态的链接。</p>\n<p><strong>静态链接：</strong></p>\n<ul>\n<li>发生在编译阶段；</li>\n<li>库（Library）中的代码文件会被包含到应用的二进制文件中（会增大应用的二进制大小）；</li>\n<li>库使用 .a 作为文件后缀，其来自 (ar)chive file3 type；</li>\n<li>如果相同的库被多次链接，编译器会由于 duplicated symbols 编译失败。</li>\n</ul>\n<p><strong>动态链接：</strong></p>\n<ul>\n<li>模块在应用启动或者运行过程中被加载；</li>\n<li>应用或者扩展的 target 都可以共享相同的动态库（仅被复制一份）</li>\n</ul>\n<p>关于 framework 和 library（无论是静态链接还是动态链接）的区别在于前者可以在相同的 bundle 中包含多个版本，还可以包含额外的资源文件。</p>\n<blockquote>\n<p>一个 Library 是一个 .a 文件，其来源于 归档（archive）文件类型。一个单一的归档文件仅支持单一的架构。如果需要打包多个架构，则需要将其打包成胖Match-O二进制（<strong>fat Match-O binary</strong>），该二进制文件是一种容器格式，其将支持不同架构的Mach-O打包在一起。如果我们想生成、修改一个胖二进制文件或者从其中提取某个特定架构的库的话，可以使用命令行工具<code>lipo</code>。</p>\n</blockquote>\n<p>你可以在<a href=\"https://pewpewthespells.com/blog/static_and_dynamic_libraries.html\" target=\"_blank\" rel=\"noopener\">这里</a>了解更多关于 frameworks/libraries 以及 static/dynamic 的内容。</p>\n<p><img src=\"https://i.imgur.com/qKHdwhp.png\" alt=\"动态链接和静态链接的区别\"></p>\n<p>应用的依赖项分为预编译过的（<strong>precompiled</strong>）和未经编译过（<strong>not-compiled</strong>）两类。</p>\n<h5 id=\"Precompiled-dependencies\"><a href=\"#Precompiled-dependencies\" class=\"headerlink\" title=\"Precompiled dependencies\"></a>Precompiled dependencies</h5><p><a href=\"https://github.com/carthage\" target=\"_blank\" rel=\"noopener\">Carthage</a> 是这类型依赖的典型代表。某些 SDK，比如 <a href=\"https://github.com/CocoaPods/Specs/blob/master/Specs/0/3/5/Firebase/4.2.0/Firebase.podspec.json#L23\" target=\"_blank\" rel=\"noopener\">Firebase</a> 就是作为编译过的依赖来发布的。当预编译过的依赖是库（library）的时候，这些依赖就包含 <code>.a</code> 的库及一个公共头文件，包含了该库所暴露出的公共接口。当这些依赖是 framework 的时候，这些依赖就以包含了库和资源文件的 <code>.framework</code> 文件发布。</p>\n<p>当我们的 app 依赖的是预编译依赖的时候，很重要的一点是，这些依赖也是依照我们 app 所构建架构来构建出来的。一旦其中缺失某个架构的代码，我们就会在编译 app 的时候收到编译错误。一会儿后文会看到，Carthage 使用 lipo 工具生成那些包含模拟器或者真机所必须的架构的 framework 的，同时根据构建配置来剔除掉那些不需要的 framework。</p>\n<h5 id=\"Non-compiled-dependencies\"><a href=\"#Non-compiled-dependencies\" class=\"headerlink\" title=\"Non-compiled dependencies\"></a>Non-compiled dependencies</h5><p><a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"noopener\">CocoaPods</a> 是该种类型的典型代表。依赖项被定义在我们要链接的 frameworks/libraries 的 target 中。这里有多种方式在 Xcode 中指定我们的 target 依赖其他 target 的输出。</p>\n<ul>\n<li><strong>如果这些 target 分布在同一个 project 中</strong>，你可以在 Build Phase 的<em>Target dependencies</em> 中指定依赖。 Xcode 会在编译该 target 的时候首先编译这些指定的依赖项；</li>\n<li><strong>如果这些 target 分布在不同的 project 中</strong>，我们就可以使用<em>Scheme</em>来定义这些 target 之间的依赖关系。在 scheme 的 Build 部分，我们可以定义要被构建的 target 以及以什么顺序构建（基于他们之间的依赖关系）。如果你开启了<em>Find implicit dependencies</em>标识，Xcode 能够根据每个 target 的输入输出来猜测依赖。如果 scheme 中有错误配置，你就会得到类似<code>xxxx.framework not found</code>的错误。如果在 framework 之间出现了循环依赖也会报类似的错误。</li>\n</ul>\n<blockquote>\n<p>关于依赖项和配置项有个需要注意的地方：所有依赖项的配置一定要完全匹配。如果你在使用 Alpha 配置项构建你的 app，但是其依赖项中但凡出现了不包含这种配置，编译过程都会因为找不到某个 framework 而失败。当这种情况发生的时候，Xcode 不会编译该 framework 但是不报任何错误。</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/TrXKUTJ.png\" alt=\"各个依赖项是如何基于 project 的配置得到编译的\"></p>\n<h3 id=\"Linking-with-Xcode\"><a href=\"#Linking-with-Xcode\" class=\"headerlink\" title=\"Linking with Xcode\"></a>Linking with Xcode</h3><p>Target 本身可以链接其他 target 的输出，我们可以使用 Xcode 中的工具，比如 scheme 或者 target dependencies 来指定依赖，但是，我们是如何通过定义这些依赖的链接关系来将它们融为一体的？</p>\n<h4 id=\"1-动态或者静态链接-libraries-和-frameworks\"><a href=\"#1-动态或者静态链接-libraries-和-frameworks\" class=\"headerlink\" title=\"1. 动态或者静态链接 libraries 和 frameworks\"></a>1. 动态或者静态链接 libraries 和 frameworks</h4><p>我们可以通过以下的方式定义链接：</p>\n<ul>\n<li><strong>一个构建阶段（build phase）：</strong>，在所有可用的 build phase 中，有一个是定义链接的，<em>Link Binary With Libraries</em>。你可以在这里添加某个 target 的依赖项，这些依赖项可以来自于同一个 project，也可以来自同一个 workspace 中的其他 project。这个 build phase 被 Xcode 用来识别 target 被构建时所需的依赖项；</li>\n<li><strong>编译器构建设置：</strong>一个 build phase 中所定义的内容会被转换成编译器参数。其中某些内容你也可以通过定义编译设置项做到：</li>\n<li><code>FRAMEWORK_SEARCH_PATHS</code>：定义编译器所链接的 framework 所在路径</li>\n<li><code>LIBRARY_SEARCH_PATHS</code>：定义编译器所链接的 library 所在路径</li>\n<li><code>OTHER_LDFLAGS</code> <em>(Other Linker Flags)</em>：我们可以使用<code>-l</code>参数指定链接的 library，比如<code>-l&quot;1PasswordExtension&quot; -l&quot;Adjust&quot;</code>。如果需要链接一个 framework，就需要使用<code>-framework</code>参数，比如：<code>-framework &quot;GoogleSignIn&quot; -framework &quot;HockeySDK&quot;</code>。如果我们尝试链接一个无法在上方指定路径中找到的 framework 或者 library 的话，编译过程就会失败。</li>\n</ul>\n<h4 id=\"2-暴露库的头文件\"><a href=\"#2-暴露库的头文件\" class=\"headerlink\" title=\"2. 暴露库的头文件\"></a>2. 暴露库的头文件</h4><p>Library 的头文件需要暴露给依赖该库的 targe。为了做到这个，有一个编译设置项：<code>HEADER_SEARCH_PATHS</code>用来指定头文件所在路径。如果我们链接某个库，但是忘记暴露该库的头文件，编译过程就会因为找不到其头文件而失败。</p>\n<h4 id=\"3-将-Framework-嵌入到应用中\"><a href=\"#3-将-Framework-嵌入到应用中\" class=\"headerlink\" title=\"3. 将 Framework 嵌入到应用中\"></a>3. 将 Framework 嵌入到应用中</h4><p>App 的 target 链接动态 framework，需要把这些依赖项复制到应用的 bundle 中。这个过程被称作 <strong>framework embedding</strong>。为了达到这个目的，我们需要使用 Xcode 的<strong>Copy Files Phase</strong>，其拷贝 这些 framework 到 <code>Frameworks</code>目录中。不仅仅需要把这些直接依赖项嵌入应用中，还包括直接依赖所依赖的项目。如果缺少任意的 framework，当我们尝试打开 app 的时候都会抛出错误。</p>\n<hr>\n<h3 id=\"案例学习-👨‍💻\"><a href=\"#案例学习-👨‍💻\" class=\"headerlink\" title=\"案例学习 👨‍💻\"></a>案例学习 👨‍💻</h3><p>在这个部分，我们会分析以下 Cocopods 和 Carthage 是如何贯彻上面这些概念来管理你的工程依赖的。</p>\n<h4 id=\"CocoaPods\"><a href=\"#CocoaPods\" class=\"headerlink\" title=\"CocoaPods\"></a>CocoaPods</h4><p><img src=\"https://i.imgur.com/yYLLsbQ.png\" alt=\"CocoaPods\"></p>\n<p>Cocoapods 解析你的工程依赖，并将它们融合到你的工程中。虽然直接修改你的工程配置是不太推荐的，但是它从最初的版本已经有了很大的提升，用这种方式，我们几乎不需要对 project 做很多改变。那么它底层到底是怎么做到的？</p>\n<ul>\n<li>它创建一个工程（project）<em>(</em><code>*Pods.xcodeproj*</code><em>)</em> ，其包含了所有的依赖项，每个依赖项以 target 的形式存在。每个 target 各自编译需要被链接到 app 中的依赖项；</li>\n<li>它创建一个额外的 target，其依赖于其他所有的依赖项。该 target 是一个 umbrella target，用来触发其他 target 的编译。这样做也最小程度的减少了你的 project 中所需要的改变。通过链接这个 target，Xcode 会先编译其所有依赖项，然后是你的 app；</li>\n<li>它创建了一个 workspace，包含了你的 project 以及 Pods project；</li>\n<li>Frameworks 和 libraries 使用<code>.xcconfig</code>文件链接。这些文件被加到了你的 project 群组中，并且被设置为你 project 中 target 的配置项；</li>\n<li>嵌入过程是通过一个构建阶段脚本（build phase script）来做到的。类似的，所有的 framework 所需要的资源也通过一个构建阶段（build phase）来完成。</li>\n</ul>\n<p>下面这张图展示了整个设置过程：</p>\n<p><img src=\"https://i.imgur.com/UARMUhl.png\" alt=\"CocoaPods 如何将依赖项融合到整个 Project 中\"></p>\n<h4 id=\"Carthage\"><a href=\"#Carthage\" class=\"headerlink\" title=\"Carthage\"></a>Carthage</h4><p><img src=\"https://i.imgur.com/IUXCxhQ.png\" alt=\"Carthage\"></p>\n<p>Carthage 的方式和 CocoaPods 比起来大不同。除了依赖项的解析，该工具是还一种去中心化的模式，其生成那些需要被链接或者嵌入到 app 的依赖项的预编译版本。</p>\n<ul>\n<li>Carthage 解析依赖项，并且编译它们生成你能够链接到 app 中的动态 framework，或者为了调试所需要的符号。这些 framework 是 fat framework，支持模拟器和真机的架构；</li>\n<li>这些 framework 被用户使用 <em>Link Binary With Libraries</em> 的构建阶段（build phase）手动的链接；</li>\n<li>嵌入过程使用 Carthage 提供的脚本完成。这个脚本会剔除那些我们正在构建目标所不必要的架构版本；</li>\n<li>使用同样的脚本，复制符号到合适的文件夹，使得调试能够正常进行。</li>\n</ul>\n<p><img src=\"https://i.imgur.com/HXqtoDl.png\" alt=\"Carthage 是如何生成依赖项的 framework 和 symbol\"></p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><a href=\"http://www.knowstack.com/framework-vs-library-cocoa-ios/\" target=\"_blank\" rel=\"noopener\">Framework vs Library</a></li>\n<li><a href=\"https://pewpewthespells.com/blog/static_and_dynamic_libraries.html\" target=\"_blank\" rel=\"noopener\">Static and dynamic libraries</a></li>\n<li><a href=\"https://pewpewthespells.com/blog/buildsettings.html\" target=\"_blank\" rel=\"noopener\">Xcode Build Settings Reference</a></li>\n<li><a href=\"https://developer.apple.com/library/content/technotes/tn2435/_index.html\" target=\"_blank\" rel=\"noopener\">Embedding Frameworks in an App</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html\" target=\"_blank\" rel=\"noopener\">Introduction to Framework Programming Guide</a></li>\n<li><a href=\"https://www.cocoanetics.com/2015/04/skipping-copy-phase-strip/\" target=\"_blank\" rel=\"noopener\">Skippy Copy Phase Strip</a></li>\n</ul>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<blockquote>\n<p>原文：<a href=\"https://ppinera.es/2017/09/29/modular-xcode-projects.html\" target=\"_blank\" rel=\"noopener\">Modular Xcode projects</a><br>原作者 &amp; Copyright <a href=\"http://twitter.com/pepibumur\" target=\"_blank\" rel=\"noopener\">@pepibumur</a><br>翻译：<a href=\"https://twitter.com/OgreMergO\" target=\"_blank\" rel=\"noopener\">@OgreMergO</a></p>\n</blockquote>\n<p>使用 Xcode 构建模块化的工程就需要对工程结构以及其基础概念有很好的理解才行。","more":"我们平时不怎么关注工程结构本身，只有在工程逐渐变大，要添加更多依赖的时候才会注意的到。而即使到了这个时候，我们大多数的工程都会使用  <a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"noopener\">CocoaPods</a> 来设置那些依赖项，或者 <a href=\"https://github.com/carthage\" target=\"_blank\" rel=\"noopener\">Carthage</a>, 后者虽然没有帮我们做依赖性的设置，但是使得我们会更容易的，通过在工程的 build phase 选项中添加一些内容，达到同样的目的。当配置项越来越复杂，我们就很容易产生困惑，这是因为我们并没有完全掌握 Xcode 工程中所涉及的所有元素。我经常被问到的问题如下：</p>\n<ul>\n<li>我能不能在工程里同时使用 Carthage，Cocoapods 以及自己个人的依赖设置？</li>\n<li>我添加了依赖，但是当模拟器打开 App 的时候 Crash 了。</li>\n<li>为什么我需要只在某些 targets 里嵌入 framework？</li>\n<li>我的 framework 应该是静态的还是动态的？</li>\n</ul>\n<p>在这篇博文中，我会引导你遍历 Xcode Project 中的各个元素，指导你如何通过改变这些元素来模块化你的设置项。我希望下次你遇到上面这些问题的时候，你不需要再花大量时间取 Stack Overflow 上查这些确定的答案。</p>\n<h3 id=\"Elements-⚒\"><a href=\"#Elements-⚒\" class=\"headerlink\" title=\"Elements ⚒\"></a>Elements ⚒</h3><h4 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h4><p>工程（Projects）都是由多个更小的叫做 target 的单元组成的。这些 target 包含编译特定平台产品，比如 frameworks, libraries, apps, testing bundles, extensions 等所需要的配置。 你可以在<a href=\"https://github.com/xcodeswift/xcproj/blob/master/Sources/xcproj/PBXProductType.swift\" target=\"_blank\" rel=\"noopener\">这里</a>看到 target 所有可用的类型。 Target 可以相互依赖，当一个 target A 依赖另外一个 target B 的时候，target B 就会被先构建出来以便 target A 使用其产出。而 target 的配置项会涉及以下几个地方：</p>\n<ul>\n<li><strong>Info.plist 文件</strong>: 该文件包含产出特定的设置项，比如 版本、App 的名字或者 App 的类型，你可以在<a href=\"https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">这里</a>详细了解这个文件。</li>\n<li><strong>Entitlements</strong>: 其指定了应用的能力。如果在授权文件中指定的能力和开发者平台上设置的无法匹配，签名过程就会出错。</li>\n<li><strong>Build settings</strong>: 如其名字所描述的那样，这些都是构建 target 所必要的设置项。构建设置项要么在 target 自身定义或者在 <code>xcconfig</code> 文件中定义。一个 target 的配置项可以继承而来，首先是配置文件本身，其次是 target 的配置项，最后是 project 配置项。</li>\n<li><strong>Build phases</strong>: 构建流水线由 build phase 定义。当一个 target 被创建出来之后，其包含默认的构建阶段（包含 <em>构建源码、拷贝资源等</em>），但是你可以自行添加你需要的。举个例子，这些阶段里，有个 shell script phase 允许你在构建过程中执行一些脚本。这些脚本可以读取 Xcode 暴露出来的那些<a href=\"http://ppinera.es/2017/09/15/modular-xcode-projects.html\" target=\"_blank\" rel=\"noopener\">构建参数</a>。</li>\n</ul>\n<p>基于<code>.xcconfig</code>文件的可组合性以及其可重用性的考虑，强烈建议你在这些文件中定义你那些编译设置。Target 的配置，比如 build setting 、build phase 等的变更都体现在 <code>.pbxproj</code> 文件中，这个文件是一种特殊的plist 文件，当我们使用 Git 管理我们的工程的时候，这个文件很容易出现冲突。当然，更新 <code>pbxproj</code> 文件中配置的最简单方式就是使用 Xcode，其了解如何从这些文件中读取配置和向其中写入配置。如果你对不使用 Xcode 更新 <code>pbxproj</code> 文件感兴趣的话，你可以试试 <a href=\"https://github.com/cocoapods/xcodeproj\" target=\"_blank\" rel=\"noopener\">Xcodeproj</a> 或者 <a href=\"https://github.com/swift-xcode/xcodeproj\" target=\"_blank\" rel=\"noopener\">xcproj</a>。</p>\n<p>构建这些 target 的输出要么是比如 app，extension 或者测试文件等 <strong>bundles</strong>，要么就是<strong>intermediate products</strong> ，例如 library 或者那些封装了代码和资源文件用来给别的 target 使用的 framework。这些 Target 的输出内容你可以在工程文件中的 <code>Products</code> 的 Group 下找到，如果有红色的文件引用表示没有 product 输出，很大可能是你还没有构建过这个 target。</p>\n<h4 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h4><p>Xcode 工程中另外一个要素是 scheme。 一个工程可以包含多个 scheme，他们可以被共享，作为工程的一部分被人们使用。这些 scheme 指定了 Xcode 中每个具体动作的配置，这些动作包括：<strong>run</strong>，<strong>test</strong>，<strong>profile</strong>，<strong>analyze</strong> 以及 <strong>archive</strong>。 细的来讲，可以指定哪些 target 需要被构建，以什么顺序构建甚至针对每一种动作指定不同的配置。</p>\n<p>关于 scheme 的编译配置有一些东西要讲。当我们指定针对哪些动作构建哪些 target 的时候，在下面两种情况下，我们不需要指定每个 target 的依赖项：</p>\n<ol>\n<li>如果依赖项是是相同 project 中的一部分，并且已经在 <code>Target dependencies</code> 的 <code>Build Phases</code> 中定义过；</li>\n<li>开启了 <code>Find implicit dependencies</code>。</li>\n</ol>\n<p>第 2 点中开启的标识，构建过程必须找到 target 的依赖项，并且先行构建。另外，如果你开启了<code>Parallelize build</code> 的话，一旦 target 相互之间没有依赖的话，就能够并行构建，因而会节省一部分时间。</p>\n<p>一个有问题的构建配置会导致你编译 target 的时候出现错误，比如 <code>Framework XXX not found</code>。如果你曾经或者当前遇到了类似的报错，检查一下在构建每个 scheme 的时候，你的 target 的所有依赖是否已经被构建。</p>\n<p>scheme 文件定义是存储在 <code>Project.xcodeproj/xcshareddata/xcodeproj.xcscheme</code> 路径下的一个标准的 XML 文本，因此你可以很容易的使用任意 XML 编辑器来修改它。</p>\n<h4 id=\"Workspace\"><a href=\"#Workspace\" class=\"headerlink\" title=\"Workspace\"></a>Workspace</h4><p>多个 project 文件被组合成一个 workspace。当 project 被添加到一个 workspace 的时候：</p>\n<ol>\n<li>其 schemes 会出现在 workspace 的 scheme 列表中；</li>\n<li>project 彼此可以产生依赖关系，后文会讲到。</li>\n</ol>\n<p>和 scheme 类似，workspace 也是普通的 XML 文件，修改起来很方便。</p>\n<p><img src=\"https://i.imgur.com/wGXI5fy.png\" alt=\"工程构建组合中的每一个基础元素： target、scheme、project 以及 workspace 是如何被组织起来的\"></p>\n<h4 id=\"Dependencies-🌱\"><a href=\"#Dependencies-🌱\" class=\"headerlink\" title=\"Dependencies 🌱\"></a>Dependencies 🌱</h4><p>每个 target 都可以有依赖，这些依赖是 target 需要链接的那些 framework 以及 library等，其包含了能够被 target 共享的源代码以及资源。这些依赖项可以被静态或者动态的链接。</p>\n<p><strong>静态链接：</strong></p>\n<ul>\n<li>发生在编译阶段；</li>\n<li>库（Library）中的代码文件会被包含到应用的二进制文件中（会增大应用的二进制大小）；</li>\n<li>库使用 .a 作为文件后缀，其来自 (ar)chive file3 type；</li>\n<li>如果相同的库被多次链接，编译器会由于 duplicated symbols 编译失败。</li>\n</ul>\n<p><strong>动态链接：</strong></p>\n<ul>\n<li>模块在应用启动或者运行过程中被加载；</li>\n<li>应用或者扩展的 target 都可以共享相同的动态库（仅被复制一份）</li>\n</ul>\n<p>关于 framework 和 library（无论是静态链接还是动态链接）的区别在于前者可以在相同的 bundle 中包含多个版本，还可以包含额外的资源文件。</p>\n<blockquote>\n<p>一个 Library 是一个 .a 文件，其来源于 归档（archive）文件类型。一个单一的归档文件仅支持单一的架构。如果需要打包多个架构，则需要将其打包成胖Match-O二进制（<strong>fat Match-O binary</strong>），该二进制文件是一种容器格式，其将支持不同架构的Mach-O打包在一起。如果我们想生成、修改一个胖二进制文件或者从其中提取某个特定架构的库的话，可以使用命令行工具<code>lipo</code>。</p>\n</blockquote>\n<p>你可以在<a href=\"https://pewpewthespells.com/blog/static_and_dynamic_libraries.html\" target=\"_blank\" rel=\"noopener\">这里</a>了解更多关于 frameworks/libraries 以及 static/dynamic 的内容。</p>\n<p><img src=\"https://i.imgur.com/qKHdwhp.png\" alt=\"动态链接和静态链接的区别\"></p>\n<p>应用的依赖项分为预编译过的（<strong>precompiled</strong>）和未经编译过（<strong>not-compiled</strong>）两类。</p>\n<h5 id=\"Precompiled-dependencies\"><a href=\"#Precompiled-dependencies\" class=\"headerlink\" title=\"Precompiled dependencies\"></a>Precompiled dependencies</h5><p><a href=\"https://github.com/carthage\" target=\"_blank\" rel=\"noopener\">Carthage</a> 是这类型依赖的典型代表。某些 SDK，比如 <a href=\"https://github.com/CocoaPods/Specs/blob/master/Specs/0/3/5/Firebase/4.2.0/Firebase.podspec.json#L23\" target=\"_blank\" rel=\"noopener\">Firebase</a> 就是作为编译过的依赖来发布的。当预编译过的依赖是库（library）的时候，这些依赖就包含 <code>.a</code> 的库及一个公共头文件，包含了该库所暴露出的公共接口。当这些依赖是 framework 的时候，这些依赖就以包含了库和资源文件的 <code>.framework</code> 文件发布。</p>\n<p>当我们的 app 依赖的是预编译依赖的时候，很重要的一点是，这些依赖也是依照我们 app 所构建架构来构建出来的。一旦其中缺失某个架构的代码，我们就会在编译 app 的时候收到编译错误。一会儿后文会看到，Carthage 使用 lipo 工具生成那些包含模拟器或者真机所必须的架构的 framework 的，同时根据构建配置来剔除掉那些不需要的 framework。</p>\n<h5 id=\"Non-compiled-dependencies\"><a href=\"#Non-compiled-dependencies\" class=\"headerlink\" title=\"Non-compiled dependencies\"></a>Non-compiled dependencies</h5><p><a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"noopener\">CocoaPods</a> 是该种类型的典型代表。依赖项被定义在我们要链接的 frameworks/libraries 的 target 中。这里有多种方式在 Xcode 中指定我们的 target 依赖其他 target 的输出。</p>\n<ul>\n<li><strong>如果这些 target 分布在同一个 project 中</strong>，你可以在 Build Phase 的<em>Target dependencies</em> 中指定依赖。 Xcode 会在编译该 target 的时候首先编译这些指定的依赖项；</li>\n<li><strong>如果这些 target 分布在不同的 project 中</strong>，我们就可以使用<em>Scheme</em>来定义这些 target 之间的依赖关系。在 scheme 的 Build 部分，我们可以定义要被构建的 target 以及以什么顺序构建（基于他们之间的依赖关系）。如果你开启了<em>Find implicit dependencies</em>标识，Xcode 能够根据每个 target 的输入输出来猜测依赖。如果 scheme 中有错误配置，你就会得到类似<code>xxxx.framework not found</code>的错误。如果在 framework 之间出现了循环依赖也会报类似的错误。</li>\n</ul>\n<blockquote>\n<p>关于依赖项和配置项有个需要注意的地方：所有依赖项的配置一定要完全匹配。如果你在使用 Alpha 配置项构建你的 app，但是其依赖项中但凡出现了不包含这种配置，编译过程都会因为找不到某个 framework 而失败。当这种情况发生的时候，Xcode 不会编译该 framework 但是不报任何错误。</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/TrXKUTJ.png\" alt=\"各个依赖项是如何基于 project 的配置得到编译的\"></p>\n<h3 id=\"Linking-with-Xcode\"><a href=\"#Linking-with-Xcode\" class=\"headerlink\" title=\"Linking with Xcode\"></a>Linking with Xcode</h3><p>Target 本身可以链接其他 target 的输出，我们可以使用 Xcode 中的工具，比如 scheme 或者 target dependencies 来指定依赖，但是，我们是如何通过定义这些依赖的链接关系来将它们融为一体的？</p>\n<h4 id=\"1-动态或者静态链接-libraries-和-frameworks\"><a href=\"#1-动态或者静态链接-libraries-和-frameworks\" class=\"headerlink\" title=\"1. 动态或者静态链接 libraries 和 frameworks\"></a>1. 动态或者静态链接 libraries 和 frameworks</h4><p>我们可以通过以下的方式定义链接：</p>\n<ul>\n<li><strong>一个构建阶段（build phase）：</strong>，在所有可用的 build phase 中，有一个是定义链接的，<em>Link Binary With Libraries</em>。你可以在这里添加某个 target 的依赖项，这些依赖项可以来自于同一个 project，也可以来自同一个 workspace 中的其他 project。这个 build phase 被 Xcode 用来识别 target 被构建时所需的依赖项；</li>\n<li><strong>编译器构建设置：</strong>一个 build phase 中所定义的内容会被转换成编译器参数。其中某些内容你也可以通过定义编译设置项做到：</li>\n<li><code>FRAMEWORK_SEARCH_PATHS</code>：定义编译器所链接的 framework 所在路径</li>\n<li><code>LIBRARY_SEARCH_PATHS</code>：定义编译器所链接的 library 所在路径</li>\n<li><code>OTHER_LDFLAGS</code> <em>(Other Linker Flags)</em>：我们可以使用<code>-l</code>参数指定链接的 library，比如<code>-l&quot;1PasswordExtension&quot; -l&quot;Adjust&quot;</code>。如果需要链接一个 framework，就需要使用<code>-framework</code>参数，比如：<code>-framework &quot;GoogleSignIn&quot; -framework &quot;HockeySDK&quot;</code>。如果我们尝试链接一个无法在上方指定路径中找到的 framework 或者 library 的话，编译过程就会失败。</li>\n</ul>\n<h4 id=\"2-暴露库的头文件\"><a href=\"#2-暴露库的头文件\" class=\"headerlink\" title=\"2. 暴露库的头文件\"></a>2. 暴露库的头文件</h4><p>Library 的头文件需要暴露给依赖该库的 targe。为了做到这个，有一个编译设置项：<code>HEADER_SEARCH_PATHS</code>用来指定头文件所在路径。如果我们链接某个库，但是忘记暴露该库的头文件，编译过程就会因为找不到其头文件而失败。</p>\n<h4 id=\"3-将-Framework-嵌入到应用中\"><a href=\"#3-将-Framework-嵌入到应用中\" class=\"headerlink\" title=\"3. 将 Framework 嵌入到应用中\"></a>3. 将 Framework 嵌入到应用中</h4><p>App 的 target 链接动态 framework，需要把这些依赖项复制到应用的 bundle 中。这个过程被称作 <strong>framework embedding</strong>。为了达到这个目的，我们需要使用 Xcode 的<strong>Copy Files Phase</strong>，其拷贝 这些 framework 到 <code>Frameworks</code>目录中。不仅仅需要把这些直接依赖项嵌入应用中，还包括直接依赖所依赖的项目。如果缺少任意的 framework，当我们尝试打开 app 的时候都会抛出错误。</p>\n<hr>\n<h3 id=\"案例学习-👨‍💻\"><a href=\"#案例学习-👨‍💻\" class=\"headerlink\" title=\"案例学习 👨‍💻\"></a>案例学习 👨‍💻</h3><p>在这个部分，我们会分析以下 Cocopods 和 Carthage 是如何贯彻上面这些概念来管理你的工程依赖的。</p>\n<h4 id=\"CocoaPods\"><a href=\"#CocoaPods\" class=\"headerlink\" title=\"CocoaPods\"></a>CocoaPods</h4><p><img src=\"https://i.imgur.com/yYLLsbQ.png\" alt=\"CocoaPods\"></p>\n<p>Cocoapods 解析你的工程依赖，并将它们融合到你的工程中。虽然直接修改你的工程配置是不太推荐的，但是它从最初的版本已经有了很大的提升，用这种方式，我们几乎不需要对 project 做很多改变。那么它底层到底是怎么做到的？</p>\n<ul>\n<li>它创建一个工程（project）<em>(</em><code>*Pods.xcodeproj*</code><em>)</em> ，其包含了所有的依赖项，每个依赖项以 target 的形式存在。每个 target 各自编译需要被链接到 app 中的依赖项；</li>\n<li>它创建一个额外的 target，其依赖于其他所有的依赖项。该 target 是一个 umbrella target，用来触发其他 target 的编译。这样做也最小程度的减少了你的 project 中所需要的改变。通过链接这个 target，Xcode 会先编译其所有依赖项，然后是你的 app；</li>\n<li>它创建了一个 workspace，包含了你的 project 以及 Pods project；</li>\n<li>Frameworks 和 libraries 使用<code>.xcconfig</code>文件链接。这些文件被加到了你的 project 群组中，并且被设置为你 project 中 target 的配置项；</li>\n<li>嵌入过程是通过一个构建阶段脚本（build phase script）来做到的。类似的，所有的 framework 所需要的资源也通过一个构建阶段（build phase）来完成。</li>\n</ul>\n<p>下面这张图展示了整个设置过程：</p>\n<p><img src=\"https://i.imgur.com/UARMUhl.png\" alt=\"CocoaPods 如何将依赖项融合到整个 Project 中\"></p>\n<h4 id=\"Carthage\"><a href=\"#Carthage\" class=\"headerlink\" title=\"Carthage\"></a>Carthage</h4><p><img src=\"https://i.imgur.com/IUXCxhQ.png\" alt=\"Carthage\"></p>\n<p>Carthage 的方式和 CocoaPods 比起来大不同。除了依赖项的解析，该工具是还一种去中心化的模式，其生成那些需要被链接或者嵌入到 app 的依赖项的预编译版本。</p>\n<ul>\n<li>Carthage 解析依赖项，并且编译它们生成你能够链接到 app 中的动态 framework，或者为了调试所需要的符号。这些 framework 是 fat framework，支持模拟器和真机的架构；</li>\n<li>这些 framework 被用户使用 <em>Link Binary With Libraries</em> 的构建阶段（build phase）手动的链接；</li>\n<li>嵌入过程使用 Carthage 提供的脚本完成。这个脚本会剔除那些我们正在构建目标所不必要的架构版本；</li>\n<li>使用同样的脚本，复制符号到合适的文件夹，使得调试能够正常进行。</li>\n</ul>\n<p><img src=\"https://i.imgur.com/HXqtoDl.png\" alt=\"Carthage 是如何生成依赖项的 framework 和 symbol\"></p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><a href=\"http://www.knowstack.com/framework-vs-library-cocoa-ios/\" target=\"_blank\" rel=\"noopener\">Framework vs Library</a></li>\n<li><a href=\"https://pewpewthespells.com/blog/static_and_dynamic_libraries.html\" target=\"_blank\" rel=\"noopener\">Static and dynamic libraries</a></li>\n<li><a href=\"https://pewpewthespells.com/blog/buildsettings.html\" target=\"_blank\" rel=\"noopener\">Xcode Build Settings Reference</a></li>\n<li><a href=\"https://developer.apple.com/library/content/technotes/tn2435/_index.html\" target=\"_blank\" rel=\"noopener\">Embedding Frameworks in an App</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html\" target=\"_blank\" rel=\"noopener\">Introduction to Framework Programming Guide</a></li>\n<li><a href=\"https://www.cocoanetics.com/2015/04/skipping-copy-phase-strip/\" target=\"_blank\" rel=\"noopener\">Skippy Copy Phase Strip</a></li>\n</ul>"},{"title":"在 Swift Framework 中使用 C 文件的过程探索","date":"2019-01-03T13:19:24.000Z","top_img":"https://i.imgur.com/NJi1fs6.jpg","_content":"\n\nSwift 真香！\n\n## 问题描述\n\n我们在开发线上诊断工具需求的时候，是以单个 Pod 的形式提供支持，并且代码文件中只有纯 Swift 文件，但是其中需要用到系统的 C 库的一些功能，本次就是使用了系统 C 库中 `resolv.h` 这个文件来进行 DNS 解析所用。\n\n当后期 Pod 功能完善之后，在 Example 工程中也已经编译通过之后，接入主项目中之后遇到了下面这个编译错误：\n\n![Error When Compile](https://i.imgur.com/ADh0sy6.png)\n\n\n具体文字错误信息如下：\n\n\n```txt\n/Users/chen/Repos/Work/ZHDiagnosisTool/ZHDiagnosisTool/Classes/Core/Network/ZHDiagnosisTool-Network-Header.h:8:10: \n    Include of non-modular header inside framework module 'Diagnosis.ZHDiagnosisTool_Network_Header': '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk/usr/include/resolv.h'\n```\n\n大概的意思就是在 Umbrella Header 中加入的 Briding header 指定了 include 一个 C 文件，而该 C 文件本身并不是  Modular Header， 因此编译无法通过。这就涉及了目前 iOS 生态中普遍使用的 Modules 概念。\n\n## 几个概念\n\n### Modules\n\nModules 的概念是 XCode 5 带到 iOS 开发者面前的，从那时起 LLVM 编译器就已经内在支持了，具体关于其历史在 [WWDC 2013 Session笔记 - Xcode5和ObjC新特性](https://onevcat.com/2013/06/new-in-xcode5-and-objc/) 这篇文章中已经讲解的非常详细了，不再赘述，总结一句话就是：\n\n> Modules 是被引入 LLVM 层面的，用以解决之前 C/C++ 系中 #include 和 #import 带来的引用泛滥以及编译时间过长的问题的一种手段。\n\n尤其是在 Swift 引入之后，Module 的概念应该已经深入人心。大家可能已经习惯直接使用 @import 来引用某个 Module，或者其中某个逻辑单元。尤其是使用 CocoaPods 集成开发的时候，其也帮你底层做了一些 Modules 的工作， module 的属性是由定义它的 `.modulemap` 文件来决定的，在 Pods 的工程目录结构中充斥着 `.modulemap` 的身影，其语法大概如下：\n\n``` Shell\nmodule module_name [system] {\n    header \"header.h\"\n    link \"linked_library\"\n    export *\n}\n```\n\n如果对其中 [Modules 的语法](https://clang.llvm.org/docs/Modules.html#module-map-language)感兴趣，可以到 Clang 的官方文档下通读下，你肯定会对 Modules 这一套有更清楚的认识。\n\n### Umbrella Header\n\n说起来，Umbrella Header 是在 Framework 的概念被引入的，你可以理解为一个模块均存在一个 Umbrella Header 用来将那些你想暴露给模块外界调用的头文件包裹在一起。避免使用者在使用该模块的时候需要手动输入多个 Header 的一种解决方案。 iOS 中特指 iOS 8 系统官方加入 Dynamic Framework 之后引入的。\n\n如下所示，没有 Umbrella Header 的情况下你需要将所有需要引入的头文件依次写出。\n\n```objc\n#import <XYZModule/XYZCustomCell.h>\n#import <XYZModule/XYZCustomView.h>\n#import <XYZModule/XYZCustomViewController.h>\n```\n在使用了 Umbrella Header 之后，你只需要下面一行即可。\n\n```objc\n#import <XYZModule/XYZModule.h>\n```\n当然，还存在 umbrella framework，感兴趣大家可以到[官方文档](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC)下观看。\n\n- Bridging-Header\n\n桥接文件是在 Swift 推出之后，Apple 引入目前iOS 生态的一个概念用以桥接 Swift 和 Objective-C 的一种方式 （Mix and Match），如下图所示，如果在 Swift 中想使用 Objective-C 类定义的内容，就需要建立 Bridging Header，然后在其中定义你想要暴露的 OC 头文件。\n\n![Bridging Header](https://i.imgur.com/YwqHEKJ.png)\n\n具体的操作在[官方文档](https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift)有针对在同一个 App Target 和在同一个 Framework 内两种情况均有说明。\n\n> 在梳理这些概念的过程中，发现自己之前对桥接文件有个误区，如果你在 App 的主 Target 中需要进行 OC 和 Swift 的混编，使用 Bridging Header 是必选，如果你是在同一个 Framework 中进行的混编，Bridging-Header 是并不需要的，你需要做的只是在 Umbrella Header 里加入你想暴露给 Swift 文件使用的 OC 头文件即可，之前自己一直是显式的建立一个 Bridging-Header，然后在 Umbrella Header 中引入该头文件，想来这种方式只是将你想暴露在外的头文件进行了二次包裹而已，因为 Cocoapods 是将所有 public header 均加入到 umbrella header 里了，因此单个 framework 内部开发，即使没有 bridge header 也是能够将符号暴露给 Swift 的。\n\n### Cocoapods\n\n我们每次执行 `pod install` 的时候，如果你使用 —verbose 来看详细安装过程就能看到，针对每一个将要被安装的 Pod 均会执行生成 module map 和 umbrella header 这两个阶段，如下所示部分 Install 指令的代码，代码位于 `lib/cocoapods/installer/xcode/pods_project_generator/aggregate_target_installer.rb` \n\n    \n```ruby\ndef install!\n       UI.message \"- Installing target `#{target.name}` #{target.platform}\" do\n       native_target = add_target\n       create_support_files_dir\n       create_support_files_group\n       create_xcconfig_file(native_target)\n       if target.host_requires_frameworks?\n          create_info_plist_file(target.info_plist_path, native_target, target.version, target.platform)\n    \t    create_module_map(native_target)\n          create_umbrella_header(native_target)\n       elsif target.uses_swift?\n          create_module_map(native_target)\n    \t\t\tcreate_umbrella_header(native_target)\n       end\n      \n     # Some Code\n     # Some Code\n     # Some Code      \n    end\n```\n\n很明确，Cocoapods 在 install 某个 Pod 的时候会执行创建 module map 文件以及 umbrella header 文件的工作。详细的代码大家可以直接到 Cocoapods 源码下  `lib/cocoapods/generator` 目录下看，分别是 `module_map.rb` 和 `umbrella_header.rb` 文件。\n\n其中在各自文件的注释部分也有针对生成文件的说明，比如 `module_map.rb` 中说明了 module map 的作用，\n\n> Generates LLVM module map files. A module map file is generated for each Pod and for each Pod target definition that is built as a framework. It specifies a different umbrella header than usual to avoid name conflicts with existing headers of the podspec.\n\n在 `umbrella_header.rb` 中说明了 umbrella header 的作用，\n\n> Generates an umbrella header file for clang modules, which are used by dynamic frameworks on iOS 8 and OSX 10.10 under the hood. If the target is a +PodTarget+, then the umbrella header is required to make all public headers in a convenient manner available without the need to write out header declarations for every library header.\n\n## 问题原因\n\n首先先解答：为什么 Example 工程能够编译通过 而用了主工程是无法编译通过？\n\n因为目前主工程都要求我们自行开发的 pod 以动态 framework 的形式参与，但是在 Example 工程开发的时候我们的 `podfile` 并未指定 `use_frameworks!` 用以产出动态 framework，因此未暴露出该问题，也就是说只有以 framework 的形式的 module 才会有该问题，准确的说，应该是 `Dynamic Framework`\n\n了解了以上概念之后，我们再来看我们的问题，首先我们的问题是在 framework 内部调用系统 C 库代码出现的问题，从 Xcode 的报错，我们知道我们通过 bridging header 引入的 C 文件并不以 module 的形式存在，因此编译器报错。\n\n## 解决过程\n\n其实吧，大家都能想到，使用 Objective-C 做个封装，或者干脆直接调用 C 文件的类用 OC 重写不就完了么，可是如果下次你再遇到了呢？ 或者要改造了一个纯 Swift 库呢？知其所以然，才能避免再次落坑吧。\n\n> 因为 Objective-C 自身编译器是帮你做了 modular 化的，当然，如果你选择了前者，还有个限制，你并不能把上面 C 的头文件放到你的 Objective-C 的头文件中，因为本质上，最后这个头文件还是要暴露给 Umbrella Header 的。\n\n首先，能否允许编译器支持在 module 中引入非 modular 的头文件呢？ \n\nXcode 在 build setting 中提供了  `Allow Non-modular Includes In Framework Modules` 来控制是否允许在当前 framework 中支持非 modular 头文件引入，其并不适用于纯 Swift 项目，而且即使适用，其会导致所有用到该 framework 的地方也不能再适用 module 形式引入头文件了，也就是必须适用平坦式的 `#include \"\"`\n\n![Build Setting](https://i.imgur.com/S4i2chx.png)\n\n\n最后，通过只能从根源上来解决该问题了，既然需要引入的文件是 modular header，我们就要想办法来将其包裹为 module。 在查找解决方案的过程中发现，就在 Swift 刚推出的时候，大家已经遇到这个问题了，遇到最多的就是`CommonCrypto` 经常被使用到的 C 库，常见的 MD5 计算就是其提供的 API，但是在前几年官方并未将该动态库 module 化，因此导致你无法在 Swift 文件中直接使用类似 `#import <CommonCrypto/CommonCrypto.h>` 这种写法。自然而言多了很多解决方案，如下出自 StackOverflow 上 [Importing CommonCrypto in a Swift framework](https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785) 的帖子下面就提供了多种解决方案：\n\n> 还是那句话，你是可以通过 Objective-C 做桥接来达到同样效果的。毕竟 Swift 本身就是一门心思想抛开 C 的历史包袱，因此想拥有一个纯纯的 Swift 代码不沾染一点 C 文件气息，你就要做一些工作。\n\n其中根本问题就是为 `CommonCrypto` 这个 C 编译单元定义 module，上面也提到了 LLVM 是通过 `modulemap` 文件来识别的，所以只要通过 `.modulemap` 来定义即可，\n\n```\n    module CommonCrypto [system] {\n        header \"/usr/include/CommonCrypto/CommonCrypto.h\"\n        export *\n    }\n```\n\n定义的 modulemap 自然可以放到任意目录，只要让编译单元在编译的时候能够搜索的到即可，Xcode 选项的 Build Settings 下的 Swift Compiler - Search Paths 。添加 .modulemap 文件所在路径即可。在编译的时候 LLVM 自然会查找到 .modulemap 文件自动生成 Module 信息。你此时就可以在使用  CommonCrypto 的地方使用 modular header 了。\n\n过了几年之后，官方才将该库定义为 module，在 Xcode 自带的 iOS SDK 中 `/usr/include/CommonCrypto` 下可以看到 `module.modulemap` 文件：\n\n\n```\nmodule CommonCrypto [system] [extern_c] {\n      umbrella header \"CommonCrypto.h\"\n      export *\n      module * { export * }\n      \n      module Error {\n          header \"CommonCryptoError.h\"\n          export *\n      }\n      \n      module Random {\n          header \"CommonRandom.h\"\n          export *\n      }\n    }\n\n```\n大家也注意到了在 CommonCrypto 的同级目录中实际上还有很多的系统 C 库代码，并且也有一个 module.modulemap 文件，我裁剪一段代码大家看下：\n\n \n``` \nmodule Compression [system] [extern_c] {\n    header \"compression.h\"\n    export *\n    link \"compression\"\n}\n    \nmodule Darwin [system] [extern_c] [no_undeclared_includes] {\n    // Headers that are repeatedly included, and therefore should not be\n    \t// assigned to any given module.\n    \texclude header \"_structs.h\"\n    \texclude header \"sys/_structs.h\"\n    \n    \t// C standard library\n    \tmodule C {\n    \t\ttextual header \"assert.h\"\n    \n    \t  module setjmp {\n    \t\t\theader \"setjmp.h\"\n    \t\t\texport *\n    \t\t}\n    \n    \t\tmodule signal {\n    \t\t\theader \"signal.h\"\n    \t\t\texport *\n    \t\t}\n    \n    \t\tmodule stdio {\n    \t\t\theader \"stdio.h\"\n    \t\t\texport *\n    \t\t}\n    }\n    \n    module zlib [system] [extern_c] {\n    \theader \"zlib.h\"\n    \texport *\n    \tlink \"z\"\n    }\n    \n    module SQLite3 [system] [extern_c] {\n    \theader \"sqlite3.h\"\n    \tlink \"sqlite3\"\n    \texplicit module Ext {\n    \t\theader \"sqlite3ext.h\"\n    \t\texport *\n    \t}\n    \texport *\n    }\n\n```\n这也是为什么我们在 Swift 代码里可以直接使用类似 `import Darwin.C.stdio` 写法的原因。但是还是存在一些 C 库并没有被定义为 module，而本次用来做 DNS 解析的 `resolv.h` 就是其中一员。\n\n具体到我们开发流程里说，是要解决 modulemap 如何定义，如何和我们目前使用的 Cocoapods 整合的问题了。既然是在作为 Pod 进行开发，自然是需要将 module map 文件加入到 pod 的代码管理中去。比如将其放置于单个 pod 根目录下，然后在 podspec 中配置好路径以便编译的时候 Swift Search Paths 中有它。自然，我们可以建立 resolv.modulemap 如下：\n\n\n```shell \nmodule Resolv [system] {\n    header \"/usr/include/resolv.h\"\n    export *\n}\n```\n\n然后在对应的 podspec 文件中配置 build setting 中的参数，如下所示\n\n\n```ruby\ns.subspec 'Core' do |core|\n    core.source_files   = ['ZHDiagnosisTool/Classes/Core/**/*'] \n    core.preserve_paths = 'ZHDiagnosisTool/Classes/Core/ModuleMap'\n    core.pod_target_xcconfig = {\n        'SWIFT_INCLUDE_PATHS[sdk=macosx*]'           => '$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap',\n        'SWIFT_INCLUDE_PATHS[sdk=iphoneos*]'         => '$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap',\n        'SWIFT_INCLUDE_PATHS[sdk=iphonesimulator*]'  => '$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap',\n      }\nend\n\n```\n可是，问题出在 PODS_ROOTS 这个路径上，如果我们进行本地开发，该路径就是 Cocoapods 执行完毕之后生成的临时 Pods 目录，并不是原始 podspec 文件所在的地方，而官方也表明了，不会对这种 Local Pods 特定提供一个环境变量来获取， 如下链接可以看到：\n\n[local pod development on a project that includes libraries · Issue #809 · CocoaPods/CocoaPods](https://github.com/CocoaPods/CocoaPods/issues/809)\n\n如图中，指定 $(PODS_ROOT) 路径实际上在开发 Local Pod 的时候就会找不到，所以就需要按照上面链接中的方式自行手动拼接路径，所以，我们尽可能不用 PODS_ROOT 这个路径，需要另外找一个不会因为 Pod 位置而变化的路径。\n\n最终参考了以下 repo 中工程的解决方案，\n\n[onmyway133/Arcane](https://github.com/onmyway133/Arcane)\n\n其中作者使用 Pod 的 script phase 来完成 .modulemap 的操作，这样会更加灵活。\n\n这样，针对我们自己本次的需求来看，.podspec 中的 script 如下所写即可：\n\n\n```shell\n# Create\nFRAMEWORK_DIR=\"${BUILT_PRODUCTS_DIR}/RESOLV.framework\"\n          \nif [ -d \"${FRAMEWORK_DIR}\" ]; then\n    echo \"${FRAMEWORK_DIR} already exists, so skipping the rest of the script.\"\n    exit 0\nfi\n          \nmkdir -p \"${FRAMEWORK_DIR}/Modules\"\n          \necho \"module RESOLV [system] {\n    header \\\"${SDKROOT}/usr/include/resolv.h\\\"\n    export *\n}\" > \"${FRAMEWORK_DIR}/Modules/module.modulemap\"\n               \n    \n# Generate fake header...\n[ -d \"${FRAMEWORK_DIR}/Headers\" ] || mkdir \"${FRAMEWORK_DIR}/Headers\"\ntouch \"${FRAMEWORK_DIR}/Headers/resolv.h\"\n    \n# Soft link C header to local framework Headers\nln -sf \"${SDKROOT}/usr/include/resolv.h\" \"${FRAMEWORK_DIR}/Headers/resolv.h\"\n```\n\n每次在编译运行前，我们会自行创建一个 `Resolv.framework`，其中 Header 目录中我们放一个空白文件并且软链接到真正想要链接的头文件上，然后在该 framework 中创建 modulemap 文件。\n\n之后，我们在 .podspec 中指定 script phase 为编译前即可，如下所示，\n\n\n``` ruby\ns.script_phase = {\n    :name => 'Resolv',\n    :script => script_above,\n    :execution_position => :before_compile\n}\n```\n\n这样，通过 `Resolv.framework` 的桥接，Swift 代码中就可以直接通过 `import RESOLV` 来使用了。当然，链接这一环你可以通过以下两种形式达到：\n\n1. 直接在 podspec 文件中指定依赖，如 `core.library = \"resolv\"`\n2. 在 `.modulemap` 文件中显式的 link，如下所示：\n\n```shell\nmodule Resolv [system] {\n    header \"/usr/include/resolv.h\"\n    link \"resolv\"\n    export *\n}\n```\n\n而且通过将 module map 文件放置于 product 产出目录这里也解决了路径指定的问题，因为 product folder 是默认在编译的搜索路径下的。\n\n### 问题解惑\n\n#### 关于某些\n\n## 总结\n\n总结来看，就是想要在纯 Swift 的项目中引入系统 C 库文件（这里指的是未被 modular 化的文件，因为有些 C 文件已经被系统默认封装成了 module 了）。以上只是一些简单的概念讲解，整个编译系统以及套件都是长时间不断演化的结果，这里也只是简单的讲述，有一些概念实际上也只是点到为止，大家如果感兴趣可以多找一些相关资料阅读下，亲自试一试。当然，当然刚开始直接用 Objective-C 来写不就好了，确实，不过通过本次解决这个问题，对 iOS 开发过程中遇到的某些司空见惯的概念（充斥在整个开发周期中）有了更清楚的了解，不是更好。\n\n## 参考资料\n\n1. [Modules](http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf)\n2. [LLVM - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/LLVM)\n3. [Modules - Clang 8 documentation](https://clang.llvm.org/docs/Modules.html#introduction)\n4. [WWDC 2013 Session笔记 - Xcode5和ObjC新特性](https://onevcat.com/2013/06/new-in-xcode5-and-objc/)\n5. [Importing CommonCrypto in a Swift framework](https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785)\n6. [Adding CommonCrypto to custom Swift framework |Apple Developer Forums](https://forums.developer.apple.com/thread/46477)\n7. [How to call C code from Swift - The.Swift.Dev.](https://theswiftdev.com/2018/01/15/how-to-call-c-code-from-swift/)\n8. [Using a C library inside a Swift framework - Swift and iOS Writing - Medium](https://medium.com/swift-and-ios-writing/using-a-c-library-inside-a-swift-framework-d041d7b701d9/)","source":"_posts/Swift-and-Modules.md","raw":"---\ntitle: 在 Swift Framework 中使用 C 文件的过程探索\ndate: 2019-01-03 21:19:24\ntags: Swift, Module, CocoaPods\ncategory: iOS\ntop_img: https://i.imgur.com/NJi1fs6.jpg\n---\n\n\nSwift 真香！\n\n## 问题描述\n\n我们在开发线上诊断工具需求的时候，是以单个 Pod 的形式提供支持，并且代码文件中只有纯 Swift 文件，但是其中需要用到系统的 C 库的一些功能，本次就是使用了系统 C 库中 `resolv.h` 这个文件来进行 DNS 解析所用。\n\n当后期 Pod 功能完善之后，在 Example 工程中也已经编译通过之后，接入主项目中之后遇到了下面这个编译错误：\n\n![Error When Compile](https://i.imgur.com/ADh0sy6.png)\n\n\n具体文字错误信息如下：\n\n\n```txt\n/Users/chen/Repos/Work/ZHDiagnosisTool/ZHDiagnosisTool/Classes/Core/Network/ZHDiagnosisTool-Network-Header.h:8:10: \n    Include of non-modular header inside framework module 'Diagnosis.ZHDiagnosisTool_Network_Header': '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk/usr/include/resolv.h'\n```\n\n大概的意思就是在 Umbrella Header 中加入的 Briding header 指定了 include 一个 C 文件，而该 C 文件本身并不是  Modular Header， 因此编译无法通过。这就涉及了目前 iOS 生态中普遍使用的 Modules 概念。\n\n## 几个概念\n\n### Modules\n\nModules 的概念是 XCode 5 带到 iOS 开发者面前的，从那时起 LLVM 编译器就已经内在支持了，具体关于其历史在 [WWDC 2013 Session笔记 - Xcode5和ObjC新特性](https://onevcat.com/2013/06/new-in-xcode5-and-objc/) 这篇文章中已经讲解的非常详细了，不再赘述，总结一句话就是：\n\n> Modules 是被引入 LLVM 层面的，用以解决之前 C/C++ 系中 #include 和 #import 带来的引用泛滥以及编译时间过长的问题的一种手段。\n\n尤其是在 Swift 引入之后，Module 的概念应该已经深入人心。大家可能已经习惯直接使用 @import 来引用某个 Module，或者其中某个逻辑单元。尤其是使用 CocoaPods 集成开发的时候，其也帮你底层做了一些 Modules 的工作， module 的属性是由定义它的 `.modulemap` 文件来决定的，在 Pods 的工程目录结构中充斥着 `.modulemap` 的身影，其语法大概如下：\n\n``` Shell\nmodule module_name [system] {\n    header \"header.h\"\n    link \"linked_library\"\n    export *\n}\n```\n\n如果对其中 [Modules 的语法](https://clang.llvm.org/docs/Modules.html#module-map-language)感兴趣，可以到 Clang 的官方文档下通读下，你肯定会对 Modules 这一套有更清楚的认识。\n\n### Umbrella Header\n\n说起来，Umbrella Header 是在 Framework 的概念被引入的，你可以理解为一个模块均存在一个 Umbrella Header 用来将那些你想暴露给模块外界调用的头文件包裹在一起。避免使用者在使用该模块的时候需要手动输入多个 Header 的一种解决方案。 iOS 中特指 iOS 8 系统官方加入 Dynamic Framework 之后引入的。\n\n如下所示，没有 Umbrella Header 的情况下你需要将所有需要引入的头文件依次写出。\n\n```objc\n#import <XYZModule/XYZCustomCell.h>\n#import <XYZModule/XYZCustomView.h>\n#import <XYZModule/XYZCustomViewController.h>\n```\n在使用了 Umbrella Header 之后，你只需要下面一行即可。\n\n```objc\n#import <XYZModule/XYZModule.h>\n```\n当然，还存在 umbrella framework，感兴趣大家可以到[官方文档](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC)下观看。\n\n- Bridging-Header\n\n桥接文件是在 Swift 推出之后，Apple 引入目前iOS 生态的一个概念用以桥接 Swift 和 Objective-C 的一种方式 （Mix and Match），如下图所示，如果在 Swift 中想使用 Objective-C 类定义的内容，就需要建立 Bridging Header，然后在其中定义你想要暴露的 OC 头文件。\n\n![Bridging Header](https://i.imgur.com/YwqHEKJ.png)\n\n具体的操作在[官方文档](https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift)有针对在同一个 App Target 和在同一个 Framework 内两种情况均有说明。\n\n> 在梳理这些概念的过程中，发现自己之前对桥接文件有个误区，如果你在 App 的主 Target 中需要进行 OC 和 Swift 的混编，使用 Bridging Header 是必选，如果你是在同一个 Framework 中进行的混编，Bridging-Header 是并不需要的，你需要做的只是在 Umbrella Header 里加入你想暴露给 Swift 文件使用的 OC 头文件即可，之前自己一直是显式的建立一个 Bridging-Header，然后在 Umbrella Header 中引入该头文件，想来这种方式只是将你想暴露在外的头文件进行了二次包裹而已，因为 Cocoapods 是将所有 public header 均加入到 umbrella header 里了，因此单个 framework 内部开发，即使没有 bridge header 也是能够将符号暴露给 Swift 的。\n\n### Cocoapods\n\n我们每次执行 `pod install` 的时候，如果你使用 —verbose 来看详细安装过程就能看到，针对每一个将要被安装的 Pod 均会执行生成 module map 和 umbrella header 这两个阶段，如下所示部分 Install 指令的代码，代码位于 `lib/cocoapods/installer/xcode/pods_project_generator/aggregate_target_installer.rb` \n\n    \n```ruby\ndef install!\n       UI.message \"- Installing target `#{target.name}` #{target.platform}\" do\n       native_target = add_target\n       create_support_files_dir\n       create_support_files_group\n       create_xcconfig_file(native_target)\n       if target.host_requires_frameworks?\n          create_info_plist_file(target.info_plist_path, native_target, target.version, target.platform)\n    \t    create_module_map(native_target)\n          create_umbrella_header(native_target)\n       elsif target.uses_swift?\n          create_module_map(native_target)\n    \t\t\tcreate_umbrella_header(native_target)\n       end\n      \n     # Some Code\n     # Some Code\n     # Some Code      \n    end\n```\n\n很明确，Cocoapods 在 install 某个 Pod 的时候会执行创建 module map 文件以及 umbrella header 文件的工作。详细的代码大家可以直接到 Cocoapods 源码下  `lib/cocoapods/generator` 目录下看，分别是 `module_map.rb` 和 `umbrella_header.rb` 文件。\n\n其中在各自文件的注释部分也有针对生成文件的说明，比如 `module_map.rb` 中说明了 module map 的作用，\n\n> Generates LLVM module map files. A module map file is generated for each Pod and for each Pod target definition that is built as a framework. It specifies a different umbrella header than usual to avoid name conflicts with existing headers of the podspec.\n\n在 `umbrella_header.rb` 中说明了 umbrella header 的作用，\n\n> Generates an umbrella header file for clang modules, which are used by dynamic frameworks on iOS 8 and OSX 10.10 under the hood. If the target is a +PodTarget+, then the umbrella header is required to make all public headers in a convenient manner available without the need to write out header declarations for every library header.\n\n## 问题原因\n\n首先先解答：为什么 Example 工程能够编译通过 而用了主工程是无法编译通过？\n\n因为目前主工程都要求我们自行开发的 pod 以动态 framework 的形式参与，但是在 Example 工程开发的时候我们的 `podfile` 并未指定 `use_frameworks!` 用以产出动态 framework，因此未暴露出该问题，也就是说只有以 framework 的形式的 module 才会有该问题，准确的说，应该是 `Dynamic Framework`\n\n了解了以上概念之后，我们再来看我们的问题，首先我们的问题是在 framework 内部调用系统 C 库代码出现的问题，从 Xcode 的报错，我们知道我们通过 bridging header 引入的 C 文件并不以 module 的形式存在，因此编译器报错。\n\n## 解决过程\n\n其实吧，大家都能想到，使用 Objective-C 做个封装，或者干脆直接调用 C 文件的类用 OC 重写不就完了么，可是如果下次你再遇到了呢？ 或者要改造了一个纯 Swift 库呢？知其所以然，才能避免再次落坑吧。\n\n> 因为 Objective-C 自身编译器是帮你做了 modular 化的，当然，如果你选择了前者，还有个限制，你并不能把上面 C 的头文件放到你的 Objective-C 的头文件中，因为本质上，最后这个头文件还是要暴露给 Umbrella Header 的。\n\n首先，能否允许编译器支持在 module 中引入非 modular 的头文件呢？ \n\nXcode 在 build setting 中提供了  `Allow Non-modular Includes In Framework Modules` 来控制是否允许在当前 framework 中支持非 modular 头文件引入，其并不适用于纯 Swift 项目，而且即使适用，其会导致所有用到该 framework 的地方也不能再适用 module 形式引入头文件了，也就是必须适用平坦式的 `#include \"\"`\n\n![Build Setting](https://i.imgur.com/S4i2chx.png)\n\n\n最后，通过只能从根源上来解决该问题了，既然需要引入的文件是 modular header，我们就要想办法来将其包裹为 module。 在查找解决方案的过程中发现，就在 Swift 刚推出的时候，大家已经遇到这个问题了，遇到最多的就是`CommonCrypto` 经常被使用到的 C 库，常见的 MD5 计算就是其提供的 API，但是在前几年官方并未将该动态库 module 化，因此导致你无法在 Swift 文件中直接使用类似 `#import <CommonCrypto/CommonCrypto.h>` 这种写法。自然而言多了很多解决方案，如下出自 StackOverflow 上 [Importing CommonCrypto in a Swift framework](https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785) 的帖子下面就提供了多种解决方案：\n\n> 还是那句话，你是可以通过 Objective-C 做桥接来达到同样效果的。毕竟 Swift 本身就是一门心思想抛开 C 的历史包袱，因此想拥有一个纯纯的 Swift 代码不沾染一点 C 文件气息，你就要做一些工作。\n\n其中根本问题就是为 `CommonCrypto` 这个 C 编译单元定义 module，上面也提到了 LLVM 是通过 `modulemap` 文件来识别的，所以只要通过 `.modulemap` 来定义即可，\n\n```\n    module CommonCrypto [system] {\n        header \"/usr/include/CommonCrypto/CommonCrypto.h\"\n        export *\n    }\n```\n\n定义的 modulemap 自然可以放到任意目录，只要让编译单元在编译的时候能够搜索的到即可，Xcode 选项的 Build Settings 下的 Swift Compiler - Search Paths 。添加 .modulemap 文件所在路径即可。在编译的时候 LLVM 自然会查找到 .modulemap 文件自动生成 Module 信息。你此时就可以在使用  CommonCrypto 的地方使用 modular header 了。\n\n过了几年之后，官方才将该库定义为 module，在 Xcode 自带的 iOS SDK 中 `/usr/include/CommonCrypto` 下可以看到 `module.modulemap` 文件：\n\n\n```\nmodule CommonCrypto [system] [extern_c] {\n      umbrella header \"CommonCrypto.h\"\n      export *\n      module * { export * }\n      \n      module Error {\n          header \"CommonCryptoError.h\"\n          export *\n      }\n      \n      module Random {\n          header \"CommonRandom.h\"\n          export *\n      }\n    }\n\n```\n大家也注意到了在 CommonCrypto 的同级目录中实际上还有很多的系统 C 库代码，并且也有一个 module.modulemap 文件，我裁剪一段代码大家看下：\n\n \n``` \nmodule Compression [system] [extern_c] {\n    header \"compression.h\"\n    export *\n    link \"compression\"\n}\n    \nmodule Darwin [system] [extern_c] [no_undeclared_includes] {\n    // Headers that are repeatedly included, and therefore should not be\n    \t// assigned to any given module.\n    \texclude header \"_structs.h\"\n    \texclude header \"sys/_structs.h\"\n    \n    \t// C standard library\n    \tmodule C {\n    \t\ttextual header \"assert.h\"\n    \n    \t  module setjmp {\n    \t\t\theader \"setjmp.h\"\n    \t\t\texport *\n    \t\t}\n    \n    \t\tmodule signal {\n    \t\t\theader \"signal.h\"\n    \t\t\texport *\n    \t\t}\n    \n    \t\tmodule stdio {\n    \t\t\theader \"stdio.h\"\n    \t\t\texport *\n    \t\t}\n    }\n    \n    module zlib [system] [extern_c] {\n    \theader \"zlib.h\"\n    \texport *\n    \tlink \"z\"\n    }\n    \n    module SQLite3 [system] [extern_c] {\n    \theader \"sqlite3.h\"\n    \tlink \"sqlite3\"\n    \texplicit module Ext {\n    \t\theader \"sqlite3ext.h\"\n    \t\texport *\n    \t}\n    \texport *\n    }\n\n```\n这也是为什么我们在 Swift 代码里可以直接使用类似 `import Darwin.C.stdio` 写法的原因。但是还是存在一些 C 库并没有被定义为 module，而本次用来做 DNS 解析的 `resolv.h` 就是其中一员。\n\n具体到我们开发流程里说，是要解决 modulemap 如何定义，如何和我们目前使用的 Cocoapods 整合的问题了。既然是在作为 Pod 进行开发，自然是需要将 module map 文件加入到 pod 的代码管理中去。比如将其放置于单个 pod 根目录下，然后在 podspec 中配置好路径以便编译的时候 Swift Search Paths 中有它。自然，我们可以建立 resolv.modulemap 如下：\n\n\n```shell \nmodule Resolv [system] {\n    header \"/usr/include/resolv.h\"\n    export *\n}\n```\n\n然后在对应的 podspec 文件中配置 build setting 中的参数，如下所示\n\n\n```ruby\ns.subspec 'Core' do |core|\n    core.source_files   = ['ZHDiagnosisTool/Classes/Core/**/*'] \n    core.preserve_paths = 'ZHDiagnosisTool/Classes/Core/ModuleMap'\n    core.pod_target_xcconfig = {\n        'SWIFT_INCLUDE_PATHS[sdk=macosx*]'           => '$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap',\n        'SWIFT_INCLUDE_PATHS[sdk=iphoneos*]'         => '$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap',\n        'SWIFT_INCLUDE_PATHS[sdk=iphonesimulator*]'  => '$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap',\n      }\nend\n\n```\n可是，问题出在 PODS_ROOTS 这个路径上，如果我们进行本地开发，该路径就是 Cocoapods 执行完毕之后生成的临时 Pods 目录，并不是原始 podspec 文件所在的地方，而官方也表明了，不会对这种 Local Pods 特定提供一个环境变量来获取， 如下链接可以看到：\n\n[local pod development on a project that includes libraries · Issue #809 · CocoaPods/CocoaPods](https://github.com/CocoaPods/CocoaPods/issues/809)\n\n如图中，指定 $(PODS_ROOT) 路径实际上在开发 Local Pod 的时候就会找不到，所以就需要按照上面链接中的方式自行手动拼接路径，所以，我们尽可能不用 PODS_ROOT 这个路径，需要另外找一个不会因为 Pod 位置而变化的路径。\n\n最终参考了以下 repo 中工程的解决方案，\n\n[onmyway133/Arcane](https://github.com/onmyway133/Arcane)\n\n其中作者使用 Pod 的 script phase 来完成 .modulemap 的操作，这样会更加灵活。\n\n这样，针对我们自己本次的需求来看，.podspec 中的 script 如下所写即可：\n\n\n```shell\n# Create\nFRAMEWORK_DIR=\"${BUILT_PRODUCTS_DIR}/RESOLV.framework\"\n          \nif [ -d \"${FRAMEWORK_DIR}\" ]; then\n    echo \"${FRAMEWORK_DIR} already exists, so skipping the rest of the script.\"\n    exit 0\nfi\n          \nmkdir -p \"${FRAMEWORK_DIR}/Modules\"\n          \necho \"module RESOLV [system] {\n    header \\\"${SDKROOT}/usr/include/resolv.h\\\"\n    export *\n}\" > \"${FRAMEWORK_DIR}/Modules/module.modulemap\"\n               \n    \n# Generate fake header...\n[ -d \"${FRAMEWORK_DIR}/Headers\" ] || mkdir \"${FRAMEWORK_DIR}/Headers\"\ntouch \"${FRAMEWORK_DIR}/Headers/resolv.h\"\n    \n# Soft link C header to local framework Headers\nln -sf \"${SDKROOT}/usr/include/resolv.h\" \"${FRAMEWORK_DIR}/Headers/resolv.h\"\n```\n\n每次在编译运行前，我们会自行创建一个 `Resolv.framework`，其中 Header 目录中我们放一个空白文件并且软链接到真正想要链接的头文件上，然后在该 framework 中创建 modulemap 文件。\n\n之后，我们在 .podspec 中指定 script phase 为编译前即可，如下所示，\n\n\n``` ruby\ns.script_phase = {\n    :name => 'Resolv',\n    :script => script_above,\n    :execution_position => :before_compile\n}\n```\n\n这样，通过 `Resolv.framework` 的桥接，Swift 代码中就可以直接通过 `import RESOLV` 来使用了。当然，链接这一环你可以通过以下两种形式达到：\n\n1. 直接在 podspec 文件中指定依赖，如 `core.library = \"resolv\"`\n2. 在 `.modulemap` 文件中显式的 link，如下所示：\n\n```shell\nmodule Resolv [system] {\n    header \"/usr/include/resolv.h\"\n    link \"resolv\"\n    export *\n}\n```\n\n而且通过将 module map 文件放置于 product 产出目录这里也解决了路径指定的问题，因为 product folder 是默认在编译的搜索路径下的。\n\n### 问题解惑\n\n#### 关于某些\n\n## 总结\n\n总结来看，就是想要在纯 Swift 的项目中引入系统 C 库文件（这里指的是未被 modular 化的文件，因为有些 C 文件已经被系统默认封装成了 module 了）。以上只是一些简单的概念讲解，整个编译系统以及套件都是长时间不断演化的结果，这里也只是简单的讲述，有一些概念实际上也只是点到为止，大家如果感兴趣可以多找一些相关资料阅读下，亲自试一试。当然，当然刚开始直接用 Objective-C 来写不就好了，确实，不过通过本次解决这个问题，对 iOS 开发过程中遇到的某些司空见惯的概念（充斥在整个开发周期中）有了更清楚的了解，不是更好。\n\n## 参考资料\n\n1. [Modules](http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf)\n2. [LLVM - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/LLVM)\n3. [Modules - Clang 8 documentation](https://clang.llvm.org/docs/Modules.html#introduction)\n4. [WWDC 2013 Session笔记 - Xcode5和ObjC新特性](https://onevcat.com/2013/06/new-in-xcode5-and-objc/)\n5. [Importing CommonCrypto in a Swift framework](https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785)\n6. [Adding CommonCrypto to custom Swift framework |Apple Developer Forums](https://forums.developer.apple.com/thread/46477)\n7. [How to call C code from Swift - The.Swift.Dev.](https://theswiftdev.com/2018/01/15/how-to-call-c-code-from-swift/)\n8. [Using a C library inside a Swift framework - Swift and iOS Writing - Medium](https://medium.com/swift-and-ios-writing/using-a-c-library-inside-a-swift-framework-d041d7b701d9/)","slug":"Swift-and-Modules","published":1,"updated":"2019-01-07T04:12:30.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftcy006279po5f7dzvcq","content":"<p>Swift 真香！</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>我们在开发线上诊断工具需求的时候，是以单个 Pod 的形式提供支持，并且代码文件中只有纯 Swift 文件，但是其中需要用到系统的 C 库的一些功能，本次就是使用了系统 C 库中 <code>resolv.h</code> 这个文件来进行 DNS 解析所用。</p>\n<p>当后期 Pod 功能完善之后，在 Example 工程中也已经编译通过之后，接入主项目中之后遇到了下面这个编译错误：</p>\n<p><img src=\"https://i.imgur.com/ADh0sy6.png\" alt=\"Error When Compile\"></p>\n<p>具体文字错误信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/Users/chen/Repos/Work/ZHDiagnosisTool/ZHDiagnosisTool/Classes/Core/Network/ZHDiagnosisTool-Network-Header.h:8:10: </span><br><span class=\"line\">    Include of non-modular header inside framework module &apos;Diagnosis.ZHDiagnosisTool_Network_Header&apos;: &apos;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk/usr/include/resolv.h&apos;</span><br></pre></td></tr></table></figure>\n<p>大概的意思就是在 Umbrella Header 中加入的 Briding header 指定了 include 一个 C 文件，而该 C 文件本身并不是  Modular Header， 因此编译无法通过。这就涉及了目前 iOS 生态中普遍使用的 Modules 概念。</p>\n<h2 id=\"几个概念\"><a href=\"#几个概念\" class=\"headerlink\" title=\"几个概念\"></a>几个概念</h2><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Modules 的概念是 XCode 5 带到 iOS 开发者面前的，从那时起 LLVM 编译器就已经内在支持了，具体关于其历史在 <a href=\"https://onevcat.com/2013/06/new-in-xcode5-and-objc/\" target=\"_blank\" rel=\"noopener\">WWDC 2013 Session笔记 - Xcode5和ObjC新特性</a> 这篇文章中已经讲解的非常详细了，不再赘述，总结一句话就是：</p>\n<blockquote>\n<p>Modules 是被引入 LLVM 层面的，用以解决之前 C/C++ 系中 #include 和 #import 带来的引用泛滥以及编译时间过长的问题的一种手段。</p>\n</blockquote>\n<p>尤其是在 Swift 引入之后，Module 的概念应该已经深入人心。大家可能已经习惯直接使用 @import 来引用某个 Module，或者其中某个逻辑单元。尤其是使用 CocoaPods 集成开发的时候，其也帮你底层做了一些 Modules 的工作， module 的属性是由定义它的 <code>.modulemap</code> 文件来决定的，在 Pods 的工程目录结构中充斥着 <code>.modulemap</code> 的身影，其语法大概如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">module module_name [system] &#123;</span><br><span class=\"line\">    header \"header.h\"</span><br><span class=\"line\">    link \"linked_library\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果对其中 <a href=\"https://clang.llvm.org/docs/Modules.html#module-map-language\" target=\"_blank\" rel=\"noopener\">Modules 的语法</a>感兴趣，可以到 Clang 的官方文档下通读下，你肯定会对 Modules 这一套有更清楚的认识。</p>\n<h3 id=\"Umbrella-Header\"><a href=\"#Umbrella-Header\" class=\"headerlink\" title=\"Umbrella Header\"></a>Umbrella Header</h3><p>说起来，Umbrella Header 是在 Framework 的概念被引入的，你可以理解为一个模块均存在一个 Umbrella Header 用来将那些你想暴露给模块外界调用的头文件包裹在一起。避免使用者在使用该模块的时候需要手动输入多个 Header 的一种解决方案。 iOS 中特指 iOS 8 系统官方加入 Dynamic Framework 之后引入的。</p>\n<p>如下所示，没有 Umbrella Header 的情况下你需要将所有需要引入的头文件依次写出。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZCustomCell.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZCustomView.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZCustomViewController.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>在使用了 Umbrella Header 之后，你只需要下面一行即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZModule.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>当然，还存在 umbrella framework，感兴趣大家可以到<a href=\"https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC\" target=\"_blank\" rel=\"noopener\">官方文档</a>下观看。</p>\n<ul>\n<li>Bridging-Header</li>\n</ul>\n<p>桥接文件是在 Swift 推出之后，Apple 引入目前iOS 生态的一个概念用以桥接 Swift 和 Objective-C 的一种方式 （Mix and Match），如下图所示，如果在 Swift 中想使用 Objective-C 类定义的内容，就需要建立 Bridging Header，然后在其中定义你想要暴露的 OC 头文件。</p>\n<p><img src=\"https://i.imgur.com/YwqHEKJ.png\" alt=\"Bridging Header\"></p>\n<p>具体的操作在<a href=\"https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift\" target=\"_blank\" rel=\"noopener\">官方文档</a>有针对在同一个 App Target 和在同一个 Framework 内两种情况均有说明。</p>\n<blockquote>\n<p>在梳理这些概念的过程中，发现自己之前对桥接文件有个误区，如果你在 App 的主 Target 中需要进行 OC 和 Swift 的混编，使用 Bridging Header 是必选，如果你是在同一个 Framework 中进行的混编，Bridging-Header 是并不需要的，你需要做的只是在 Umbrella Header 里加入你想暴露给 Swift 文件使用的 OC 头文件即可，之前自己一直是显式的建立一个 Bridging-Header，然后在 Umbrella Header 中引入该头文件，想来这种方式只是将你想暴露在外的头文件进行了二次包裹而已，因为 Cocoapods 是将所有 public header 均加入到 umbrella header 里了，因此单个 framework 内部开发，即使没有 bridge header 也是能够将符号暴露给 Swift 的。</p>\n</blockquote>\n<h3 id=\"Cocoapods\"><a href=\"#Cocoapods\" class=\"headerlink\" title=\"Cocoapods\"></a>Cocoapods</h3><p>我们每次执行 <code>pod install</code> 的时候，如果你使用 —verbose 来看详细安装过程就能看到，针对每一个将要被安装的 Pod 均会执行生成 module map 和 umbrella header 这两个阶段，如下所示部分 Install 指令的代码，代码位于 <code>lib/cocoapods/installer/xcode/pods_project_generator/aggregate_target_installer.rb</code> </p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">install!</span></span></span><br><span class=\"line\">       UI.message <span class=\"string\">\"- Installing target `<span class=\"subst\">#&#123;target.name&#125;</span>` <span class=\"subst\">#&#123;target.platform&#125;</span>\"</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">       native_target = add_target</span><br><span class=\"line\">       create_support_files_dir</span><br><span class=\"line\">       create_support_files_group</span><br><span class=\"line\">       create_xcconfig_file(native_target)</span><br><span class=\"line\">       <span class=\"keyword\">if</span> target.host_requires_frameworks?</span><br><span class=\"line\">          create_info_plist_file(target.info_plist_path, native_target, target.version, target.platform)</span><br><span class=\"line\">    \t    create_module_map(native_target)</span><br><span class=\"line\">          create_umbrella_header(native_target)</span><br><span class=\"line\">       <span class=\"keyword\">elsif</span> target.uses_swift?</span><br><span class=\"line\">          create_module_map(native_target)</span><br><span class=\"line\">    \t\t\tcreate_umbrella_header(native_target)</span><br><span class=\"line\">       <span class=\"keyword\">end</span></span><br><span class=\"line\">      </span><br><span class=\"line\">     <span class=\"comment\"># Some Code</span></span><br><span class=\"line\">     <span class=\"comment\"># Some Code</span></span><br><span class=\"line\">     <span class=\"comment\"># Some Code      </span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>很明确，Cocoapods 在 install 某个 Pod 的时候会执行创建 module map 文件以及 umbrella header 文件的工作。详细的代码大家可以直接到 Cocoapods 源码下  <code>lib/cocoapods/generator</code> 目录下看，分别是 <code>module_map.rb</code> 和 <code>umbrella_header.rb</code> 文件。</p>\n<p>其中在各自文件的注释部分也有针对生成文件的说明，比如 <code>module_map.rb</code> 中说明了 module map 的作用，</p>\n<blockquote>\n<p>Generates LLVM module map files. A module map file is generated for each Pod and for each Pod target definition that is built as a framework. It specifies a different umbrella header than usual to avoid name conflicts with existing headers of the podspec.</p>\n</blockquote>\n<p>在 <code>umbrella_header.rb</code> 中说明了 umbrella header 的作用，</p>\n<blockquote>\n<p>Generates an umbrella header file for clang modules, which are used by dynamic frameworks on iOS 8 and OSX 10.10 under the hood. If the target is a +PodTarget+, then the umbrella header is required to make all public headers in a convenient manner available without the need to write out header declarations for every library header.</p>\n</blockquote>\n<h2 id=\"问题原因\"><a href=\"#问题原因\" class=\"headerlink\" title=\"问题原因\"></a>问题原因</h2><p>首先先解答：为什么 Example 工程能够编译通过 而用了主工程是无法编译通过？</p>\n<p>因为目前主工程都要求我们自行开发的 pod 以动态 framework 的形式参与，但是在 Example 工程开发的时候我们的 <code>podfile</code> 并未指定 <code>use_frameworks!</code> 用以产出动态 framework，因此未暴露出该问题，也就是说只有以 framework 的形式的 module 才会有该问题，准确的说，应该是 <code>Dynamic Framework</code></p>\n<p>了解了以上概念之后，我们再来看我们的问题，首先我们的问题是在 framework 内部调用系统 C 库代码出现的问题，从 Xcode 的报错，我们知道我们通过 bridging header 引入的 C 文件并不以 module 的形式存在，因此编译器报错。</p>\n<h2 id=\"解决过程\"><a href=\"#解决过程\" class=\"headerlink\" title=\"解决过程\"></a>解决过程</h2><p>其实吧，大家都能想到，使用 Objective-C 做个封装，或者干脆直接调用 C 文件的类用 OC 重写不就完了么，可是如果下次你再遇到了呢？ 或者要改造了一个纯 Swift 库呢？知其所以然，才能避免再次落坑吧。</p>\n<blockquote>\n<p>因为 Objective-C 自身编译器是帮你做了 modular 化的，当然，如果你选择了前者，还有个限制，你并不能把上面 C 的头文件放到你的 Objective-C 的头文件中，因为本质上，最后这个头文件还是要暴露给 Umbrella Header 的。</p>\n</blockquote>\n<p>首先，能否允许编译器支持在 module 中引入非 modular 的头文件呢？ </p>\n<p>Xcode 在 build setting 中提供了  <code>Allow Non-modular Includes In Framework Modules</code> 来控制是否允许在当前 framework 中支持非 modular 头文件引入，其并不适用于纯 Swift 项目，而且即使适用，其会导致所有用到该 framework 的地方也不能再适用 module 形式引入头文件了，也就是必须适用平坦式的 <code>#include &quot;&quot;</code></p>\n<p><img src=\"https://i.imgur.com/S4i2chx.png\" alt=\"Build Setting\"></p>\n<p>最后，通过只能从根源上来解决该问题了，既然需要引入的文件是 modular header，我们就要想办法来将其包裹为 module。 在查找解决方案的过程中发现，就在 Swift 刚推出的时候，大家已经遇到这个问题了，遇到最多的就是<code>CommonCrypto</code> 经常被使用到的 C 库，常见的 MD5 计算就是其提供的 API，但是在前几年官方并未将该动态库 module 化，因此导致你无法在 Swift 文件中直接使用类似 <code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code> 这种写法。自然而言多了很多解决方案，如下出自 StackOverflow 上 <a href=\"https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785\" target=\"_blank\" rel=\"noopener\">Importing CommonCrypto in a Swift framework</a> 的帖子下面就提供了多种解决方案：</p>\n<blockquote>\n<p>还是那句话，你是可以通过 Objective-C 做桥接来达到同样效果的。毕竟 Swift 本身就是一门心思想抛开 C 的历史包袱，因此想拥有一个纯纯的 Swift 代码不沾染一点 C 文件气息，你就要做一些工作。</p>\n</blockquote>\n<p>其中根本问题就是为 <code>CommonCrypto</code> 这个 C 编译单元定义 module，上面也提到了 LLVM 是通过 <code>modulemap</code> 文件来识别的，所以只要通过 <code>.modulemap</code> 来定义即可，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">module CommonCrypto [system] &#123;</span><br><span class=\"line\">    header &quot;/usr/include/CommonCrypto/CommonCrypto.h&quot;</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义的 modulemap 自然可以放到任意目录，只要让编译单元在编译的时候能够搜索的到即可，Xcode 选项的 Build Settings 下的 Swift Compiler - Search Paths 。添加 .modulemap 文件所在路径即可。在编译的时候 LLVM 自然会查找到 .modulemap 文件自动生成 Module 信息。你此时就可以在使用  CommonCrypto 的地方使用 modular header 了。</p>\n<p>过了几年之后，官方才将该库定义为 module，在 Xcode 自带的 iOS SDK 中 <code>/usr/include/CommonCrypto</code> 下可以看到 <code>module.modulemap</code> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">module CommonCrypto [system] [extern_c] &#123;</span><br><span class=\"line\">      umbrella header &quot;CommonCrypto.h&quot;</span><br><span class=\"line\">      export *</span><br><span class=\"line\">      module * &#123; export * &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      module Error &#123;</span><br><span class=\"line\">          header &quot;CommonCryptoError.h&quot;</span><br><span class=\"line\">          export *</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      module Random &#123;</span><br><span class=\"line\">          header &quot;CommonRandom.h&quot;</span><br><span class=\"line\">          export *</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>大家也注意到了在 CommonCrypto 的同级目录中实际上还有很多的系统 C 库代码，并且也有一个 module.modulemap 文件，我裁剪一段代码大家看下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">module Compression [system] [extern_c] &#123;</span><br><span class=\"line\">    header &quot;compression.h&quot;</span><br><span class=\"line\">    export *</span><br><span class=\"line\">    link &quot;compression&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">module Darwin [system] [extern_c] [no_undeclared_includes] &#123;</span><br><span class=\"line\">    // Headers that are repeatedly included, and therefore should not be</span><br><span class=\"line\">    \t// assigned to any given module.</span><br><span class=\"line\">    \texclude header &quot;_structs.h&quot;</span><br><span class=\"line\">    \texclude header &quot;sys/_structs.h&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t// C standard library</span><br><span class=\"line\">    \tmodule C &#123;</span><br><span class=\"line\">    \t\ttextual header &quot;assert.h&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t  module setjmp &#123;</span><br><span class=\"line\">    \t\t\theader &quot;setjmp.h&quot;</span><br><span class=\"line\">    \t\t\texport *</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t\tmodule signal &#123;</span><br><span class=\"line\">    \t\t\theader &quot;signal.h&quot;</span><br><span class=\"line\">    \t\t\texport *</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t\tmodule stdio &#123;</span><br><span class=\"line\">    \t\t\theader &quot;stdio.h&quot;</span><br><span class=\"line\">    \t\t\texport *</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    module zlib [system] [extern_c] &#123;</span><br><span class=\"line\">    \theader &quot;zlib.h&quot;</span><br><span class=\"line\">    \texport *</span><br><span class=\"line\">    \tlink &quot;z&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    module SQLite3 [system] [extern_c] &#123;</span><br><span class=\"line\">    \theader &quot;sqlite3.h&quot;</span><br><span class=\"line\">    \tlink &quot;sqlite3&quot;</span><br><span class=\"line\">    \texplicit module Ext &#123;</span><br><span class=\"line\">    \t\theader &quot;sqlite3ext.h&quot;</span><br><span class=\"line\">    \t\texport *</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \texport *</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这也是为什么我们在 Swift 代码里可以直接使用类似 <code>import Darwin.C.stdio</code> 写法的原因。但是还是存在一些 C 库并没有被定义为 module，而本次用来做 DNS 解析的 <code>resolv.h</code> 就是其中一员。</p>\n<p>具体到我们开发流程里说，是要解决 modulemap 如何定义，如何和我们目前使用的 Cocoapods 整合的问题了。既然是在作为 Pod 进行开发，自然是需要将 module map 文件加入到 pod 的代码管理中去。比如将其放置于单个 pod 根目录下，然后在 podspec 中配置好路径以便编译的时候 Swift Search Paths 中有它。自然，我们可以建立 resolv.modulemap 如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">module Resolv [system] &#123;</span><br><span class=\"line\">    header \"/usr/include/resolv.h\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在对应的 podspec 文件中配置 build setting 中的参数，如下所示</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.subspec <span class=\"string\">'Core'</span> <span class=\"keyword\">do</span> <span class=\"params\">|core|</span></span><br><span class=\"line\">    core.source_files   = [<span class=\"string\">'ZHDiagnosisTool/Classes/Core/**/*'</span>] </span><br><span class=\"line\">    core.preserve_paths = <span class=\"string\">'ZHDiagnosisTool/Classes/Core/ModuleMap'</span></span><br><span class=\"line\">    core.pod_target_xcconfig = &#123;</span><br><span class=\"line\">        <span class=\"string\">'SWIFT_INCLUDE_PATHS[sdk=macosx*]'</span>           =&gt; <span class=\"string\">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class=\"line\">        <span class=\"string\">'SWIFT_INCLUDE_PATHS[sdk=iphoneos*]'</span>         =&gt; <span class=\"string\">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class=\"line\">        <span class=\"string\">'SWIFT_INCLUDE_PATHS[sdk=iphonesimulator*]'</span>  =&gt; <span class=\"string\">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>可是，问题出在 PODS_ROOTS 这个路径上，如果我们进行本地开发，该路径就是 Cocoapods 执行完毕之后生成的临时 Pods 目录，并不是原始 podspec 文件所在的地方，而官方也表明了，不会对这种 Local Pods 特定提供一个环境变量来获取， 如下链接可以看到：</p>\n<p><a href=\"https://github.com/CocoaPods/CocoaPods/issues/809\" target=\"_blank\" rel=\"noopener\">local pod development on a project that includes libraries · Issue #809 · CocoaPods/CocoaPods</a></p>\n<p>如图中，指定 $(PODS_ROOT) 路径实际上在开发 Local Pod 的时候就会找不到，所以就需要按照上面链接中的方式自行手动拼接路径，所以，我们尽可能不用 PODS_ROOT 这个路径，需要另外找一个不会因为 Pod 位置而变化的路径。</p>\n<p>最终参考了以下 repo 中工程的解决方案，</p>\n<p><a href=\"https://github.com/onmyway133/Arcane\" target=\"_blank\" rel=\"noopener\">onmyway133/Arcane</a></p>\n<p>其中作者使用 Pod 的 script phase 来完成 .modulemap 的操作，这样会更加灵活。</p>\n<p>这样，针对我们自己本次的需求来看，.podspec 中的 script 如下所写即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> Create</span><br><span class=\"line\">FRAMEWORK_DIR=\"$&#123;BUILT_PRODUCTS_DIR&#125;/RESOLV.framework\"</span><br><span class=\"line\">          </span><br><span class=\"line\">if [ -d \"$&#123;FRAMEWORK_DIR&#125;\" ]; then</span><br><span class=\"line\">    echo \"$&#123;FRAMEWORK_DIR&#125; already exists, so skipping the rest of the script.\"</span><br><span class=\"line\">    exit 0</span><br><span class=\"line\">fi</span><br><span class=\"line\">          </span><br><span class=\"line\">mkdir -p \"$&#123;FRAMEWORK_DIR&#125;/Modules\"</span><br><span class=\"line\">          </span><br><span class=\"line\">echo \"module RESOLV [system] &#123;</span><br><span class=\"line\">    header \\\"$&#123;SDKROOT&#125;/usr/include/resolv.h\\\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;\" &gt; \"$&#123;FRAMEWORK_DIR&#125;/Modules/module.modulemap\"</span><br><span class=\"line\">               </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#</span> Generate fake header...</span><br><span class=\"line\">[ -d \"$&#123;FRAMEWORK_DIR&#125;/Headers\" ] || mkdir \"$&#123;FRAMEWORK_DIR&#125;/Headers\"</span><br><span class=\"line\">touch \"$&#123;FRAMEWORK_DIR&#125;/Headers/resolv.h\"</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#</span> Soft link C header to local framework Headers</span><br><span class=\"line\">ln -sf \"$&#123;SDKROOT&#125;/usr/include/resolv.h\" \"$&#123;FRAMEWORK_DIR&#125;/Headers/resolv.h\"</span><br></pre></td></tr></table></figure>\n<p>每次在编译运行前，我们会自行创建一个 <code>Resolv.framework</code>，其中 Header 目录中我们放一个空白文件并且软链接到真正想要链接的头文件上，然后在该 framework 中创建 modulemap 文件。</p>\n<p>之后，我们在 .podspec 中指定 script phase 为编译前即可，如下所示，</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.script_phase = &#123;</span><br><span class=\"line\">    <span class=\"symbol\">:name</span> =&gt; <span class=\"string\">'Resolv'</span>,</span><br><span class=\"line\">    <span class=\"symbol\">:script</span> =&gt; script_above,</span><br><span class=\"line\">    <span class=\"symbol\">:execution_position</span> =&gt; <span class=\"symbol\">:before_compile</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，通过 <code>Resolv.framework</code> 的桥接，Swift 代码中就可以直接通过 <code>import RESOLV</code> 来使用了。当然，链接这一环你可以通过以下两种形式达到：</p>\n<ol>\n<li>直接在 podspec 文件中指定依赖，如 <code>core.library = &quot;resolv&quot;</code></li>\n<li>在 <code>.modulemap</code> 文件中显式的 link，如下所示：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">module Resolv [system] &#123;</span><br><span class=\"line\">    header \"/usr/include/resolv.h\"</span><br><span class=\"line\">    link \"resolv\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而且通过将 module map 文件放置于 product 产出目录这里也解决了路径指定的问题，因为 product folder 是默认在编译的搜索路径下的。</p>\n<h3 id=\"问题解惑\"><a href=\"#问题解惑\" class=\"headerlink\" title=\"问题解惑\"></a>问题解惑</h3><h4 id=\"关于某些\"><a href=\"#关于某些\" class=\"headerlink\" title=\"关于某些\"></a>关于某些</h4><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结来看，就是想要在纯 Swift 的项目中引入系统 C 库文件（这里指的是未被 modular 化的文件，因为有些 C 文件已经被系统默认封装成了 module 了）。以上只是一些简单的概念讲解，整个编译系统以及套件都是长时间不断演化的结果，这里也只是简单的讲述，有一些概念实际上也只是点到为止，大家如果感兴趣可以多找一些相关资料阅读下，亲自试一试。当然，当然刚开始直接用 Objective-C 来写不就好了，确实，不过通过本次解决这个问题，对 iOS 开发过程中遇到的某些司空见惯的概念（充斥在整个开发周期中）有了更清楚的了解，不是更好。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf\" target=\"_blank\" rel=\"noopener\">Modules</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM - 维基百科，自由的百科全书</a></li>\n<li><a href=\"https://clang.llvm.org/docs/Modules.html#introduction\" target=\"_blank\" rel=\"noopener\">Modules - Clang 8 documentation</a></li>\n<li><a href=\"https://onevcat.com/2013/06/new-in-xcode5-and-objc/\" target=\"_blank\" rel=\"noopener\">WWDC 2013 Session笔记 - Xcode5和ObjC新特性</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785\" target=\"_blank\" rel=\"noopener\">Importing CommonCrypto in a Swift framework</a></li>\n<li><a href=\"https://forums.developer.apple.com/thread/46477\" target=\"_blank\" rel=\"noopener\">Adding CommonCrypto to custom Swift framework |Apple Developer Forums</a></li>\n<li><a href=\"https://theswiftdev.com/2018/01/15/how-to-call-c-code-from-swift/\" target=\"_blank\" rel=\"noopener\">How to call C code from Swift - The.Swift.Dev.</a></li>\n<li><a href=\"https://medium.com/swift-and-ios-writing/using-a-c-library-inside-a-swift-framework-d041d7b701d9/\" target=\"_blank\" rel=\"noopener\">Using a C library inside a Swift framework - Swift and iOS Writing - Medium</a></li>\n</ol>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"","more":"<p>Swift 真香！</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>我们在开发线上诊断工具需求的时候，是以单个 Pod 的形式提供支持，并且代码文件中只有纯 Swift 文件，但是其中需要用到系统的 C 库的一些功能，本次就是使用了系统 C 库中 <code>resolv.h</code> 这个文件来进行 DNS 解析所用。</p>\n<p>当后期 Pod 功能完善之后，在 Example 工程中也已经编译通过之后，接入主项目中之后遇到了下面这个编译错误：</p>\n<p><img src=\"https://i.imgur.com/ADh0sy6.png\" alt=\"Error When Compile\"></p>\n<p>具体文字错误信息如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/Users/chen/Repos/Work/ZHDiagnosisTool/ZHDiagnosisTool/Classes/Core/Network/ZHDiagnosisTool-Network-Header.h:8:10: </span><br><span class=\"line\">    Include of non-modular header inside framework module &apos;Diagnosis.ZHDiagnosisTool_Network_Header&apos;: &apos;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk/usr/include/resolv.h&apos;</span><br></pre></td></tr></table></figure>\n<p>大概的意思就是在 Umbrella Header 中加入的 Briding header 指定了 include 一个 C 文件，而该 C 文件本身并不是  Modular Header， 因此编译无法通过。这就涉及了目前 iOS 生态中普遍使用的 Modules 概念。</p>\n<h2 id=\"几个概念\"><a href=\"#几个概念\" class=\"headerlink\" title=\"几个概念\"></a>几个概念</h2><h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>Modules 的概念是 XCode 5 带到 iOS 开发者面前的，从那时起 LLVM 编译器就已经内在支持了，具体关于其历史在 <a href=\"https://onevcat.com/2013/06/new-in-xcode5-and-objc/\" target=\"_blank\" rel=\"noopener\">WWDC 2013 Session笔记 - Xcode5和ObjC新特性</a> 这篇文章中已经讲解的非常详细了，不再赘述，总结一句话就是：</p>\n<blockquote>\n<p>Modules 是被引入 LLVM 层面的，用以解决之前 C/C++ 系中 #include 和 #import 带来的引用泛滥以及编译时间过长的问题的一种手段。</p>\n</blockquote>\n<p>尤其是在 Swift 引入之后，Module 的概念应该已经深入人心。大家可能已经习惯直接使用 @import 来引用某个 Module，或者其中某个逻辑单元。尤其是使用 CocoaPods 集成开发的时候，其也帮你底层做了一些 Modules 的工作， module 的属性是由定义它的 <code>.modulemap</code> 文件来决定的，在 Pods 的工程目录结构中充斥着 <code>.modulemap</code> 的身影，其语法大概如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">module module_name [system] &#123;</span><br><span class=\"line\">    header \"header.h\"</span><br><span class=\"line\">    link \"linked_library\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果对其中 <a href=\"https://clang.llvm.org/docs/Modules.html#module-map-language\" target=\"_blank\" rel=\"noopener\">Modules 的语法</a>感兴趣，可以到 Clang 的官方文档下通读下，你肯定会对 Modules 这一套有更清楚的认识。</p>\n<h3 id=\"Umbrella-Header\"><a href=\"#Umbrella-Header\" class=\"headerlink\" title=\"Umbrella Header\"></a>Umbrella Header</h3><p>说起来，Umbrella Header 是在 Framework 的概念被引入的，你可以理解为一个模块均存在一个 Umbrella Header 用来将那些你想暴露给模块外界调用的头文件包裹在一起。避免使用者在使用该模块的时候需要手动输入多个 Header 的一种解决方案。 iOS 中特指 iOS 8 系统官方加入 Dynamic Framework 之后引入的。</p>\n<p>如下所示，没有 Umbrella Header 的情况下你需要将所有需要引入的头文件依次写出。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZCustomCell.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZCustomView.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZCustomViewController.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>在使用了 Umbrella Header 之后，你只需要下面一行即可。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;XYZModule/XYZModule.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>当然，还存在 umbrella framework，感兴趣大家可以到<a href=\"https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC\" target=\"_blank\" rel=\"noopener\">官方文档</a>下观看。</p>\n<ul>\n<li>Bridging-Header</li>\n</ul>\n<p>桥接文件是在 Swift 推出之后，Apple 引入目前iOS 生态的一个概念用以桥接 Swift 和 Objective-C 的一种方式 （Mix and Match），如下图所示，如果在 Swift 中想使用 Objective-C 类定义的内容，就需要建立 Bridging Header，然后在其中定义你想要暴露的 OC 头文件。</p>\n<p><img src=\"https://i.imgur.com/YwqHEKJ.png\" alt=\"Bridging Header\"></p>\n<p>具体的操作在<a href=\"https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift\" target=\"_blank\" rel=\"noopener\">官方文档</a>有针对在同一个 App Target 和在同一个 Framework 内两种情况均有说明。</p>\n<blockquote>\n<p>在梳理这些概念的过程中，发现自己之前对桥接文件有个误区，如果你在 App 的主 Target 中需要进行 OC 和 Swift 的混编，使用 Bridging Header 是必选，如果你是在同一个 Framework 中进行的混编，Bridging-Header 是并不需要的，你需要做的只是在 Umbrella Header 里加入你想暴露给 Swift 文件使用的 OC 头文件即可，之前自己一直是显式的建立一个 Bridging-Header，然后在 Umbrella Header 中引入该头文件，想来这种方式只是将你想暴露在外的头文件进行了二次包裹而已，因为 Cocoapods 是将所有 public header 均加入到 umbrella header 里了，因此单个 framework 内部开发，即使没有 bridge header 也是能够将符号暴露给 Swift 的。</p>\n</blockquote>\n<h3 id=\"Cocoapods\"><a href=\"#Cocoapods\" class=\"headerlink\" title=\"Cocoapods\"></a>Cocoapods</h3><p>我们每次执行 <code>pod install</code> 的时候，如果你使用 —verbose 来看详细安装过程就能看到，针对每一个将要被安装的 Pod 均会执行生成 module map 和 umbrella header 这两个阶段，如下所示部分 Install 指令的代码，代码位于 <code>lib/cocoapods/installer/xcode/pods_project_generator/aggregate_target_installer.rb</code> </p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">install!</span></span></span><br><span class=\"line\">       UI.message <span class=\"string\">\"- Installing target `<span class=\"subst\">#&#123;target.name&#125;</span>` <span class=\"subst\">#&#123;target.platform&#125;</span>\"</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">       native_target = add_target</span><br><span class=\"line\">       create_support_files_dir</span><br><span class=\"line\">       create_support_files_group</span><br><span class=\"line\">       create_xcconfig_file(native_target)</span><br><span class=\"line\">       <span class=\"keyword\">if</span> target.host_requires_frameworks?</span><br><span class=\"line\">          create_info_plist_file(target.info_plist_path, native_target, target.version, target.platform)</span><br><span class=\"line\">    \t    create_module_map(native_target)</span><br><span class=\"line\">          create_umbrella_header(native_target)</span><br><span class=\"line\">       <span class=\"keyword\">elsif</span> target.uses_swift?</span><br><span class=\"line\">          create_module_map(native_target)</span><br><span class=\"line\">    \t\t\tcreate_umbrella_header(native_target)</span><br><span class=\"line\">       <span class=\"keyword\">end</span></span><br><span class=\"line\">      </span><br><span class=\"line\">     <span class=\"comment\"># Some Code</span></span><br><span class=\"line\">     <span class=\"comment\"># Some Code</span></span><br><span class=\"line\">     <span class=\"comment\"># Some Code      </span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>很明确，Cocoapods 在 install 某个 Pod 的时候会执行创建 module map 文件以及 umbrella header 文件的工作。详细的代码大家可以直接到 Cocoapods 源码下  <code>lib/cocoapods/generator</code> 目录下看，分别是 <code>module_map.rb</code> 和 <code>umbrella_header.rb</code> 文件。</p>\n<p>其中在各自文件的注释部分也有针对生成文件的说明，比如 <code>module_map.rb</code> 中说明了 module map 的作用，</p>\n<blockquote>\n<p>Generates LLVM module map files. A module map file is generated for each Pod and for each Pod target definition that is built as a framework. It specifies a different umbrella header than usual to avoid name conflicts with existing headers of the podspec.</p>\n</blockquote>\n<p>在 <code>umbrella_header.rb</code> 中说明了 umbrella header 的作用，</p>\n<blockquote>\n<p>Generates an umbrella header file for clang modules, which are used by dynamic frameworks on iOS 8 and OSX 10.10 under the hood. If the target is a +PodTarget+, then the umbrella header is required to make all public headers in a convenient manner available without the need to write out header declarations for every library header.</p>\n</blockquote>\n<h2 id=\"问题原因\"><a href=\"#问题原因\" class=\"headerlink\" title=\"问题原因\"></a>问题原因</h2><p>首先先解答：为什么 Example 工程能够编译通过 而用了主工程是无法编译通过？</p>\n<p>因为目前主工程都要求我们自行开发的 pod 以动态 framework 的形式参与，但是在 Example 工程开发的时候我们的 <code>podfile</code> 并未指定 <code>use_frameworks!</code> 用以产出动态 framework，因此未暴露出该问题，也就是说只有以 framework 的形式的 module 才会有该问题，准确的说，应该是 <code>Dynamic Framework</code></p>\n<p>了解了以上概念之后，我们再来看我们的问题，首先我们的问题是在 framework 内部调用系统 C 库代码出现的问题，从 Xcode 的报错，我们知道我们通过 bridging header 引入的 C 文件并不以 module 的形式存在，因此编译器报错。</p>\n<h2 id=\"解决过程\"><a href=\"#解决过程\" class=\"headerlink\" title=\"解决过程\"></a>解决过程</h2><p>其实吧，大家都能想到，使用 Objective-C 做个封装，或者干脆直接调用 C 文件的类用 OC 重写不就完了么，可是如果下次你再遇到了呢？ 或者要改造了一个纯 Swift 库呢？知其所以然，才能避免再次落坑吧。</p>\n<blockquote>\n<p>因为 Objective-C 自身编译器是帮你做了 modular 化的，当然，如果你选择了前者，还有个限制，你并不能把上面 C 的头文件放到你的 Objective-C 的头文件中，因为本质上，最后这个头文件还是要暴露给 Umbrella Header 的。</p>\n</blockquote>\n<p>首先，能否允许编译器支持在 module 中引入非 modular 的头文件呢？ </p>\n<p>Xcode 在 build setting 中提供了  <code>Allow Non-modular Includes In Framework Modules</code> 来控制是否允许在当前 framework 中支持非 modular 头文件引入，其并不适用于纯 Swift 项目，而且即使适用，其会导致所有用到该 framework 的地方也不能再适用 module 形式引入头文件了，也就是必须适用平坦式的 <code>#include &quot;&quot;</code></p>\n<p><img src=\"https://i.imgur.com/S4i2chx.png\" alt=\"Build Setting\"></p>\n<p>最后，通过只能从根源上来解决该问题了，既然需要引入的文件是 modular header，我们就要想办法来将其包裹为 module。 在查找解决方案的过程中发现，就在 Swift 刚推出的时候，大家已经遇到这个问题了，遇到最多的就是<code>CommonCrypto</code> 经常被使用到的 C 库，常见的 MD5 计算就是其提供的 API，但是在前几年官方并未将该动态库 module 化，因此导致你无法在 Swift 文件中直接使用类似 <code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code> 这种写法。自然而言多了很多解决方案，如下出自 StackOverflow 上 <a href=\"https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785\" target=\"_blank\" rel=\"noopener\">Importing CommonCrypto in a Swift framework</a> 的帖子下面就提供了多种解决方案：</p>\n<blockquote>\n<p>还是那句话，你是可以通过 Objective-C 做桥接来达到同样效果的。毕竟 Swift 本身就是一门心思想抛开 C 的历史包袱，因此想拥有一个纯纯的 Swift 代码不沾染一点 C 文件气息，你就要做一些工作。</p>\n</blockquote>\n<p>其中根本问题就是为 <code>CommonCrypto</code> 这个 C 编译单元定义 module，上面也提到了 LLVM 是通过 <code>modulemap</code> 文件来识别的，所以只要通过 <code>.modulemap</code> 来定义即可，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">module CommonCrypto [system] &#123;</span><br><span class=\"line\">    header &quot;/usr/include/CommonCrypto/CommonCrypto.h&quot;</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义的 modulemap 自然可以放到任意目录，只要让编译单元在编译的时候能够搜索的到即可，Xcode 选项的 Build Settings 下的 Swift Compiler - Search Paths 。添加 .modulemap 文件所在路径即可。在编译的时候 LLVM 自然会查找到 .modulemap 文件自动生成 Module 信息。你此时就可以在使用  CommonCrypto 的地方使用 modular header 了。</p>\n<p>过了几年之后，官方才将该库定义为 module，在 Xcode 自带的 iOS SDK 中 <code>/usr/include/CommonCrypto</code> 下可以看到 <code>module.modulemap</code> 文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">module CommonCrypto [system] [extern_c] &#123;</span><br><span class=\"line\">      umbrella header &quot;CommonCrypto.h&quot;</span><br><span class=\"line\">      export *</span><br><span class=\"line\">      module * &#123; export * &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      module Error &#123;</span><br><span class=\"line\">          header &quot;CommonCryptoError.h&quot;</span><br><span class=\"line\">          export *</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      module Random &#123;</span><br><span class=\"line\">          header &quot;CommonRandom.h&quot;</span><br><span class=\"line\">          export *</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>大家也注意到了在 CommonCrypto 的同级目录中实际上还有很多的系统 C 库代码，并且也有一个 module.modulemap 文件，我裁剪一段代码大家看下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">module Compression [system] [extern_c] &#123;</span><br><span class=\"line\">    header &quot;compression.h&quot;</span><br><span class=\"line\">    export *</span><br><span class=\"line\">    link &quot;compression&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">module Darwin [system] [extern_c] [no_undeclared_includes] &#123;</span><br><span class=\"line\">    // Headers that are repeatedly included, and therefore should not be</span><br><span class=\"line\">    \t// assigned to any given module.</span><br><span class=\"line\">    \texclude header &quot;_structs.h&quot;</span><br><span class=\"line\">    \texclude header &quot;sys/_structs.h&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t// C standard library</span><br><span class=\"line\">    \tmodule C &#123;</span><br><span class=\"line\">    \t\ttextual header &quot;assert.h&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t  module setjmp &#123;</span><br><span class=\"line\">    \t\t\theader &quot;setjmp.h&quot;</span><br><span class=\"line\">    \t\t\texport *</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t\tmodule signal &#123;</span><br><span class=\"line\">    \t\t\theader &quot;signal.h&quot;</span><br><span class=\"line\">    \t\t\texport *</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    \t\tmodule stdio &#123;</span><br><span class=\"line\">    \t\t\theader &quot;stdio.h&quot;</span><br><span class=\"line\">    \t\t\texport *</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    module zlib [system] [extern_c] &#123;</span><br><span class=\"line\">    \theader &quot;zlib.h&quot;</span><br><span class=\"line\">    \texport *</span><br><span class=\"line\">    \tlink &quot;z&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    module SQLite3 [system] [extern_c] &#123;</span><br><span class=\"line\">    \theader &quot;sqlite3.h&quot;</span><br><span class=\"line\">    \tlink &quot;sqlite3&quot;</span><br><span class=\"line\">    \texplicit module Ext &#123;</span><br><span class=\"line\">    \t\theader &quot;sqlite3ext.h&quot;</span><br><span class=\"line\">    \t\texport *</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \texport *</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这也是为什么我们在 Swift 代码里可以直接使用类似 <code>import Darwin.C.stdio</code> 写法的原因。但是还是存在一些 C 库并没有被定义为 module，而本次用来做 DNS 解析的 <code>resolv.h</code> 就是其中一员。</p>\n<p>具体到我们开发流程里说，是要解决 modulemap 如何定义，如何和我们目前使用的 Cocoapods 整合的问题了。既然是在作为 Pod 进行开发，自然是需要将 module map 文件加入到 pod 的代码管理中去。比如将其放置于单个 pod 根目录下，然后在 podspec 中配置好路径以便编译的时候 Swift Search Paths 中有它。自然，我们可以建立 resolv.modulemap 如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">module Resolv [system] &#123;</span><br><span class=\"line\">    header \"/usr/include/resolv.h\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在对应的 podspec 文件中配置 build setting 中的参数，如下所示</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.subspec <span class=\"string\">'Core'</span> <span class=\"keyword\">do</span> <span class=\"params\">|core|</span></span><br><span class=\"line\">    core.source_files   = [<span class=\"string\">'ZHDiagnosisTool/Classes/Core/**/*'</span>] </span><br><span class=\"line\">    core.preserve_paths = <span class=\"string\">'ZHDiagnosisTool/Classes/Core/ModuleMap'</span></span><br><span class=\"line\">    core.pod_target_xcconfig = &#123;</span><br><span class=\"line\">        <span class=\"string\">'SWIFT_INCLUDE_PATHS[sdk=macosx*]'</span>           =&gt; <span class=\"string\">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class=\"line\">        <span class=\"string\">'SWIFT_INCLUDE_PATHS[sdk=iphoneos*]'</span>         =&gt; <span class=\"string\">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class=\"line\">        <span class=\"string\">'SWIFT_INCLUDE_PATHS[sdk=iphonesimulator*]'</span>  =&gt; <span class=\"string\">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>可是，问题出在 PODS_ROOTS 这个路径上，如果我们进行本地开发，该路径就是 Cocoapods 执行完毕之后生成的临时 Pods 目录，并不是原始 podspec 文件所在的地方，而官方也表明了，不会对这种 Local Pods 特定提供一个环境变量来获取， 如下链接可以看到：</p>\n<p><a href=\"https://github.com/CocoaPods/CocoaPods/issues/809\" target=\"_blank\" rel=\"noopener\">local pod development on a project that includes libraries · Issue #809 · CocoaPods/CocoaPods</a></p>\n<p>如图中，指定 $(PODS_ROOT) 路径实际上在开发 Local Pod 的时候就会找不到，所以就需要按照上面链接中的方式自行手动拼接路径，所以，我们尽可能不用 PODS_ROOT 这个路径，需要另外找一个不会因为 Pod 位置而变化的路径。</p>\n<p>最终参考了以下 repo 中工程的解决方案，</p>\n<p><a href=\"https://github.com/onmyway133/Arcane\" target=\"_blank\" rel=\"noopener\">onmyway133/Arcane</a></p>\n<p>其中作者使用 Pod 的 script phase 来完成 .modulemap 的操作，这样会更加灵活。</p>\n<p>这样，针对我们自己本次的需求来看，.podspec 中的 script 如下所写即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> Create</span><br><span class=\"line\">FRAMEWORK_DIR=\"$&#123;BUILT_PRODUCTS_DIR&#125;/RESOLV.framework\"</span><br><span class=\"line\">          </span><br><span class=\"line\">if [ -d \"$&#123;FRAMEWORK_DIR&#125;\" ]; then</span><br><span class=\"line\">    echo \"$&#123;FRAMEWORK_DIR&#125; already exists, so skipping the rest of the script.\"</span><br><span class=\"line\">    exit 0</span><br><span class=\"line\">fi</span><br><span class=\"line\">          </span><br><span class=\"line\">mkdir -p \"$&#123;FRAMEWORK_DIR&#125;/Modules\"</span><br><span class=\"line\">          </span><br><span class=\"line\">echo \"module RESOLV [system] &#123;</span><br><span class=\"line\">    header \\\"$&#123;SDKROOT&#125;/usr/include/resolv.h\\\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;\" &gt; \"$&#123;FRAMEWORK_DIR&#125;/Modules/module.modulemap\"</span><br><span class=\"line\">               </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#</span> Generate fake header...</span><br><span class=\"line\">[ -d \"$&#123;FRAMEWORK_DIR&#125;/Headers\" ] || mkdir \"$&#123;FRAMEWORK_DIR&#125;/Headers\"</span><br><span class=\"line\">touch \"$&#123;FRAMEWORK_DIR&#125;/Headers/resolv.h\"</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">#</span> Soft link C header to local framework Headers</span><br><span class=\"line\">ln -sf \"$&#123;SDKROOT&#125;/usr/include/resolv.h\" \"$&#123;FRAMEWORK_DIR&#125;/Headers/resolv.h\"</span><br></pre></td></tr></table></figure>\n<p>每次在编译运行前，我们会自行创建一个 <code>Resolv.framework</code>，其中 Header 目录中我们放一个空白文件并且软链接到真正想要链接的头文件上，然后在该 framework 中创建 modulemap 文件。</p>\n<p>之后，我们在 .podspec 中指定 script phase 为编译前即可，如下所示，</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.script_phase = &#123;</span><br><span class=\"line\">    <span class=\"symbol\">:name</span> =&gt; <span class=\"string\">'Resolv'</span>,</span><br><span class=\"line\">    <span class=\"symbol\">:script</span> =&gt; script_above,</span><br><span class=\"line\">    <span class=\"symbol\">:execution_position</span> =&gt; <span class=\"symbol\">:before_compile</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，通过 <code>Resolv.framework</code> 的桥接，Swift 代码中就可以直接通过 <code>import RESOLV</code> 来使用了。当然，链接这一环你可以通过以下两种形式达到：</p>\n<ol>\n<li>直接在 podspec 文件中指定依赖，如 <code>core.library = &quot;resolv&quot;</code></li>\n<li>在 <code>.modulemap</code> 文件中显式的 link，如下所示：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">module Resolv [system] &#123;</span><br><span class=\"line\">    header \"/usr/include/resolv.h\"</span><br><span class=\"line\">    link \"resolv\"</span><br><span class=\"line\">    export *</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而且通过将 module map 文件放置于 product 产出目录这里也解决了路径指定的问题，因为 product folder 是默认在编译的搜索路径下的。</p>\n<h3 id=\"问题解惑\"><a href=\"#问题解惑\" class=\"headerlink\" title=\"问题解惑\"></a>问题解惑</h3><h4 id=\"关于某些\"><a href=\"#关于某些\" class=\"headerlink\" title=\"关于某些\"></a>关于某些</h4><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结来看，就是想要在纯 Swift 的项目中引入系统 C 库文件（这里指的是未被 modular 化的文件，因为有些 C 文件已经被系统默认封装成了 module 了）。以上只是一些简单的概念讲解，整个编译系统以及套件都是长时间不断演化的结果，这里也只是简单的讲述，有一些概念实际上也只是点到为止，大家如果感兴趣可以多找一些相关资料阅读下，亲自试一试。当然，当然刚开始直接用 Objective-C 来写不就好了，确实，不过通过本次解决这个问题，对 iOS 开发过程中遇到的某些司空见惯的概念（充斥在整个开发周期中）有了更清楚的了解，不是更好。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf\" target=\"_blank\" rel=\"noopener\">Modules</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/LLVM\" target=\"_blank\" rel=\"noopener\">LLVM - 维基百科，自由的百科全书</a></li>\n<li><a href=\"https://clang.llvm.org/docs/Modules.html#introduction\" target=\"_blank\" rel=\"noopener\">Modules - Clang 8 documentation</a></li>\n<li><a href=\"https://onevcat.com/2013/06/new-in-xcode5-and-objc/\" target=\"_blank\" rel=\"noopener\">WWDC 2013 Session笔记 - Xcode5和ObjC新特性</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785\" target=\"_blank\" rel=\"noopener\">Importing CommonCrypto in a Swift framework</a></li>\n<li><a href=\"https://forums.developer.apple.com/thread/46477\" target=\"_blank\" rel=\"noopener\">Adding CommonCrypto to custom Swift framework |Apple Developer Forums</a></li>\n<li><a href=\"https://theswiftdev.com/2018/01/15/how-to-call-c-code-from-swift/\" target=\"_blank\" rel=\"noopener\">How to call C code from Swift - The.Swift.Dev.</a></li>\n<li><a href=\"https://medium.com/swift-and-ios-writing/using-a-c-library-inside-a-swift-framework-d041d7b701d9/\" target=\"_blank\" rel=\"noopener\">Using a C library inside a Swift framework - Swift and iOS Writing - Medium</a></li>\n</ol>\n"},{"title":"如何使用UIBezierPath实现一个弹性视图动画","date":"2015-12-02T10:53:51.000Z","_content":"\n> 翻译自：[Elastic view animation using UIBezierPath](http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/)\n> 译者：[@这个昵称有点萌](http://weibo.com/hc2feifei)\n\nHey！\n[DGElasticPullToRefresh](https://github.com/gontovnik/DGElasticPullToRefresh)展示如何实现一个弹性效果。效果如下图所示：\n\n![DGElasticPullToRefresh.gif](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshDGElasticPullToRefresh1.gif)\n\n<!-- more -->\n\n开发环境：\nXcode 7\nSwift 2.0\n\n要求：\n开发者至少对UIBezierPath和UIGestureRecognizer有一定的了解.\n\n### 理解业务逻辑\n你可能从上面的效果图上可以看到一些端倪，这个动画中我们主要使用到了UIBezierPath来实现上面这种效果。\n我们首先创建一个贝塞尔曲线路径的CAShapeLayer，然后当你的手指在屏幕上移动的时候我们将移动所有的控制点来呈现动画。每一个控制点会使用一个可见的UIView来表示。下面有几张图来演示它们是如何工作的，我将所有的控制点标识成了红色：\n![ControlPoints1](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints1.png)\n![ControlPoints2](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints2.png)\n\n第二章图片中将每个表示控制点的View的变量名称标记出来了，如L3，L2等。\n\n当你的手指释放的时候，我们就播放Spring动画，让所有的控制点向其初始位置以一定的回弹效果移动。当所有的视图在动画播放过程中，我们需要时刻计算并我们的贝塞尔曲线（每一帧都进行计算）。因此，我们准备使用CADisplayLink，CADisplayLink在主循环中运行而且每一帧都会去执行指定的方法。\n\n> A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display.    - Apple doc\n\n让我们开始Code吧~\n\n----------\n\n### Build\n\n创建一个单视图控制器，然后将下面这些代码粘贴到viewController.swift文件的类声明中。\n\n```\n// MARK: -\n// MARK: Vars\n\nprivate let minimalHeight: CGFloat = 50.0  \nprivate let shapeLayer = CAShapeLayer()\n\n// MARK: -\n\noverride func loadView() {  \n    super.loadView()\n\n    shapeLayer.frame = CGRect(x: 0.0, y: 0.0, width: view.bounds.width, height: minimalHeight)\n    shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor\n    view.layer.addSublayer(shapeLayer)\n\n    view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: \"panGestureDidMove:\"))\n}\n\n// MARK: -\n// MARK: Methods\n\nfunc panGestureDidMove(gesture: UIPanGestureRecognizer) {  \n    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {\n\n    } else {\n        shapeLayer.frame.size.height = minimalHeight + max(gesture.translationInView(view).y, 0)\n    }\n}\n\noverride func preferredStatusBarStyle() -> UIStatusBarStyle {  \n    return .LightContent\n}\n```\n\n以上代码中，我们做的工作主要有以下几点：\n1. 声明了两个变量：shapeLayer 和 minimalHeight。前者是用来表示贝塞尔曲线的，后者是用来定义shapeLayer最小的高度值；\n2. 将shapeLayer添加到view的layer中；\n3. 添加了一个pan手势到view中，并为该手势添加panGestureDidMove目标方法，当手指移动的时候就会被调用，我们在该方法中修改shapeLayer的高度；\n4. 重写父类的preferredStatusBarStyle方法来确保我们的UI更美观一些。\n\n然后编译你的程序，确保实现了以下效果：\n![Builds1](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds1.gif)\n\n每件事情都在按着我们期待的呈现，不过有一点瑕疵。那就是shapeLayer的高度变化有一定的延迟（动画），那是因为隐式动画的原因。我们确定不需要这样的动画，因此在将shapeLayer添加到view的sublayers中之前禁用该layer关于position、bounds以及path的隐式动画。\n\n```\nshapeLayer.actions = [\"position\" : NSNull(), \"bounds\" : NSNull(), \"path\" : NSNull()]  \n```\n然后再次运行，会看到延迟的动画效果没有了。\n\n![Builds2](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds2.gif)\n\n接下来，我们就需要将最开始所说的那些控制点（L3, L2, L1, C, R1, R2, R3）加入到程序里，然后加入必要的逻辑。\n\n让我们一步一步来：\n\n- 首先，声明一个maxWaveHeight变量，定义这个变量的原因仅仅是希望让我们最终的效果好看一些而已。如果你不指定这个最大值，最终的效果会看起来很丑的；\n```\nprivate let maxWaveHeight: CGFloat = 100.0  \n```\n\n- 为我们的控制点视图声明变量；\n\n```\nprivate let l3ControlPointView = UIView()  \nprivate let l2ControlPointView = UIView()  \nprivate let l1ControlPointView = UIView()  \nprivate let cControlPointView = UIView()  \nprivate let r1ControlPointView = UIView()  \nprivate let r2ControlPointView = UIView()  \nprivate let r3ControlPointView = UIView()  \n```\n\n- 将上面定义的控制点视图设置为3*3的size，然后背景色设置为红色（这里我们只是暂时希望能够更方便演示，最终完成的时候会让它们不可见的），然后将这些控制点添加到View子视图中。将下面这些代码拷贝到loadView方法的尾部；\n\n```\nl3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nl2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nl1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \ncControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nr1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nr2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nr3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)\n\nl3ControlPointView.backgroundColor = .redColor()  \nl2ControlPointView.backgroundColor = .redColor()  \nl1ControlPointView.backgroundColor = .redColor()  \ncControlPointView.backgroundColor = .redColor()  \nr1ControlPointView.backgroundColor = .redColor()  \nr2ControlPointView.backgroundColor = .redColor()  \nr3ControlPointView.backgroundColor = .redColor()\n\nview.addSubview(l3ControlPointView)  \nview.addSubview(l2ControlPointView)  \nview.addSubview(l1ControlPointView)  \nview.addSubview(cControlPointView)  \nview.addSubview(r1ControlPointView)  \nview.addSubview(r2ControlPointView)  \nview.addSubview(r3ControlPointView)  \n```\n\n- 创建一个UIView的扩展，将其放到ViewController的声明上方；\n\n```\nextension UIView {  \n    func dg_center(usePresentationLayerIfPossible: Bool) -> CGPoint {\n        if usePresentationLayerIfPossible, let presentationLayer = layer.presentationLayer() as? CALayer {\n            return presentationLayer.position\n        }\n        return center\n    }\n}\n```\n\n- 当UIView从一帧到另外一帧进行动画的时候，你会试图去取得UIView.frame，而UIView.center会提供给你动画最终的值而不是每一帧的过渡值。因此我们需要定义一个扩展方法提供给我们UIView.layer.presentationLayer的实时位置；\n>  presentationLayer的详细信息可以在[官方文档](https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instm/CALayer/presentationLayer) 中查看\n\n- 声明一个currentPath()方法；\n\n```\nprivate func currentPath() -> CGPath {  \n    let width = view.bounds.width\n\n    let bezierPath = UIBezierPath()\n\n    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))\n    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(false).y))\n    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(false), controlPoint1: l3ControlPointView.dg_center(false), controlPoint2: l2ControlPointView.dg_center(false))\n    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(false), controlPoint1: cControlPointView.dg_center(false), controlPoint2: r1ControlPointView.dg_center(false))\n    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(false), controlPoint1: r1ControlPointView.dg_center(false), controlPoint2: r2ControlPointView.dg_center(false))\n    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))\n\n    bezierPath.closePath()\n\n    return bezierPath.CGPath\n}\n```\n\n这个方法返回shapeLayer当前的CGPath。它用到了我们前面所定义和讨论的控制点。\n\n- 声明updateShapeLayer方法；\n\n```\nfunc updateShapeLayer() {  \n    shapeLayer.path = currentPath()\n}\n```\nThis function will be called when we need shapeLayer to be updated. It is not a private func because we are going to use Selector() for CADisplayLink.\n\n这个方法会在shapeLayer需要更新的时候调用。\n- 声明layoutControlPoints方法；\n\n```\nprivate func layoutControlPoints(baseHeight baseHeight: CGFloat, waveHeight: CGFloat, locationX: CGFloat) {  \n    let width = view.bounds.width\n\n    let minLeftX = min((locationX - width / 2.0) * 0.28, 0.0)\n    let maxRightX = max(width + (locationX - width / 2.0) * 0.28, width)\n\n    let leftPartWidth = locationX - minLeftX\n    let rightPartWidth = maxRightX - locationX\n\n    l3ControlPointView.center = CGPoint(x: minLeftX, y: baseHeight)\n    l2ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.44, y: baseHeight)\n    l1ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)\n    cControlPointView.center = CGPoint(x: locationX , y: baseHeight + waveHeight * 1.36)\n    r1ControlPointView.center = CGPoint(x: maxRightX - rightPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)\n    r2ControlPointView.center = CGPoint(x: maxRightX - (rightPartWidth * 0.44), y: baseHeight)\n    r3ControlPointView.center = CGPoint(x: maxRightX, y: baseHeight)\n}\n```\n\n这一部分可能需要解释下这些变量的职责：\n\n1. baseHeight - base的高度。  baseHeight + waveHeight = 我们所需要的总高度；\n2. waveHeight - 曲线的波浪高度，我们前面的maxWaveHeight为其设定一个最大值；\n3. locationX - 手指在视图中的位置的X坐标\n4. width - 显而易见，我们视图的宽度；\n5. minLeftX - 定义l3ControlPointView的坐标X值的最小值，这个值可以是负值；\n6. maxRightX - 和minLeftX类似，定义r3ControlPointView的坐标X值的最大值；\n7. leftPartWidth - 定义 minLeftX 和 locationX之间的距离；\n8. rightPartWidth -  定义 locationX 和 maxRightX之间的距离；\n\n你可能会问，为什么我们要使用这些值来设定我们的控制点呢？答案很简单，我使用了PaintCode，然后内部建立贝塞尔曲线，不断的试直到令我满意\n的效果时，我就将这些值替换到程序中即可。\n\n- 更新我们的panGestureDidMove方法，这样当我们手指移动的时候所有的控制点也能移动。用以下的代码替换panGestureDidMove方法中的内容；\n\n```\nfunc panGestureDidMove(gesture: UIPanGestureRecognizer) {  \n    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {\n\n    } else {\n        let additionalHeight = max(gesture.translationInView(view).y, 0)\n\n        let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)\n        let baseHeight = minimalHeight + additionalHeight - waveHeight\n\n        let locationX = gesture.locationInView(gesture.view).x\n\n        layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)\n        updateShapeLayer()\n    }\n}\n```\n\n我们所做的就是计算wave高度，基础高度以及手指的位置，然后调用layoutControlPoints去布局各个控制点，然后调用updateShapeLayer来更新我们的shapeLayer的path。\n\nWhat we do is calculate wave height, base height, location of the finger and call our function: layoutControlPoints to layout control points and updateShapeLayer to update our shape layer path.\n\n- 在loadView方法尾部添加两行代码，使得我们在打开app的时候正确的显示；\n\n```\nlayoutControlPoints(baseHeight: minimalHeight, waveHeight: 0.0, locationX: view.bounds.width / 2.0)  \nupdateShapeLayer()  \n```\n\n- 修改\n```\nshapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor  \n```\n为\n\n```\nshapeLayer.fillColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor  \n```\n\n\n到这里，效果应该如下所示：\n\n![Build3](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds3.gif)\n\n\n最后一件要做的事情就是，把我们释放手指之后的回弹动画整合进去。\n还是让我们一步一步来吧：\n\n- 定义displayLink变量；\n\n```\nprivate var displayLink: CADisplayLink!\n```\n\n在loadView方法的末尾进行初始化：\n\n```\ndisplayLink = CADisplayLink(target: self, selector: Selector(\"updateShapeLayer\"))  \n        displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)\n        displayLink.paused = true\n```\n\n前面我们也提到过，我们的CADisplayLink对象会在每一帧都调用指定的方法（这里就是指定的updateShapeLayer），因此我们就可以在UIView的动画期间实时的更新shapeLayer的path了。\n\n- 定义animating变量；\n\n```\nprivate var animating = false {  \n    didSet {\n        view.userInteractionEnabled = !animating\n        displayLink.paused = !animating\n    }\n}\n```\n\n这个可以控制用户交互是否开启以及displayLink的停止和播放（动画播放期间你肯定不希望用户的交互直接就把动画效果给破坏了。）\n\n```\nprivate func currentPath() -> CGPath {  \n    let width = view.bounds.width\n\n    let bezierPath = UIBezierPath()\n\n    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))\n    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(animating).y))\n    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(animating), controlPoint1: l3ControlPointView.dg_center(animating), controlPoint2: l2ControlPointView.dg_center(animating))\n    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(animating), controlPoint1: cControlPointView.dg_center(animating), controlPoint2: r1ControlPointView.dg_center(animating))\n    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(animating), controlPoint1: r1ControlPointView.dg_center(animating), controlPoint2: r2ControlPointView.dg_center(animating))\n    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))\n\n    bezierPath.closePath()\n\n    return bezierPath.CGPath\n}\n```\n\n更新currentPath方法，将dg_center方法参数换为animating参数仅当动画需要的时候才提供layer的准确过渡值。\n\n- 最后一步就是需要更新panGestureDidMove方法中的if判断语句；\n\n```\nif gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {  \n    let centerY = minimalHeight\n\n    animating = true\n    UIView.animateWithDuration(0.9, delay: 0.0, usingSpringWithDamping: 0.57, initialSpringVelocity: 0.0, options: [], animations: { () -> Void in\n        self.l3ControlPointView.center.y = centerY\n        self.l2ControlPointView.center.y = centerY\n        self.l1ControlPointView.center.y = centerY\n        self.cControlPointView.center.y = centerY\n        self.r1ControlPointView.center.y = centerY\n        self.r2ControlPointView.center.y = centerY\n        self.r3ControlPointView.center.y = centerY\n        }, completion: { _ in\n            self.animating = false\n    })\n} else {\n    let additionalHeight = max(gesture.translationInView(view).y, 0)\n\n    let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)\n    let baseHeight = minimalHeight + additionalHeight - waveHeight\n\n    let locationX = gesture.locationInView(gesture.view).x\n\n    layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)\n    updateShapeLayer()\n}\n```\n\n我们已经为UIView添加了Sprint动画，让我们的控制点能够通过很优雅的回弹效果回到它们的位置。你可以修改以上的变量值来使你的动画看起来更优美，更好看。\n\n让我们在设备上运行下看看能够让你震惊的效果：\n![Build4](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds4.gif)\n当然，我们可能不太想显示这些红色的点。你可以在loadView方法中移除那些设置这些控制点的frame以及背景色的代码。\n\n再次运行代码效果如下：\n\n![Build5](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds5.gif)\n\n效果很完美，但是，在这个例子中有一件事情我们忘记做了，就是我们没有改变shapeLayer的高度，我们仅仅修改了path的高度。这个不够完美，需要修复它。我想这个对于你来说应该是不错的作业。尽情修改frame、path以及所有变量的值吧！\n\n\n> 这个Demo的源码在[这里](https://github.com/gontovnik/DGElasticBounceTutorial)\n> [DGElasticPullToRefresh](https://github.com/gontovnik/DGElasticPullToRefresh)的源码在这里\n\n\n","source":"_posts/Elastic-view-animation-using-UIBezierPath.md","raw":"title: \"如何使用UIBezierPath实现一个弹性视图动画\"\ndate: 2015-12-02 18:53:51\ncategories: 翻译\ntags: [iOS,Animation,Objective-C,Swift]\n---\n\n> 翻译自：[Elastic view animation using UIBezierPath](http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/)\n> 译者：[@这个昵称有点萌](http://weibo.com/hc2feifei)\n\nHey！\n[DGElasticPullToRefresh](https://github.com/gontovnik/DGElasticPullToRefresh)展示如何实现一个弹性效果。效果如下图所示：\n\n![DGElasticPullToRefresh.gif](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshDGElasticPullToRefresh1.gif)\n\n<!-- more -->\n\n开发环境：\nXcode 7\nSwift 2.0\n\n要求：\n开发者至少对UIBezierPath和UIGestureRecognizer有一定的了解.\n\n### 理解业务逻辑\n你可能从上面的效果图上可以看到一些端倪，这个动画中我们主要使用到了UIBezierPath来实现上面这种效果。\n我们首先创建一个贝塞尔曲线路径的CAShapeLayer，然后当你的手指在屏幕上移动的时候我们将移动所有的控制点来呈现动画。每一个控制点会使用一个可见的UIView来表示。下面有几张图来演示它们是如何工作的，我将所有的控制点标识成了红色：\n![ControlPoints1](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints1.png)\n![ControlPoints2](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints2.png)\n\n第二章图片中将每个表示控制点的View的变量名称标记出来了，如L3，L2等。\n\n当你的手指释放的时候，我们就播放Spring动画，让所有的控制点向其初始位置以一定的回弹效果移动。当所有的视图在动画播放过程中，我们需要时刻计算并我们的贝塞尔曲线（每一帧都进行计算）。因此，我们准备使用CADisplayLink，CADisplayLink在主循环中运行而且每一帧都会去执行指定的方法。\n\n> A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display.    - Apple doc\n\n让我们开始Code吧~\n\n----------\n\n### Build\n\n创建一个单视图控制器，然后将下面这些代码粘贴到viewController.swift文件的类声明中。\n\n```\n// MARK: -\n// MARK: Vars\n\nprivate let minimalHeight: CGFloat = 50.0  \nprivate let shapeLayer = CAShapeLayer()\n\n// MARK: -\n\noverride func loadView() {  \n    super.loadView()\n\n    shapeLayer.frame = CGRect(x: 0.0, y: 0.0, width: view.bounds.width, height: minimalHeight)\n    shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor\n    view.layer.addSublayer(shapeLayer)\n\n    view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: \"panGestureDidMove:\"))\n}\n\n// MARK: -\n// MARK: Methods\n\nfunc panGestureDidMove(gesture: UIPanGestureRecognizer) {  \n    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {\n\n    } else {\n        shapeLayer.frame.size.height = minimalHeight + max(gesture.translationInView(view).y, 0)\n    }\n}\n\noverride func preferredStatusBarStyle() -> UIStatusBarStyle {  \n    return .LightContent\n}\n```\n\n以上代码中，我们做的工作主要有以下几点：\n1. 声明了两个变量：shapeLayer 和 minimalHeight。前者是用来表示贝塞尔曲线的，后者是用来定义shapeLayer最小的高度值；\n2. 将shapeLayer添加到view的layer中；\n3. 添加了一个pan手势到view中，并为该手势添加panGestureDidMove目标方法，当手指移动的时候就会被调用，我们在该方法中修改shapeLayer的高度；\n4. 重写父类的preferredStatusBarStyle方法来确保我们的UI更美观一些。\n\n然后编译你的程序，确保实现了以下效果：\n![Builds1](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds1.gif)\n\n每件事情都在按着我们期待的呈现，不过有一点瑕疵。那就是shapeLayer的高度变化有一定的延迟（动画），那是因为隐式动画的原因。我们确定不需要这样的动画，因此在将shapeLayer添加到view的sublayers中之前禁用该layer关于position、bounds以及path的隐式动画。\n\n```\nshapeLayer.actions = [\"position\" : NSNull(), \"bounds\" : NSNull(), \"path\" : NSNull()]  \n```\n然后再次运行，会看到延迟的动画效果没有了。\n\n![Builds2](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds2.gif)\n\n接下来，我们就需要将最开始所说的那些控制点（L3, L2, L1, C, R1, R2, R3）加入到程序里，然后加入必要的逻辑。\n\n让我们一步一步来：\n\n- 首先，声明一个maxWaveHeight变量，定义这个变量的原因仅仅是希望让我们最终的效果好看一些而已。如果你不指定这个最大值，最终的效果会看起来很丑的；\n```\nprivate let maxWaveHeight: CGFloat = 100.0  \n```\n\n- 为我们的控制点视图声明变量；\n\n```\nprivate let l3ControlPointView = UIView()  \nprivate let l2ControlPointView = UIView()  \nprivate let l1ControlPointView = UIView()  \nprivate let cControlPointView = UIView()  \nprivate let r1ControlPointView = UIView()  \nprivate let r2ControlPointView = UIView()  \nprivate let r3ControlPointView = UIView()  \n```\n\n- 将上面定义的控制点视图设置为3*3的size，然后背景色设置为红色（这里我们只是暂时希望能够更方便演示，最终完成的时候会让它们不可见的），然后将这些控制点添加到View子视图中。将下面这些代码拷贝到loadView方法的尾部；\n\n```\nl3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nl2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nl1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \ncControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nr1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nr2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  \nr3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)\n\nl3ControlPointView.backgroundColor = .redColor()  \nl2ControlPointView.backgroundColor = .redColor()  \nl1ControlPointView.backgroundColor = .redColor()  \ncControlPointView.backgroundColor = .redColor()  \nr1ControlPointView.backgroundColor = .redColor()  \nr2ControlPointView.backgroundColor = .redColor()  \nr3ControlPointView.backgroundColor = .redColor()\n\nview.addSubview(l3ControlPointView)  \nview.addSubview(l2ControlPointView)  \nview.addSubview(l1ControlPointView)  \nview.addSubview(cControlPointView)  \nview.addSubview(r1ControlPointView)  \nview.addSubview(r2ControlPointView)  \nview.addSubview(r3ControlPointView)  \n```\n\n- 创建一个UIView的扩展，将其放到ViewController的声明上方；\n\n```\nextension UIView {  \n    func dg_center(usePresentationLayerIfPossible: Bool) -> CGPoint {\n        if usePresentationLayerIfPossible, let presentationLayer = layer.presentationLayer() as? CALayer {\n            return presentationLayer.position\n        }\n        return center\n    }\n}\n```\n\n- 当UIView从一帧到另外一帧进行动画的时候，你会试图去取得UIView.frame，而UIView.center会提供给你动画最终的值而不是每一帧的过渡值。因此我们需要定义一个扩展方法提供给我们UIView.layer.presentationLayer的实时位置；\n>  presentationLayer的详细信息可以在[官方文档](https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instm/CALayer/presentationLayer) 中查看\n\n- 声明一个currentPath()方法；\n\n```\nprivate func currentPath() -> CGPath {  \n    let width = view.bounds.width\n\n    let bezierPath = UIBezierPath()\n\n    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))\n    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(false).y))\n    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(false), controlPoint1: l3ControlPointView.dg_center(false), controlPoint2: l2ControlPointView.dg_center(false))\n    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(false), controlPoint1: cControlPointView.dg_center(false), controlPoint2: r1ControlPointView.dg_center(false))\n    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(false), controlPoint1: r1ControlPointView.dg_center(false), controlPoint2: r2ControlPointView.dg_center(false))\n    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))\n\n    bezierPath.closePath()\n\n    return bezierPath.CGPath\n}\n```\n\n这个方法返回shapeLayer当前的CGPath。它用到了我们前面所定义和讨论的控制点。\n\n- 声明updateShapeLayer方法；\n\n```\nfunc updateShapeLayer() {  \n    shapeLayer.path = currentPath()\n}\n```\nThis function will be called when we need shapeLayer to be updated. It is not a private func because we are going to use Selector() for CADisplayLink.\n\n这个方法会在shapeLayer需要更新的时候调用。\n- 声明layoutControlPoints方法；\n\n```\nprivate func layoutControlPoints(baseHeight baseHeight: CGFloat, waveHeight: CGFloat, locationX: CGFloat) {  \n    let width = view.bounds.width\n\n    let minLeftX = min((locationX - width / 2.0) * 0.28, 0.0)\n    let maxRightX = max(width + (locationX - width / 2.0) * 0.28, width)\n\n    let leftPartWidth = locationX - minLeftX\n    let rightPartWidth = maxRightX - locationX\n\n    l3ControlPointView.center = CGPoint(x: minLeftX, y: baseHeight)\n    l2ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.44, y: baseHeight)\n    l1ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)\n    cControlPointView.center = CGPoint(x: locationX , y: baseHeight + waveHeight * 1.36)\n    r1ControlPointView.center = CGPoint(x: maxRightX - rightPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)\n    r2ControlPointView.center = CGPoint(x: maxRightX - (rightPartWidth * 0.44), y: baseHeight)\n    r3ControlPointView.center = CGPoint(x: maxRightX, y: baseHeight)\n}\n```\n\n这一部分可能需要解释下这些变量的职责：\n\n1. baseHeight - base的高度。  baseHeight + waveHeight = 我们所需要的总高度；\n2. waveHeight - 曲线的波浪高度，我们前面的maxWaveHeight为其设定一个最大值；\n3. locationX - 手指在视图中的位置的X坐标\n4. width - 显而易见，我们视图的宽度；\n5. minLeftX - 定义l3ControlPointView的坐标X值的最小值，这个值可以是负值；\n6. maxRightX - 和minLeftX类似，定义r3ControlPointView的坐标X值的最大值；\n7. leftPartWidth - 定义 minLeftX 和 locationX之间的距离；\n8. rightPartWidth -  定义 locationX 和 maxRightX之间的距离；\n\n你可能会问，为什么我们要使用这些值来设定我们的控制点呢？答案很简单，我使用了PaintCode，然后内部建立贝塞尔曲线，不断的试直到令我满意\n的效果时，我就将这些值替换到程序中即可。\n\n- 更新我们的panGestureDidMove方法，这样当我们手指移动的时候所有的控制点也能移动。用以下的代码替换panGestureDidMove方法中的内容；\n\n```\nfunc panGestureDidMove(gesture: UIPanGestureRecognizer) {  \n    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {\n\n    } else {\n        let additionalHeight = max(gesture.translationInView(view).y, 0)\n\n        let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)\n        let baseHeight = minimalHeight + additionalHeight - waveHeight\n\n        let locationX = gesture.locationInView(gesture.view).x\n\n        layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)\n        updateShapeLayer()\n    }\n}\n```\n\n我们所做的就是计算wave高度，基础高度以及手指的位置，然后调用layoutControlPoints去布局各个控制点，然后调用updateShapeLayer来更新我们的shapeLayer的path。\n\nWhat we do is calculate wave height, base height, location of the finger and call our function: layoutControlPoints to layout control points and updateShapeLayer to update our shape layer path.\n\n- 在loadView方法尾部添加两行代码，使得我们在打开app的时候正确的显示；\n\n```\nlayoutControlPoints(baseHeight: minimalHeight, waveHeight: 0.0, locationX: view.bounds.width / 2.0)  \nupdateShapeLayer()  \n```\n\n- 修改\n```\nshapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor  \n```\n为\n\n```\nshapeLayer.fillColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor  \n```\n\n\n到这里，效果应该如下所示：\n\n![Build3](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds3.gif)\n\n\n最后一件要做的事情就是，把我们释放手指之后的回弹动画整合进去。\n还是让我们一步一步来吧：\n\n- 定义displayLink变量；\n\n```\nprivate var displayLink: CADisplayLink!\n```\n\n在loadView方法的末尾进行初始化：\n\n```\ndisplayLink = CADisplayLink(target: self, selector: Selector(\"updateShapeLayer\"))  \n        displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)\n        displayLink.paused = true\n```\n\n前面我们也提到过，我们的CADisplayLink对象会在每一帧都调用指定的方法（这里就是指定的updateShapeLayer），因此我们就可以在UIView的动画期间实时的更新shapeLayer的path了。\n\n- 定义animating变量；\n\n```\nprivate var animating = false {  \n    didSet {\n        view.userInteractionEnabled = !animating\n        displayLink.paused = !animating\n    }\n}\n```\n\n这个可以控制用户交互是否开启以及displayLink的停止和播放（动画播放期间你肯定不希望用户的交互直接就把动画效果给破坏了。）\n\n```\nprivate func currentPath() -> CGPath {  \n    let width = view.bounds.width\n\n    let bezierPath = UIBezierPath()\n\n    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))\n    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(animating).y))\n    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(animating), controlPoint1: l3ControlPointView.dg_center(animating), controlPoint2: l2ControlPointView.dg_center(animating))\n    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(animating), controlPoint1: cControlPointView.dg_center(animating), controlPoint2: r1ControlPointView.dg_center(animating))\n    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(animating), controlPoint1: r1ControlPointView.dg_center(animating), controlPoint2: r2ControlPointView.dg_center(animating))\n    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))\n\n    bezierPath.closePath()\n\n    return bezierPath.CGPath\n}\n```\n\n更新currentPath方法，将dg_center方法参数换为animating参数仅当动画需要的时候才提供layer的准确过渡值。\n\n- 最后一步就是需要更新panGestureDidMove方法中的if判断语句；\n\n```\nif gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled {  \n    let centerY = minimalHeight\n\n    animating = true\n    UIView.animateWithDuration(0.9, delay: 0.0, usingSpringWithDamping: 0.57, initialSpringVelocity: 0.0, options: [], animations: { () -> Void in\n        self.l3ControlPointView.center.y = centerY\n        self.l2ControlPointView.center.y = centerY\n        self.l1ControlPointView.center.y = centerY\n        self.cControlPointView.center.y = centerY\n        self.r1ControlPointView.center.y = centerY\n        self.r2ControlPointView.center.y = centerY\n        self.r3ControlPointView.center.y = centerY\n        }, completion: { _ in\n            self.animating = false\n    })\n} else {\n    let additionalHeight = max(gesture.translationInView(view).y, 0)\n\n    let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)\n    let baseHeight = minimalHeight + additionalHeight - waveHeight\n\n    let locationX = gesture.locationInView(gesture.view).x\n\n    layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)\n    updateShapeLayer()\n}\n```\n\n我们已经为UIView添加了Sprint动画，让我们的控制点能够通过很优雅的回弹效果回到它们的位置。你可以修改以上的变量值来使你的动画看起来更优美，更好看。\n\n让我们在设备上运行下看看能够让你震惊的效果：\n![Build4](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds4.gif)\n当然，我们可能不太想显示这些红色的点。你可以在loadView方法中移除那些设置这些控制点的frame以及背景色的代码。\n\n再次运行代码效果如下：\n\n![Build5](http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds5.gif)\n\n效果很完美，但是，在这个例子中有一件事情我们忘记做了，就是我们没有改变shapeLayer的高度，我们仅仅修改了path的高度。这个不够完美，需要修复它。我想这个对于你来说应该是不错的作业。尽情修改frame、path以及所有变量的值吧！\n\n\n> 这个Demo的源码在[这里](https://github.com/gontovnik/DGElasticBounceTutorial)\n> [DGElasticPullToRefresh](https://github.com/gontovnik/DGElasticPullToRefresh)的源码在这里\n\n\n","slug":"Elastic-view-animation-using-UIBezierPath","published":1,"updated":"2017-05-21T12:34:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftd0006479pouikreom4","content":"<blockquote>\n<p>翻译自：<a href=\"http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/\" target=\"_blank\" rel=\"noopener\">Elastic view animation using UIBezierPath</a><br>译者：<a href=\"http://weibo.com/hc2feifei\" target=\"_blank\" rel=\"noopener\">@这个昵称有点萌</a></p>\n</blockquote>\n<p>Hey！<br><a href=\"https://github.com/gontovnik/DGElasticPullToRefresh\" target=\"_blank\" rel=\"noopener\">DGElasticPullToRefresh</a>展示如何实现一个弹性效果。效果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshDGElasticPullToRefresh1.gif\" alt=\"DGElasticPullToRefresh.gif\"></p>\n<a id=\"more\"></a>\n<p>开发环境：<br>Xcode 7<br>Swift 2.0</p>\n<p>要求：<br>开发者至少对UIBezierPath和UIGestureRecognizer有一定的了解.</p>\n<h3 id=\"理解业务逻辑\"><a href=\"#理解业务逻辑\" class=\"headerlink\" title=\"理解业务逻辑\"></a>理解业务逻辑</h3><p>你可能从上面的效果图上可以看到一些端倪，这个动画中我们主要使用到了UIBezierPath来实现上面这种效果。<br>我们首先创建一个贝塞尔曲线路径的CAShapeLayer，然后当你的手指在屏幕上移动的时候我们将移动所有的控制点来呈现动画。每一个控制点会使用一个可见的UIView来表示。下面有几张图来演示它们是如何工作的，我将所有的控制点标识成了红色：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints1.png\" alt=\"ControlPoints1\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints2.png\" alt=\"ControlPoints2\"></p>\n<p>第二章图片中将每个表示控制点的View的变量名称标记出来了，如L3，L2等。</p>\n<p>当你的手指释放的时候，我们就播放Spring动画，让所有的控制点向其初始位置以一定的回弹效果移动。当所有的视图在动画播放过程中，我们需要时刻计算并我们的贝塞尔曲线（每一帧都进行计算）。因此，我们准备使用CADisplayLink，CADisplayLink在主循环中运行而且每一帧都会去执行指定的方法。</p>\n<blockquote>\n<p>A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display.    - Apple doc</p>\n</blockquote>\n<p>让我们开始Code吧~</p>\n<hr>\n<h3 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a>Build</h3><p>创建一个单视图控制器，然后将下面这些代码粘贴到viewController.swift文件的类声明中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// MARK: -</span><br><span class=\"line\">// MARK: Vars</span><br><span class=\"line\"></span><br><span class=\"line\">private let minimalHeight: CGFloat = 50.0  </span><br><span class=\"line\">private let shapeLayer = CAShapeLayer()</span><br><span class=\"line\"></span><br><span class=\"line\">// MARK: -</span><br><span class=\"line\"></span><br><span class=\"line\">override func loadView() &#123;  </span><br><span class=\"line\">    super.loadView()</span><br><span class=\"line\"></span><br><span class=\"line\">    shapeLayer.frame = CGRect(x: 0.0, y: 0.0, width: view.bounds.width, height: minimalHeight)</span><br><span class=\"line\">    shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br><span class=\"line\">    view.layer.addSublayer(shapeLayer)</span><br><span class=\"line\"></span><br><span class=\"line\">    view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: &quot;panGestureDidMove:&quot;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// MARK: -</span><br><span class=\"line\">// MARK: Methods</span><br><span class=\"line\"></span><br><span class=\"line\">func panGestureDidMove(gesture: UIPanGestureRecognizer) &#123;  </span><br><span class=\"line\">    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        shapeLayer.frame.size.height = minimalHeight + max(gesture.translationInView(view).y, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">override func preferredStatusBarStyle() -&gt; UIStatusBarStyle &#123;  </span><br><span class=\"line\">    return .LightContent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码中，我们做的工作主要有以下几点：</p>\n<ol>\n<li>声明了两个变量：shapeLayer 和 minimalHeight。前者是用来表示贝塞尔曲线的，后者是用来定义shapeLayer最小的高度值；</li>\n<li>将shapeLayer添加到view的layer中；</li>\n<li>添加了一个pan手势到view中，并为该手势添加panGestureDidMove目标方法，当手指移动的时候就会被调用，我们在该方法中修改shapeLayer的高度；</li>\n<li>重写父类的preferredStatusBarStyle方法来确保我们的UI更美观一些。</li>\n</ol>\n<p>然后编译你的程序，确保实现了以下效果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds1.gif\" alt=\"Builds1\"></p>\n<p>每件事情都在按着我们期待的呈现，不过有一点瑕疵。那就是shapeLayer的高度变化有一定的延迟（动画），那是因为隐式动画的原因。我们确定不需要这样的动画，因此在将shapeLayer添加到view的sublayers中之前禁用该layer关于position、bounds以及path的隐式动画。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shapeLayer.actions = [&quot;position&quot; : NSNull(), &quot;bounds&quot; : NSNull(), &quot;path&quot; : NSNull()]</span><br></pre></td></tr></table></figure>\n<p>然后再次运行，会看到延迟的动画效果没有了。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds2.gif\" alt=\"Builds2\"></p>\n<p>接下来，我们就需要将最开始所说的那些控制点（L3, L2, L1, C, R1, R2, R3）加入到程序里，然后加入必要的逻辑。</p>\n<p>让我们一步一步来：</p>\n<ul>\n<li><p>首先，声明一个maxWaveHeight变量，定义这个变量的原因仅仅是希望让我们最终的效果好看一些而已。如果你不指定这个最大值，最终的效果会看起来很丑的；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private let maxWaveHeight: CGFloat = 100.0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为我们的控制点视图声明变量；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private let l3ControlPointView = UIView()  </span><br><span class=\"line\">private let l2ControlPointView = UIView()  </span><br><span class=\"line\">private let l1ControlPointView = UIView()  </span><br><span class=\"line\">private let cControlPointView = UIView()  </span><br><span class=\"line\">private let r1ControlPointView = UIView()  </span><br><span class=\"line\">private let r2ControlPointView = UIView()  </span><br><span class=\"line\">private let r3ControlPointView = UIView()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将上面定义的控制点视图设置为3*3的size，然后背景色设置为红色（这里我们只是暂时希望能够更方便演示，最终完成的时候会让它们不可见的），然后将这些控制点添加到View子视图中。将下面这些代码拷贝到loadView方法的尾部；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">l3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">l2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">l1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">cControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">r1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">r2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">r3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)</span><br><span class=\"line\"></span><br><span class=\"line\">l3ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">l2ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">l1ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">cControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">r1ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">r2ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">r3ControlPointView.backgroundColor = .redColor()</span><br><span class=\"line\"></span><br><span class=\"line\">view.addSubview(l3ControlPointView)  </span><br><span class=\"line\">view.addSubview(l2ControlPointView)  </span><br><span class=\"line\">view.addSubview(l1ControlPointView)  </span><br><span class=\"line\">view.addSubview(cControlPointView)  </span><br><span class=\"line\">view.addSubview(r1ControlPointView)  </span><br><span class=\"line\">view.addSubview(r2ControlPointView)  </span><br><span class=\"line\">view.addSubview(r3ControlPointView)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个UIView的扩展，将其放到ViewController的声明上方；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extension UIView &#123;  </span><br><span class=\"line\">    func dg_center(usePresentationLayerIfPossible: Bool) -&gt; CGPoint &#123;</span><br><span class=\"line\">        if usePresentationLayerIfPossible, let presentationLayer = layer.presentationLayer() as? CALayer &#123;</span><br><span class=\"line\">            return presentationLayer.position</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return center</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>当UIView从一帧到另外一帧进行动画的时候，你会试图去取得UIView.frame，而UIView.center会提供给你动画最终的值而不是每一帧的过渡值。因此我们需要定义一个扩展方法提供给我们UIView.layer.presentationLayer的实时位置；</p>\n<blockquote>\n<p> presentationLayer的详细信息可以在<a href=\"https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instm/CALayer/presentationLayer\" target=\"_blank\" rel=\"noopener\">官方文档</a> 中查看</p>\n</blockquote>\n</li>\n<li><p>声明一个currentPath()方法；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private func currentPath() -&gt; CGPath &#123;  </span><br><span class=\"line\">    let width = view.bounds.width</span><br><span class=\"line\"></span><br><span class=\"line\">    let bezierPath = UIBezierPath()</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(false).y))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(false), controlPoint1: l3ControlPointView.dg_center(false), controlPoint2: l2ControlPointView.dg_center(false))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(false), controlPoint1: cControlPointView.dg_center(false), controlPoint2: r1ControlPointView.dg_center(false))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(false), controlPoint1: r1ControlPointView.dg_center(false), controlPoint2: r2ControlPointView.dg_center(false))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.closePath()</span><br><span class=\"line\"></span><br><span class=\"line\">    return bezierPath.CGPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法返回shapeLayer当前的CGPath。它用到了我们前面所定义和讨论的控制点。</p>\n<ul>\n<li>声明updateShapeLayer方法；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func updateShapeLayer() &#123;  </span><br><span class=\"line\">    shapeLayer.path = currentPath()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This function will be called when we need shapeLayer to be updated. It is not a private func because we are going to use Selector() for CADisplayLink.</p>\n<p>这个方法会在shapeLayer需要更新的时候调用。</p>\n<ul>\n<li>声明layoutControlPoints方法；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private func layoutControlPoints(baseHeight baseHeight: CGFloat, waveHeight: CGFloat, locationX: CGFloat) &#123;  </span><br><span class=\"line\">    let width = view.bounds.width</span><br><span class=\"line\"></span><br><span class=\"line\">    let minLeftX = min((locationX - width / 2.0) * 0.28, 0.0)</span><br><span class=\"line\">    let maxRightX = max(width + (locationX - width / 2.0) * 0.28, width)</span><br><span class=\"line\"></span><br><span class=\"line\">    let leftPartWidth = locationX - minLeftX</span><br><span class=\"line\">    let rightPartWidth = maxRightX - locationX</span><br><span class=\"line\"></span><br><span class=\"line\">    l3ControlPointView.center = CGPoint(x: minLeftX, y: baseHeight)</span><br><span class=\"line\">    l2ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.44, y: baseHeight)</span><br><span class=\"line\">    l1ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)</span><br><span class=\"line\">    cControlPointView.center = CGPoint(x: locationX , y: baseHeight + waveHeight * 1.36)</span><br><span class=\"line\">    r1ControlPointView.center = CGPoint(x: maxRightX - rightPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)</span><br><span class=\"line\">    r2ControlPointView.center = CGPoint(x: maxRightX - (rightPartWidth * 0.44), y: baseHeight)</span><br><span class=\"line\">    r3ControlPointView.center = CGPoint(x: maxRightX, y: baseHeight)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一部分可能需要解释下这些变量的职责：</p>\n<ol>\n<li>baseHeight - base的高度。  baseHeight + waveHeight = 我们所需要的总高度；</li>\n<li>waveHeight - 曲线的波浪高度，我们前面的maxWaveHeight为其设定一个最大值；</li>\n<li>locationX - 手指在视图中的位置的X坐标</li>\n<li>width - 显而易见，我们视图的宽度；</li>\n<li>minLeftX - 定义l3ControlPointView的坐标X值的最小值，这个值可以是负值；</li>\n<li>maxRightX - 和minLeftX类似，定义r3ControlPointView的坐标X值的最大值；</li>\n<li>leftPartWidth - 定义 minLeftX 和 locationX之间的距离；</li>\n<li>rightPartWidth -  定义 locationX 和 maxRightX之间的距离；</li>\n</ol>\n<p>你可能会问，为什么我们要使用这些值来设定我们的控制点呢？答案很简单，我使用了PaintCode，然后内部建立贝塞尔曲线，不断的试直到令我满意<br>的效果时，我就将这些值替换到程序中即可。</p>\n<ul>\n<li>更新我们的panGestureDidMove方法，这样当我们手指移动的时候所有的控制点也能移动。用以下的代码替换panGestureDidMove方法中的内容；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func panGestureDidMove(gesture: UIPanGestureRecognizer) &#123;  </span><br><span class=\"line\">    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        let additionalHeight = max(gesture.translationInView(view).y, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">        let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)</span><br><span class=\"line\">        let baseHeight = minimalHeight + additionalHeight - waveHeight</span><br><span class=\"line\"></span><br><span class=\"line\">        let locationX = gesture.locationInView(gesture.view).x</span><br><span class=\"line\"></span><br><span class=\"line\">        layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)</span><br><span class=\"line\">        updateShapeLayer()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们所做的就是计算wave高度，基础高度以及手指的位置，然后调用layoutControlPoints去布局各个控制点，然后调用updateShapeLayer来更新我们的shapeLayer的path。</p>\n<p>What we do is calculate wave height, base height, location of the finger and call our function: layoutControlPoints to layout control points and updateShapeLayer to update our shape layer path.</p>\n<ul>\n<li>在loadView方法尾部添加两行代码，使得我们在打开app的时候正确的显示；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">layoutControlPoints(baseHeight: minimalHeight, waveHeight: 0.0, locationX: view.bounds.width / 2.0)  </span><br><span class=\"line\">updateShapeLayer()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shapeLayer.fillColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br></pre></td></tr></table></figure>\n<p>到这里，效果应该如下所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds3.gif\" alt=\"Build3\"></p>\n<p>最后一件要做的事情就是，把我们释放手指之后的回弹动画整合进去。<br>还是让我们一步一步来吧：</p>\n<ul>\n<li>定义displayLink变量；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private var displayLink: CADisplayLink!</span><br></pre></td></tr></table></figure>\n<p>在loadView方法的末尾进行初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">displayLink = CADisplayLink(target: self, selector: Selector(&quot;updateShapeLayer&quot;))  </span><br><span class=\"line\">        displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)</span><br><span class=\"line\">        displayLink.paused = true</span><br></pre></td></tr></table></figure>\n<p>前面我们也提到过，我们的CADisplayLink对象会在每一帧都调用指定的方法（这里就是指定的updateShapeLayer），因此我们就可以在UIView的动画期间实时的更新shapeLayer的path了。</p>\n<ul>\n<li>定义animating变量；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private var animating = false &#123;  </span><br><span class=\"line\">    didSet &#123;</span><br><span class=\"line\">        view.userInteractionEnabled = !animating</span><br><span class=\"line\">        displayLink.paused = !animating</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个可以控制用户交互是否开启以及displayLink的停止和播放（动画播放期间你肯定不希望用户的交互直接就把动画效果给破坏了。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private func currentPath() -&gt; CGPath &#123;  </span><br><span class=\"line\">    let width = view.bounds.width</span><br><span class=\"line\"></span><br><span class=\"line\">    let bezierPath = UIBezierPath()</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(animating).y))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(animating), controlPoint1: l3ControlPointView.dg_center(animating), controlPoint2: l2ControlPointView.dg_center(animating))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(animating), controlPoint1: cControlPointView.dg_center(animating), controlPoint2: r1ControlPointView.dg_center(animating))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(animating), controlPoint1: r1ControlPointView.dg_center(animating), controlPoint2: r2ControlPointView.dg_center(animating))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.closePath()</span><br><span class=\"line\"></span><br><span class=\"line\">    return bezierPath.CGPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更新currentPath方法，将dg_center方法参数换为animating参数仅当动画需要的时候才提供layer的准确过渡值。</p>\n<ul>\n<li>最后一步就是需要更新panGestureDidMove方法中的if判断语句；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;  </span><br><span class=\"line\">    let centerY = minimalHeight</span><br><span class=\"line\"></span><br><span class=\"line\">    animating = true</span><br><span class=\"line\">    UIView.animateWithDuration(0.9, delay: 0.0, usingSpringWithDamping: 0.57, initialSpringVelocity: 0.0, options: [], animations: &#123; () -&gt; Void in</span><br><span class=\"line\">        self.l3ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.l2ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.l1ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.cControlPointView.center.y = centerY</span><br><span class=\"line\">        self.r1ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.r2ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.r3ControlPointView.center.y = centerY</span><br><span class=\"line\">        &#125;, completion: &#123; _ in</span><br><span class=\"line\">            self.animating = false</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    let additionalHeight = max(gesture.translationInView(view).y, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">    let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)</span><br><span class=\"line\">    let baseHeight = minimalHeight + additionalHeight - waveHeight</span><br><span class=\"line\"></span><br><span class=\"line\">    let locationX = gesture.locationInView(gesture.view).x</span><br><span class=\"line\"></span><br><span class=\"line\">    layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)</span><br><span class=\"line\">    updateShapeLayer()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们已经为UIView添加了Sprint动画，让我们的控制点能够通过很优雅的回弹效果回到它们的位置。你可以修改以上的变量值来使你的动画看起来更优美，更好看。</p>\n<p>让我们在设备上运行下看看能够让你震惊的效果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds4.gif\" alt=\"Build4\"><br>当然，我们可能不太想显示这些红色的点。你可以在loadView方法中移除那些设置这些控制点的frame以及背景色的代码。</p>\n<p>再次运行代码效果如下：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds5.gif\" alt=\"Build5\"></p>\n<p>效果很完美，但是，在这个例子中有一件事情我们忘记做了，就是我们没有改变shapeLayer的高度，我们仅仅修改了path的高度。这个不够完美，需要修复它。我想这个对于你来说应该是不错的作业。尽情修改frame、path以及所有变量的值吧！</p>\n<blockquote>\n<p>这个Demo的源码在<a href=\"https://github.com/gontovnik/DGElasticBounceTutorial\" target=\"_blank\" rel=\"noopener\">这里</a><br><a href=\"https://github.com/gontovnik/DGElasticPullToRefresh\" target=\"_blank\" rel=\"noopener\">DGElasticPullToRefresh</a>的源码在这里</p>\n</blockquote>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<blockquote>\n<p>翻译自：<a href=\"http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/\" target=\"_blank\" rel=\"noopener\">Elastic view animation using UIBezierPath</a><br>译者：<a href=\"http://weibo.com/hc2feifei\" target=\"_blank\" rel=\"noopener\">@这个昵称有点萌</a></p>\n</blockquote>\n<p>Hey！<br><a href=\"https://github.com/gontovnik/DGElasticPullToRefresh\" target=\"_blank\" rel=\"noopener\">DGElasticPullToRefresh</a>展示如何实现一个弹性效果。效果如下图所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshDGElasticPullToRefresh1.gif\" alt=\"DGElasticPullToRefresh.gif\"></p>","more":"<p>开发环境：<br>Xcode 7<br>Swift 2.0</p>\n<p>要求：<br>开发者至少对UIBezierPath和UIGestureRecognizer有一定的了解.</p>\n<h3 id=\"理解业务逻辑\"><a href=\"#理解业务逻辑\" class=\"headerlink\" title=\"理解业务逻辑\"></a>理解业务逻辑</h3><p>你可能从上面的效果图上可以看到一些端倪，这个动画中我们主要使用到了UIBezierPath来实现上面这种效果。<br>我们首先创建一个贝塞尔曲线路径的CAShapeLayer，然后当你的手指在屏幕上移动的时候我们将移动所有的控制点来呈现动画。每一个控制点会使用一个可见的UIView来表示。下面有几张图来演示它们是如何工作的，我将所有的控制点标识成了红色：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints1.png\" alt=\"ControlPoints1\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints2.png\" alt=\"ControlPoints2\"></p>\n<p>第二章图片中将每个表示控制点的View的变量名称标记出来了，如L3，L2等。</p>\n<p>当你的手指释放的时候，我们就播放Spring动画，让所有的控制点向其初始位置以一定的回弹效果移动。当所有的视图在动画播放过程中，我们需要时刻计算并我们的贝塞尔曲线（每一帧都进行计算）。因此，我们准备使用CADisplayLink，CADisplayLink在主循环中运行而且每一帧都会去执行指定的方法。</p>\n<blockquote>\n<p>A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display.    - Apple doc</p>\n</blockquote>\n<p>让我们开始Code吧~</p>\n<hr>\n<h3 id=\"Build\"><a href=\"#Build\" class=\"headerlink\" title=\"Build\"></a>Build</h3><p>创建一个单视图控制器，然后将下面这些代码粘贴到viewController.swift文件的类声明中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// MARK: -</span><br><span class=\"line\">// MARK: Vars</span><br><span class=\"line\"></span><br><span class=\"line\">private let minimalHeight: CGFloat = 50.0  </span><br><span class=\"line\">private let shapeLayer = CAShapeLayer()</span><br><span class=\"line\"></span><br><span class=\"line\">// MARK: -</span><br><span class=\"line\"></span><br><span class=\"line\">override func loadView() &#123;  </span><br><span class=\"line\">    super.loadView()</span><br><span class=\"line\"></span><br><span class=\"line\">    shapeLayer.frame = CGRect(x: 0.0, y: 0.0, width: view.bounds.width, height: minimalHeight)</span><br><span class=\"line\">    shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br><span class=\"line\">    view.layer.addSublayer(shapeLayer)</span><br><span class=\"line\"></span><br><span class=\"line\">    view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: &quot;panGestureDidMove:&quot;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// MARK: -</span><br><span class=\"line\">// MARK: Methods</span><br><span class=\"line\"></span><br><span class=\"line\">func panGestureDidMove(gesture: UIPanGestureRecognizer) &#123;  </span><br><span class=\"line\">    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        shapeLayer.frame.size.height = minimalHeight + max(gesture.translationInView(view).y, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">override func preferredStatusBarStyle() -&gt; UIStatusBarStyle &#123;  </span><br><span class=\"line\">    return .LightContent</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码中，我们做的工作主要有以下几点：</p>\n<ol>\n<li>声明了两个变量：shapeLayer 和 minimalHeight。前者是用来表示贝塞尔曲线的，后者是用来定义shapeLayer最小的高度值；</li>\n<li>将shapeLayer添加到view的layer中；</li>\n<li>添加了一个pan手势到view中，并为该手势添加panGestureDidMove目标方法，当手指移动的时候就会被调用，我们在该方法中修改shapeLayer的高度；</li>\n<li>重写父类的preferredStatusBarStyle方法来确保我们的UI更美观一些。</li>\n</ol>\n<p>然后编译你的程序，确保实现了以下效果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds1.gif\" alt=\"Builds1\"></p>\n<p>每件事情都在按着我们期待的呈现，不过有一点瑕疵。那就是shapeLayer的高度变化有一定的延迟（动画），那是因为隐式动画的原因。我们确定不需要这样的动画，因此在将shapeLayer添加到view的sublayers中之前禁用该layer关于position、bounds以及path的隐式动画。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shapeLayer.actions = [&quot;position&quot; : NSNull(), &quot;bounds&quot; : NSNull(), &quot;path&quot; : NSNull()]</span><br></pre></td></tr></table></figure>\n<p>然后再次运行，会看到延迟的动画效果没有了。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds2.gif\" alt=\"Builds2\"></p>\n<p>接下来，我们就需要将最开始所说的那些控制点（L3, L2, L1, C, R1, R2, R3）加入到程序里，然后加入必要的逻辑。</p>\n<p>让我们一步一步来：</p>\n<ul>\n<li><p>首先，声明一个maxWaveHeight变量，定义这个变量的原因仅仅是希望让我们最终的效果好看一些而已。如果你不指定这个最大值，最终的效果会看起来很丑的；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private let maxWaveHeight: CGFloat = 100.0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为我们的控制点视图声明变量；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private let l3ControlPointView = UIView()  </span><br><span class=\"line\">private let l2ControlPointView = UIView()  </span><br><span class=\"line\">private let l1ControlPointView = UIView()  </span><br><span class=\"line\">private let cControlPointView = UIView()  </span><br><span class=\"line\">private let r1ControlPointView = UIView()  </span><br><span class=\"line\">private let r2ControlPointView = UIView()  </span><br><span class=\"line\">private let r3ControlPointView = UIView()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将上面定义的控制点视图设置为3*3的size，然后背景色设置为红色（这里我们只是暂时希望能够更方便演示，最终完成的时候会让它们不可见的），然后将这些控制点添加到View子视图中。将下面这些代码拷贝到loadView方法的尾部；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">l3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">l2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">l1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">cControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">r1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">r2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class=\"line\">r3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)</span><br><span class=\"line\"></span><br><span class=\"line\">l3ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">l2ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">l1ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">cControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">r1ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">r2ControlPointView.backgroundColor = .redColor()  </span><br><span class=\"line\">r3ControlPointView.backgroundColor = .redColor()</span><br><span class=\"line\"></span><br><span class=\"line\">view.addSubview(l3ControlPointView)  </span><br><span class=\"line\">view.addSubview(l2ControlPointView)  </span><br><span class=\"line\">view.addSubview(l1ControlPointView)  </span><br><span class=\"line\">view.addSubview(cControlPointView)  </span><br><span class=\"line\">view.addSubview(r1ControlPointView)  </span><br><span class=\"line\">view.addSubview(r2ControlPointView)  </span><br><span class=\"line\">view.addSubview(r3ControlPointView)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建一个UIView的扩展，将其放到ViewController的声明上方；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">extension UIView &#123;  </span><br><span class=\"line\">    func dg_center(usePresentationLayerIfPossible: Bool) -&gt; CGPoint &#123;</span><br><span class=\"line\">        if usePresentationLayerIfPossible, let presentationLayer = layer.presentationLayer() as? CALayer &#123;</span><br><span class=\"line\">            return presentationLayer.position</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return center</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>当UIView从一帧到另外一帧进行动画的时候，你会试图去取得UIView.frame，而UIView.center会提供给你动画最终的值而不是每一帧的过渡值。因此我们需要定义一个扩展方法提供给我们UIView.layer.presentationLayer的实时位置；</p>\n<blockquote>\n<p> presentationLayer的详细信息可以在<a href=\"https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instm/CALayer/presentationLayer\" target=\"_blank\" rel=\"noopener\">官方文档</a> 中查看</p>\n</blockquote>\n</li>\n<li><p>声明一个currentPath()方法；</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private func currentPath() -&gt; CGPath &#123;  </span><br><span class=\"line\">    let width = view.bounds.width</span><br><span class=\"line\"></span><br><span class=\"line\">    let bezierPath = UIBezierPath()</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(false).y))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(false), controlPoint1: l3ControlPointView.dg_center(false), controlPoint2: l2ControlPointView.dg_center(false))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(false), controlPoint1: cControlPointView.dg_center(false), controlPoint2: r1ControlPointView.dg_center(false))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(false), controlPoint1: r1ControlPointView.dg_center(false), controlPoint2: r2ControlPointView.dg_center(false))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.closePath()</span><br><span class=\"line\"></span><br><span class=\"line\">    return bezierPath.CGPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法返回shapeLayer当前的CGPath。它用到了我们前面所定义和讨论的控制点。</p>\n<ul>\n<li>声明updateShapeLayer方法；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func updateShapeLayer() &#123;  </span><br><span class=\"line\">    shapeLayer.path = currentPath()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>This function will be called when we need shapeLayer to be updated. It is not a private func because we are going to use Selector() for CADisplayLink.</p>\n<p>这个方法会在shapeLayer需要更新的时候调用。</p>\n<ul>\n<li>声明layoutControlPoints方法；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private func layoutControlPoints(baseHeight baseHeight: CGFloat, waveHeight: CGFloat, locationX: CGFloat) &#123;  </span><br><span class=\"line\">    let width = view.bounds.width</span><br><span class=\"line\"></span><br><span class=\"line\">    let minLeftX = min((locationX - width / 2.0) * 0.28, 0.0)</span><br><span class=\"line\">    let maxRightX = max(width + (locationX - width / 2.0) * 0.28, width)</span><br><span class=\"line\"></span><br><span class=\"line\">    let leftPartWidth = locationX - minLeftX</span><br><span class=\"line\">    let rightPartWidth = maxRightX - locationX</span><br><span class=\"line\"></span><br><span class=\"line\">    l3ControlPointView.center = CGPoint(x: minLeftX, y: baseHeight)</span><br><span class=\"line\">    l2ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.44, y: baseHeight)</span><br><span class=\"line\">    l1ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)</span><br><span class=\"line\">    cControlPointView.center = CGPoint(x: locationX , y: baseHeight + waveHeight * 1.36)</span><br><span class=\"line\">    r1ControlPointView.center = CGPoint(x: maxRightX - rightPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)</span><br><span class=\"line\">    r2ControlPointView.center = CGPoint(x: maxRightX - (rightPartWidth * 0.44), y: baseHeight)</span><br><span class=\"line\">    r3ControlPointView.center = CGPoint(x: maxRightX, y: baseHeight)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一部分可能需要解释下这些变量的职责：</p>\n<ol>\n<li>baseHeight - base的高度。  baseHeight + waveHeight = 我们所需要的总高度；</li>\n<li>waveHeight - 曲线的波浪高度，我们前面的maxWaveHeight为其设定一个最大值；</li>\n<li>locationX - 手指在视图中的位置的X坐标</li>\n<li>width - 显而易见，我们视图的宽度；</li>\n<li>minLeftX - 定义l3ControlPointView的坐标X值的最小值，这个值可以是负值；</li>\n<li>maxRightX - 和minLeftX类似，定义r3ControlPointView的坐标X值的最大值；</li>\n<li>leftPartWidth - 定义 minLeftX 和 locationX之间的距离；</li>\n<li>rightPartWidth -  定义 locationX 和 maxRightX之间的距离；</li>\n</ol>\n<p>你可能会问，为什么我们要使用这些值来设定我们的控制点呢？答案很简单，我使用了PaintCode，然后内部建立贝塞尔曲线，不断的试直到令我满意<br>的效果时，我就将这些值替换到程序中即可。</p>\n<ul>\n<li>更新我们的panGestureDidMove方法，这样当我们手指移动的时候所有的控制点也能移动。用以下的代码替换panGestureDidMove方法中的内容；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func panGestureDidMove(gesture: UIPanGestureRecognizer) &#123;  </span><br><span class=\"line\">    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        let additionalHeight = max(gesture.translationInView(view).y, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">        let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)</span><br><span class=\"line\">        let baseHeight = minimalHeight + additionalHeight - waveHeight</span><br><span class=\"line\"></span><br><span class=\"line\">        let locationX = gesture.locationInView(gesture.view).x</span><br><span class=\"line\"></span><br><span class=\"line\">        layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)</span><br><span class=\"line\">        updateShapeLayer()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们所做的就是计算wave高度，基础高度以及手指的位置，然后调用layoutControlPoints去布局各个控制点，然后调用updateShapeLayer来更新我们的shapeLayer的path。</p>\n<p>What we do is calculate wave height, base height, location of the finger and call our function: layoutControlPoints to layout control points and updateShapeLayer to update our shape layer path.</p>\n<ul>\n<li>在loadView方法尾部添加两行代码，使得我们在打开app的时候正确的显示；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">layoutControlPoints(baseHeight: minimalHeight, waveHeight: 0.0, locationX: view.bounds.width / 2.0)  </span><br><span class=\"line\">updateShapeLayer()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shapeLayer.fillColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br></pre></td></tr></table></figure>\n<p>到这里，效果应该如下所示：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds3.gif\" alt=\"Build3\"></p>\n<p>最后一件要做的事情就是，把我们释放手指之后的回弹动画整合进去。<br>还是让我们一步一步来吧：</p>\n<ul>\n<li>定义displayLink变量；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private var displayLink: CADisplayLink!</span><br></pre></td></tr></table></figure>\n<p>在loadView方法的末尾进行初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">displayLink = CADisplayLink(target: self, selector: Selector(&quot;updateShapeLayer&quot;))  </span><br><span class=\"line\">        displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)</span><br><span class=\"line\">        displayLink.paused = true</span><br></pre></td></tr></table></figure>\n<p>前面我们也提到过，我们的CADisplayLink对象会在每一帧都调用指定的方法（这里就是指定的updateShapeLayer），因此我们就可以在UIView的动画期间实时的更新shapeLayer的path了。</p>\n<ul>\n<li>定义animating变量；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private var animating = false &#123;  </span><br><span class=\"line\">    didSet &#123;</span><br><span class=\"line\">        view.userInteractionEnabled = !animating</span><br><span class=\"line\">        displayLink.paused = !animating</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个可以控制用户交互是否开启以及displayLink的停止和播放（动画播放期间你肯定不希望用户的交互直接就把动画效果给破坏了。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private func currentPath() -&gt; CGPath &#123;  </span><br><span class=\"line\">    let width = view.bounds.width</span><br><span class=\"line\"></span><br><span class=\"line\">    let bezierPath = UIBezierPath()</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(animating).y))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(animating), controlPoint1: l3ControlPointView.dg_center(animating), controlPoint2: l2ControlPointView.dg_center(animating))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(animating), controlPoint1: cControlPointView.dg_center(animating), controlPoint2: r1ControlPointView.dg_center(animating))</span><br><span class=\"line\">    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(animating), controlPoint1: r1ControlPointView.dg_center(animating), controlPoint2: r2ControlPointView.dg_center(animating))</span><br><span class=\"line\">    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))</span><br><span class=\"line\"></span><br><span class=\"line\">    bezierPath.closePath()</span><br><span class=\"line\"></span><br><span class=\"line\">    return bezierPath.CGPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更新currentPath方法，将dg_center方法参数换为animating参数仅当动画需要的时候才提供layer的准确过渡值。</p>\n<ul>\n<li>最后一步就是需要更新panGestureDidMove方法中的if判断语句；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;  </span><br><span class=\"line\">    let centerY = minimalHeight</span><br><span class=\"line\"></span><br><span class=\"line\">    animating = true</span><br><span class=\"line\">    UIView.animateWithDuration(0.9, delay: 0.0, usingSpringWithDamping: 0.57, initialSpringVelocity: 0.0, options: [], animations: &#123; () -&gt; Void in</span><br><span class=\"line\">        self.l3ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.l2ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.l1ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.cControlPointView.center.y = centerY</span><br><span class=\"line\">        self.r1ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.r2ControlPointView.center.y = centerY</span><br><span class=\"line\">        self.r3ControlPointView.center.y = centerY</span><br><span class=\"line\">        &#125;, completion: &#123; _ in</span><br><span class=\"line\">            self.animating = false</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    let additionalHeight = max(gesture.translationInView(view).y, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">    let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)</span><br><span class=\"line\">    let baseHeight = minimalHeight + additionalHeight - waveHeight</span><br><span class=\"line\"></span><br><span class=\"line\">    let locationX = gesture.locationInView(gesture.view).x</span><br><span class=\"line\"></span><br><span class=\"line\">    layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)</span><br><span class=\"line\">    updateShapeLayer()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们已经为UIView添加了Sprint动画，让我们的控制点能够通过很优雅的回弹效果回到它们的位置。你可以修改以上的变量值来使你的动画看起来更优美，更好看。</p>\n<p>让我们在设备上运行下看看能够让你震惊的效果：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds4.gif\" alt=\"Build4\"><br>当然，我们可能不太想显示这些红色的点。你可以在loadView方法中移除那些设置这些控制点的frame以及背景色的代码。</p>\n<p>再次运行代码效果如下：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds5.gif\" alt=\"Build5\"></p>\n<p>效果很完美，但是，在这个例子中有一件事情我们忘记做了，就是我们没有改变shapeLayer的高度，我们仅仅修改了path的高度。这个不够完美，需要修复它。我想这个对于你来说应该是不错的作业。尽情修改frame、path以及所有变量的值吧！</p>\n<blockquote>\n<p>这个Demo的源码在<a href=\"https://github.com/gontovnik/DGElasticBounceTutorial\" target=\"_blank\" rel=\"noopener\">这里</a><br><a href=\"https://github.com/gontovnik/DGElasticPullToRefresh\" target=\"_blank\" rel=\"noopener\">DGElasticPullToRefresh</a>的源码在这里</p>\n</blockquote>"},{"title":"iOS 远端推送部署详解","date":"2015-07-30T06:30:00.000Z","_content":"\n最近几天被iOS的推送部署给搞懵了，现在特地整理下和大家进行分享。\n\n#### iOS远端推送机制\n\nAPNS，全称为Apple Push Notification service，是苹果通知推送服务中最重要的一环。它是苹果通知推送服务器，为所有iOS设备以及OS X设备提供强大并且可靠的推送通知服务。每个注册通知服务的设备都会和该服务器进行长连接，从而实时获取推送通知。即使当前APP不在运行状态，当通知到达的时候也会有提示发生，最常见的就是短信服务。\n\n<!-- more -->\n\n每一个App必须向APNs注册通知服务，APNs会返回给设备一个DeviceToken，该Token为APNs上针对该设备的唯一标示符。App需要将该DeviceToken返给自身的Server端保存后续使用，如下所示。\n![DeviceToken的操作流程](http://7xilk1.com1.z0.glb.clouddn.com/iosPushshare%20the%20device%20Token.png)\n\n当App开发者的server需要向特定设备推送通知时，就使用DeviceToken和固定格式数据（Push payload）发给APNs，然后APNs就会向DeviceToken指定的设备推送通知了，具体流程如下所示，单一推送\n![通知方推送一条远端通知给客户端代码的整个流程](http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20a%20remote%20notification%20from%20a%20provider%20to%20a%20client%20app.png)\n或者多方通知，APNs都能一一对应，靠的就是之前我们提供给它的DeviceToken。\n![多个通知方向向不同的客户端推送通知的流程示意](http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20remote%20notifications%20from%20multiple%20providers%20to%20multiple%20devices.png)\n\n\n----------\n\n#### 本地推送证书配置\n\n打开你mac的钥匙串访问，然后点击钥匙串访问\n![打开钥匙串](http://7xilk1.com1.z0.glb.clouddn.com/iosPush钥匙串.png)\n随后它会弹出一个窗口 用户电子邮件信息\n![生成CSR文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书1.png)\n就填写你苹果开发者账号的名称即可（应该是一个邮件名称），点击保存到磁盘的选项，点击继续，点击存储，文件名为：CertificateSigningRequest.certSigningRequest。\n![保存生成的CSR文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书2.png)\n\n然后我们打开[苹果开发者中心](developer.apple.com)  进入Member Center\n![苹果开发者中心](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书3.png)\n然后点击左侧列表中任意一项进入详情页面，\n![开发者个人首页选项](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书4.png)\n![选择IOS Apps中列表项](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书5.png)\n\n##### APP ID\n\n首先我们需要为我们要开发的APP建立身份信息，就是AppID，如图所示，点击左侧\n![添加AppID](http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID1.png)\n点击添加按钮进入注册页面，我们需要输入App Id的名字以及BundleID，其中BundleID不能有通配符，否则无法具备推送功能，然后在下面的APP Service中勾选Push Notification一项\n![填写BundleID以及App ID Description](http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID2.png)\n![选择App Service](http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID3.png)\n点击下一步，然后确认提交即可，大家注意到Push Notification一项为Configurable，这是因为我们还没有为该AppID生成推送证书，等推送证书生成完毕之后可以再回来查看该AppID 的状态。\n![确认提交App ID](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书13.jpg)\n\n##### Certificates\n\n其次，我们需要生成开发者证书和推送证书，如下图所示，点击左侧Cerifications列表，选择添加进入下一页面，\n![添加证书](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书11.png)\n\n如果您的页面如图所示为灰色不可选，说明您已经拥有了开发者证书。就不需要再次生成了，如果可选就选择该选项，\n![选择证书类型](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书7.png)\n\n接下来进入以下界面，选择你之前添加的AppID，之后点击Continue即可，\n![选择需要绑定证书的App ID](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书8.png)\n\n然后选择之前我们保存在本地的CSR文件CertificateSigningRequest.certSigningRequest，点击Generate就生成了开发者的证书。\n![上传本机CSR文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书9.png)\n\n同理我们需要生成推送测试证书，生成流程和开发者证书类似，只是在证书类型页面，选择的证书类型换成了Apple Push Notification service SSL。\n![选择生成证书类型](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书10.png)\n\n当我们生成好推送证书之后再回头看我们之前创建的AppId，能够看Push Notifications一项已经为Enabled了。当然发布推送证书配置完毕之后，Distribution一项也显示为Enable。\n![再次查看APPID 状态](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书12.jpg)\n\n##### Provisioning Profiles\n\n第三步，需要生成Provisioning Profiles，该文件其实就是以上的证书、AppId以及设备信息的打包集合，我们只要在不同的场景下生成不同类型Provisioning Profiles即可，它会在后续打包ipa文件的时候被嵌入安装包内。\n首先我们选择左侧列表中的Provisioning Profiles中的All选项，选择添加\n![添加Provisioning Profiles文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision1.png)\n\n之后选择生成类型，我们这里以开发类型为例，下面还有发布的两种类型，\n![选择生成PP文件类型](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision2.png)\n\n之后点击Continue，进入下一页面，同样选择我们之前创建的具有Push服务的AppId，\n![选择绑定的App ID](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision3.png)\n\n接下来，选择上面生成的开发证书（一一对应的，如果你选择生成的是发布Provisioning Profiles，则会出现发布证书），\n![选择之前生成的对应证书](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision4.png)\n\n紧接着，我们选择授权设备，即你需要进行开发的设备，该设备可以在左侧Devices列表中添加，需要提供设备的UUID，这里我们选择所有设备，点击Continue，\n![选择授权设备](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision5.png)\n\n最后一步，我们给Provisioning Profiles添加名称，\n![添加Provisioning Profiles名称](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision6.png)\n点击Generate即生成我们所需要的Provisioning Profile。\n\n其实同理，我们可以生成发布版的开发者证书，推送证书以及对应的Provisioning Profiles。最后的文件我们都放到同一个文件夹里，如图所示，其中我把发布的两种（Ad Hoc 和 Distribution）都一起搞出来。\n![生成的各个证书以及Provisioning Profile文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书200.png)\n\n其中Push.p12文件后续会提及~\n\n----------\n\n#### 开发环境配置\n\n我们将上一步生成的开发者证书`ios_development.cer`以及推送证书`aps_development.cer`在最初生成CSR文件的MAC机上安装，双击即可安装，同时会打开钥匙串页面，安装之后我们找到之前生成CSR文件时生成的专用密钥，名称就是我们之前生成CSR文件时填写的，选择该专用密钥，同时选中刚刚安装成功的推送证书，（**必须注意，同时选择，我们需要将专用密钥以及安装成功的推送证书同时导出成一个文件**）右键菜单导出，\n![导出专用密钥和本地安装的推送证书](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode6.png)\n如图我们命名Push，点击存储，\n![保存到本地](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode7.png)\n接下来需要为证书添加密码，这个密码是需要提供给服务器的。\n![添加证书密码](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode8.png)\n\n最后我们需要配置我们本地的开发环境，也就是XCode，第一步我们点击XCode的Preference打开XCode的首选项菜单，\n![打开Preference选项](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode1.png)\n\n在Account选项中添加我们的开发者账户，如果之前已经登录就会看到该账户信息，然后点击下方的View Details，\n![查看账户信息](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode5.png)\n\n之后会显示该开发者账户的证书和Provisioning Profiles等信息，该信息会和你开发者账号里面显示的一致，如果不一致就点击刷新，\n![刷新账户信息](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode3.png)\n\n不久就会出现我们之前创建的Provisioning Profiles，接下来，我们在XCode中Build Settings -> Code Signing中选择我们需要的Provisioning Profiles文件即可\n![XCode选择对应的Provisioning Profile文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode4.png)\n\n此时本地开发环境已经配置完毕。接下来就开始Coding，Coding，Coding。。。。\n\n\n#### 远端推送通知的代码实现\n\n首先我们需要注册推送通知服务并获取DeviceToken；\n\n``` Objc\n- (void)initPushNotificationWithApp: (UIApplication*)application {\n    // 注册通知服务\n    if([UIDevice currentDevice].systemVersion.floatValue < 8.0) {\n        [application registerForRemoteNotificationTypes:(UIRemoteNotificationTypeBadge\n                                                       | UIRemoteNotificationTypeSound\n                                                       | UIRemoteNotificationTypeAlert)];\n    } else {\n        // IOS8.0以上版本的注册推送方式和以往不同\n        UIUserNotificationSettings* settings = [UIUserNotificationSettings settingsForTypes:(UIRemoteNotificationTypeBadge\n                                                                                           | UIRemoteNotificationTypeSound\n                                                                                           | UIRemoteNotificationTypeAlert)\n                                                                                 categories:nil];\n        [application registerUserNotificationSettings:settings];\n        [application registerForRemoteNotifications];\n    }\n}\n```\n\n\n\n\n如果注册成功，APNs会返回给你设备的token，iOS系统会把它传递给app delegate代理：\n\n``` Objective-C\n// 如果注册成功，则会收到DeviceToken，我们需要将该Token发给服务器保存\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {\n    PRINT_FUNC\n    \n    NSString* tokenStr = [NSString stringWithFormat:@\"%@\", deviceToken];\n    NSLog(@\"deviceToken: %@\", tokenStr);\n    if(tokenStr.length == 0)\n    {\n        NSLog(@\"Device Token Invalid!\");\n    }\n\t\n\t// 然后我们需要将该DeviceToken发给我们自己的服务器进行保存；\n    [self sendDeviceToken:deviceToken]; \n}\n\n// 如果注册失败，会收到错误信息，包含错误原因\n- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {\n    PRINT_FUNC\n    \n    NSLog(@\"***************************************\\n\");\n    NSLog(@\"Failed to Register The Notification!!!!\\n\");\n    NSLog(@\"error = %@\", error);\n    NSLog(@\"***************************************\\n\");\n}\n```\n\n之后我们就可以在AppDelegate中添加处理代码，当用户点击通知栏的通知或者处于运行状态时，App代码会执行- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo代理方法，如下所示：\n\n``` Objective-C\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {\n    PRINT_FUNC\n    \n    NSLog(@\"收到推送通知: %@\", userInfo);\n    \n    // userInfo是一个字典数据类型，具体Key Value由客户端和服务器进行协商确定\n    NSString* orderId = [userInfo objectForKey:@\"carryOrderId\"];\n    NSLog(@\"收到订单消息通知，订单号：%@\",orderId);\n\t\n\t// .... 其余逻辑，拿到具体关键信息之后进行下一步处理\n}\n```\n\n还有一个方法 \n\n``` Objective-C\n/*! This delegate method offers an opportunity for applications with the \"remote-notification\" background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you're finished performing that operation, so the system can accurately estimate its power and data cost.\n \n This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/\n \n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler; \n```\n\n我发现这两个方法在APP处于后台或者前台展示，也就是App存活期会同样调用，但当APP并未启动或者被后台销毁之后，用户点击通知象虽然都会调起App，但是前者这个方法就不会被触发，而后者依然会被触发。注释中也说明了该方法即使在其中或者休眠状态下都会由于远端通知而被调用而且会优先于上一个方法。而且后者可以让你和服务器进行一定的数据交互，比如订单状态变化了，我们在该方法中向服务器请求最新的订单信息等等。\n\n官方文档是这样描述这两个方法的，一目了然：\n\n```\n// Tells the delegate that the running app received a remote notification.\n\t- application:didReceiveRemoteNotification:\n\n// Tells the app that a remote notification arrived that indicates there is data to be fetched.\n\t- application:didReceiveRemoteNotification:fetchCompletionHandler:\n```\n\n----------\n\n####服务器端代码实现\n\nApple官方APNs地址：\n1. 测试地址 gateway.sandbox.push.apple.com:2195\n2. 正式发布地址 gateway.push.apple.com:2195\n\n简单的通知数据格式，以二进制形式发送，网络字节序。\n![简单的推送通知格式](http://7xilk1.com1.z0.glb.clouddn.com/iosPushSimple%20Notification%20Format.png)\n\n服务器端代码也可以自己使用原生的Socket写，这里我使用Javapns这个开源代码实现，比较简单，Payload数据格式也已经被封装，你只需要add，add，add。代码如下：\n其中就需要用到我们之前生成的Push.p12\n\n``` Java\npackage testApplePush;\n\nimport java.util.List;\nimport javapns.Push;\nimport javapns.notification.PushNotificationPayload;\nimport javapns.notification.PushedNotifications;\n\npublic class testApplePush \n{\n    public static void main(String[] args)\n    {\n       try \n       {\n          PushNotificationPayload payload = new PushNotificationPayload();\n\n          payload.addAlert(\"这是一条推送通知!\"); // 通知主体内容\n          payload.addBadge(1); // 角标数字\n          payload.addSound(\"default\"); // 通知铃音\n          \n          // 加入自定义信息\n          payload.addCustomDictionary(\"carryOrderId\", \"121212121212121212121212\");\n \n\t\t    // 服务器端记录的DeviceToken\n          String deviceToken = \"************************************************\";\n          PushedNotifications notifications = Push.payload(payload, \t// 自定义payload\n\t\t\t\t\t\t\t\t\t\t\t\t          \"Push.p12\",\t// 前面生成的证书\n\t\t\t\t\t\t\t\t\t\t\t\t          \"111111111\", \t// 证书导出时的密码\n\t\t\t\t\t\t\t\t\t\t\t\t          false,\t\t// 是否发送到发布地址\n\t\t\t\t\t\t\t\t\t\t\t\t          deviceToken); // 客户端DeviceToken\n\n            int numOfFailedNotifications = notifications.getFailedNotifications()\n                    .size();\n            int numOfSuccessfulNotificatios = notifications\n                    .getSuccessfulNotifications().size();\n\n            System.out.println(String.format(\n                    \"Successful Send: %d, Failed Send: %d\",\n                    numOfSuccessfulNotificatios, numOfFailedNotifications));\n\n        } \n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n当前这里只是发送一条，如果需要批量发送，貌似Javapns支持的不是太好。这里使用的证书就是上面我们导出的.p12格式证书（**Windows平台使用没问题。有些教程说是Win系统不识别是不正确的**），接下来还有一份PHP写的代码，供大家查阅。但是这其中需要将我们的p12格式证书转换成pem格式证书。具体教程如下：\n-  将我们之前生成的推送证书aps_developement.cer文件以及Push.p12文件放在同一文件夹下；\n-  在Terminal中切换到该目录下，然后执行命令将aps_developement.cer文件转换成pem格式文件，之后会在本目录下生成PushCert.pem文件\n\n```\nopenssl x509 -in aps_development.cer -inform der -out PushCert.pem\n```\n- 紧接着执行命令将Push.p12文件转换成pem格式文件，之后在本目录下生成PushKey.pem文件，其中会提示你先输入之前生成Push.p12文件的时候的密码，然后需要为新生成的证书文件添加密码，这个密码是要提供给服务端使用的；\n\n```\nopenssl pkcs12 -nocerts -out Pushkey.pem -in Push.p12 \n```\n- 然后将这两个pem文件合成成一个pem文件，Push.pem\n```\ncat PushCert.pem PushKey.pem > Push.pem\n```\n整个过程如下图所示：\n![pem文件生成过程](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode9.png)\n\n证书生成完毕之后，我们就可以在代码中使用了。\n如下为PHP写的推送通知服务。代码很简单，主要是注意其中证书为上一步生成的Push.pem，密码就是生成时输入的密码。\n\n``` PHP\n<?php\n// DeviceToken 不包含空格\n$deviceToken = '********************************************************';\n// 证书密码\n$passphrase = '1111111111';\n// 通知主体内容\n$alert = '这是一条推送通知!';\n\n////////////////////////////////////////////////////////////////////////////////\n$ctx = stream_context_create();\nstream_context_set_option($ctx, 'ssl', 'local_cert', 'Push.pem');\t\t// ck.pem证书上有提及\nstream_context_set_option($ctx, 'ssl', 'passphrase', $passphrase);\n\n// Open a connection to the APNS server\n$fp = stream_socket_client(\n\t\t'ssl://gateway.sandbox.push.apple.com:2195', \t\t\t// 远端测试地址\n\t\t$err,\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t$errstr, \n\t\t60, \t\t\t\t\t\t\t\t\t\t\t\t\t// 超时时间\n\t\tSTREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT,\n\t\t$ctx);\nif (!$fp)\n\texit(\"Failed to connect: $err $errstr\" . PHP_EOL);\n\necho 'Connected to APNS' . PHP_EOL;\n\n// 建立字典数据\n$body['aps'] = array(\n\t'alert' => $alert,\n\t'sound' => 'default',\n\t'badge' => 66\n\t);\n\n// 将字典数据转换成JSON\n$payload = json_encode($body);\n\n// 组织二进制数据格式，具体格式参照apple官方文档，本文中也有提及。\n// Command + Token length + deviceToken + Payload length + payload\n$msg = chr(0) . pack('n', 32) . pack('H*', $deviceToken) . pack('n', strlen($payload)) . $payload;\n\n// 发送组成的数据给APNs\n$result = fwrite($fp, $msg, strlen($msg));\nif (!$result)\n\techo 'Fail to delivery Notification' . PHP_EOL;\nelse\n\techo 'Delivery Notification successfully' . PHP_EOL;\n\nfclose($fp);\n?>\n```\n运行下下测试：\n![最终测试效果](http://7xilk1.com1.z0.glb.clouddn.com/iosPushResult.png)\n\n\n参考：\n[1]. https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1\n[2]. https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/\n[3]. http://blog.csdn.net/shenjie12345678/article/details/41120637\n\n\n","source":"_posts/iOS-Push-Notification.md","raw":"title: \"iOS 远端推送部署详解\"\ndate: 2015-07-30 14:30:00\ncategories: iOS\ntags: [iOS,Push Notification]\n---\n\n最近几天被iOS的推送部署给搞懵了，现在特地整理下和大家进行分享。\n\n#### iOS远端推送机制\n\nAPNS，全称为Apple Push Notification service，是苹果通知推送服务中最重要的一环。它是苹果通知推送服务器，为所有iOS设备以及OS X设备提供强大并且可靠的推送通知服务。每个注册通知服务的设备都会和该服务器进行长连接，从而实时获取推送通知。即使当前APP不在运行状态，当通知到达的时候也会有提示发生，最常见的就是短信服务。\n\n<!-- more -->\n\n每一个App必须向APNs注册通知服务，APNs会返回给设备一个DeviceToken，该Token为APNs上针对该设备的唯一标示符。App需要将该DeviceToken返给自身的Server端保存后续使用，如下所示。\n![DeviceToken的操作流程](http://7xilk1.com1.z0.glb.clouddn.com/iosPushshare%20the%20device%20Token.png)\n\n当App开发者的server需要向特定设备推送通知时，就使用DeviceToken和固定格式数据（Push payload）发给APNs，然后APNs就会向DeviceToken指定的设备推送通知了，具体流程如下所示，单一推送\n![通知方推送一条远端通知给客户端代码的整个流程](http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20a%20remote%20notification%20from%20a%20provider%20to%20a%20client%20app.png)\n或者多方通知，APNs都能一一对应，靠的就是之前我们提供给它的DeviceToken。\n![多个通知方向向不同的客户端推送通知的流程示意](http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20remote%20notifications%20from%20multiple%20providers%20to%20multiple%20devices.png)\n\n\n----------\n\n#### 本地推送证书配置\n\n打开你mac的钥匙串访问，然后点击钥匙串访问\n![打开钥匙串](http://7xilk1.com1.z0.glb.clouddn.com/iosPush钥匙串.png)\n随后它会弹出一个窗口 用户电子邮件信息\n![生成CSR文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书1.png)\n就填写你苹果开发者账号的名称即可（应该是一个邮件名称），点击保存到磁盘的选项，点击继续，点击存储，文件名为：CertificateSigningRequest.certSigningRequest。\n![保存生成的CSR文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书2.png)\n\n然后我们打开[苹果开发者中心](developer.apple.com)  进入Member Center\n![苹果开发者中心](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书3.png)\n然后点击左侧列表中任意一项进入详情页面，\n![开发者个人首页选项](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书4.png)\n![选择IOS Apps中列表项](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书5.png)\n\n##### APP ID\n\n首先我们需要为我们要开发的APP建立身份信息，就是AppID，如图所示，点击左侧\n![添加AppID](http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID1.png)\n点击添加按钮进入注册页面，我们需要输入App Id的名字以及BundleID，其中BundleID不能有通配符，否则无法具备推送功能，然后在下面的APP Service中勾选Push Notification一项\n![填写BundleID以及App ID Description](http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID2.png)\n![选择App Service](http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID3.png)\n点击下一步，然后确认提交即可，大家注意到Push Notification一项为Configurable，这是因为我们还没有为该AppID生成推送证书，等推送证书生成完毕之后可以再回来查看该AppID 的状态。\n![确认提交App ID](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书13.jpg)\n\n##### Certificates\n\n其次，我们需要生成开发者证书和推送证书，如下图所示，点击左侧Cerifications列表，选择添加进入下一页面，\n![添加证书](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书11.png)\n\n如果您的页面如图所示为灰色不可选，说明您已经拥有了开发者证书。就不需要再次生成了，如果可选就选择该选项，\n![选择证书类型](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书7.png)\n\n接下来进入以下界面，选择你之前添加的AppID，之后点击Continue即可，\n![选择需要绑定证书的App ID](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书8.png)\n\n然后选择之前我们保存在本地的CSR文件CertificateSigningRequest.certSigningRequest，点击Generate就生成了开发者的证书。\n![上传本机CSR文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书9.png)\n\n同理我们需要生成推送测试证书，生成流程和开发者证书类似，只是在证书类型页面，选择的证书类型换成了Apple Push Notification service SSL。\n![选择生成证书类型](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书10.png)\n\n当我们生成好推送证书之后再回头看我们之前创建的AppId，能够看Push Notifications一项已经为Enabled了。当然发布推送证书配置完毕之后，Distribution一项也显示为Enable。\n![再次查看APPID 状态](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书12.jpg)\n\n##### Provisioning Profiles\n\n第三步，需要生成Provisioning Profiles，该文件其实就是以上的证书、AppId以及设备信息的打包集合，我们只要在不同的场景下生成不同类型Provisioning Profiles即可，它会在后续打包ipa文件的时候被嵌入安装包内。\n首先我们选择左侧列表中的Provisioning Profiles中的All选项，选择添加\n![添加Provisioning Profiles文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision1.png)\n\n之后选择生成类型，我们这里以开发类型为例，下面还有发布的两种类型，\n![选择生成PP文件类型](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision2.png)\n\n之后点击Continue，进入下一页面，同样选择我们之前创建的具有Push服务的AppId，\n![选择绑定的App ID](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision3.png)\n\n接下来，选择上面生成的开发证书（一一对应的，如果你选择生成的是发布Provisioning Profiles，则会出现发布证书），\n![选择之前生成的对应证书](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision4.png)\n\n紧接着，我们选择授权设备，即你需要进行开发的设备，该设备可以在左侧Devices列表中添加，需要提供设备的UUID，这里我们选择所有设备，点击Continue，\n![选择授权设备](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision5.png)\n\n最后一步，我们给Provisioning Profiles添加名称，\n![添加Provisioning Profiles名称](http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision6.png)\n点击Generate即生成我们所需要的Provisioning Profile。\n\n其实同理，我们可以生成发布版的开发者证书，推送证书以及对应的Provisioning Profiles。最后的文件我们都放到同一个文件夹里，如图所示，其中我把发布的两种（Ad Hoc 和 Distribution）都一起搞出来。\n![生成的各个证书以及Provisioning Profile文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书200.png)\n\n其中Push.p12文件后续会提及~\n\n----------\n\n#### 开发环境配置\n\n我们将上一步生成的开发者证书`ios_development.cer`以及推送证书`aps_development.cer`在最初生成CSR文件的MAC机上安装，双击即可安装，同时会打开钥匙串页面，安装之后我们找到之前生成CSR文件时生成的专用密钥，名称就是我们之前生成CSR文件时填写的，选择该专用密钥，同时选中刚刚安装成功的推送证书，（**必须注意，同时选择，我们需要将专用密钥以及安装成功的推送证书同时导出成一个文件**）右键菜单导出，\n![导出专用密钥和本地安装的推送证书](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode6.png)\n如图我们命名Push，点击存储，\n![保存到本地](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode7.png)\n接下来需要为证书添加密码，这个密码是需要提供给服务器的。\n![添加证书密码](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode8.png)\n\n最后我们需要配置我们本地的开发环境，也就是XCode，第一步我们点击XCode的Preference打开XCode的首选项菜单，\n![打开Preference选项](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode1.png)\n\n在Account选项中添加我们的开发者账户，如果之前已经登录就会看到该账户信息，然后点击下方的View Details，\n![查看账户信息](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode5.png)\n\n之后会显示该开发者账户的证书和Provisioning Profiles等信息，该信息会和你开发者账号里面显示的一致，如果不一致就点击刷新，\n![刷新账户信息](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode3.png)\n\n不久就会出现我们之前创建的Provisioning Profiles，接下来，我们在XCode中Build Settings -> Code Signing中选择我们需要的Provisioning Profiles文件即可\n![XCode选择对应的Provisioning Profile文件](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode4.png)\n\n此时本地开发环境已经配置完毕。接下来就开始Coding，Coding，Coding。。。。\n\n\n#### 远端推送通知的代码实现\n\n首先我们需要注册推送通知服务并获取DeviceToken；\n\n``` Objc\n- (void)initPushNotificationWithApp: (UIApplication*)application {\n    // 注册通知服务\n    if([UIDevice currentDevice].systemVersion.floatValue < 8.0) {\n        [application registerForRemoteNotificationTypes:(UIRemoteNotificationTypeBadge\n                                                       | UIRemoteNotificationTypeSound\n                                                       | UIRemoteNotificationTypeAlert)];\n    } else {\n        // IOS8.0以上版本的注册推送方式和以往不同\n        UIUserNotificationSettings* settings = [UIUserNotificationSettings settingsForTypes:(UIRemoteNotificationTypeBadge\n                                                                                           | UIRemoteNotificationTypeSound\n                                                                                           | UIRemoteNotificationTypeAlert)\n                                                                                 categories:nil];\n        [application registerUserNotificationSettings:settings];\n        [application registerForRemoteNotifications];\n    }\n}\n```\n\n\n\n\n如果注册成功，APNs会返回给你设备的token，iOS系统会把它传递给app delegate代理：\n\n``` Objective-C\n// 如果注册成功，则会收到DeviceToken，我们需要将该Token发给服务器保存\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {\n    PRINT_FUNC\n    \n    NSString* tokenStr = [NSString stringWithFormat:@\"%@\", deviceToken];\n    NSLog(@\"deviceToken: %@\", tokenStr);\n    if(tokenStr.length == 0)\n    {\n        NSLog(@\"Device Token Invalid!\");\n    }\n\t\n\t// 然后我们需要将该DeviceToken发给我们自己的服务器进行保存；\n    [self sendDeviceToken:deviceToken]; \n}\n\n// 如果注册失败，会收到错误信息，包含错误原因\n- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {\n    PRINT_FUNC\n    \n    NSLog(@\"***************************************\\n\");\n    NSLog(@\"Failed to Register The Notification!!!!\\n\");\n    NSLog(@\"error = %@\", error);\n    NSLog(@\"***************************************\\n\");\n}\n```\n\n之后我们就可以在AppDelegate中添加处理代码，当用户点击通知栏的通知或者处于运行状态时，App代码会执行- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo代理方法，如下所示：\n\n``` Objective-C\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {\n    PRINT_FUNC\n    \n    NSLog(@\"收到推送通知: %@\", userInfo);\n    \n    // userInfo是一个字典数据类型，具体Key Value由客户端和服务器进行协商确定\n    NSString* orderId = [userInfo objectForKey:@\"carryOrderId\"];\n    NSLog(@\"收到订单消息通知，订单号：%@\",orderId);\n\t\n\t// .... 其余逻辑，拿到具体关键信息之后进行下一步处理\n}\n```\n\n还有一个方法 \n\n``` Objective-C\n/*! This delegate method offers an opportunity for applications with the \"remote-notification\" background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you're finished performing that operation, so the system can accurately estimate its power and data cost.\n \n This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/\n \n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler; \n```\n\n我发现这两个方法在APP处于后台或者前台展示，也就是App存活期会同样调用，但当APP并未启动或者被后台销毁之后，用户点击通知象虽然都会调起App，但是前者这个方法就不会被触发，而后者依然会被触发。注释中也说明了该方法即使在其中或者休眠状态下都会由于远端通知而被调用而且会优先于上一个方法。而且后者可以让你和服务器进行一定的数据交互，比如订单状态变化了，我们在该方法中向服务器请求最新的订单信息等等。\n\n官方文档是这样描述这两个方法的，一目了然：\n\n```\n// Tells the delegate that the running app received a remote notification.\n\t- application:didReceiveRemoteNotification:\n\n// Tells the app that a remote notification arrived that indicates there is data to be fetched.\n\t- application:didReceiveRemoteNotification:fetchCompletionHandler:\n```\n\n----------\n\n####服务器端代码实现\n\nApple官方APNs地址：\n1. 测试地址 gateway.sandbox.push.apple.com:2195\n2. 正式发布地址 gateway.push.apple.com:2195\n\n简单的通知数据格式，以二进制形式发送，网络字节序。\n![简单的推送通知格式](http://7xilk1.com1.z0.glb.clouddn.com/iosPushSimple%20Notification%20Format.png)\n\n服务器端代码也可以自己使用原生的Socket写，这里我使用Javapns这个开源代码实现，比较简单，Payload数据格式也已经被封装，你只需要add，add，add。代码如下：\n其中就需要用到我们之前生成的Push.p12\n\n``` Java\npackage testApplePush;\n\nimport java.util.List;\nimport javapns.Push;\nimport javapns.notification.PushNotificationPayload;\nimport javapns.notification.PushedNotifications;\n\npublic class testApplePush \n{\n    public static void main(String[] args)\n    {\n       try \n       {\n          PushNotificationPayload payload = new PushNotificationPayload();\n\n          payload.addAlert(\"这是一条推送通知!\"); // 通知主体内容\n          payload.addBadge(1); // 角标数字\n          payload.addSound(\"default\"); // 通知铃音\n          \n          // 加入自定义信息\n          payload.addCustomDictionary(\"carryOrderId\", \"121212121212121212121212\");\n \n\t\t    // 服务器端记录的DeviceToken\n          String deviceToken = \"************************************************\";\n          PushedNotifications notifications = Push.payload(payload, \t// 自定义payload\n\t\t\t\t\t\t\t\t\t\t\t\t          \"Push.p12\",\t// 前面生成的证书\n\t\t\t\t\t\t\t\t\t\t\t\t          \"111111111\", \t// 证书导出时的密码\n\t\t\t\t\t\t\t\t\t\t\t\t          false,\t\t// 是否发送到发布地址\n\t\t\t\t\t\t\t\t\t\t\t\t          deviceToken); // 客户端DeviceToken\n\n            int numOfFailedNotifications = notifications.getFailedNotifications()\n                    .size();\n            int numOfSuccessfulNotificatios = notifications\n                    .getSuccessfulNotifications().size();\n\n            System.out.println(String.format(\n                    \"Successful Send: %d, Failed Send: %d\",\n                    numOfSuccessfulNotificatios, numOfFailedNotifications));\n\n        } \n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n当前这里只是发送一条，如果需要批量发送，貌似Javapns支持的不是太好。这里使用的证书就是上面我们导出的.p12格式证书（**Windows平台使用没问题。有些教程说是Win系统不识别是不正确的**），接下来还有一份PHP写的代码，供大家查阅。但是这其中需要将我们的p12格式证书转换成pem格式证书。具体教程如下：\n-  将我们之前生成的推送证书aps_developement.cer文件以及Push.p12文件放在同一文件夹下；\n-  在Terminal中切换到该目录下，然后执行命令将aps_developement.cer文件转换成pem格式文件，之后会在本目录下生成PushCert.pem文件\n\n```\nopenssl x509 -in aps_development.cer -inform der -out PushCert.pem\n```\n- 紧接着执行命令将Push.p12文件转换成pem格式文件，之后在本目录下生成PushKey.pem文件，其中会提示你先输入之前生成Push.p12文件的时候的密码，然后需要为新生成的证书文件添加密码，这个密码是要提供给服务端使用的；\n\n```\nopenssl pkcs12 -nocerts -out Pushkey.pem -in Push.p12 \n```\n- 然后将这两个pem文件合成成一个pem文件，Push.pem\n```\ncat PushCert.pem PushKey.pem > Push.pem\n```\n整个过程如下图所示：\n![pem文件生成过程](http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode9.png)\n\n证书生成完毕之后，我们就可以在代码中使用了。\n如下为PHP写的推送通知服务。代码很简单，主要是注意其中证书为上一步生成的Push.pem，密码就是生成时输入的密码。\n\n``` PHP\n<?php\n// DeviceToken 不包含空格\n$deviceToken = '********************************************************';\n// 证书密码\n$passphrase = '1111111111';\n// 通知主体内容\n$alert = '这是一条推送通知!';\n\n////////////////////////////////////////////////////////////////////////////////\n$ctx = stream_context_create();\nstream_context_set_option($ctx, 'ssl', 'local_cert', 'Push.pem');\t\t// ck.pem证书上有提及\nstream_context_set_option($ctx, 'ssl', 'passphrase', $passphrase);\n\n// Open a connection to the APNS server\n$fp = stream_socket_client(\n\t\t'ssl://gateway.sandbox.push.apple.com:2195', \t\t\t// 远端测试地址\n\t\t$err,\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t$errstr, \n\t\t60, \t\t\t\t\t\t\t\t\t\t\t\t\t// 超时时间\n\t\tSTREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT,\n\t\t$ctx);\nif (!$fp)\n\texit(\"Failed to connect: $err $errstr\" . PHP_EOL);\n\necho 'Connected to APNS' . PHP_EOL;\n\n// 建立字典数据\n$body['aps'] = array(\n\t'alert' => $alert,\n\t'sound' => 'default',\n\t'badge' => 66\n\t);\n\n// 将字典数据转换成JSON\n$payload = json_encode($body);\n\n// 组织二进制数据格式，具体格式参照apple官方文档，本文中也有提及。\n// Command + Token length + deviceToken + Payload length + payload\n$msg = chr(0) . pack('n', 32) . pack('H*', $deviceToken) . pack('n', strlen($payload)) . $payload;\n\n// 发送组成的数据给APNs\n$result = fwrite($fp, $msg, strlen($msg));\nif (!$result)\n\techo 'Fail to delivery Notification' . PHP_EOL;\nelse\n\techo 'Delivery Notification successfully' . PHP_EOL;\n\nfclose($fp);\n?>\n```\n运行下下测试：\n![最终测试效果](http://7xilk1.com1.z0.glb.clouddn.com/iosPushResult.png)\n\n\n参考：\n[1]. https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1\n[2]. https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/\n[3]. http://blog.csdn.net/shenjie12345678/article/details/41120637\n\n\n","slug":"iOS-Push-Notification","published":1,"updated":"2017-05-21T08:40:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftd2006579po5dh9pf1e","content":"<p>最近几天被iOS的推送部署给搞懵了，现在特地整理下和大家进行分享。</p>\n<h4 id=\"iOS远端推送机制\"><a href=\"#iOS远端推送机制\" class=\"headerlink\" title=\"iOS远端推送机制\"></a>iOS远端推送机制</h4><p>APNS，全称为Apple Push Notification service，是苹果通知推送服务中最重要的一环。它是苹果通知推送服务器，为所有iOS设备以及OS X设备提供强大并且可靠的推送通知服务。每个注册通知服务的设备都会和该服务器进行长连接，从而实时获取推送通知。即使当前APP不在运行状态，当通知到达的时候也会有提示发生，最常见的就是短信服务。</p>\n<a id=\"more\"></a>\n<p>每一个App必须向APNs注册通知服务，APNs会返回给设备一个DeviceToken，该Token为APNs上针对该设备的唯一标示符。App需要将该DeviceToken返给自身的Server端保存后续使用，如下所示。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushshare%20the%20device%20Token.png\" alt=\"DeviceToken的操作流程\"></p>\n<p>当App开发者的server需要向特定设备推送通知时，就使用DeviceToken和固定格式数据（Push payload）发给APNs，然后APNs就会向DeviceToken指定的设备推送通知了，具体流程如下所示，单一推送<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20a%20remote%20notification%20from%20a%20provider%20to%20a%20client%20app.png\" alt=\"通知方推送一条远端通知给客户端代码的整个流程\"><br>或者多方通知，APNs都能一一对应，靠的就是之前我们提供给它的DeviceToken。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20remote%20notifications%20from%20multiple%20providers%20to%20multiple%20devices.png\" alt=\"多个通知方向向不同的客户端推送通知的流程示意\"></p>\n<hr>\n<h4 id=\"本地推送证书配置\"><a href=\"#本地推送证书配置\" class=\"headerlink\" title=\"本地推送证书配置\"></a>本地推送证书配置</h4><p>打开你mac的钥匙串访问，然后点击钥匙串访问<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush钥匙串.png\" alt=\"打开钥匙串\"><br>随后它会弹出一个窗口 用户电子邮件信息<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书1.png\" alt=\"生成CSR文件\"><br>就填写你苹果开发者账号的名称即可（应该是一个邮件名称），点击保存到磁盘的选项，点击继续，点击存储，文件名为：CertificateSigningRequest.certSigningRequest。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书2.png\" alt=\"保存生成的CSR文件\"></p>\n<p>然后我们打开<a href=\"developer.apple.com\">苹果开发者中心</a>  进入Member Center<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书3.png\" alt=\"苹果开发者中心\"><br>然后点击左侧列表中任意一项进入详情页面，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书4.png\" alt=\"开发者个人首页选项\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书5.png\" alt=\"选择IOS Apps中列表项\"></p>\n<h5 id=\"APP-ID\"><a href=\"#APP-ID\" class=\"headerlink\" title=\"APP ID\"></a>APP ID</h5><p>首先我们需要为我们要开发的APP建立身份信息，就是AppID，如图所示，点击左侧<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID1.png\" alt=\"添加AppID\"><br>点击添加按钮进入注册页面，我们需要输入App Id的名字以及BundleID，其中BundleID不能有通配符，否则无法具备推送功能，然后在下面的APP Service中勾选Push Notification一项<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID2.png\" alt=\"填写BundleID以及App ID Description\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID3.png\" alt=\"选择App Service\"><br>点击下一步，然后确认提交即可，大家注意到Push Notification一项为Configurable，这是因为我们还没有为该AppID生成推送证书，等推送证书生成完毕之后可以再回来查看该AppID 的状态。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书13.jpg\" alt=\"确认提交App ID\"></p>\n<h5 id=\"Certificates\"><a href=\"#Certificates\" class=\"headerlink\" title=\"Certificates\"></a>Certificates</h5><p>其次，我们需要生成开发者证书和推送证书，如下图所示，点击左侧Cerifications列表，选择添加进入下一页面，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书11.png\" alt=\"添加证书\"></p>\n<p>如果您的页面如图所示为灰色不可选，说明您已经拥有了开发者证书。就不需要再次生成了，如果可选就选择该选项，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书7.png\" alt=\"选择证书类型\"></p>\n<p>接下来进入以下界面，选择你之前添加的AppID，之后点击Continue即可，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书8.png\" alt=\"选择需要绑定证书的App ID\"></p>\n<p>然后选择之前我们保存在本地的CSR文件CertificateSigningRequest.certSigningRequest，点击Generate就生成了开发者的证书。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书9.png\" alt=\"上传本机CSR文件\"></p>\n<p>同理我们需要生成推送测试证书，生成流程和开发者证书类似，只是在证书类型页面，选择的证书类型换成了Apple Push Notification service SSL。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书10.png\" alt=\"选择生成证书类型\"></p>\n<p>当我们生成好推送证书之后再回头看我们之前创建的AppId，能够看Push Notifications一项已经为Enabled了。当然发布推送证书配置完毕之后，Distribution一项也显示为Enable。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书12.jpg\" alt=\"再次查看APPID 状态\"></p>\n<h5 id=\"Provisioning-Profiles\"><a href=\"#Provisioning-Profiles\" class=\"headerlink\" title=\"Provisioning Profiles\"></a>Provisioning Profiles</h5><p>第三步，需要生成Provisioning Profiles，该文件其实就是以上的证书、AppId以及设备信息的打包集合，我们只要在不同的场景下生成不同类型Provisioning Profiles即可，它会在后续打包ipa文件的时候被嵌入安装包内。<br>首先我们选择左侧列表中的Provisioning Profiles中的All选项，选择添加<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision1.png\" alt=\"添加Provisioning Profiles文件\"></p>\n<p>之后选择生成类型，我们这里以开发类型为例，下面还有发布的两种类型，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision2.png\" alt=\"选择生成PP文件类型\"></p>\n<p>之后点击Continue，进入下一页面，同样选择我们之前创建的具有Push服务的AppId，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision3.png\" alt=\"选择绑定的App ID\"></p>\n<p>接下来，选择上面生成的开发证书（一一对应的，如果你选择生成的是发布Provisioning Profiles，则会出现发布证书），<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision4.png\" alt=\"选择之前生成的对应证书\"></p>\n<p>紧接着，我们选择授权设备，即你需要进行开发的设备，该设备可以在左侧Devices列表中添加，需要提供设备的UUID，这里我们选择所有设备，点击Continue，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision5.png\" alt=\"选择授权设备\"></p>\n<p>最后一步，我们给Provisioning Profiles添加名称，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision6.png\" alt=\"添加Provisioning Profiles名称\"><br>点击Generate即生成我们所需要的Provisioning Profile。</p>\n<p>其实同理，我们可以生成发布版的开发者证书，推送证书以及对应的Provisioning Profiles。最后的文件我们都放到同一个文件夹里，如图所示，其中我把发布的两种（Ad Hoc 和 Distribution）都一起搞出来。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书200.png\" alt=\"生成的各个证书以及Provisioning Profile文件\"></p>\n<p>其中Push.p12文件后续会提及~</p>\n<hr>\n<h4 id=\"开发环境配置\"><a href=\"#开发环境配置\" class=\"headerlink\" title=\"开发环境配置\"></a>开发环境配置</h4><p>我们将上一步生成的开发者证书<code>ios_development.cer</code>以及推送证书<code>aps_development.cer</code>在最初生成CSR文件的MAC机上安装，双击即可安装，同时会打开钥匙串页面，安装之后我们找到之前生成CSR文件时生成的专用密钥，名称就是我们之前生成CSR文件时填写的，选择该专用密钥，同时选中刚刚安装成功的推送证书，（<strong>必须注意，同时选择，我们需要将专用密钥以及安装成功的推送证书同时导出成一个文件</strong>）右键菜单导出，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode6.png\" alt=\"导出专用密钥和本地安装的推送证书\"><br>如图我们命名Push，点击存储，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode7.png\" alt=\"保存到本地\"><br>接下来需要为证书添加密码，这个密码是需要提供给服务器的。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode8.png\" alt=\"添加证书密码\"></p>\n<p>最后我们需要配置我们本地的开发环境，也就是XCode，第一步我们点击XCode的Preference打开XCode的首选项菜单，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode1.png\" alt=\"打开Preference选项\"></p>\n<p>在Account选项中添加我们的开发者账户，如果之前已经登录就会看到该账户信息，然后点击下方的View Details，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode5.png\" alt=\"查看账户信息\"></p>\n<p>之后会显示该开发者账户的证书和Provisioning Profiles等信息，该信息会和你开发者账号里面显示的一致，如果不一致就点击刷新，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode3.png\" alt=\"刷新账户信息\"></p>\n<p>不久就会出现我们之前创建的Provisioning Profiles，接下来，我们在XCode中Build Settings -&gt; Code Signing中选择我们需要的Provisioning Profiles文件即可<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode4.png\" alt=\"XCode选择对应的Provisioning Profile文件\"></p>\n<p>此时本地开发环境已经配置完毕。接下来就开始Coding，Coding，Coding。。。。</p>\n<h4 id=\"远端推送通知的代码实现\"><a href=\"#远端推送通知的代码实现\" class=\"headerlink\" title=\"远端推送通知的代码实现\"></a>远端推送通知的代码实现</h4><p>首先我们需要注册推送通知服务并获取DeviceToken；</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)initPushNotificationWithApp: (<span class=\"built_in\">UIApplication</span>*)application &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册通知服务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>([<span class=\"built_in\">UIDevice</span> currentDevice].systemVersion.floatValue &lt; <span class=\"number\">8.0</span>) &#123;</span><br><span class=\"line\">        [application registerForRemoteNotificationTypes:(<span class=\"built_in\">UIRemoteNotificationTypeBadge</span></span><br><span class=\"line\">                                                       | <span class=\"built_in\">UIRemoteNotificationTypeSound</span></span><br><span class=\"line\">                                                       | <span class=\"built_in\">UIRemoteNotificationTypeAlert</span>)];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// IOS8.0以上版本的注册推送方式和以往不同</span></span><br><span class=\"line\">        <span class=\"built_in\">UIUserNotificationSettings</span>* settings = [<span class=\"built_in\">UIUserNotificationSettings</span> settingsForTypes:(<span class=\"built_in\">UIRemoteNotificationTypeBadge</span></span><br><span class=\"line\">                                                                                           | <span class=\"built_in\">UIRemoteNotificationTypeSound</span></span><br><span class=\"line\">                                                                                           | <span class=\"built_in\">UIRemoteNotificationTypeAlert</span>)</span><br><span class=\"line\">                                                                                 categories:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        [application registerUserNotificationSettings:settings];</span><br><span class=\"line\">        [application registerForRemoteNotifications];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果注册成功，APNs会返回给你设备的token，iOS系统会把它传递给app delegate代理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 如果注册成功，则会收到DeviceToken，我们需要将该Token发给服务器保存</span><br><span class=\"line\">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class=\"line\">    PRINT_FUNC</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString* tokenStr = [NSString stringWithFormat:@&quot;%@&quot;, deviceToken];</span><br><span class=\"line\">    NSLog(@&quot;deviceToken: %@&quot;, tokenStr);</span><br><span class=\"line\">    if(tokenStr.length == 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        NSLog(@&quot;Device Token Invalid!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 然后我们需要将该DeviceToken发给我们自己的服务器进行保存；</span><br><span class=\"line\">    [self sendDeviceToken:deviceToken]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果注册失败，会收到错误信息，包含错误原因</span><br><span class=\"line\">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error &#123;</span><br><span class=\"line\">    PRINT_FUNC</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;***************************************\\n&quot;);</span><br><span class=\"line\">    NSLog(@&quot;Failed to Register The Notification!!!!\\n&quot;);</span><br><span class=\"line\">    NSLog(@&quot;error = %@&quot;, error);</span><br><span class=\"line\">    NSLog(@&quot;***************************************\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后我们就可以在AppDelegate中添加处理代码，当用户点击通知栏的通知或者处于运行状态时，App代码会执行- (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo代理方法，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123;</span><br><span class=\"line\">    PRINT_FUNC</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;收到推送通知: %@&quot;, userInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // userInfo是一个字典数据类型，具体Key Value由客户端和服务器进行协商确定</span><br><span class=\"line\">    NSString* orderId = [userInfo objectForKey:@&quot;carryOrderId&quot;];</span><br><span class=\"line\">    NSLog(@&quot;收到订单消息通知，订单号：%@&quot;,orderId);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// .... 其余逻辑，拿到具体关键信息之后进行下一步处理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个方法 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*! This delegate method offers an opportunity for applications with the &quot;remote-notification&quot; background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you&apos;re finished performing that operation, so the system can accurately estimate its power and data cost.</span><br><span class=\"line\"> </span><br><span class=\"line\"> This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/</span><br><span class=\"line\"> </span><br><span class=\"line\">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler;</span><br></pre></td></tr></table></figure>\n<p>我发现这两个方法在APP处于后台或者前台展示，也就是App存活期会同样调用，但当APP并未启动或者被后台销毁之后，用户点击通知象虽然都会调起App，但是前者这个方法就不会被触发，而后者依然会被触发。注释中也说明了该方法即使在其中或者休眠状态下都会由于远端通知而被调用而且会优先于上一个方法。而且后者可以让你和服务器进行一定的数据交互，比如订单状态变化了，我们在该方法中向服务器请求最新的订单信息等等。</p>\n<p>官方文档是这样描述这两个方法的，一目了然：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// Tells the delegate that the running app received a remote notification.</span><br><span class=\"line\">\t- application:didReceiveRemoteNotification:</span><br><span class=\"line\"></span><br><span class=\"line\">// Tells the app that a remote notification arrived that indicates there is data to be fetched.</span><br><span class=\"line\">\t- application:didReceiveRemoteNotification:fetchCompletionHandler:</span><br></pre></td></tr></table></figure>\n<hr>\n<p>####服务器端代码实现</p>\n<p>Apple官方APNs地址：</p>\n<ol>\n<li>测试地址 gateway.sandbox.push.apple.com:2195</li>\n<li>正式发布地址 gateway.push.apple.com:2195</li>\n</ol>\n<p>简单的通知数据格式，以二进制形式发送，网络字节序。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushSimple%20Notification%20Format.png\" alt=\"简单的推送通知格式\"></p>\n<p>服务器端代码也可以自己使用原生的Socket写，这里我使用Javapns这个开源代码实现，比较简单，Payload数据格式也已经被封装，你只需要add，add，add。代码如下：<br>其中就需要用到我们之前生成的Push.p12</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> testApplePush;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javapns.Push;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javapns.notification.PushNotificationPayload;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javapns.notification.PushedNotifications;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">testApplePush</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> </span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          PushNotificationPayload payload = <span class=\"keyword\">new</span> PushNotificationPayload();</span><br><span class=\"line\"></span><br><span class=\"line\">          payload.addAlert(<span class=\"string\">\"这是一条推送通知!\"</span>); <span class=\"comment\">// 通知主体内容</span></span><br><span class=\"line\">          payload.addBadge(<span class=\"number\">1</span>); <span class=\"comment\">// 角标数字</span></span><br><span class=\"line\">          payload.addSound(<span class=\"string\">\"default\"</span>); <span class=\"comment\">// 通知铃音</span></span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"comment\">// 加入自定义信息</span></span><br><span class=\"line\">          payload.addCustomDictionary(<span class=\"string\">\"carryOrderId\"</span>, <span class=\"string\">\"121212121212121212121212\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t    <span class=\"comment\">// 服务器端记录的DeviceToken</span></span><br><span class=\"line\">          String deviceToken = <span class=\"string\">\"************************************************\"</span>;</span><br><span class=\"line\">          PushedNotifications notifications = Push.payload(payload, \t<span class=\"comment\">// 自定义payload</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          <span class=\"string\">\"Push.p12\"</span>,\t<span class=\"comment\">// 前面生成的证书</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          <span class=\"string\">\"111111111\"</span>, \t<span class=\"comment\">// 证书导出时的密码</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          <span class=\"keyword\">false</span>,\t\t<span class=\"comment\">// 是否发送到发布地址</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          deviceToken); <span class=\"comment\">// 客户端DeviceToken</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> numOfFailedNotifications = notifications.getFailedNotifications()</span><br><span class=\"line\">                    .size();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> numOfSuccessfulNotificatios = notifications</span><br><span class=\"line\">                    .getSuccessfulNotifications().size();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(String.format(</span><br><span class=\"line\">                    <span class=\"string\">\"Successful Send: %d, Failed Send: %d\"</span>,</span><br><span class=\"line\">                    numOfSuccessfulNotificatios, numOfFailedNotifications));</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当前这里只是发送一条，如果需要批量发送，貌似Javapns支持的不是太好。这里使用的证书就是上面我们导出的.p12格式证书（<strong>Windows平台使用没问题。有些教程说是Win系统不识别是不正确的</strong>），接下来还有一份PHP写的代码，供大家查阅。但是这其中需要将我们的p12格式证书转换成pem格式证书。具体教程如下：</p>\n<ul>\n<li>将我们之前生成的推送证书aps_developement.cer文件以及Push.p12文件放在同一文件夹下；</li>\n<li>在Terminal中切换到该目录下，然后执行命令将aps_developement.cer文件转换成pem格式文件，之后会在本目录下生成PushCert.pem文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in aps_development.cer -inform der -out PushCert.pem</span><br></pre></td></tr></table></figure>\n<ul>\n<li>紧接着执行命令将Push.p12文件转换成pem格式文件，之后在本目录下生成PushKey.pem文件，其中会提示你先输入之前生成Push.p12文件的时候的密码，然后需要为新生成的证书文件添加密码，这个密码是要提供给服务端使用的；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -nocerts -out Pushkey.pem -in Push.p12</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后将这两个pem文件合成成一个pem文件，Push.pem<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat PushCert.pem PushKey.pem &gt; Push.pem</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>整个过程如下图所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode9.png\" alt=\"pem文件生成过程\"></p>\n<p>证书生成完毕之后，我们就可以在代码中使用了。<br>如下为PHP写的推送通知服务。代码很简单，主要是注意其中证书为上一步生成的Push.pem，密码就是生成时输入的密码。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// DeviceToken 不包含空格</span></span><br><span class=\"line\">$deviceToken = <span class=\"string\">'********************************************************'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 证书密码</span></span><br><span class=\"line\">$passphrase = <span class=\"string\">'1111111111'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 通知主体内容</span></span><br><span class=\"line\">$alert = <span class=\"string\">'这是一条推送通知!'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\">$ctx = stream_context_create();</span><br><span class=\"line\">stream_context_set_option($ctx, <span class=\"string\">'ssl'</span>, <span class=\"string\">'local_cert'</span>, <span class=\"string\">'Push.pem'</span>);\t\t<span class=\"comment\">// ck.pem证书上有提及</span></span><br><span class=\"line\">stream_context_set_option($ctx, <span class=\"string\">'ssl'</span>, <span class=\"string\">'passphrase'</span>, $passphrase);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Open a connection to the APNS server</span></span><br><span class=\"line\">$fp = stream_socket_client(</span><br><span class=\"line\">\t\t<span class=\"string\">'ssl://gateway.sandbox.push.apple.com:2195'</span>, \t\t\t<span class=\"comment\">// 远端测试地址</span></span><br><span class=\"line\">\t\t$err,\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t$errstr, </span><br><span class=\"line\">\t\t<span class=\"number\">60</span>, \t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 超时时间</span></span><br><span class=\"line\">\t\tSTREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT,</span><br><span class=\"line\">\t\t$ctx);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!$fp)</span><br><span class=\"line\">\t<span class=\"keyword\">exit</span>(<span class=\"string\">\"Failed to connect: $err $errstr\"</span> . PHP_EOL);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'Connected to APNS'</span> . PHP_EOL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立字典数据</span></span><br><span class=\"line\">$body[<span class=\"string\">'aps'</span>] = <span class=\"keyword\">array</span>(</span><br><span class=\"line\">\t<span class=\"string\">'alert'</span> =&gt; $alert,</span><br><span class=\"line\">\t<span class=\"string\">'sound'</span> =&gt; <span class=\"string\">'default'</span>,</span><br><span class=\"line\">\t<span class=\"string\">'badge'</span> =&gt; <span class=\"number\">66</span></span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字典数据转换成JSON</span></span><br><span class=\"line\">$payload = json_encode($body);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组织二进制数据格式，具体格式参照apple官方文档，本文中也有提及。</span></span><br><span class=\"line\"><span class=\"comment\">// Command + Token length + deviceToken + Payload length + payload</span></span><br><span class=\"line\">$msg = chr(<span class=\"number\">0</span>) . pack(<span class=\"string\">'n'</span>, <span class=\"number\">32</span>) . pack(<span class=\"string\">'H*'</span>, $deviceToken) . pack(<span class=\"string\">'n'</span>, strlen($payload)) . $payload;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送组成的数据给APNs</span></span><br><span class=\"line\">$result = fwrite($fp, $msg, strlen($msg));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!$result)</span><br><span class=\"line\">\t<span class=\"keyword\">echo</span> <span class=\"string\">'Fail to delivery Notification'</span> . PHP_EOL;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"keyword\">echo</span> <span class=\"string\">'Delivery Notification successfully'</span> . PHP_EOL;</span><br><span class=\"line\"></span><br><span class=\"line\">fclose($fp);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行下下测试：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushResult.png\" alt=\"最终测试效果\"></p>\n<p>参考：<br>[1]. <a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1</a><br>[2]. <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/</a><br>[3]. <a href=\"http://blog.csdn.net/shenjie12345678/article/details/41120637\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/shenjie12345678/article/details/41120637</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<p>最近几天被iOS的推送部署给搞懵了，现在特地整理下和大家进行分享。</p>\n<h4 id=\"iOS远端推送机制\"><a href=\"#iOS远端推送机制\" class=\"headerlink\" title=\"iOS远端推送机制\"></a>iOS远端推送机制</h4><p>APNS，全称为Apple Push Notification service，是苹果通知推送服务中最重要的一环。它是苹果通知推送服务器，为所有iOS设备以及OS X设备提供强大并且可靠的推送通知服务。每个注册通知服务的设备都会和该服务器进行长连接，从而实时获取推送通知。即使当前APP不在运行状态，当通知到达的时候也会有提示发生，最常见的就是短信服务。</p>","more":"<p>每一个App必须向APNs注册通知服务，APNs会返回给设备一个DeviceToken，该Token为APNs上针对该设备的唯一标示符。App需要将该DeviceToken返给自身的Server端保存后续使用，如下所示。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushshare%20the%20device%20Token.png\" alt=\"DeviceToken的操作流程\"></p>\n<p>当App开发者的server需要向特定设备推送通知时，就使用DeviceToken和固定格式数据（Push payload）发给APNs，然后APNs就会向DeviceToken指定的设备推送通知了，具体流程如下所示，单一推送<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20a%20remote%20notification%20from%20a%20provider%20to%20a%20client%20app.png\" alt=\"通知方推送一条远端通知给客户端代码的整个流程\"><br>或者多方通知，APNs都能一一对应，靠的就是之前我们提供给它的DeviceToken。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20remote%20notifications%20from%20multiple%20providers%20to%20multiple%20devices.png\" alt=\"多个通知方向向不同的客户端推送通知的流程示意\"></p>\n<hr>\n<h4 id=\"本地推送证书配置\"><a href=\"#本地推送证书配置\" class=\"headerlink\" title=\"本地推送证书配置\"></a>本地推送证书配置</h4><p>打开你mac的钥匙串访问，然后点击钥匙串访问<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush钥匙串.png\" alt=\"打开钥匙串\"><br>随后它会弹出一个窗口 用户电子邮件信息<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书1.png\" alt=\"生成CSR文件\"><br>就填写你苹果开发者账号的名称即可（应该是一个邮件名称），点击保存到磁盘的选项，点击继续，点击存储，文件名为：CertificateSigningRequest.certSigningRequest。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书2.png\" alt=\"保存生成的CSR文件\"></p>\n<p>然后我们打开<a href=\"developer.apple.com\">苹果开发者中心</a>  进入Member Center<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书3.png\" alt=\"苹果开发者中心\"><br>然后点击左侧列表中任意一项进入详情页面，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书4.png\" alt=\"开发者个人首页选项\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书5.png\" alt=\"选择IOS Apps中列表项\"></p>\n<h5 id=\"APP-ID\"><a href=\"#APP-ID\" class=\"headerlink\" title=\"APP ID\"></a>APP ID</h5><p>首先我们需要为我们要开发的APP建立身份信息，就是AppID，如图所示，点击左侧<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID1.png\" alt=\"添加AppID\"><br>点击添加按钮进入注册页面，我们需要输入App Id的名字以及BundleID，其中BundleID不能有通配符，否则无法具备推送功能，然后在下面的APP Service中勾选Push Notification一项<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID2.png\" alt=\"填写BundleID以及App ID Description\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID3.png\" alt=\"选择App Service\"><br>点击下一步，然后确认提交即可，大家注意到Push Notification一项为Configurable，这是因为我们还没有为该AppID生成推送证书，等推送证书生成完毕之后可以再回来查看该AppID 的状态。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书13.jpg\" alt=\"确认提交App ID\"></p>\n<h5 id=\"Certificates\"><a href=\"#Certificates\" class=\"headerlink\" title=\"Certificates\"></a>Certificates</h5><p>其次，我们需要生成开发者证书和推送证书，如下图所示，点击左侧Cerifications列表，选择添加进入下一页面，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书11.png\" alt=\"添加证书\"></p>\n<p>如果您的页面如图所示为灰色不可选，说明您已经拥有了开发者证书。就不需要再次生成了，如果可选就选择该选项，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书7.png\" alt=\"选择证书类型\"></p>\n<p>接下来进入以下界面，选择你之前添加的AppID，之后点击Continue即可，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书8.png\" alt=\"选择需要绑定证书的App ID\"></p>\n<p>然后选择之前我们保存在本地的CSR文件CertificateSigningRequest.certSigningRequest，点击Generate就生成了开发者的证书。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书9.png\" alt=\"上传本机CSR文件\"></p>\n<p>同理我们需要生成推送测试证书，生成流程和开发者证书类似，只是在证书类型页面，选择的证书类型换成了Apple Push Notification service SSL。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书10.png\" alt=\"选择生成证书类型\"></p>\n<p>当我们生成好推送证书之后再回头看我们之前创建的AppId，能够看Push Notifications一项已经为Enabled了。当然发布推送证书配置完毕之后，Distribution一项也显示为Enable。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书12.jpg\" alt=\"再次查看APPID 状态\"></p>\n<h5 id=\"Provisioning-Profiles\"><a href=\"#Provisioning-Profiles\" class=\"headerlink\" title=\"Provisioning Profiles\"></a>Provisioning Profiles</h5><p>第三步，需要生成Provisioning Profiles，该文件其实就是以上的证书、AppId以及设备信息的打包集合，我们只要在不同的场景下生成不同类型Provisioning Profiles即可，它会在后续打包ipa文件的时候被嵌入安装包内。<br>首先我们选择左侧列表中的Provisioning Profiles中的All选项，选择添加<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision1.png\" alt=\"添加Provisioning Profiles文件\"></p>\n<p>之后选择生成类型，我们这里以开发类型为例，下面还有发布的两种类型，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision2.png\" alt=\"选择生成PP文件类型\"></p>\n<p>之后点击Continue，进入下一页面，同样选择我们之前创建的具有Push服务的AppId，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision3.png\" alt=\"选择绑定的App ID\"></p>\n<p>接下来，选择上面生成的开发证书（一一对应的，如果你选择生成的是发布Provisioning Profiles，则会出现发布证书），<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision4.png\" alt=\"选择之前生成的对应证书\"></p>\n<p>紧接着，我们选择授权设备，即你需要进行开发的设备，该设备可以在左侧Devices列表中添加，需要提供设备的UUID，这里我们选择所有设备，点击Continue，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision5.png\" alt=\"选择授权设备\"></p>\n<p>最后一步，我们给Provisioning Profiles添加名称，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision6.png\" alt=\"添加Provisioning Profiles名称\"><br>点击Generate即生成我们所需要的Provisioning Profile。</p>\n<p>其实同理，我们可以生成发布版的开发者证书，推送证书以及对应的Provisioning Profiles。最后的文件我们都放到同一个文件夹里，如图所示，其中我把发布的两种（Ad Hoc 和 Distribution）都一起搞出来。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书200.png\" alt=\"生成的各个证书以及Provisioning Profile文件\"></p>\n<p>其中Push.p12文件后续会提及~</p>\n<hr>\n<h4 id=\"开发环境配置\"><a href=\"#开发环境配置\" class=\"headerlink\" title=\"开发环境配置\"></a>开发环境配置</h4><p>我们将上一步生成的开发者证书<code>ios_development.cer</code>以及推送证书<code>aps_development.cer</code>在最初生成CSR文件的MAC机上安装，双击即可安装，同时会打开钥匙串页面，安装之后我们找到之前生成CSR文件时生成的专用密钥，名称就是我们之前生成CSR文件时填写的，选择该专用密钥，同时选中刚刚安装成功的推送证书，（<strong>必须注意，同时选择，我们需要将专用密钥以及安装成功的推送证书同时导出成一个文件</strong>）右键菜单导出，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode6.png\" alt=\"导出专用密钥和本地安装的推送证书\"><br>如图我们命名Push，点击存储，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode7.png\" alt=\"保存到本地\"><br>接下来需要为证书添加密码，这个密码是需要提供给服务器的。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode8.png\" alt=\"添加证书密码\"></p>\n<p>最后我们需要配置我们本地的开发环境，也就是XCode，第一步我们点击XCode的Preference打开XCode的首选项菜单，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode1.png\" alt=\"打开Preference选项\"></p>\n<p>在Account选项中添加我们的开发者账户，如果之前已经登录就会看到该账户信息，然后点击下方的View Details，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode5.png\" alt=\"查看账户信息\"></p>\n<p>之后会显示该开发者账户的证书和Provisioning Profiles等信息，该信息会和你开发者账号里面显示的一致，如果不一致就点击刷新，<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode3.png\" alt=\"刷新账户信息\"></p>\n<p>不久就会出现我们之前创建的Provisioning Profiles，接下来，我们在XCode中Build Settings -&gt; Code Signing中选择我们需要的Provisioning Profiles文件即可<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode4.png\" alt=\"XCode选择对应的Provisioning Profile文件\"></p>\n<p>此时本地开发环境已经配置完毕。接下来就开始Coding，Coding，Coding。。。。</p>\n<h4 id=\"远端推送通知的代码实现\"><a href=\"#远端推送通知的代码实现\" class=\"headerlink\" title=\"远端推送通知的代码实现\"></a>远端推送通知的代码实现</h4><p>首先我们需要注册推送通知服务并获取DeviceToken；</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)initPushNotificationWithApp: (<span class=\"built_in\">UIApplication</span>*)application &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册通知服务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>([<span class=\"built_in\">UIDevice</span> currentDevice].systemVersion.floatValue &lt; <span class=\"number\">8.0</span>) &#123;</span><br><span class=\"line\">        [application registerForRemoteNotificationTypes:(<span class=\"built_in\">UIRemoteNotificationTypeBadge</span></span><br><span class=\"line\">                                                       | <span class=\"built_in\">UIRemoteNotificationTypeSound</span></span><br><span class=\"line\">                                                       | <span class=\"built_in\">UIRemoteNotificationTypeAlert</span>)];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// IOS8.0以上版本的注册推送方式和以往不同</span></span><br><span class=\"line\">        <span class=\"built_in\">UIUserNotificationSettings</span>* settings = [<span class=\"built_in\">UIUserNotificationSettings</span> settingsForTypes:(<span class=\"built_in\">UIRemoteNotificationTypeBadge</span></span><br><span class=\"line\">                                                                                           | <span class=\"built_in\">UIRemoteNotificationTypeSound</span></span><br><span class=\"line\">                                                                                           | <span class=\"built_in\">UIRemoteNotificationTypeAlert</span>)</span><br><span class=\"line\">                                                                                 categories:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">        [application registerUserNotificationSettings:settings];</span><br><span class=\"line\">        [application registerForRemoteNotifications];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果注册成功，APNs会返回给你设备的token，iOS系统会把它传递给app delegate代理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 如果注册成功，则会收到DeviceToken，我们需要将该Token发给服务器保存</span><br><span class=\"line\">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class=\"line\">    PRINT_FUNC</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString* tokenStr = [NSString stringWithFormat:@&quot;%@&quot;, deviceToken];</span><br><span class=\"line\">    NSLog(@&quot;deviceToken: %@&quot;, tokenStr);</span><br><span class=\"line\">    if(tokenStr.length == 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        NSLog(@&quot;Device Token Invalid!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 然后我们需要将该DeviceToken发给我们自己的服务器进行保存；</span><br><span class=\"line\">    [self sendDeviceToken:deviceToken]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果注册失败，会收到错误信息，包含错误原因</span><br><span class=\"line\">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error &#123;</span><br><span class=\"line\">    PRINT_FUNC</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;***************************************\\n&quot;);</span><br><span class=\"line\">    NSLog(@&quot;Failed to Register The Notification!!!!\\n&quot;);</span><br><span class=\"line\">    NSLog(@&quot;error = %@&quot;, error);</span><br><span class=\"line\">    NSLog(@&quot;***************************************\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后我们就可以在AppDelegate中添加处理代码，当用户点击通知栏的通知或者处于运行状态时，App代码会执行- (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo代理方法，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123;</span><br><span class=\"line\">    PRINT_FUNC</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;收到推送通知: %@&quot;, userInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // userInfo是一个字典数据类型，具体Key Value由客户端和服务器进行协商确定</span><br><span class=\"line\">    NSString* orderId = [userInfo objectForKey:@&quot;carryOrderId&quot;];</span><br><span class=\"line\">    NSLog(@&quot;收到订单消息通知，订单号：%@&quot;,orderId);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// .... 其余逻辑，拿到具体关键信息之后进行下一步处理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个方法 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*! This delegate method offers an opportunity for applications with the &quot;remote-notification&quot; background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you&apos;re finished performing that operation, so the system can accurately estimate its power and data cost.</span><br><span class=\"line\"> </span><br><span class=\"line\"> This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/</span><br><span class=\"line\"> </span><br><span class=\"line\">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler;</span><br></pre></td></tr></table></figure>\n<p>我发现这两个方法在APP处于后台或者前台展示，也就是App存活期会同样调用，但当APP并未启动或者被后台销毁之后，用户点击通知象虽然都会调起App，但是前者这个方法就不会被触发，而后者依然会被触发。注释中也说明了该方法即使在其中或者休眠状态下都会由于远端通知而被调用而且会优先于上一个方法。而且后者可以让你和服务器进行一定的数据交互，比如订单状态变化了，我们在该方法中向服务器请求最新的订单信息等等。</p>\n<p>官方文档是这样描述这两个方法的，一目了然：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// Tells the delegate that the running app received a remote notification.</span><br><span class=\"line\">\t- application:didReceiveRemoteNotification:</span><br><span class=\"line\"></span><br><span class=\"line\">// Tells the app that a remote notification arrived that indicates there is data to be fetched.</span><br><span class=\"line\">\t- application:didReceiveRemoteNotification:fetchCompletionHandler:</span><br></pre></td></tr></table></figure>\n<hr>\n<p>####服务器端代码实现</p>\n<p>Apple官方APNs地址：</p>\n<ol>\n<li>测试地址 gateway.sandbox.push.apple.com:2195</li>\n<li>正式发布地址 gateway.push.apple.com:2195</li>\n</ol>\n<p>简单的通知数据格式，以二进制形式发送，网络字节序。<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushSimple%20Notification%20Format.png\" alt=\"简单的推送通知格式\"></p>\n<p>服务器端代码也可以自己使用原生的Socket写，这里我使用Javapns这个开源代码实现，比较简单，Payload数据格式也已经被封装，你只需要add，add，add。代码如下：<br>其中就需要用到我们之前生成的Push.p12</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> testApplePush;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javapns.Push;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javapns.notification.PushNotificationPayload;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javapns.notification.PushedNotifications;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">testApplePush</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> </span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">          PushNotificationPayload payload = <span class=\"keyword\">new</span> PushNotificationPayload();</span><br><span class=\"line\"></span><br><span class=\"line\">          payload.addAlert(<span class=\"string\">\"这是一条推送通知!\"</span>); <span class=\"comment\">// 通知主体内容</span></span><br><span class=\"line\">          payload.addBadge(<span class=\"number\">1</span>); <span class=\"comment\">// 角标数字</span></span><br><span class=\"line\">          payload.addSound(<span class=\"string\">\"default\"</span>); <span class=\"comment\">// 通知铃音</span></span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"comment\">// 加入自定义信息</span></span><br><span class=\"line\">          payload.addCustomDictionary(<span class=\"string\">\"carryOrderId\"</span>, <span class=\"string\">\"121212121212121212121212\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t    <span class=\"comment\">// 服务器端记录的DeviceToken</span></span><br><span class=\"line\">          String deviceToken = <span class=\"string\">\"************************************************\"</span>;</span><br><span class=\"line\">          PushedNotifications notifications = Push.payload(payload, \t<span class=\"comment\">// 自定义payload</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          <span class=\"string\">\"Push.p12\"</span>,\t<span class=\"comment\">// 前面生成的证书</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          <span class=\"string\">\"111111111\"</span>, \t<span class=\"comment\">// 证书导出时的密码</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          <span class=\"keyword\">false</span>,\t\t<span class=\"comment\">// 是否发送到发布地址</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t          deviceToken); <span class=\"comment\">// 客户端DeviceToken</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> numOfFailedNotifications = notifications.getFailedNotifications()</span><br><span class=\"line\">                    .size();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> numOfSuccessfulNotificatios = notifications</span><br><span class=\"line\">                    .getSuccessfulNotifications().size();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(String.format(</span><br><span class=\"line\">                    <span class=\"string\">\"Successful Send: %d, Failed Send: %d\"</span>,</span><br><span class=\"line\">                    numOfSuccessfulNotificatios, numOfFailedNotifications));</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当前这里只是发送一条，如果需要批量发送，貌似Javapns支持的不是太好。这里使用的证书就是上面我们导出的.p12格式证书（<strong>Windows平台使用没问题。有些教程说是Win系统不识别是不正确的</strong>），接下来还有一份PHP写的代码，供大家查阅。但是这其中需要将我们的p12格式证书转换成pem格式证书。具体教程如下：</p>\n<ul>\n<li>将我们之前生成的推送证书aps_developement.cer文件以及Push.p12文件放在同一文件夹下；</li>\n<li>在Terminal中切换到该目录下，然后执行命令将aps_developement.cer文件转换成pem格式文件，之后会在本目录下生成PushCert.pem文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -in aps_development.cer -inform der -out PushCert.pem</span><br></pre></td></tr></table></figure>\n<ul>\n<li>紧接着执行命令将Push.p12文件转换成pem格式文件，之后在本目录下生成PushKey.pem文件，其中会提示你先输入之前生成Push.p12文件的时候的密码，然后需要为新生成的证书文件添加密码，这个密码是要提供给服务端使用的；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -nocerts -out Pushkey.pem -in Push.p12</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后将这两个pem文件合成成一个pem文件，Push.pem<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat PushCert.pem PushKey.pem &gt; Push.pem</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>整个过程如下图所示：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode9.png\" alt=\"pem文件生成过程\"></p>\n<p>证书生成完毕之后，我们就可以在代码中使用了。<br>如下为PHP写的推送通知服务。代码很简单，主要是注意其中证书为上一步生成的Push.pem，密码就是生成时输入的密码。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// DeviceToken 不包含空格</span></span><br><span class=\"line\">$deviceToken = <span class=\"string\">'********************************************************'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 证书密码</span></span><br><span class=\"line\">$passphrase = <span class=\"string\">'1111111111'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 通知主体内容</span></span><br><span class=\"line\">$alert = <span class=\"string\">'这是一条推送通知!'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class=\"line\">$ctx = stream_context_create();</span><br><span class=\"line\">stream_context_set_option($ctx, <span class=\"string\">'ssl'</span>, <span class=\"string\">'local_cert'</span>, <span class=\"string\">'Push.pem'</span>);\t\t<span class=\"comment\">// ck.pem证书上有提及</span></span><br><span class=\"line\">stream_context_set_option($ctx, <span class=\"string\">'ssl'</span>, <span class=\"string\">'passphrase'</span>, $passphrase);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Open a connection to the APNS server</span></span><br><span class=\"line\">$fp = stream_socket_client(</span><br><span class=\"line\">\t\t<span class=\"string\">'ssl://gateway.sandbox.push.apple.com:2195'</span>, \t\t\t<span class=\"comment\">// 远端测试地址</span></span><br><span class=\"line\">\t\t$err,\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t$errstr, </span><br><span class=\"line\">\t\t<span class=\"number\">60</span>, \t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 超时时间</span></span><br><span class=\"line\">\t\tSTREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT,</span><br><span class=\"line\">\t\t$ctx);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!$fp)</span><br><span class=\"line\">\t<span class=\"keyword\">exit</span>(<span class=\"string\">\"Failed to connect: $err $errstr\"</span> . PHP_EOL);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">'Connected to APNS'</span> . PHP_EOL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立字典数据</span></span><br><span class=\"line\">$body[<span class=\"string\">'aps'</span>] = <span class=\"keyword\">array</span>(</span><br><span class=\"line\">\t<span class=\"string\">'alert'</span> =&gt; $alert,</span><br><span class=\"line\">\t<span class=\"string\">'sound'</span> =&gt; <span class=\"string\">'default'</span>,</span><br><span class=\"line\">\t<span class=\"string\">'badge'</span> =&gt; <span class=\"number\">66</span></span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将字典数据转换成JSON</span></span><br><span class=\"line\">$payload = json_encode($body);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组织二进制数据格式，具体格式参照apple官方文档，本文中也有提及。</span></span><br><span class=\"line\"><span class=\"comment\">// Command + Token length + deviceToken + Payload length + payload</span></span><br><span class=\"line\">$msg = chr(<span class=\"number\">0</span>) . pack(<span class=\"string\">'n'</span>, <span class=\"number\">32</span>) . pack(<span class=\"string\">'H*'</span>, $deviceToken) . pack(<span class=\"string\">'n'</span>, strlen($payload)) . $payload;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送组成的数据给APNs</span></span><br><span class=\"line\">$result = fwrite($fp, $msg, strlen($msg));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!$result)</span><br><span class=\"line\">\t<span class=\"keyword\">echo</span> <span class=\"string\">'Fail to delivery Notification'</span> . PHP_EOL;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t<span class=\"keyword\">echo</span> <span class=\"string\">'Delivery Notification successfully'</span> . PHP_EOL;</span><br><span class=\"line\"></span><br><span class=\"line\">fclose($fp);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行下下测试：<br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iosPushResult.png\" alt=\"最终测试效果\"></p>\n<p>参考：<br>[1]. <a href=\"https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1</a><br>[2]. <a href=\"https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/\" target=\"_blank\" rel=\"noopener\">https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/</a><br>[3]. <a href=\"http://blog.csdn.net/shenjie12345678/article/details/41120637\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/shenjie12345678/article/details/41120637</a></p>"},{"title":"关于 iOS10 Notification 的那些事儿","date":"2017-05-20T02:10:54.000Z","photos":["http://7xilk1.com1.z0.glb.clouddn.com/1467010311344431.jpg"],"_content":"\n### 概览\n\n推送通知我们大家都不陌生，可以说几乎每个使用智能手机的人每天都会被不同的通知 *打扰* 到，正式因为合适的推送是吸引用户注意力的利器，其成为了各 App 吸引用户，将用户带回到 App 本身，提升用户的活跃度的一种必要的方式。当然要注意的是，推送本身是一件对用户影响特别大的事情，毕竟注意力被打断，因此合适的推送时机也是各个 App 开发者所要注意的，否则就会成为用户勿扰名单里的一员了。\n\n之前刚开始学习 iOS 开发的时候还整理了下当时部署 iOS 远程推送的流程，详见：[iOS 远端推送部署详解](http://hechen.info/2015/07/30/iOS-Push-Notification/)\n\n接下来，我们大致回顾一下 iOS 平台关于推送都有哪些历程？\n\n<!-- more -->\n\n### 历史\n\n- <= iOS 6 \n\t- 远程推送通知 （iOS 3）\n\t- 本地通知 （iOS 4）\n\n- iOS 7  参考 \n\t- 引入 Silent Remote Notifications\n\n- iOS 8  参考 [WWDC 2014 Session 713](https://developer.apple.com/videos/play/wwdc2014/713/)\n\t- 引入 Actionable Notifications\n\t- 修改 Notification 的权限请求\n\n- iOS 9  参考 [WWDC 2015 Session 720](https://developer.apple.com/videos/play/wwdc2015/720/)\n\t- 引入 Text Input Action\n\t- UIUserNotificationActionBehavior\n\n- iOS 10 参考 [WWDC 707 Introduction to Notifications](https://developer.apple.com/videos/play/wwdc2016/707) && [WWDC 708 Advanced Notifications](https://developer.apple.com/videos/play/wwdc2016/708)\n   - UserNotification Framework\n   - Extensions\n\nWWDC 2016 大会上，Apple 在 iOS 10 上引入了 **UserNotification** 框架，可以说是对之前的各种代码做了一次重构。该框架统一了通知的行为，尤其是针对远程推送和本地推送不再有两套完全不同的使用方式了。\n\n### 变化\n\n关于 iOS 10 上 UserNotification 框架的变化，主要从几个方面来讲述：\n\n1. 权限申请\n2. 推送内容变更\n3. 推送管理\n4. Extensions\n\n\n#### 权限申请\n\n``` Swift\nUNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) {\n    granted, error in\n    if granted {\n        // 用户允许进行通知\n    }\n}\n```\n\n####  远程推送\n\n``` Swift\n// 向 APNs 请求 token：\n\n// iOS 10 support\nif #available(iOS 10, *) {  \n    UNUserNotificationCenter.current().requestAuthorization(options:[.badge, .alert, .sound]){ (granted, error) in }\n    application.registerForRemoteNotifications()\n}\n// iOS 9 support\nelse if #available(iOS 9, *) {  \n\nUIApplication.shared.registerUserNotificationSettings(UIUserNotificationSettings(types: [.badge, .sound, .alert], categories: nil))\n    UIApplication.shared.registerForRemoteNotifications()\n}\n\n```\n\n关于注册远程通知的回调方法一致，\n\n``` Swift\n\n// AppDelegate.swift\n func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n    let tokenString = deviceToken.hexString\n    print(\"Get Push token: \\(tokenString)\")\n}\n```\n\n#### Payloads \n\n<  iOS 10\n\n``` JSON\n {\n   \"aps\":{\n     \"alert\":\"Test\",\n     \"sound\":\"default\",\n     \"badge\":1\n   }\n }\n```\n\niOS 10 系统提供了更为丰富的结构，比如可以指定 Title，Subtitle 等\n\n``` JSON\n{\n   \"aps\":{\n     \"alert\":{\n       \"title\":\"This is a title\",\n       \"subtitle\":\"This is a subtitle\",\n       \"body\":\"This is body\"\n     },\n     \"sound\":\"default\",\n     \"badge\":1\n   }\n }\n```\n\n甚至，现在可以支持多媒体的展示了，在 payload 上也有相应的体现，例如下面几例：\n\n1. 支持图片\n\n    ``` JSON\n    {\n        \"aps\":{\n            \"alert\": {\n                \"title\": \"Title: Notification Demo\", \n                \"subtitle\": \"Subtitle: show iOS 10 support!\",\n                \"body\": \"The Main Body For Notification!\"\n                },\n                \"mutable-content\": 1\n            },\n        \"image\" : \"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\",\n    }\n    ```\n\n2. 支持音频\n\n    ``` JSON\n    \n    {\n        \"aps\":{\n            \"alert\": {\n            \"title\": \"Title: Notification Demo\", \n            \"subtitle\": \"Subtitle: show iOS 10 support!\", \n            \"body\": \"The Main Body For Notification!\"\n            },\n            \"mutable-content\": 1,\n        },\n        \"audio\" : \"http://hao.1015600.com/upload/ring/000/982/d9924a7f4e4ab06e52a11dfdd32ffae1.mp3\",\n    }\n    \n    ```\n\n具体所有的 Key 可以参考官方文档 [Payload Key Reference](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html)\n\n> 注意到有个 key:  launch-image ，可以指定用户点击通知启动 App 的时候的 Launch Image\n\n#### 可以撤销和更新通知了！\n\nUserNotification 框架 API 提供了通知的更新和撤销的接口。具体功能主要包含几个部分：\n\n1. 删除未展示的通知\n    \n    ``` Swift\n            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.pendingRemoveNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    print(\"remove pending notification error: \\(error)\")\n                } else {\n                    print(\"Notification request added: \\(identifier)\")\n                }\n            }\n            \n            delay(2) {\n                print(\"Notification request removed: \\(identifier)\")\n                UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [identifier])\n            }\n    ```\n\n\n2. 更新未展示的通知\n\n    ``` Swift\n            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.pendingUpdateNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    print(\"update pending notification error: \\(error)\")\n                } else {\n                    print(\"Notification request added: \\(identifier) with title1\")\n                }\n            }\n            \n            delay(2) {\n                let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n                \n                // Add new request with the same identifier to update a notification.\n                let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)\n                UNUserNotificationCenter.current().add(newRequest) { error in\n                    if let error = error {\n                        print(\"update delivered notification error: \\(error)\")\n                    } else {\n                        print(\"Notification request updated: \\(identifier) with title2\")\n                    }\n                }\n            }\n    ```\n\n3. 删除已经展示的通知\n\n    ``` Swift\n            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.pendingUpdateNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    print(\"update pending notification error: \\(error)\")\n                } else {\n                    print(\"Notification request added: \\(identifier) with title1\")\n                }\n            }\n            \n            delay(2) {\n                let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n                \n                // Add new request with the same identifier to update a notification.\n                let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)\n                UNUserNotificationCenter.current().add(newRequest) { error in\n                    if let error = error {\n                        print(\"update delivered notification error: \\(error)\")\n                    } else {\n                        print(\"Notification request updated: \\(identifier) with title2\")\n                    }\n                }\n            }\n    ```\n\n\n4. 更新已经展示的通知\n\n    ``` Swift\n        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.deliveredUpdateNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    \n                } else {\n                    print(\"Notification request added: \\(identifier) with title1\")\n                }\n            }\n            \n            delay(4) {\n                let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n                \n                // Add new request with the same identifier to update a notification.\n                let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)\n                UNUserNotificationCenter.current().add(newRequest) { error in\n                    if let error = error {\n                        \n                    } else {\n                        print(\"Notification request updated: \\(identifier) with title2\")\n                    }\n                }\n            }\n    ```\n\n当然，上述均是针对本地通知的操作，关于远程推送通知，目前只支持更新通知，远程推送可以进行通知的更新，在使用 Provider API 向 APNs 提交请求时，在 HTTP/2 的 header 中 apns-collapse-id key 的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新。\n\n\n#### Notification Extension\n\niOS 10 中最重要的一个变化就是 Extension，从 iMessage Extension 到 SiriKit 中提供的  Intent Extension 等，那对于 UserNotification 来讲就是下面这两种 Extension：\n\n![18D62919-DA73-4D3D-9B05-6071E6945764](http://7xilk1.com1.z0.glb.clouddn.com/18D62919-DA73-4D3D-9B05-6071E6945764-1.png)\n\n\n1. Service Extension \n\n具体而言，就是我们可以在收到通知之后，在展示给用户之前 ，也就是以Banner 或者 Alert 的形式 或者 进入通知中心之前，给我们一次截取并处理的机会，这样就给开发者提供了针对推送通知再加工的手段，并且远程推送多媒体也是通过 Service Extension 来实现的。\n\n> 使用在本机截取推送并替换内容的方式，可以完成端到端 (end-to-end) 的推送加密。你在服务器推送 payload 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密之后再显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。\n\n生成 Extension 之后，系统已经为我们提供了模板，代码如下：\n\n``` Swift\nclass NotificationService: UNNotificationServiceExtension {\n\n    var contentHandler: ((UNNotificationContent) -> Void)?\n    var bestAttemptContent: UNMutableNotificationContent?\n    \n    // 1\n    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {\n        self.contentHandler = contentHandler\n        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)\n        \n        if let bestAttemptContent = bestAttemptContent {\n            contentHandler(bestAttemptContent)\n        }\n    }\n    \n    // 2\n    override func serviceExtensionTimeWillExpire() {\n        // Called just before the extension will be terminated by the system.\n        // Use this as an opportunity to deliver your \"best attempt\" at modified content, otherwise the original push payload will be used.\n        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {\n            contentHandler(bestAttemptContent)\n        }\n    }\n}\n```\n\n\n2. Content Extension\niOS 10 SDK 新加的另一个 Content Extension 可以用来自定义通知的详细页面的视图。 下图中就是几款市面上目前已经实现过自定义 Content Extension 的 App 截图。需要注意的是：\n\n第一个 PriceTag App 的通知样式，实际上是默认的系统显示行为。\n\n\n![IMG_AD4882D0ECDE-1](http://7xilk1.com1.z0.glb.clouddn.com/IMG_AD4882D0ECDE-1.jpeg)\n\n\n其中需要注意的一点是。如果不想默认显示通知内容，需要在 Content Extension 的 info.plist 文件中添加 UNNotificationExtensionDefaultContentHidden  并设置为 YES\n\n\n#### 支持多媒体资源在通知中心的展示\n\niOS 10 中另一个比较显著的特点就是支持了多媒体的推送和展示。开发者现在可以在通知中嵌入图片、音频甚至视频，这极大丰富了推送内容的可读性和趣味性。\n\n\n1. 本地推送支持\n本地通知添加多媒体比较简单一些，只需要通过本地磁盘上的文件 URL 创建一个 UNNotificationAttachment 对象，然后将这个对象放到数组中赋值给 content 的 attachments 属性就行了：\n\n``` Swift\nlet content = UNMutableNotificationContent()\ncontent.title = \"Image Notification\"\ncontent.body = \"Show me an image!\"\n\nif let imageURL = Bundle.main.url(forResource: \"image\", withExtension: \"jpg\"),\n   let attachment = try? UNNotificationAttachment(identifier: \"imageAttachment\", url: imageURL, options: nil) {\n    content.attachments = [attachment]\n}\n```\n\n\n2. 远程推送支持\n\n首先需要在 payloads 结构中添加对富媒体的支持，aps 字典中添加字段`mutable-content`并置为 1 来标识该远程通知是需要支持。 然后可以在 payloads 中添加资源地址，可以是本地的资源，也可以是需要 App 下载的。\n\n``` JSON\n{\n  \"aps\":{\n    \"alert\":{\n      \"title\":\"Image Notification\",\n      \"body\":\"Show me an image from web!\"\n    },\n    \"mutable-content\":1\n  },\n  \"zh_image\": \"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\"\n}\n```\n\n具体支持多媒体文件的富媒体类型以及每一种类型所支持的大小详官方文档  [UNNotificationAttachment](https://developer.apple.com/reference/usernotifications/unnotificationattachment)\n\n一旦远程推送在 aps 中添加 mutable-content 的key 并设置为 1 之后，iOS 系统接收到该推送之后就会唤起我们配套的 Service Extension 来做进一步处理，我们可以在其中下载对应 zh_image 链接的图片，然后生成 Attachment 再丢给系统处理即可。 详细做法就是在上一节讲 Service Extension 中的 `didReceive` 中写相应逻辑即可，具体代码如下所示：\n\n当然，这里的处理时间是存在时间限制的，如果处理超时系统就会回收该 Extension，并且调用 `serviceExtensionTimeWillExpire` 方法，因此每个人收到带有附件的推送之后不一定展示相同，例如下图所示的情况，第一张和第二张就属于正常设置了附件的情况，而第三张就是没有在有限时间内正确设置附件的情况。\n\n![未成功设置附件的情况](http://7xilk1.com1.z0.glb.clouddn.com/14953507334611.png)\n\n\n\n\n#### 推送证书的配置\n\n下图是获取推送通知证书并将其注册到 Leancloud 的流程，最关键的地方其实就是需要在本机生成 CSR 文件提交到 Apple Developer Website 生成 Push Certification 文件。\n\n主要有几个步骤：\n\n1. AppID 关于 Remote Push 的 注册\n2. 生成推送证书\n3. 转换证书为 P12 文件，并提供给 Leancloud\n\n![02](http://7xilk1.com1.z0.glb.clouddn.com/02.png)\n\nXCode 8 的 Auto Signing 已经省去了难以名状的复杂，但是还是有一点小事情我们需要做。\n\n![iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22](http://7xilk1.com1.z0.glb.clouddn.com/iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22.png)\n\n![0CB09A98-0D9B-4E76-BA7C-9A1766CFE](http://7xilk1.com1.z0.glb.clouddn.com/0CB09A98-0D9B-4E76-BA7C-9A1766CFEC42.png)\n\n![Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47](http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47.png)\n\n\n我们需要生成 CSR 文件 ，按照指定步骤按部就班来就行，最后会生成 默认文件 *CertificateSigningRequest.certSigningRequest*\n\n\n![Finder Finder, 今天 at 下午4.59.55](http://7xilk1.com1.z0.glb.clouddn.com/Finder Finder, 今天 at 下午4.59.55.png)\n![证书助理 证书助理, 今天 at 下午5.05.42](http://7xilk1.com1.z0.glb.clouddn.com/证书助理 证书助理, 今天 at 下午5.05.42.png)\n\n\n接着之前的步骤，选择 CSR 文件上传。\n\n![Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07](http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07.png)\n\n\n上传成功之后就会生成 Push 证书，下载到本机安装上。\n\n![Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58](http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58.png)\n\n\n#### Demo 演示  [Knuff](https://github.com/KnuffApp/Knuff) \n\n\n参考资料\n\n1. [Local and Remote Notification Programming Guide](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194-CH3-SW1)\n2. [UserNotifications 官方文档](https://developer.apple.com/reference/usernotifications)\n3. [iOS App 签名的原理](http://wereadteam.github.io/2017/03/13/Signature/)\n4. [iPhone 的后台刷新](https://medium.com/@scomper/探究-iphone-的后台刷新-a7a96cb426d4)\n\n\n\n\n\n\n\n","source":"_posts/iOS-Notification.md","raw":"title: \"关于 iOS10 Notification 的那些事儿\"\ndate: 2017-05-20 10:10:54\ncategories: iOS\nphotos: http://7xilk1.com1.z0.glb.clouddn.com/1467010311344431.jpg\ntags: [iOS,Swift,Notification]\n\n---\n\n### 概览\n\n推送通知我们大家都不陌生，可以说几乎每个使用智能手机的人每天都会被不同的通知 *打扰* 到，正式因为合适的推送是吸引用户注意力的利器，其成为了各 App 吸引用户，将用户带回到 App 本身，提升用户的活跃度的一种必要的方式。当然要注意的是，推送本身是一件对用户影响特别大的事情，毕竟注意力被打断，因此合适的推送时机也是各个 App 开发者所要注意的，否则就会成为用户勿扰名单里的一员了。\n\n之前刚开始学习 iOS 开发的时候还整理了下当时部署 iOS 远程推送的流程，详见：[iOS 远端推送部署详解](http://hechen.info/2015/07/30/iOS-Push-Notification/)\n\n接下来，我们大致回顾一下 iOS 平台关于推送都有哪些历程？\n\n<!-- more -->\n\n### 历史\n\n- <= iOS 6 \n\t- 远程推送通知 （iOS 3）\n\t- 本地通知 （iOS 4）\n\n- iOS 7  参考 \n\t- 引入 Silent Remote Notifications\n\n- iOS 8  参考 [WWDC 2014 Session 713](https://developer.apple.com/videos/play/wwdc2014/713/)\n\t- 引入 Actionable Notifications\n\t- 修改 Notification 的权限请求\n\n- iOS 9  参考 [WWDC 2015 Session 720](https://developer.apple.com/videos/play/wwdc2015/720/)\n\t- 引入 Text Input Action\n\t- UIUserNotificationActionBehavior\n\n- iOS 10 参考 [WWDC 707 Introduction to Notifications](https://developer.apple.com/videos/play/wwdc2016/707) && [WWDC 708 Advanced Notifications](https://developer.apple.com/videos/play/wwdc2016/708)\n   - UserNotification Framework\n   - Extensions\n\nWWDC 2016 大会上，Apple 在 iOS 10 上引入了 **UserNotification** 框架，可以说是对之前的各种代码做了一次重构。该框架统一了通知的行为，尤其是针对远程推送和本地推送不再有两套完全不同的使用方式了。\n\n### 变化\n\n关于 iOS 10 上 UserNotification 框架的变化，主要从几个方面来讲述：\n\n1. 权限申请\n2. 推送内容变更\n3. 推送管理\n4. Extensions\n\n\n#### 权限申请\n\n``` Swift\nUNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) {\n    granted, error in\n    if granted {\n        // 用户允许进行通知\n    }\n}\n```\n\n####  远程推送\n\n``` Swift\n// 向 APNs 请求 token：\n\n// iOS 10 support\nif #available(iOS 10, *) {  \n    UNUserNotificationCenter.current().requestAuthorization(options:[.badge, .alert, .sound]){ (granted, error) in }\n    application.registerForRemoteNotifications()\n}\n// iOS 9 support\nelse if #available(iOS 9, *) {  \n\nUIApplication.shared.registerUserNotificationSettings(UIUserNotificationSettings(types: [.badge, .sound, .alert], categories: nil))\n    UIApplication.shared.registerForRemoteNotifications()\n}\n\n```\n\n关于注册远程通知的回调方法一致，\n\n``` Swift\n\n// AppDelegate.swift\n func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n    let tokenString = deviceToken.hexString\n    print(\"Get Push token: \\(tokenString)\")\n}\n```\n\n#### Payloads \n\n<  iOS 10\n\n``` JSON\n {\n   \"aps\":{\n     \"alert\":\"Test\",\n     \"sound\":\"default\",\n     \"badge\":1\n   }\n }\n```\n\niOS 10 系统提供了更为丰富的结构，比如可以指定 Title，Subtitle 等\n\n``` JSON\n{\n   \"aps\":{\n     \"alert\":{\n       \"title\":\"This is a title\",\n       \"subtitle\":\"This is a subtitle\",\n       \"body\":\"This is body\"\n     },\n     \"sound\":\"default\",\n     \"badge\":1\n   }\n }\n```\n\n甚至，现在可以支持多媒体的展示了，在 payload 上也有相应的体现，例如下面几例：\n\n1. 支持图片\n\n    ``` JSON\n    {\n        \"aps\":{\n            \"alert\": {\n                \"title\": \"Title: Notification Demo\", \n                \"subtitle\": \"Subtitle: show iOS 10 support!\",\n                \"body\": \"The Main Body For Notification!\"\n                },\n                \"mutable-content\": 1\n            },\n        \"image\" : \"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\",\n    }\n    ```\n\n2. 支持音频\n\n    ``` JSON\n    \n    {\n        \"aps\":{\n            \"alert\": {\n            \"title\": \"Title: Notification Demo\", \n            \"subtitle\": \"Subtitle: show iOS 10 support!\", \n            \"body\": \"The Main Body For Notification!\"\n            },\n            \"mutable-content\": 1,\n        },\n        \"audio\" : \"http://hao.1015600.com/upload/ring/000/982/d9924a7f4e4ab06e52a11dfdd32ffae1.mp3\",\n    }\n    \n    ```\n\n具体所有的 Key 可以参考官方文档 [Payload Key Reference](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html)\n\n> 注意到有个 key:  launch-image ，可以指定用户点击通知启动 App 的时候的 Launch Image\n\n#### 可以撤销和更新通知了！\n\nUserNotification 框架 API 提供了通知的更新和撤销的接口。具体功能主要包含几个部分：\n\n1. 删除未展示的通知\n    \n    ``` Swift\n            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.pendingRemoveNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    print(\"remove pending notification error: \\(error)\")\n                } else {\n                    print(\"Notification request added: \\(identifier)\")\n                }\n            }\n            \n            delay(2) {\n                print(\"Notification request removed: \\(identifier)\")\n                UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [identifier])\n            }\n    ```\n\n\n2. 更新未展示的通知\n\n    ``` Swift\n            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.pendingUpdateNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    print(\"update pending notification error: \\(error)\")\n                } else {\n                    print(\"Notification request added: \\(identifier) with title1\")\n                }\n            }\n            \n            delay(2) {\n                let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n                \n                // Add new request with the same identifier to update a notification.\n                let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)\n                UNUserNotificationCenter.current().add(newRequest) { error in\n                    if let error = error {\n                        print(\"update delivered notification error: \\(error)\")\n                    } else {\n                        print(\"Notification request updated: \\(identifier) with title2\")\n                    }\n                }\n            }\n    ```\n\n3. 删除已经展示的通知\n\n    ``` Swift\n            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.pendingUpdateNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    print(\"update pending notification error: \\(error)\")\n                } else {\n                    print(\"Notification request added: \\(identifier) with title1\")\n                }\n            }\n            \n            delay(2) {\n                let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n                \n                // Add new request with the same identifier to update a notification.\n                let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)\n                UNUserNotificationCenter.current().add(newRequest) { error in\n                    if let error = error {\n                        print(\"update delivered notification error: \\(error)\")\n                    } else {\n                        print(\"Notification request updated: \\(identifier) with title2\")\n                    }\n                }\n            }\n    ```\n\n\n4. 更新已经展示的通知\n\n    ``` Swift\n        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)\n            let identifier = Constants.deliveredUpdateNotificationIdentifier\n            let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)\n            \n            UNUserNotificationCenter.current().add(request) { error in\n                if let error = error {\n                    \n                } else {\n                    print(\"Notification request added: \\(identifier) with title1\")\n                }\n            }\n            \n            delay(4) {\n                let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n                \n                // Add new request with the same identifier to update a notification.\n                let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)\n                UNUserNotificationCenter.current().add(newRequest) { error in\n                    if let error = error {\n                        \n                    } else {\n                        print(\"Notification request updated: \\(identifier) with title2\")\n                    }\n                }\n            }\n    ```\n\n当然，上述均是针对本地通知的操作，关于远程推送通知，目前只支持更新通知，远程推送可以进行通知的更新，在使用 Provider API 向 APNs 提交请求时，在 HTTP/2 的 header 中 apns-collapse-id key 的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新。\n\n\n#### Notification Extension\n\niOS 10 中最重要的一个变化就是 Extension，从 iMessage Extension 到 SiriKit 中提供的  Intent Extension 等，那对于 UserNotification 来讲就是下面这两种 Extension：\n\n![18D62919-DA73-4D3D-9B05-6071E6945764](http://7xilk1.com1.z0.glb.clouddn.com/18D62919-DA73-4D3D-9B05-6071E6945764-1.png)\n\n\n1. Service Extension \n\n具体而言，就是我们可以在收到通知之后，在展示给用户之前 ，也就是以Banner 或者 Alert 的形式 或者 进入通知中心之前，给我们一次截取并处理的机会，这样就给开发者提供了针对推送通知再加工的手段，并且远程推送多媒体也是通过 Service Extension 来实现的。\n\n> 使用在本机截取推送并替换内容的方式，可以完成端到端 (end-to-end) 的推送加密。你在服务器推送 payload 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密之后再显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。\n\n生成 Extension 之后，系统已经为我们提供了模板，代码如下：\n\n``` Swift\nclass NotificationService: UNNotificationServiceExtension {\n\n    var contentHandler: ((UNNotificationContent) -> Void)?\n    var bestAttemptContent: UNMutableNotificationContent?\n    \n    // 1\n    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {\n        self.contentHandler = contentHandler\n        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)\n        \n        if let bestAttemptContent = bestAttemptContent {\n            contentHandler(bestAttemptContent)\n        }\n    }\n    \n    // 2\n    override func serviceExtensionTimeWillExpire() {\n        // Called just before the extension will be terminated by the system.\n        // Use this as an opportunity to deliver your \"best attempt\" at modified content, otherwise the original push payload will be used.\n        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {\n            contentHandler(bestAttemptContent)\n        }\n    }\n}\n```\n\n\n2. Content Extension\niOS 10 SDK 新加的另一个 Content Extension 可以用来自定义通知的详细页面的视图。 下图中就是几款市面上目前已经实现过自定义 Content Extension 的 App 截图。需要注意的是：\n\n第一个 PriceTag App 的通知样式，实际上是默认的系统显示行为。\n\n\n![IMG_AD4882D0ECDE-1](http://7xilk1.com1.z0.glb.clouddn.com/IMG_AD4882D0ECDE-1.jpeg)\n\n\n其中需要注意的一点是。如果不想默认显示通知内容，需要在 Content Extension 的 info.plist 文件中添加 UNNotificationExtensionDefaultContentHidden  并设置为 YES\n\n\n#### 支持多媒体资源在通知中心的展示\n\niOS 10 中另一个比较显著的特点就是支持了多媒体的推送和展示。开发者现在可以在通知中嵌入图片、音频甚至视频，这极大丰富了推送内容的可读性和趣味性。\n\n\n1. 本地推送支持\n本地通知添加多媒体比较简单一些，只需要通过本地磁盘上的文件 URL 创建一个 UNNotificationAttachment 对象，然后将这个对象放到数组中赋值给 content 的 attachments 属性就行了：\n\n``` Swift\nlet content = UNMutableNotificationContent()\ncontent.title = \"Image Notification\"\ncontent.body = \"Show me an image!\"\n\nif let imageURL = Bundle.main.url(forResource: \"image\", withExtension: \"jpg\"),\n   let attachment = try? UNNotificationAttachment(identifier: \"imageAttachment\", url: imageURL, options: nil) {\n    content.attachments = [attachment]\n}\n```\n\n\n2. 远程推送支持\n\n首先需要在 payloads 结构中添加对富媒体的支持，aps 字典中添加字段`mutable-content`并置为 1 来标识该远程通知是需要支持。 然后可以在 payloads 中添加资源地址，可以是本地的资源，也可以是需要 App 下载的。\n\n``` JSON\n{\n  \"aps\":{\n    \"alert\":{\n      \"title\":\"Image Notification\",\n      \"body\":\"Show me an image from web!\"\n    },\n    \"mutable-content\":1\n  },\n  \"zh_image\": \"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\"\n}\n```\n\n具体支持多媒体文件的富媒体类型以及每一种类型所支持的大小详官方文档  [UNNotificationAttachment](https://developer.apple.com/reference/usernotifications/unnotificationattachment)\n\n一旦远程推送在 aps 中添加 mutable-content 的key 并设置为 1 之后，iOS 系统接收到该推送之后就会唤起我们配套的 Service Extension 来做进一步处理，我们可以在其中下载对应 zh_image 链接的图片，然后生成 Attachment 再丢给系统处理即可。 详细做法就是在上一节讲 Service Extension 中的 `didReceive` 中写相应逻辑即可，具体代码如下所示：\n\n当然，这里的处理时间是存在时间限制的，如果处理超时系统就会回收该 Extension，并且调用 `serviceExtensionTimeWillExpire` 方法，因此每个人收到带有附件的推送之后不一定展示相同，例如下图所示的情况，第一张和第二张就属于正常设置了附件的情况，而第三张就是没有在有限时间内正确设置附件的情况。\n\n![未成功设置附件的情况](http://7xilk1.com1.z0.glb.clouddn.com/14953507334611.png)\n\n\n\n\n#### 推送证书的配置\n\n下图是获取推送通知证书并将其注册到 Leancloud 的流程，最关键的地方其实就是需要在本机生成 CSR 文件提交到 Apple Developer Website 生成 Push Certification 文件。\n\n主要有几个步骤：\n\n1. AppID 关于 Remote Push 的 注册\n2. 生成推送证书\n3. 转换证书为 P12 文件，并提供给 Leancloud\n\n![02](http://7xilk1.com1.z0.glb.clouddn.com/02.png)\n\nXCode 8 的 Auto Signing 已经省去了难以名状的复杂，但是还是有一点小事情我们需要做。\n\n![iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22](http://7xilk1.com1.z0.glb.clouddn.com/iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22.png)\n\n![0CB09A98-0D9B-4E76-BA7C-9A1766CFE](http://7xilk1.com1.z0.glb.clouddn.com/0CB09A98-0D9B-4E76-BA7C-9A1766CFEC42.png)\n\n![Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47](http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47.png)\n\n\n我们需要生成 CSR 文件 ，按照指定步骤按部就班来就行，最后会生成 默认文件 *CertificateSigningRequest.certSigningRequest*\n\n\n![Finder Finder, 今天 at 下午4.59.55](http://7xilk1.com1.z0.glb.clouddn.com/Finder Finder, 今天 at 下午4.59.55.png)\n![证书助理 证书助理, 今天 at 下午5.05.42](http://7xilk1.com1.z0.glb.clouddn.com/证书助理 证书助理, 今天 at 下午5.05.42.png)\n\n\n接着之前的步骤，选择 CSR 文件上传。\n\n![Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07](http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07.png)\n\n\n上传成功之后就会生成 Push 证书，下载到本机安装上。\n\n![Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58](http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58.png)\n\n\n#### Demo 演示  [Knuff](https://github.com/KnuffApp/Knuff) \n\n\n参考资料\n\n1. [Local and Remote Notification Programming Guide](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194-CH3-SW1)\n2. [UserNotifications 官方文档](https://developer.apple.com/reference/usernotifications)\n3. [iOS App 签名的原理](http://wereadteam.github.io/2017/03/13/Signature/)\n4. [iPhone 的后台刷新](https://medium.com/@scomper/探究-iphone-的后台刷新-a7a96cb426d4)\n\n\n\n\n\n\n\n","slug":"iOS-Notification","published":1,"updated":"2018-05-02T12:56:13.000Z","comments":1,"layout":"post","link":"","_id":"cjrk2ftd4006879poh4v8swx0","content":"<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>推送通知我们大家都不陌生，可以说几乎每个使用智能手机的人每天都会被不同的通知 <em>打扰</em> 到，正式因为合适的推送是吸引用户注意力的利器，其成为了各 App 吸引用户，将用户带回到 App 本身，提升用户的活跃度的一种必要的方式。当然要注意的是，推送本身是一件对用户影响特别大的事情，毕竟注意力被打断，因此合适的推送时机也是各个 App 开发者所要注意的，否则就会成为用户勿扰名单里的一员了。</p>\n<p>之前刚开始学习 iOS 开发的时候还整理了下当时部署 iOS 远程推送的流程，详见：<a href=\"http://hechen.info/2015/07/30/iOS-Push-Notification/\" target=\"_blank\" rel=\"noopener\">iOS 远端推送部署详解</a></p>\n<p>接下来，我们大致回顾一下 iOS 平台关于推送都有哪些历程？</p>\n<a id=\"more\"></a>\n<h3 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h3><ul>\n<li><p>&lt;= iOS 6 </p>\n<ul>\n<li>远程推送通知 （iOS 3）</li>\n<li>本地通知 （iOS 4）</li>\n</ul>\n</li>\n<li><p>iOS 7  参考 </p>\n<ul>\n<li>引入 Silent Remote Notifications</li>\n</ul>\n</li>\n<li><p>iOS 8  参考 <a href=\"https://developer.apple.com/videos/play/wwdc2014/713/\" target=\"_blank\" rel=\"noopener\">WWDC 2014 Session 713</a></p>\n<ul>\n<li>引入 Actionable Notifications</li>\n<li>修改 Notification 的权限请求</li>\n</ul>\n</li>\n<li><p>iOS 9  参考 <a href=\"https://developer.apple.com/videos/play/wwdc2015/720/\" target=\"_blank\" rel=\"noopener\">WWDC 2015 Session 720</a></p>\n<ul>\n<li>引入 Text Input Action</li>\n<li>UIUserNotificationActionBehavior</li>\n</ul>\n</li>\n<li><p>iOS 10 参考 <a href=\"https://developer.apple.com/videos/play/wwdc2016/707\" target=\"_blank\" rel=\"noopener\">WWDC 707 Introduction to Notifications</a> &amp;&amp; <a href=\"https://developer.apple.com/videos/play/wwdc2016/708\" target=\"_blank\" rel=\"noopener\">WWDC 708 Advanced Notifications</a></p>\n<ul>\n<li>UserNotification Framework</li>\n<li>Extensions</li>\n</ul>\n</li>\n</ul>\n<p>WWDC 2016 大会上，Apple 在 iOS 10 上引入了 <strong>UserNotification</strong> 框架，可以说是对之前的各种代码做了一次重构。该框架统一了通知的行为，尤其是针对远程推送和本地推送不再有两套完全不同的使用方式了。</p>\n<h3 id=\"变化\"><a href=\"#变化\" class=\"headerlink\" title=\"变化\"></a>变化</h3><p>关于 iOS 10 上 UserNotification 框架的变化，主要从几个方面来讲述：</p>\n<ol>\n<li>权限申请</li>\n<li>推送内容变更</li>\n<li>推送管理</li>\n<li>Extensions</li>\n</ol>\n<h4 id=\"权限申请\"><a href=\"#权限申请\" class=\"headerlink\" title=\"权限申请\"></a>权限申请</h4><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().requestAuthorization(options: [.alert, .sound, .badge]) &#123;</span><br><span class=\"line\">    granted, error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> granted &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用户允许进行通知</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"远程推送\"><a href=\"#远程推送\" class=\"headerlink\" title=\"远程推送\"></a>远程推送</h4><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向 APNs 请求 token：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// iOS 10 support</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> #available(iOS <span class=\"number\">10</span>, *) &#123;  </span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().requestAuthorization(options:[.badge, .alert, .sound])&#123; (granted, error) <span class=\"keyword\">in</span> &#125;</span><br><span class=\"line\">    application.registerForRemoteNotifications()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// iOS 9 support</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> #available(iOS <span class=\"number\">9</span>, *) &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UIApplication</span>.shared.registerUserNotificationSettings(<span class=\"type\">UIUserNotificationSettings</span>(types: [.badge, .sound, .alert], categories: <span class=\"literal\">nil</span>))</span><br><span class=\"line\">    <span class=\"type\">UIApplication</span>.shared.registerForRemoteNotifications()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于注册远程通知的回调方法一致，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AppDelegate.swift</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tokenString = deviceToken.hexString</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Get Push token: <span class=\"subst\">\\(tokenString)</span>\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Payloads\"><a href=\"#Payloads\" class=\"headerlink\" title=\"Payloads\"></a>Payloads</h4><p>&lt;  iOS 10</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"alert\"</span>:<span class=\"string\">\"Test\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sound\"</span>:<span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"badge\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iOS 10 系统提供了更为丰富的结构，比如可以指定 Title，Subtitle 等</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">     <span class=\"attr\">\"alert\"</span>:&#123;</span><br><span class=\"line\">       <span class=\"attr\">\"title\"</span>:<span class=\"string\">\"This is a title\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"subtitle\"</span>:<span class=\"string\">\"This is a subtitle\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"body\"</span>:<span class=\"string\">\"This is body\"</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"attr\">\"sound\"</span>:<span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">     <span class=\"attr\">\"badge\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>甚至，现在可以支持多媒体的展示了，在 payload 上也有相应的体现，例如下面几例：</p>\n<ol>\n<li><p>支持图片</p>\n <figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">\"alert\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Title: Notification Demo\"</span>, </span><br><span class=\"line\">            <span class=\"attr\">\"subtitle\"</span>: <span class=\"string\">\"Subtitle: show iOS 10 support!\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"body\"</span>: <span class=\"string\">\"The Main Body For Notification!\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"mutable-content\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"image\"</span> : <span class=\"string\">\"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>支持音频</p>\n <figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">\"alert\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Title: Notification Demo\"</span>, </span><br><span class=\"line\">        <span class=\"attr\">\"subtitle\"</span>: <span class=\"string\">\"Subtitle: show iOS 10 support!\"</span>, </span><br><span class=\"line\">        <span class=\"attr\">\"body\"</span>: <span class=\"string\">\"The Main Body For Notification!\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"mutable-content\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"audio\"</span> : <span class=\"string\">\"http://hao.1015600.com/upload/ring/000/982/d9924a7f4e4ab06e52a11dfdd32ffae1.mp3\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>具体所有的 Key 可以参考官方文档 <a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html\" target=\"_blank\" rel=\"noopener\">Payload Key Reference</a></p>\n<blockquote>\n<p>注意到有个 key:  launch-image ，可以指定用户点击通知启动 App 的时候的 Launch Image</p>\n</blockquote>\n<h4 id=\"可以撤销和更新通知了！\"><a href=\"#可以撤销和更新通知了！\" class=\"headerlink\" title=\"可以撤销和更新通知了！\"></a>可以撤销和更新通知了！</h4><p>UserNotification 框架 API 提供了通知的更新和撤销的接口。具体功能主要包含几个部分：</p>\n<ol>\n<li><p>删除未展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.pendingRemoveNotificationIdentifier</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"remove pending notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request removed: <span class=\"subst\">\\(identifier)</span>\"</span>)</span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().removePendingNotificationRequests(withIdentifiers: [identifier])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新未展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.pendingUpdateNotificationIdentifier</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"update pending notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span> with title1\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newTrigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">1</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Add new request with the same identifier to update a notification.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: <span class=\"keyword\">self</span>.title2Content, trigger: newTrigger)</span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(newRequest) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"update delivered notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request updated: <span class=\"subst\">\\(identifier)</span> with title2\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除已经展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.pendingUpdateNotificationIdentifier</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"update pending notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span> with title1\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newTrigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">1</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Add new request with the same identifier to update a notification.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: <span class=\"keyword\">self</span>.title2Content, trigger: newTrigger)</span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(newRequest) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"update delivered notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request updated: <span class=\"subst\">\\(identifier)</span> with title2\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新已经展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.deliveredUpdateNotificationIdentifier</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span> with title1\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    delay(<span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newTrigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">1</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Add new request with the same identifier to update a notification.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> newRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: <span class=\"keyword\">self</span>.title2Content, trigger: newTrigger)</span><br><span class=\"line\">        <span class=\"type\">UNUserNotificationCenter</span>.current().add(newRequest) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request updated: <span class=\"subst\">\\(identifier)</span> with title2\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当然，上述均是针对本地通知的操作，关于远程推送通知，目前只支持更新通知，远程推送可以进行通知的更新，在使用 Provider API 向 APNs 提交请求时，在 HTTP/2 的 header 中 apns-collapse-id key 的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新。</p>\n<h4 id=\"Notification-Extension\"><a href=\"#Notification-Extension\" class=\"headerlink\" title=\"Notification Extension\"></a>Notification Extension</h4><p>iOS 10 中最重要的一个变化就是 Extension，从 iMessage Extension 到 SiriKit 中提供的  Intent Extension 等，那对于 UserNotification 来讲就是下面这两种 Extension：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/18D62919-DA73-4D3D-9B05-6071E6945764-1.png\" alt=\"18D62919-DA73-4D3D-9B05-6071E6945764\"></p>\n<ol>\n<li>Service Extension </li>\n</ol>\n<p>具体而言，就是我们可以在收到通知之后，在展示给用户之前 ，也就是以Banner 或者 Alert 的形式 或者 进入通知中心之前，给我们一次截取并处理的机会，这样就给开发者提供了针对推送通知再加工的手段，并且远程推送多媒体也是通过 Service Extension 来实现的。</p>\n<blockquote>\n<p>使用在本机截取推送并替换内容的方式，可以完成端到端 (end-to-end) 的推送加密。你在服务器推送 payload 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密之后再显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>\n</blockquote>\n<p>生成 Extension 之后，系统已经为我们提供了模板，代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotificationService</span>: <span class=\"title\">UNNotificationServiceExtension</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> contentHandler: ((<span class=\"type\">UNNotificationContent</span>) -&gt; <span class=\"type\">Void</span>)?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bestAttemptContent: <span class=\"type\">UNMutableNotificationContent</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> request: UNNotificationRequest, withContentHandler contentHandler: @escaping <span class=\"params\">(UNNotificationContent)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.contentHandler = contentHandler</span><br><span class=\"line\">        bestAttemptContent = (request.content.mutableCopy() <span class=\"keyword\">as</span>? <span class=\"type\">UNMutableNotificationContent</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> bestAttemptContent = bestAttemptContent &#123;</span><br><span class=\"line\">            contentHandler(bestAttemptContent)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serviceExtensionTimeWillExpire</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Called just before the extension will be terminated by the system.</span></span><br><span class=\"line\">        <span class=\"comment\">// Use this as an opportunity to deliver your \"best attempt\" at modified content, otherwise the original push payload will be used.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> contentHandler = contentHandler, <span class=\"keyword\">let</span> bestAttemptContent =  bestAttemptContent &#123;</span><br><span class=\"line\">            contentHandler(bestAttemptContent)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>Content Extension<br>iOS 10 SDK 新加的另一个 Content Extension 可以用来自定义通知的详细页面的视图。 下图中就是几款市面上目前已经实现过自定义 Content Extension 的 App 截图。需要注意的是：</li>\n</ol>\n<p>第一个 PriceTag App 的通知样式，实际上是默认的系统显示行为。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/IMG_AD4882D0ECDE-1.jpeg\" alt=\"IMG_AD4882D0ECDE-1\"></p>\n<p>其中需要注意的一点是。如果不想默认显示通知内容，需要在 Content Extension 的 info.plist 文件中添加 UNNotificationExtensionDefaultContentHidden  并设置为 YES</p>\n<h4 id=\"支持多媒体资源在通知中心的展示\"><a href=\"#支持多媒体资源在通知中心的展示\" class=\"headerlink\" title=\"支持多媒体资源在通知中心的展示\"></a>支持多媒体资源在通知中心的展示</h4><p>iOS 10 中另一个比较显著的特点就是支持了多媒体的推送和展示。开发者现在可以在通知中嵌入图片、音频甚至视频，这极大丰富了推送内容的可读性和趣味性。</p>\n<ol>\n<li>本地推送支持<br>本地通知添加多媒体比较简单一些，只需要通过本地磁盘上的文件 URL 创建一个 UNNotificationAttachment 对象，然后将这个对象放到数组中赋值给 content 的 attachments 属性就行了：</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> content = <span class=\"type\">UNMutableNotificationContent</span>()</span><br><span class=\"line\">content.title = <span class=\"string\">\"Image Notification\"</span></span><br><span class=\"line\">content.body = <span class=\"string\">\"Show me an image!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> imageURL = <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">\"image\"</span>, withExtension: <span class=\"string\">\"jpg\"</span>),</span><br><span class=\"line\">   <span class=\"keyword\">let</span> attachment = <span class=\"keyword\">try</span>? <span class=\"type\">UNNotificationAttachment</span>(identifier: <span class=\"string\">\"imageAttachment\"</span>, url: imageURL, options: <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">    content.attachments = [attachment]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>远程推送支持</li>\n</ol>\n<p>首先需要在 payloads 结构中添加对富媒体的支持，aps 字典中添加字段<code>mutable-content</code>并置为 1 来标识该远程通知是需要支持。 然后可以在 payloads 中添加资源地址，可以是本地的资源，也可以是需要 App 下载的。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"alert\"</span>:&#123;</span><br><span class=\"line\">      <span class=\"attr\">\"title\"</span>:<span class=\"string\">\"Image Notification\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"body\"</span>:<span class=\"string\">\"Show me an image from web!\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"mutable-content\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"zh_image\"</span>: <span class=\"string\">\"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体支持多媒体文件的富媒体类型以及每一种类型所支持的大小详官方文档  <a href=\"https://developer.apple.com/reference/usernotifications/unnotificationattachment\" target=\"_blank\" rel=\"noopener\">UNNotificationAttachment</a></p>\n<p>一旦远程推送在 aps 中添加 mutable-content 的key 并设置为 1 之后，iOS 系统接收到该推送之后就会唤起我们配套的 Service Extension 来做进一步处理，我们可以在其中下载对应 zh_image 链接的图片，然后生成 Attachment 再丢给系统处理即可。 详细做法就是在上一节讲 Service Extension 中的 <code>didReceive</code> 中写相应逻辑即可，具体代码如下所示：</p>\n<p>当然，这里的处理时间是存在时间限制的，如果处理超时系统就会回收该 Extension，并且调用 <code>serviceExtensionTimeWillExpire</code> 方法，因此每个人收到带有附件的推送之后不一定展示相同，例如下图所示的情况，第一张和第二张就属于正常设置了附件的情况，而第三张就是没有在有限时间内正确设置附件的情况。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14953507334611.png\" alt=\"未成功设置附件的情况\"></p>\n<h4 id=\"推送证书的配置\"><a href=\"#推送证书的配置\" class=\"headerlink\" title=\"推送证书的配置\"></a>推送证书的配置</h4><p>下图是获取推送通知证书并将其注册到 Leancloud 的流程，最关键的地方其实就是需要在本机生成 CSR 文件提交到 Apple Developer Website 生成 Push Certification 文件。</p>\n<p>主要有几个步骤：</p>\n<ol>\n<li>AppID 关于 Remote Push 的 注册</li>\n<li>生成推送证书</li>\n<li>转换证书为 P12 文件，并提供给 Leancloud</li>\n</ol>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/02.png\" alt=\"02\"></p>\n<p>XCode 8 的 Auto Signing 已经省去了难以名状的复杂，但是还是有一点小事情我们需要做。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22.png\" alt=\"iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22\"></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/0CB09A98-0D9B-4E76-BA7C-9A1766CFEC42.png\" alt=\"0CB09A98-0D9B-4E76-BA7C-9A1766CFE\"></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47.png\" alt=\"Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47\"></p>\n<p>我们需要生成 CSR 文件 ，按照指定步骤按部就班来就行，最后会生成 默认文件 <em>CertificateSigningRequest.certSigningRequest</em></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Finder Finder, 今天 at 下午4.59.55.png\" alt=\"Finder Finder, 今天 at 下午4.59.55\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/证书助理 证书助理, 今天 at 下午5.05.42.png\" alt=\"证书助理 证书助理, 今天 at 下午5.05.42\"></p>\n<p>接着之前的步骤，选择 CSR 文件上传。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07.png\" alt=\"Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07\"></p>\n<p>上传成功之后就会生成 Push 证书，下载到本机安装上。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58.png\" alt=\"Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58\"></p>\n<h4 id=\"Demo-演示-Knuff\"><a href=\"#Demo-演示-Knuff\" class=\"headerlink\" title=\"Demo 演示  Knuff\"></a>Demo 演示  <a href=\"https://github.com/KnuffApp/Knuff\" target=\"_blank\" rel=\"noopener\">Knuff</a></h4><p>参考资料</p>\n<ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194-CH3-SW1\" target=\"_blank\" rel=\"noopener\">Local and Remote Notification Programming Guide</a></li>\n<li><a href=\"https://developer.apple.com/reference/usernotifications\" target=\"_blank\" rel=\"noopener\">UserNotifications 官方文档</a></li>\n<li><a href=\"http://wereadteam.github.io/2017/03/13/Signature/\" target=\"_blank\" rel=\"noopener\">iOS App 签名的原理</a></li>\n<li><a href=\"https://medium.com/@scomper/探究-iphone-的后台刷新-a7a96cb426d4\" target=\"_blank\" rel=\"noopener\">iPhone 的后台刷新</a></li>\n</ol>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<h3 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h3><p>推送通知我们大家都不陌生，可以说几乎每个使用智能手机的人每天都会被不同的通知 <em>打扰</em> 到，正式因为合适的推送是吸引用户注意力的利器，其成为了各 App 吸引用户，将用户带回到 App 本身，提升用户的活跃度的一种必要的方式。当然要注意的是，推送本身是一件对用户影响特别大的事情，毕竟注意力被打断，因此合适的推送时机也是各个 App 开发者所要注意的，否则就会成为用户勿扰名单里的一员了。</p>\n<p>之前刚开始学习 iOS 开发的时候还整理了下当时部署 iOS 远程推送的流程，详见：<a href=\"http://hechen.info/2015/07/30/iOS-Push-Notification/\" target=\"_blank\" rel=\"noopener\">iOS 远端推送部署详解</a></p>\n<p>接下来，我们大致回顾一下 iOS 平台关于推送都有哪些历程？</p>","more":"<h3 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h3><ul>\n<li><p>&lt;= iOS 6 </p>\n<ul>\n<li>远程推送通知 （iOS 3）</li>\n<li>本地通知 （iOS 4）</li>\n</ul>\n</li>\n<li><p>iOS 7  参考 </p>\n<ul>\n<li>引入 Silent Remote Notifications</li>\n</ul>\n</li>\n<li><p>iOS 8  参考 <a href=\"https://developer.apple.com/videos/play/wwdc2014/713/\" target=\"_blank\" rel=\"noopener\">WWDC 2014 Session 713</a></p>\n<ul>\n<li>引入 Actionable Notifications</li>\n<li>修改 Notification 的权限请求</li>\n</ul>\n</li>\n<li><p>iOS 9  参考 <a href=\"https://developer.apple.com/videos/play/wwdc2015/720/\" target=\"_blank\" rel=\"noopener\">WWDC 2015 Session 720</a></p>\n<ul>\n<li>引入 Text Input Action</li>\n<li>UIUserNotificationActionBehavior</li>\n</ul>\n</li>\n<li><p>iOS 10 参考 <a href=\"https://developer.apple.com/videos/play/wwdc2016/707\" target=\"_blank\" rel=\"noopener\">WWDC 707 Introduction to Notifications</a> &amp;&amp; <a href=\"https://developer.apple.com/videos/play/wwdc2016/708\" target=\"_blank\" rel=\"noopener\">WWDC 708 Advanced Notifications</a></p>\n<ul>\n<li>UserNotification Framework</li>\n<li>Extensions</li>\n</ul>\n</li>\n</ul>\n<p>WWDC 2016 大会上，Apple 在 iOS 10 上引入了 <strong>UserNotification</strong> 框架，可以说是对之前的各种代码做了一次重构。该框架统一了通知的行为，尤其是针对远程推送和本地推送不再有两套完全不同的使用方式了。</p>\n<h3 id=\"变化\"><a href=\"#变化\" class=\"headerlink\" title=\"变化\"></a>变化</h3><p>关于 iOS 10 上 UserNotification 框架的变化，主要从几个方面来讲述：</p>\n<ol>\n<li>权限申请</li>\n<li>推送内容变更</li>\n<li>推送管理</li>\n<li>Extensions</li>\n</ol>\n<h4 id=\"权限申请\"><a href=\"#权限申请\" class=\"headerlink\" title=\"权限申请\"></a>权限申请</h4><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().requestAuthorization(options: [.alert, .sound, .badge]) &#123;</span><br><span class=\"line\">    granted, error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> granted &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用户允许进行通知</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"远程推送\"><a href=\"#远程推送\" class=\"headerlink\" title=\"远程推送\"></a>远程推送</h4><figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向 APNs 请求 token：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// iOS 10 support</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> #available(iOS <span class=\"number\">10</span>, *) &#123;  </span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().requestAuthorization(options:[.badge, .alert, .sound])&#123; (granted, error) <span class=\"keyword\">in</span> &#125;</span><br><span class=\"line\">    application.registerForRemoteNotifications()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// iOS 9 support</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> #available(iOS <span class=\"number\">9</span>, *) &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UIApplication</span>.shared.registerUserNotificationSettings(<span class=\"type\">UIUserNotificationSettings</span>(types: [.badge, .sound, .alert], categories: <span class=\"literal\">nil</span>))</span><br><span class=\"line\">    <span class=\"type\">UIApplication</span>.shared.registerForRemoteNotifications()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于注册远程通知的回调方法一致，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AppDelegate.swift</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tokenString = deviceToken.hexString</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Get Push token: <span class=\"subst\">\\(tokenString)</span>\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Payloads\"><a href=\"#Payloads\" class=\"headerlink\" title=\"Payloads\"></a>Payloads</h4><p>&lt;  iOS 10</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"alert\"</span>:<span class=\"string\">\"Test\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sound\"</span>:<span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"badge\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iOS 10 系统提供了更为丰富的结构，比如可以指定 Title，Subtitle 等</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">     <span class=\"attr\">\"alert\"</span>:&#123;</span><br><span class=\"line\">       <span class=\"attr\">\"title\"</span>:<span class=\"string\">\"This is a title\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"subtitle\"</span>:<span class=\"string\">\"This is a subtitle\"</span>,</span><br><span class=\"line\">       <span class=\"attr\">\"body\"</span>:<span class=\"string\">\"This is body\"</span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"attr\">\"sound\"</span>:<span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">     <span class=\"attr\">\"badge\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>甚至，现在可以支持多媒体的展示了，在 payload 上也有相应的体现，例如下面几例：</p>\n<ol>\n<li><p>支持图片</p>\n <figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">\"alert\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Title: Notification Demo\"</span>, </span><br><span class=\"line\">            <span class=\"attr\">\"subtitle\"</span>: <span class=\"string\">\"Subtitle: show iOS 10 support!\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"body\"</span>: <span class=\"string\">\"The Main Body For Notification!\"</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"mutable-content\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"image\"</span> : <span class=\"string\">\"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>支持音频</p>\n <figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">\"alert\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"Title: Notification Demo\"</span>, </span><br><span class=\"line\">        <span class=\"attr\">\"subtitle\"</span>: <span class=\"string\">\"Subtitle: show iOS 10 support!\"</span>, </span><br><span class=\"line\">        <span class=\"attr\">\"body\"</span>: <span class=\"string\">\"The Main Body For Notification!\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"mutable-content\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"audio\"</span> : <span class=\"string\">\"http://hao.1015600.com/upload/ring/000/982/d9924a7f4e4ab06e52a11dfdd32ffae1.mp3\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>具体所有的 Key 可以参考官方文档 <a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html\" target=\"_blank\" rel=\"noopener\">Payload Key Reference</a></p>\n<blockquote>\n<p>注意到有个 key:  launch-image ，可以指定用户点击通知启动 App 的时候的 Launch Image</p>\n</blockquote>\n<h4 id=\"可以撤销和更新通知了！\"><a href=\"#可以撤销和更新通知了！\" class=\"headerlink\" title=\"可以撤销和更新通知了！\"></a>可以撤销和更新通知了！</h4><p>UserNotification 框架 API 提供了通知的更新和撤销的接口。具体功能主要包含几个部分：</p>\n<ol>\n<li><p>删除未展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.pendingRemoveNotificationIdentifier</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"remove pending notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request removed: <span class=\"subst\">\\(identifier)</span>\"</span>)</span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().removePendingNotificationRequests(withIdentifiers: [identifier])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新未展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.pendingUpdateNotificationIdentifier</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"update pending notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span> with title1\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newTrigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">1</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Add new request with the same identifier to update a notification.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: <span class=\"keyword\">self</span>.title2Content, trigger: newTrigger)</span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(newRequest) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"update delivered notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request updated: <span class=\"subst\">\\(identifier)</span> with title2\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除已经展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.pendingUpdateNotificationIdentifier</span><br><span class=\"line\"><span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"update pending notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span> with title1\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newTrigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">1</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Add new request with the same identifier to update a notification.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: <span class=\"keyword\">self</span>.title2Content, trigger: newTrigger)</span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(newRequest) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"update delivered notification error: <span class=\"subst\">\\(error)</span>\"</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request updated: <span class=\"subst\">\\(identifier)</span> with title2\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新已经展示的通知</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> trigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">3</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"type\">Constants</span>.deliveredUpdateNotificationIdentifier</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: title1Content, trigger: trigger)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request added: <span class=\"subst\">\\(identifier)</span> with title1\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    delay(<span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newTrigger = <span class=\"type\">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class=\"number\">1</span>, repeats: <span class=\"literal\">false</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Add new request with the same identifier to update a notification.</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> newRequest = <span class=\"type\">UNNotificationRequest</span>(identifier: identifier, content: <span class=\"keyword\">self</span>.title2Content, trigger: newTrigger)</span><br><span class=\"line\">        <span class=\"type\">UNUserNotificationCenter</span>.current().add(newRequest) &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Notification request updated: <span class=\"subst\">\\(identifier)</span> with title2\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当然，上述均是针对本地通知的操作，关于远程推送通知，目前只支持更新通知，远程推送可以进行通知的更新，在使用 Provider API 向 APNs 提交请求时，在 HTTP/2 的 header 中 apns-collapse-id key 的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新。</p>\n<h4 id=\"Notification-Extension\"><a href=\"#Notification-Extension\" class=\"headerlink\" title=\"Notification Extension\"></a>Notification Extension</h4><p>iOS 10 中最重要的一个变化就是 Extension，从 iMessage Extension 到 SiriKit 中提供的  Intent Extension 等，那对于 UserNotification 来讲就是下面这两种 Extension：</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/18D62919-DA73-4D3D-9B05-6071E6945764-1.png\" alt=\"18D62919-DA73-4D3D-9B05-6071E6945764\"></p>\n<ol>\n<li>Service Extension </li>\n</ol>\n<p>具体而言，就是我们可以在收到通知之后，在展示给用户之前 ，也就是以Banner 或者 Alert 的形式 或者 进入通知中心之前，给我们一次截取并处理的机会，这样就给开发者提供了针对推送通知再加工的手段，并且远程推送多媒体也是通过 Service Extension 来实现的。</p>\n<blockquote>\n<p>使用在本机截取推送并替换内容的方式，可以完成端到端 (end-to-end) 的推送加密。你在服务器推送 payload 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密之后再显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>\n</blockquote>\n<p>生成 Extension 之后，系统已经为我们提供了模板，代码如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotificationService</span>: <span class=\"title\">UNNotificationServiceExtension</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> contentHandler: ((<span class=\"type\">UNNotificationContent</span>) -&gt; <span class=\"type\">Void</span>)?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> bestAttemptContent: <span class=\"type\">UNMutableNotificationContent</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">didReceive</span><span class=\"params\">(<span class=\"number\">_</span> request: UNNotificationRequest, withContentHandler contentHandler: @escaping <span class=\"params\">(UNNotificationContent)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.contentHandler = contentHandler</span><br><span class=\"line\">        bestAttemptContent = (request.content.mutableCopy() <span class=\"keyword\">as</span>? <span class=\"type\">UNMutableNotificationContent</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> bestAttemptContent = bestAttemptContent &#123;</span><br><span class=\"line\">            contentHandler(bestAttemptContent)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serviceExtensionTimeWillExpire</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Called just before the extension will be terminated by the system.</span></span><br><span class=\"line\">        <span class=\"comment\">// Use this as an opportunity to deliver your \"best attempt\" at modified content, otherwise the original push payload will be used.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> contentHandler = contentHandler, <span class=\"keyword\">let</span> bestAttemptContent =  bestAttemptContent &#123;</span><br><span class=\"line\">            contentHandler(bestAttemptContent)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>Content Extension<br>iOS 10 SDK 新加的另一个 Content Extension 可以用来自定义通知的详细页面的视图。 下图中就是几款市面上目前已经实现过自定义 Content Extension 的 App 截图。需要注意的是：</li>\n</ol>\n<p>第一个 PriceTag App 的通知样式，实际上是默认的系统显示行为。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/IMG_AD4882D0ECDE-1.jpeg\" alt=\"IMG_AD4882D0ECDE-1\"></p>\n<p>其中需要注意的一点是。如果不想默认显示通知内容，需要在 Content Extension 的 info.plist 文件中添加 UNNotificationExtensionDefaultContentHidden  并设置为 YES</p>\n<h4 id=\"支持多媒体资源在通知中心的展示\"><a href=\"#支持多媒体资源在通知中心的展示\" class=\"headerlink\" title=\"支持多媒体资源在通知中心的展示\"></a>支持多媒体资源在通知中心的展示</h4><p>iOS 10 中另一个比较显著的特点就是支持了多媒体的推送和展示。开发者现在可以在通知中嵌入图片、音频甚至视频，这极大丰富了推送内容的可读性和趣味性。</p>\n<ol>\n<li>本地推送支持<br>本地通知添加多媒体比较简单一些，只需要通过本地磁盘上的文件 URL 创建一个 UNNotificationAttachment 对象，然后将这个对象放到数组中赋值给 content 的 attachments 属性就行了：</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> content = <span class=\"type\">UNMutableNotificationContent</span>()</span><br><span class=\"line\">content.title = <span class=\"string\">\"Image Notification\"</span></span><br><span class=\"line\">content.body = <span class=\"string\">\"Show me an image!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> imageURL = <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">\"image\"</span>, withExtension: <span class=\"string\">\"jpg\"</span>),</span><br><span class=\"line\">   <span class=\"keyword\">let</span> attachment = <span class=\"keyword\">try</span>? <span class=\"type\">UNNotificationAttachment</span>(identifier: <span class=\"string\">\"imageAttachment\"</span>, url: imageURL, options: <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">    content.attachments = [attachment]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>远程推送支持</li>\n</ol>\n<p>首先需要在 payloads 结构中添加对富媒体的支持，aps 字典中添加字段<code>mutable-content</code>并置为 1 来标识该远程通知是需要支持。 然后可以在 payloads 中添加资源地址，可以是本地的资源，也可以是需要 App 下载的。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"aps\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"alert\"</span>:&#123;</span><br><span class=\"line\">      <span class=\"attr\">\"title\"</span>:<span class=\"string\">\"Image Notification\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"body\"</span>:<span class=\"string\">\"Show me an image from web!\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"mutable-content\"</span>:<span class=\"number\">1</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"zh_image\"</span>: <span class=\"string\">\"https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体支持多媒体文件的富媒体类型以及每一种类型所支持的大小详官方文档  <a href=\"https://developer.apple.com/reference/usernotifications/unnotificationattachment\" target=\"_blank\" rel=\"noopener\">UNNotificationAttachment</a></p>\n<p>一旦远程推送在 aps 中添加 mutable-content 的key 并设置为 1 之后，iOS 系统接收到该推送之后就会唤起我们配套的 Service Extension 来做进一步处理，我们可以在其中下载对应 zh_image 链接的图片，然后生成 Attachment 再丢给系统处理即可。 详细做法就是在上一节讲 Service Extension 中的 <code>didReceive</code> 中写相应逻辑即可，具体代码如下所示：</p>\n<p>当然，这里的处理时间是存在时间限制的，如果处理超时系统就会回收该 Extension，并且调用 <code>serviceExtensionTimeWillExpire</code> 方法，因此每个人收到带有附件的推送之后不一定展示相同，例如下图所示的情况，第一张和第二张就属于正常设置了附件的情况，而第三张就是没有在有限时间内正确设置附件的情况。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/14953507334611.png\" alt=\"未成功设置附件的情况\"></p>\n<h4 id=\"推送证书的配置\"><a href=\"#推送证书的配置\" class=\"headerlink\" title=\"推送证书的配置\"></a>推送证书的配置</h4><p>下图是获取推送通知证书并将其注册到 Leancloud 的流程，最关键的地方其实就是需要在本机生成 CSR 文件提交到 Apple Developer Website 生成 Push Certification 文件。</p>\n<p>主要有几个步骤：</p>\n<ol>\n<li>AppID 关于 Remote Push 的 注册</li>\n<li>生成推送证书</li>\n<li>转换证书为 P12 文件，并提供给 Leancloud</li>\n</ol>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/02.png\" alt=\"02\"></p>\n<p>XCode 8 的 Auto Signing 已经省去了难以名状的复杂，但是还是有一点小事情我们需要做。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22.png\" alt=\"iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22\"></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/0CB09A98-0D9B-4E76-BA7C-9A1766CFEC42.png\" alt=\"0CB09A98-0D9B-4E76-BA7C-9A1766CFE\"></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47.png\" alt=\"Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47\"></p>\n<p>我们需要生成 CSR 文件 ，按照指定步骤按部就班来就行，最后会生成 默认文件 <em>CertificateSigningRequest.certSigningRequest</em></p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Finder Finder, 今天 at 下午4.59.55.png\" alt=\"Finder Finder, 今天 at 下午4.59.55\"><br><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/证书助理 证书助理, 今天 at 下午5.05.42.png\" alt=\"证书助理 证书助理, 今天 at 下午5.05.42\"></p>\n<p>接着之前的步骤，选择 CSR 文件上传。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07.png\" alt=\"Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07\"></p>\n<p>上传成功之后就会生成 Push 证书，下载到本机安装上。</p>\n<p><img src=\"http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58.png\" alt=\"Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58\"></p>\n<h4 id=\"Demo-演示-Knuff\"><a href=\"#Demo-演示-Knuff\" class=\"headerlink\" title=\"Demo 演示  Knuff\"></a>Demo 演示  <a href=\"https://github.com/KnuffApp/Knuff\" target=\"_blank\" rel=\"noopener\">Knuff</a></h4><p>参考资料</p>\n<ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194-CH3-SW1\" target=\"_blank\" rel=\"noopener\">Local and Remote Notification Programming Guide</a></li>\n<li><a href=\"https://developer.apple.com/reference/usernotifications\" target=\"_blank\" rel=\"noopener\">UserNotifications 官方文档</a></li>\n<li><a href=\"http://wereadteam.github.io/2017/03/13/Signature/\" target=\"_blank\" rel=\"noopener\">iOS App 签名的原理</a></li>\n<li><a href=\"https://medium.com/@scomper/探究-iphone-的后台刷新-a7a96cb426d4\" target=\"_blank\" rel=\"noopener\">iPhone 的后台刷新</a></li>\n</ol>"},{"title":"理解Objective-C运行时","date":"2015-09-07T09:55:33.000Z","top_img":"https://i.imgur.com/5SKmTN3.png","_content":"\n> 翻译自：[Understanding the Objective-C Runtime](https://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html)\n> 译者： [@这个昵称有点萌](http://weibo.com/hc2feifei)\n\n\nObjective-C 运行时对于刚刚踏入 Cocoa/Objective 世界的人是很容易忽\n略的 Objective-C 语言的特性之一。原因就是尽管 Objective-C 是一门几个小时之内入门的语言，但是投身 Cocoa 的新手们会花费大量时间在 Cocoa 框架中，试图搞清楚他到底是怎么工作的。<!-- more --> 我觉得每个开发者都应该对其有深入的了解，明白一些内部的实现细节，而不仅仅只知道代码 `[target doMethodWith:var]` 会被编译器转换成 `objc_msgSend(target,@selector(doMethodWith:),var1);` 而已。了解 Objective-C 运行时的原理有助于你对 Objective-C 语言有更深入的理解，清楚你得 App 是怎么运行的。我觉得这对无论是 Mac/iPhone 新手或者老手都会有所帮助。\n\n\n\n\n[TOC]\n\n#### Objective-C运行时是开源的\n\nObjective-C 运行时是开源的，你可以随时从 [Apple](http://opensource.apple.com) 获取到。实际上查看 Objective-C 运行时源码是我搞清楚这个语言是怎么运作的首选方法，而不是去查看和它相关的苹果文档。你可以到[这里](http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz) 下载到运行时的源码（截止到译者翻译的时候，最新版本的文件是objc4-647.tar.gz）。\n\n#### 动态 Vs. 静态\n\nObjective-C 是一门动态的面向对象语言，这意味着它可以将编译链接时决定的事情推迟到运行时进行。这就给了你很大的灵活性，你可以按照自己的需要重定向消息到适当的对象上，你甚至可以交换方法实现（译者注：method swizzling，方法调配，开发者常用此技术向原有实现中添加新功能）。而运行时可以使对象明白自己可以响应哪些消息，不能响应哪些消息（译者注：introspect 内省），并正确的派发消息。\n\n> 译者注： 内省（introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。\n> \n> 参考: [Objective-C 的 Introspection](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Introspection/Introspection.html)\n\n我们将这些特征和C语言进行对比来看，在C中，你从`main()`函数开始，然后按顺序从上往下写你的代码逻辑或者执行函数方法。C结构体是无法将请求转发到其他目标对象来执行方法的。你很可能写了如下类似的代码：\n\n``` objc\n#include < stdio.h >\n \nint main(int argc, const char **argv[]) {\n    printf(\"Hello World!\");\n    return 0;\n}\n```\n\n编译器解析、优化然后将优化后的代码转换成如下的汇编语言：\n\n``` objc\n.text\n .align 4,0x90\n .globl _main\n_main:\nLeh_func_begin1:\n pushq %rbp\nLlabel1:\n movq %rsp, %rbp\nLlabel2:\n subq $16, %rsp\nLlabel3:\n movq %rsi, %rax\n movl %edi, %ecx\n movl %ecx, -8(%rbp)\n movq %rax, -16(%rbp)\n xorb %al, %al\n leaq LC(%rip), %rcx\n movq %rcx, %rdi\n call _printf\n movl $0, -4(%rbp)\n movl -4(%rbp), %eax\n addq $16, %rsp\n popq %rbp\n ret\nLeh_func_end1:\n .cstring\nLC:\n .asciz \"Hello World!\"\n```\n\n然后将其和C库链接生成可执行文件。相比之下，Objective-C语言整个过程和上面类似，不过代码的产生依赖Objective-C运行时的具体表现（译者注：运行时按照不同情况，生成不同的代码吧）。当我们刚接触Objective-C语言的时候，我们可能被告知像如下代码\n\n``` objc\n[self doSomethingWithVar:var1];\n```\n会被转换成\n\n``` objc\nobjc_msgSend(self,@selector(doSomethingWithVar:),var1);\n```\n而除了这些，我们似乎就不清楚运行时还干了什么。\n\n\n#### 什么是 Objective-C 运行时？\n\nObjective-C Runtime 是一个运行时库，主要是由C语言和汇编语言写成，为 C 语言添加面向对象的能力而创造了 Objective-C（译者注：正是 OC Runtime，才有 OC 这门语言）。这意味着它可以加载类信息，进行方法派发以及方法转发等等。Objective-C 运行时最重要的就是为Objective-C语言的面向对象特性的实现提供了所有的基础支撑。\n\n#### Objective-C 运行时术语\n\n在我们进一步了解整个运行时之前，需要先了解一些接下来出现的术语。截至目前Mac和iPhone的开发者关心的有两个运行时：Modern Runtime & Legacy Runtime 。前者覆盖所有64位Mac OS X 的app和所有的iOS app，后者覆盖其余的（全部的Mac OS X 32位 App）。关于方法，这里有两种基本类型的方法，一种是实例方法（'-'开头， 例如`-(void)doFoo`，作用于对象实例），另一种是类方法（'+'开头，例如`+(id)alloc`）。方法就像C语言中的函数类似，一段代码完成一个小的任务，如下：\n\n``` objc\n- (NSString *)movieTitle {\n    return @\"Futurama: Into the Wild Green Yonder\";\n}\n```\n**Selector**  \nObjective-C中的Selector（选择子）是一个重要的C数据结构，用以标识你要一个对象执行的Objective-C方法。在运行时中，Selector的定义应该和下面这样类似：\n\n``` objc\ntypedef struct objc_selector  *SEL; \n```\n\n用法就像下面这样：\n\n``` objc\nSEL aSel = @selector(movieTitle); \n```\n\n\n**Message**\n\n``` objc\n[target getMovieTitleForObject:obj];\n```\n\nObjective-C中的方法由两个方括号[]组成，括号中间是你将要将消息发往的目标对象和你将要该对象执行的方法以及所需要发送的参数列表。Objective-C中的消息和C函数类似，但是又不同。你向一个对象发送消息并不意味着该对象就一定会执行它。这个对象会检查该消息的发送者，然后基于该发送者要么执行一个不同的方法或者将该消息转发给另外的不同的对象。\n\n**Class**\n如果你看过Runtime中关于类的定义信息，你可能会遇到这样的定义：\n\n``` objc\ntypedef struct objc_class *Class;\ntypedef struct objc_object {\n    Class isa;\n} *id; \n```\n\n这其中有一些事情要注意。\n每一个Objective-C类拥有一个结构体，每一个对象也有一个结构体。所有的对象都包含一个isa指针。所有的Objective-C运行时需要这个isa指针，用以检查一个对象具体的类型是什么，然后判别其是否能够响应你所派发过来的消息。\n最后我们还注意到了id指针，这个id指针仅仅告诉我们其指向的是Objective-C对象，仅此而已。当你拥有一个id指针，你可以查询该对象的类型，然后查看该类型是否可以响应某个方法等等。还有就是当你知道了当前所指向的具体对象的具体类别，你就可以做出更具体的动作。\n\n\n**Blocks** \n\n你也可以在LLVM/Clang文档中对Blocks 的定义中发现和上面类似的东西。\n\n``` objc\nstruct Block_literal_1 {\n    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock\n    int flags;\n    int reserved; \n    void (*invoke)(void *, ...);\n    struct Block_descriptor_1 {\n         unsigned long int reserved; // NULL\n         unsigned long int size;  // sizeof(struct Block_literal_1)\n         // optional helper functions\n         void (*copy_helper)(void *dst, void *src);\n         void (*dispose_helper)(void *src); \n    } *descriptor;\n    // imported variables\n}; \n```\n\nBlocks被设计成能够与Objective-C运行时兼容，因此它们可以被当做对象处理，并可以响应消息（像`-retain`, `-release`, `-copy`等）。\n\n**IMP**（Method Implementations）\n\n``` objc\ntypedef id (*IMP)(id self,SEL _cmd,...); \n```\n\nIMP是编译器生成的函数指针，指向方法执行处。如果你刚接触Objective-C语言，你不需要直接和这些东西打交道，但是慢慢深入之后接触的就多了。后面我们会看到这也是Objective-C运行时唤醒方法的方式。\n\n\n**Objective-C Classes** \n\nObjective-C 的类内部有些什么东西呢？一个Objective-C的类的样子大体如下：\n\n``` objc\n@interface MyClass : NSObject {\n    // vars\n    NSInteger counter;\n}\n// methods\n-(void)doFoo;\n@end\n```\n\n但是运行时还会追加更多的内容以便跟踪（类每一时刻的状态）。\n\n``` objc\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif \n```\n我们可以看到一个类中包含一个指向其父类的引用，该类的名字、实例变量、方法集合、缓存以及该类遵循的协议列表。运行时需要这些信息以便响应那些分发到该类或者类实例对象上得方法。\n\n#### 因此类定义了对象而不是对象本身，那这又是如何实现的？\n\n正如我前面说过的，Objective-C类本身也同样是对象（译者注：意味着你可以向一个类发送消息），运行时通过创建元类来处理它们。当你发送类似`[NSObject alloc]`的消息时，你实际上是向类对象发送了消息，而这个类对象需要是**元类**的实例，而元类本身又是**根元类**的一个实例。\n当你说一个类继承自NSObject，那就意味着你的类指向NSObject作为其父类。而所有的元类指向根元类作为它们的父类，所有的元类都仅包含那些它能够响应的消息中的类方法。所以当你向一个类对象发送消息，例如`[NSObject alloc]`的时候，`objc_msgSend()`实际上会查看元类来确定该对象是否能够响应该消息，那如果找到了一个能响应该消息的方法，就在该对象上执行它。\n\n> 译者注：Objective-C类体系结构图如下所示：![ios-runtime-class](https://i.imgur.com/D7GUGKB.png)\n\n\n\n\n#### 为什么我们都要继承自Apple的类呢？\n\n当你刚踏入Cocoa开发的时候，很多代码例子都告诉你这样做：先继承NSObject类然后再进行其他编码。你也乐在其中，确实享受到了很多继承自Apple类所提供的便利。但是你甚至可能都没有发现实际上你的类在和Objective-C运行时打交道。当你为我们的类实例化的时候，像这样：\n\n``` objc\nMyObject *object = [[MyObject alloc] init];\n```\n\n第一个你要执行的消息就是`+alloc`。如果你[查看文档][6]，里面会讲到“一个新生实例的isa实例会被初始化为一个描述该类信息的数据结构，其余的实例变量的内存均被设置为空。”所以通过继承自Apple的类，我们不仅继承了一些很棒的属性，同时也继承了这些在内存上分配空间（大小是我们类的大小），创建对象的能力（就是创建运行时所期望的带有isa指针的数据结构）。\n\n#### 类缓存（objc\\_cache\\* cache）是什么？\n当Objective-C运行时通过一个对象的isa指针检查对象的时候，它会找到能够执行很多方法的类。然后你只需要调用其中很小一部分，所以每次运行时在进行一次查询动作时需要查找类分发表中所有的selectors这个动作是毫无意义的。这就是为什么类会由cache这个东西，当你查询一个类体系中的派发表的时候，一旦找到对应的selector时，就将该selector放到cache中。当`objc_msgSend()`方法在一个类中查询selector时，会先在cache中查找，这个理论的基础就是如果你曾经调用过一个类的消息，你有很大可能在之后还调用同样的方法。（译者注：CACHE的局部性原理）。所以按照这样考虑，如果我们先在有一个NSObject的子类MyObject如下：\n\n\n``` objc\nMyObject *obj = [[MyObject alloc] init];\n \n@implementation MyObject\n-(id)init {\n    if(self = [super init]) {\n        [self setVarA:@”blah”];\n    }\n    return self;\n}\n@end\n```\n\n具体发生了以下几点：\n1. `[MyObject alloc]`首先被执行，MyObject类没有实现该方法，因此在该类中没有找到`+alloc`方法，接着顺着superclass指针找到其父类`NSObject`；\n2. 我们询问`NSObject`类是否能够响应`+alloc`方法，而它能够响应。`+alloc`方法检查接受者类（也就是`MyObject`），分配该类大小的一块内存空间，然后初始化其isa指针指向`MyObject`类，此时我们拥有一个实例了，同时稍早我们将`+alloc`方法放置于`NSObject`的类缓存（cache）中；\n3. 到目前为止，我们都是在发送类方法，此刻我们需要向一个实例对象发送消息，这里简单的调用`-init`方法或者指定初始化方法（designated initializer），当然我们的类实现了该方法，因此我们将`-(id)init`方法放置于cache中；\n4. 接下来`self = [super init]`被调用，`super`是一个神奇的关键字（**magic keyword**），其指向类的父类，也即`NSObject`，我们调用`NSObject`的`init`方法。这样做的目的是为了确保面向对象编程的集成体系能够正确运行，在你正确初始化自身变量之前需要先初始化该类的所有父类的变量，如果你需要，你还可以覆写父类的方法。在该例中，对于NSObject类来说并没有多少特别重要的操作要进行，不过这并不是常态。有时候初始化中会做非常重要的事情，考虑以下代码：\n\n``` objc\n#import < Foundation/Foundation.h>\n \n@interface MyObject : NSObject {\n    NSString *aString;\n}\n \n@property(retain) NSString *aString;\n \n@end\n \n@implementation MyObject\n \n- (id)init {\n    if (self = [super init]) {\n      [self setAString:nil];\n    }\n    return self;\n}\n \n@synthesize aString;\n \n@end\n\n \nint main (int argc, const char * argv[]) {\n    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n \n    id obj1 = [NSMutableArray alloc];\n    id obj2 = [[NSMutableArray alloc] init];\n \n    id obj3 = [NSArray alloc];\n    id obj4 = [[NSArray alloc] initWithObjects:@\"Hello\",nil];\n      \n    NSLog(@\"obj1 class is %@\",NSStringFromClass([obj1 class]));\n    NSLog(@\"obj2 class is %@\",NSStringFromClass([obj2 class]));\n  \n    NSLog(@\"obj3 class is %@\",NSStringFromClass([obj3 class]));\n    NSLog(@\"obj4 class is %@\",NSStringFromClass([obj4 class]));\n  \n    id obj5 = [MyObject alloc];\n    id obj6 = [[MyObject alloc] init];\n  \n    NSLog(@\"obj5 class is %@\",NSStringFromClass([obj5 class]));\n    NSLog(@\"obj6 class is %@\",NSStringFromClass([obj6 class]));\n          \n    [pool drain];\n    return 0;\n}\n```\n\n\n如果你是刚刚接触Cocoa，我让你猜以上代码打印结果是什么，你很可能会给出这样的结果：\n\n``` objc\n\nNSMutableArray\nNSMutableArray \nNSArray\nNSArray\nMyObject\nMyObject\n\n```\n\n但实际上是如下结果：\n\n``` objc \n\nobj1 class is __NSPlaceholderArray\nobj2 class is NSCFArray\nobj3 class is __NSPlaceholderArray\nobj4 class is NSCFArray\nobj5 class is MyObject\nobj6 class is MyObject\n\n```\n\n> 译者注：（本机XCode 7 beta6 运行结果如下：）\n\n``` objc\n2015-09-07 13:43:06.922 ObjMessage[5185:1441448] obj1 class is __NSPlaceholderArray\n2015-09-07 13:43:11.201 ObjMessage[5185:1441448] obj2 class is __NSArrayM\n2015-09-07 13:43:17.987 ObjMessage[5185:1441448] obj3 class is __NSPlaceholderArray\n2015-09-07 13:43:18.503 ObjMessage[5185:1441448] obj4 class is __NSArrayI\n2015-09-07 13:43:32.228 ObjMessage[5185:1441448] obj5 class is MyObject\n2015-09-07 13:43:33.478 ObjMessage[5185:1441448] obj6 class is MyObject\n```\n\n\n原因就是Objective-C语言这里使用`+alloc`方法返回某个类的对象，但随后`-init`方法又可能返回另一个类的对象。\n\n#### 那 objc\\_msgSend 方法都发生了什么呢？\n\n实际上`objc_msgSend()`方法内部发生了许多事情。如下我们有这样的代码：\n\n``` objc\n[self printMessageWithString:@\"Hello World!\"];\n```\n\n编译器会把其翻译成如下所示代码：\n\n``` objc\n\nobjc_msgSend(self, @selector(printMessageWithString:), @\"Hello World!\");\n\n```\n我们通过目标对象的isa指针来查询该类或者其继承体系中的父类是否能够响应 `@selector(printMessageWithString:)`。假设我们在类的派发表或者它的cache中找到了该selector，然后我们通过该函数指针来执行该方法。因此我们可以了解`objc_msgSend()`方法永远不会返回，它从执行开始，通过指针查找到你的方法执行，然后是你的方法执行之后返回，因此看起来好像`objc_msgSend()`方法返回似的。Bill Bumgarner对此过程有更多的细节探索（[Part 1](http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map), [Part 2](http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path) & [Part 3](http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage)）。\n\n我这里总结下他所讲的，也就是你会在运行时代码中看到的：\n1. 检查那些忽略掉的Selectors和Short Circut， 很明显如果我们运行在垃圾回收环境下，我们可以忽略掉针对`-retain`，`-release`等的调用；\n\n2. 检查那些nil的目标。不像其他语言，Objective-C中向nil派发消息是合法的。当然你肯定也有很多理由希望这样。这里假设我们有一个非空的目标；\n\n3. 接下来我们需要在该类中找到IMP，我们首先查找该类的缓存（cache），如果找到我们便通过缓存中的指针跳转到该函数执行处；\n\n4. 如果缓存中没有找到该IMP，我们便紧接着查找类的派发表（dispatch table），如果找到同样跳转到函数执行处；\n\n5. 如果类的派发表中也未找到我们就需要触发消息分发机制了，这意味着最终你得代码会被编译器转换成了C函数。因此一个如下方法：\n\n``` objc\n-(int)doComputeWithNum:(int)aNum \n```\n\n会被转换成如下：\n \n``` objc\nint aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) \n```\n\nObjective-C运行时通过触发指向这些方法的函数指针来调用你的方法。告诉你，你没法直接调用这些转换之后的方法，尽管Cocoa框架确实提供了能够获取这些指针的方法。\n\n``` objc\n//declare C function pointer\nint (computeNum *)(id,SEL,int);\n \n//methodForSelector is COCOA & not ObjC Runtime\n//gets the same function pointer objc_msgSend gets\ncomputeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(doComputeWithNum:)];\n \n//execute the C function pointer returned by the runtime\ncomputeNum(obj,@selector(doComputeWithNum:),aNum); \n```\n通过这个方法，你可以获取到在运行时直接获取该方法并调用它。甚至在你确认一个指定的方法需要被执行的时候可以绕过运行时机制。这也是Objective-C运行时如何调用你的方法的，但还是使用`objc_msgSend()`方法为好。\n\n#### Objective-C 消息转发\n\n在Objective-C中，向一个根本不知道怎么响应方法的对象发送方法是合法的（也可能是该语言内部设计哲理）。Apple这样做的其中一个原因就是模拟Objective-C语言原生不支持的多重继承。或者你也许想抽象化自己的设计，隐藏该消息响应背后的其他类或者对象。这对于运行时系统也是非常必要的。它的工作流程大体是这样：\n\n1. 运行时在该类或者其继承体系中的缓存中和派发表中查找，然后查找失败；\n\n2. Objective-C运行时在所属对象的类上调用`+ (BOOL) resolveInstanceMethod:(SEL)aSEL`类方法，该类给予你一次机会来新增一个处理选择子`aSEL`的方法，然后告诉运行时你已经解决了该方法，消息转发机制会找到该方法。\n\n如下示例，你定义了一个函数：\n\n``` objc\nvoid fooMethod(id obj, SEL _cmd) {\n    NSLog(@\"Doing Foo\");\n}\n```\n\n你可以使用`class_addMethod()`方法类解决它：\n\n``` objc\n+(BOOL)resolveInstanceMethod:(SEL)aSEL {\n    if(aSEL == @selector(doFoo:)) {\n        class_addMethod([self class],aSEL,(IMP)fooMethod,\"v@:\");\n        return YES;\n    }\n    return [super resolveInstanceMethod];\n}\n```\n\n其中方法`class_addMethod()`中的`v@:`标明了方法的返回类型以及其参数类型。你可以在运行时文档中[Type Encodings][10]分查看到详细的说明。\n\n3. 如果2中`+(BOOL)resolveInstanceMethod:(SEL)aSEL`返回NO表示无法解析该方法的话，运行时接着调用`- (id)forwardingTargetForSelector:(SEL) aSelector`来给你再一次机会是否能够将该消息转发给其他接收者来处理。这要比之后运行完整的消息转发`- (void)forwardInvocation:(NSInvocation *)anInvocation`要好。你可以这样执行：\n\n``` objc\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if(aSelector == @selector(mysteriousMethod:)) {\n        return alternateObject;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n\n很明显，你肯定不想返回 self，否则会引起死循环。\n\n4. 如果上一步没有找到合适的目标对象来执行上面的消息，接着运行时会尝试最后一步 `- (void)forwardInvocation:(NSInvocation *)anInvocation`。你可能没见过NSInvocation，它实际上是Objective-C语言中的消息类型。一旦你有一个NSInvocation，你基本上能够改变这个消息的任何东西，包括其目标、选择子以及参数。所以你可以这样做：\n\n``` objc\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    SEL invSEL = invocation.selector;\n \n    if([altObject respondsToSelector:invSEL]) {\n        [invocation invokeWithTarget:altObject];\n    } \n    else {\n        [self doesNotRecognizeSelector:invSEL];\n    }\n}\n```\n默认情况下，如果你继承自NSObject类，它所实现的`- (void)forwardInvocation:(NSInvocation *)anInvocation`内部仅仅简单的调用了`-doesNotRecognizeSelector:`方法，如果你想给自己最后一次机会做一些事情的话，你可以重载该方法。\n\n\n#### Non Fragile ivars (Modern Runtime)\n\n一个Modern Runtime新增加的概念就是Non Fragile ivars。当编译器编译我们的类时，编译器会生成一个变量布局来显示每次我们从什么位置去取我们的实例变量，其底层的实现细节是这样的，查看类成员变量和类对象指针指向位置的偏移，读取该变量大小的字节就可以将该变量读取出来。所以你得变量布局可能如下所示，左侧列标明字节偏移量：\n\n![NSObject 布局](https://i.imgur.com/35waSjN.png)\n\n\n这里我们有NSObject类型的变量布局，然后我们继承NSObject来扩展它，并添加自己的变量，这在Apple发布新版本OSX SDK之前都运行良好。\n\n![NSObject 布局](https://i.imgur.com/xPo1FAw.png)\n\n我们的代码就无法正常运行，我们自定义对象中的内容被擦出了，因为NSObject增加了两个成员变量，而MyObject类成员变量布局在编译时已经确定，有两个成员变量和基类的内存区域重叠。唯一能够阻止这个发生的就是Apple维持它之前的布局策略，但是一旦这样他们的框架就无法再往前发展了，因为它们的变量布局已经固化了。在这种情况下（也就是fragile ivars）你只能通过重新编译这些继承自Apple类的类来使得代码得以兼容。那在 non fragile ivars下会发生什么呢？\n\n![NSObject 布局](https://i.imgur.com/w9Fxvpa.png)\n\n在Non Fragile ivars下编译器虽然生成了和fragile ivars同样的布局，但是运行时会通过计算基类大小，动态调整MyObject类成员布局。结果如上图所示。\n\n#### Objective-C 关联对象\n\n最近引入Mac OS X 10.6系统有一个特性称作“关联引用”。Objective-C不像其他语言，其原生不支持向对象动态添加变量。所以到目前为止，你都必须要费很大的劲，编译整个体系结构来假装自己向类中添加一个变量。不过在Mac OS X 10.6系统中，Objective-C 运行时原生支持（动态添加变量）。如果我们想向每一个已经存在的类中添加一个变量，例如向NSView类中添加，如下所示：\n\n``` objc\n#import < Cocoa/Cocoa.h> //Cocoa\n#include < objc/runtime.h> //objc runtime api’s\n \n@interface NSView (CustomAdditions)\n@property(retain) NSImage *customImage;\n@end\n \n@implementation NSView (CustomAdditions)\n \nstatic char img_key; //has a unique address (identifier)\n \n-(NSImage *)customImage {\n    return objc_getAssociatedObject(self,&img_key);\n}\n \n-(void)setCustomImage:(NSImage *)image {\n    objc_setAssociatedObject(self,&img_key,image,\n                             OBJC_ASSOCIATION_RETAIN);\n}\n \n@end\n```\n\n你可以在[runtime.h][11]，（译者注：最新版 [runtime.h][12]）文件中看到向`objc_setAssociatedObject()`传递的几个选项：\n\n``` objc\n/* Associative References */\n\n/**\n * Policies related to associative references.\n * These are options to objc_setAssociatedObject()\n */\nenum {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n\n```\n\n这些和你通过`@property`方式传递的选项相吻合。\n\n#### 混合的虚表派生\n如果你查看Modern runtime 代码，你会在[objc-runtime-new.m]()（译者注： 最新版objc runtime源码为[objc-runtime-new.mm][14] 已经去掉了这个特性，译者发现从[objc4-551.1][15]版本开始就不支持了，不过读者还是可以借鉴下之前版本的实现方式。）中发现这个：\n\n``` objc\n/***********************************************************************\n* vtable dispatch\n* \n* Every class gets a vtable pointer. The vtable is an array of IMPs.\n* The selectors represented in the vtable are the same for all classes\n*   (i.e. no class has a bigger or smaller vtable).\n* Each vtable index has an associated trampoline which dispatches to \n*   the IMP at that index for the receiver class's vtable (after \n*   checking for NULL). Dispatch fixup uses these trampolines instead \n*   of objc_msgSend.\n* Fragility: The vtable size and list of selectors is chosen at launch \n*   time. No compiler-generated code depends on any particular vtable \n*   configuration, or even the use of vtable dispatch at all.\n* Memory size: If a class's vtable is identical to its superclass's \n*   (i.e. the class overrides none of the vtable selectors), then \n*   the class points directly to its superclass's vtable. This means \n*   selectors to be included in the vtable should be chosen so they are \n*   (1) frequently called, but (2) not too frequently overridden. In \n*   particular, -dealloc is a bad choice.\n* Forwarding: If a class doesn't implement some vtable selector, that \n*   selector's IMP is set to objc_msgSend in that class's vtable.\n* +initialize: Each class keeps the default vtable (which always \n*   redirects to objc_msgSend) until its +initialize is completed.\n*   Otherwise, the first message to a class could be a vtable dispatch, \n*   and the vtable trampoline doesn't include +initialize checking.\n* Changes: Categories, addMethod, and setImplementation all force vtable \n*   reconstruction for the class and all of its subclasses, if the \n*   vtable selectors are affected.\n**********************************************************************/\n```\n\n这背后的原理就是，运行时试图去存储你最近调用过的选择子（selector）以便能够为你的App加速，因为其比`objc_msgSend`方法使用更少的指令。这个`vTable`存储你最近全局调用的16个选择子，实际上，在代码文件往下接着看你就会看到垃圾回收和非垃圾回收类型的App的默认选择子（selectors）。\n \n``` objc\nstatic const char * const defaultVtable[] = {\n    \"allocWithZone:\", \n    \"alloc\", \n    \"class\", \n    \"self\", \n    \"isKindOfClass:\", \n    \"respondsToSelector:\", \n    \"isFlipped\", \n    \"length\", \n    \"objectForKey:\", \n    \"count\", \n    \"objectAtIndex:\", \n    \"isEqualToString:\", \n    \"isEqual:\", \n    \"retain\", \n    \"release\", \n    \"autorelease\", \n};\nstatic const char * const defaultVtableGC[] = {\n    \"allocWithZone:\", \n    \"alloc\", \n    \"class\", \n    \"self\", \n    \"isKindOfClass:\", \n    \"respondsToSelector:\", \n    \"isFlipped\", \n    \"length\", \n    \"objectForKey:\", \n    \"count\", \n    \"objectAtIndex:\", \n    \"isEqualToString:\", \n    \"isEqual:\", \n    \"hash\", \n    \"addObject:\", \n    \"countByEnumeratingWithState:objects:count:\", \n};\n```\n\n\n#### 因此你如何能知道你正在和它打交道呢？\n当你进行调试的时候，你会在你的调试栈中看到稍后讲解到的某些方法的身影。你就把这些方法按照`objc_msgSend()`方法来对待就行，不过这些方法都是为了调试，具体有如下几个方法。\n1.  当运行时正在将你所有调用的这些方法中的其中一个插入到虚表（vTable）中时，会调用`objc_msgSend_fixup`。\n\n2. 而当`objc_msgSend_fixedup`发生时，表明你当前所调用的一个方法本应该存在于虚表中`objc_msgSend_vtable[0-15]`的位置，但却并不在\n\n3. 你可能会看到`objc_msgSend_vtable5`类似的东西，其意味着你正在调用虚表中的一个方法。运行时可以根据需要动态调整虚表中的内容。因此你不应该期望这次代码循环调用的`objc_msgSend_vtable10`对应了`-length`方法，而之后每次代码循环还依然会这样。（因为vTable也在不断变化中）\n\n译者注：参考[[objc explain]: objc\\_msgSend\\_vtable](http://www.sealiesoftware.com/blog/archive/2011/06/17/objc\\_explain\\_objc\\_msgSend\\_vtable.html)\n\n#### 总结\n\n我希望你们能够喜欢以上这些东西，这篇文章主要讲述了我和Des Moines Cocoaheads关于Objective-C runtime的谈话（我们的讨论估计能打包一箩筐）。Objective-C Runtime是一项很了不起的工程，它为我们Cocoa/Objective-C下制作的Apps注入能量，使得我们能够实现很多我们认为理所当然的特性。希望你能够看一看Apple官方文档对Objective-C运行时的讲解，这样能够使你更好的利用Objective-C运行时。谢谢。\n\n\n\n####  参考链接\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n[Objective-C Runtime Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html)","source":"_posts/Understanding-the-Objective-C-Runtime.md","raw":"title: \"理解Objective-C运行时\"\ndate: 2015-09-07 17:55:33\ncategories: 翻译\ntop_img: https://i.imgur.com/5SKmTN3.png\ntags: [iOS,Objective-C,Runtime]\n\n---\n\n> 翻译自：[Understanding the Objective-C Runtime](https://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html)\n> 译者： [@这个昵称有点萌](http://weibo.com/hc2feifei)\n\n\nObjective-C 运行时对于刚刚踏入 Cocoa/Objective 世界的人是很容易忽\n略的 Objective-C 语言的特性之一。原因就是尽管 Objective-C 是一门几个小时之内入门的语言，但是投身 Cocoa 的新手们会花费大量时间在 Cocoa 框架中，试图搞清楚他到底是怎么工作的。<!-- more --> 我觉得每个开发者都应该对其有深入的了解，明白一些内部的实现细节，而不仅仅只知道代码 `[target doMethodWith:var]` 会被编译器转换成 `objc_msgSend(target,@selector(doMethodWith:),var1);` 而已。了解 Objective-C 运行时的原理有助于你对 Objective-C 语言有更深入的理解，清楚你得 App 是怎么运行的。我觉得这对无论是 Mac/iPhone 新手或者老手都会有所帮助。\n\n\n\n\n[TOC]\n\n#### Objective-C运行时是开源的\n\nObjective-C 运行时是开源的，你可以随时从 [Apple](http://opensource.apple.com) 获取到。实际上查看 Objective-C 运行时源码是我搞清楚这个语言是怎么运作的首选方法，而不是去查看和它相关的苹果文档。你可以到[这里](http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz) 下载到运行时的源码（截止到译者翻译的时候，最新版本的文件是objc4-647.tar.gz）。\n\n#### 动态 Vs. 静态\n\nObjective-C 是一门动态的面向对象语言，这意味着它可以将编译链接时决定的事情推迟到运行时进行。这就给了你很大的灵活性，你可以按照自己的需要重定向消息到适当的对象上，你甚至可以交换方法实现（译者注：method swizzling，方法调配，开发者常用此技术向原有实现中添加新功能）。而运行时可以使对象明白自己可以响应哪些消息，不能响应哪些消息（译者注：introspect 内省），并正确的派发消息。\n\n> 译者注： 内省（introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。\n> \n> 参考: [Objective-C 的 Introspection](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Introspection/Introspection.html)\n\n我们将这些特征和C语言进行对比来看，在C中，你从`main()`函数开始，然后按顺序从上往下写你的代码逻辑或者执行函数方法。C结构体是无法将请求转发到其他目标对象来执行方法的。你很可能写了如下类似的代码：\n\n``` objc\n#include < stdio.h >\n \nint main(int argc, const char **argv[]) {\n    printf(\"Hello World!\");\n    return 0;\n}\n```\n\n编译器解析、优化然后将优化后的代码转换成如下的汇编语言：\n\n``` objc\n.text\n .align 4,0x90\n .globl _main\n_main:\nLeh_func_begin1:\n pushq %rbp\nLlabel1:\n movq %rsp, %rbp\nLlabel2:\n subq $16, %rsp\nLlabel3:\n movq %rsi, %rax\n movl %edi, %ecx\n movl %ecx, -8(%rbp)\n movq %rax, -16(%rbp)\n xorb %al, %al\n leaq LC(%rip), %rcx\n movq %rcx, %rdi\n call _printf\n movl $0, -4(%rbp)\n movl -4(%rbp), %eax\n addq $16, %rsp\n popq %rbp\n ret\nLeh_func_end1:\n .cstring\nLC:\n .asciz \"Hello World!\"\n```\n\n然后将其和C库链接生成可执行文件。相比之下，Objective-C语言整个过程和上面类似，不过代码的产生依赖Objective-C运行时的具体表现（译者注：运行时按照不同情况，生成不同的代码吧）。当我们刚接触Objective-C语言的时候，我们可能被告知像如下代码\n\n``` objc\n[self doSomethingWithVar:var1];\n```\n会被转换成\n\n``` objc\nobjc_msgSend(self,@selector(doSomethingWithVar:),var1);\n```\n而除了这些，我们似乎就不清楚运行时还干了什么。\n\n\n#### 什么是 Objective-C 运行时？\n\nObjective-C Runtime 是一个运行时库，主要是由C语言和汇编语言写成，为 C 语言添加面向对象的能力而创造了 Objective-C（译者注：正是 OC Runtime，才有 OC 这门语言）。这意味着它可以加载类信息，进行方法派发以及方法转发等等。Objective-C 运行时最重要的就是为Objective-C语言的面向对象特性的实现提供了所有的基础支撑。\n\n#### Objective-C 运行时术语\n\n在我们进一步了解整个运行时之前，需要先了解一些接下来出现的术语。截至目前Mac和iPhone的开发者关心的有两个运行时：Modern Runtime & Legacy Runtime 。前者覆盖所有64位Mac OS X 的app和所有的iOS app，后者覆盖其余的（全部的Mac OS X 32位 App）。关于方法，这里有两种基本类型的方法，一种是实例方法（'-'开头， 例如`-(void)doFoo`，作用于对象实例），另一种是类方法（'+'开头，例如`+(id)alloc`）。方法就像C语言中的函数类似，一段代码完成一个小的任务，如下：\n\n``` objc\n- (NSString *)movieTitle {\n    return @\"Futurama: Into the Wild Green Yonder\";\n}\n```\n**Selector**  \nObjective-C中的Selector（选择子）是一个重要的C数据结构，用以标识你要一个对象执行的Objective-C方法。在运行时中，Selector的定义应该和下面这样类似：\n\n``` objc\ntypedef struct objc_selector  *SEL; \n```\n\n用法就像下面这样：\n\n``` objc\nSEL aSel = @selector(movieTitle); \n```\n\n\n**Message**\n\n``` objc\n[target getMovieTitleForObject:obj];\n```\n\nObjective-C中的方法由两个方括号[]组成，括号中间是你将要将消息发往的目标对象和你将要该对象执行的方法以及所需要发送的参数列表。Objective-C中的消息和C函数类似，但是又不同。你向一个对象发送消息并不意味着该对象就一定会执行它。这个对象会检查该消息的发送者，然后基于该发送者要么执行一个不同的方法或者将该消息转发给另外的不同的对象。\n\n**Class**\n如果你看过Runtime中关于类的定义信息，你可能会遇到这样的定义：\n\n``` objc\ntypedef struct objc_class *Class;\ntypedef struct objc_object {\n    Class isa;\n} *id; \n```\n\n这其中有一些事情要注意。\n每一个Objective-C类拥有一个结构体，每一个对象也有一个结构体。所有的对象都包含一个isa指针。所有的Objective-C运行时需要这个isa指针，用以检查一个对象具体的类型是什么，然后判别其是否能够响应你所派发过来的消息。\n最后我们还注意到了id指针，这个id指针仅仅告诉我们其指向的是Objective-C对象，仅此而已。当你拥有一个id指针，你可以查询该对象的类型，然后查看该类型是否可以响应某个方法等等。还有就是当你知道了当前所指向的具体对象的具体类别，你就可以做出更具体的动作。\n\n\n**Blocks** \n\n你也可以在LLVM/Clang文档中对Blocks 的定义中发现和上面类似的东西。\n\n``` objc\nstruct Block_literal_1 {\n    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock\n    int flags;\n    int reserved; \n    void (*invoke)(void *, ...);\n    struct Block_descriptor_1 {\n         unsigned long int reserved; // NULL\n         unsigned long int size;  // sizeof(struct Block_literal_1)\n         // optional helper functions\n         void (*copy_helper)(void *dst, void *src);\n         void (*dispose_helper)(void *src); \n    } *descriptor;\n    // imported variables\n}; \n```\n\nBlocks被设计成能够与Objective-C运行时兼容，因此它们可以被当做对象处理，并可以响应消息（像`-retain`, `-release`, `-copy`等）。\n\n**IMP**（Method Implementations）\n\n``` objc\ntypedef id (*IMP)(id self,SEL _cmd,...); \n```\n\nIMP是编译器生成的函数指针，指向方法执行处。如果你刚接触Objective-C语言，你不需要直接和这些东西打交道，但是慢慢深入之后接触的就多了。后面我们会看到这也是Objective-C运行时唤醒方法的方式。\n\n\n**Objective-C Classes** \n\nObjective-C 的类内部有些什么东西呢？一个Objective-C的类的样子大体如下：\n\n``` objc\n@interface MyClass : NSObject {\n    // vars\n    NSInteger counter;\n}\n// methods\n-(void)doFoo;\n@end\n```\n\n但是运行时还会追加更多的内容以便跟踪（类每一时刻的状态）。\n\n``` objc\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif \n```\n我们可以看到一个类中包含一个指向其父类的引用，该类的名字、实例变量、方法集合、缓存以及该类遵循的协议列表。运行时需要这些信息以便响应那些分发到该类或者类实例对象上得方法。\n\n#### 因此类定义了对象而不是对象本身，那这又是如何实现的？\n\n正如我前面说过的，Objective-C类本身也同样是对象（译者注：意味着你可以向一个类发送消息），运行时通过创建元类来处理它们。当你发送类似`[NSObject alloc]`的消息时，你实际上是向类对象发送了消息，而这个类对象需要是**元类**的实例，而元类本身又是**根元类**的一个实例。\n当你说一个类继承自NSObject，那就意味着你的类指向NSObject作为其父类。而所有的元类指向根元类作为它们的父类，所有的元类都仅包含那些它能够响应的消息中的类方法。所以当你向一个类对象发送消息，例如`[NSObject alloc]`的时候，`objc_msgSend()`实际上会查看元类来确定该对象是否能够响应该消息，那如果找到了一个能响应该消息的方法，就在该对象上执行它。\n\n> 译者注：Objective-C类体系结构图如下所示：![ios-runtime-class](https://i.imgur.com/D7GUGKB.png)\n\n\n\n\n#### 为什么我们都要继承自Apple的类呢？\n\n当你刚踏入Cocoa开发的时候，很多代码例子都告诉你这样做：先继承NSObject类然后再进行其他编码。你也乐在其中，确实享受到了很多继承自Apple类所提供的便利。但是你甚至可能都没有发现实际上你的类在和Objective-C运行时打交道。当你为我们的类实例化的时候，像这样：\n\n``` objc\nMyObject *object = [[MyObject alloc] init];\n```\n\n第一个你要执行的消息就是`+alloc`。如果你[查看文档][6]，里面会讲到“一个新生实例的isa实例会被初始化为一个描述该类信息的数据结构，其余的实例变量的内存均被设置为空。”所以通过继承自Apple的类，我们不仅继承了一些很棒的属性，同时也继承了这些在内存上分配空间（大小是我们类的大小），创建对象的能力（就是创建运行时所期望的带有isa指针的数据结构）。\n\n#### 类缓存（objc\\_cache\\* cache）是什么？\n当Objective-C运行时通过一个对象的isa指针检查对象的时候，它会找到能够执行很多方法的类。然后你只需要调用其中很小一部分，所以每次运行时在进行一次查询动作时需要查找类分发表中所有的selectors这个动作是毫无意义的。这就是为什么类会由cache这个东西，当你查询一个类体系中的派发表的时候，一旦找到对应的selector时，就将该selector放到cache中。当`objc_msgSend()`方法在一个类中查询selector时，会先在cache中查找，这个理论的基础就是如果你曾经调用过一个类的消息，你有很大可能在之后还调用同样的方法。（译者注：CACHE的局部性原理）。所以按照这样考虑，如果我们先在有一个NSObject的子类MyObject如下：\n\n\n``` objc\nMyObject *obj = [[MyObject alloc] init];\n \n@implementation MyObject\n-(id)init {\n    if(self = [super init]) {\n        [self setVarA:@”blah”];\n    }\n    return self;\n}\n@end\n```\n\n具体发生了以下几点：\n1. `[MyObject alloc]`首先被执行，MyObject类没有实现该方法，因此在该类中没有找到`+alloc`方法，接着顺着superclass指针找到其父类`NSObject`；\n2. 我们询问`NSObject`类是否能够响应`+alloc`方法，而它能够响应。`+alloc`方法检查接受者类（也就是`MyObject`），分配该类大小的一块内存空间，然后初始化其isa指针指向`MyObject`类，此时我们拥有一个实例了，同时稍早我们将`+alloc`方法放置于`NSObject`的类缓存（cache）中；\n3. 到目前为止，我们都是在发送类方法，此刻我们需要向一个实例对象发送消息，这里简单的调用`-init`方法或者指定初始化方法（designated initializer），当然我们的类实现了该方法，因此我们将`-(id)init`方法放置于cache中；\n4. 接下来`self = [super init]`被调用，`super`是一个神奇的关键字（**magic keyword**），其指向类的父类，也即`NSObject`，我们调用`NSObject`的`init`方法。这样做的目的是为了确保面向对象编程的集成体系能够正确运行，在你正确初始化自身变量之前需要先初始化该类的所有父类的变量，如果你需要，你还可以覆写父类的方法。在该例中，对于NSObject类来说并没有多少特别重要的操作要进行，不过这并不是常态。有时候初始化中会做非常重要的事情，考虑以下代码：\n\n``` objc\n#import < Foundation/Foundation.h>\n \n@interface MyObject : NSObject {\n    NSString *aString;\n}\n \n@property(retain) NSString *aString;\n \n@end\n \n@implementation MyObject\n \n- (id)init {\n    if (self = [super init]) {\n      [self setAString:nil];\n    }\n    return self;\n}\n \n@synthesize aString;\n \n@end\n\n \nint main (int argc, const char * argv[]) {\n    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\n \n    id obj1 = [NSMutableArray alloc];\n    id obj2 = [[NSMutableArray alloc] init];\n \n    id obj3 = [NSArray alloc];\n    id obj4 = [[NSArray alloc] initWithObjects:@\"Hello\",nil];\n      \n    NSLog(@\"obj1 class is %@\",NSStringFromClass([obj1 class]));\n    NSLog(@\"obj2 class is %@\",NSStringFromClass([obj2 class]));\n  \n    NSLog(@\"obj3 class is %@\",NSStringFromClass([obj3 class]));\n    NSLog(@\"obj4 class is %@\",NSStringFromClass([obj4 class]));\n  \n    id obj5 = [MyObject alloc];\n    id obj6 = [[MyObject alloc] init];\n  \n    NSLog(@\"obj5 class is %@\",NSStringFromClass([obj5 class]));\n    NSLog(@\"obj6 class is %@\",NSStringFromClass([obj6 class]));\n          \n    [pool drain];\n    return 0;\n}\n```\n\n\n如果你是刚刚接触Cocoa，我让你猜以上代码打印结果是什么，你很可能会给出这样的结果：\n\n``` objc\n\nNSMutableArray\nNSMutableArray \nNSArray\nNSArray\nMyObject\nMyObject\n\n```\n\n但实际上是如下结果：\n\n``` objc \n\nobj1 class is __NSPlaceholderArray\nobj2 class is NSCFArray\nobj3 class is __NSPlaceholderArray\nobj4 class is NSCFArray\nobj5 class is MyObject\nobj6 class is MyObject\n\n```\n\n> 译者注：（本机XCode 7 beta6 运行结果如下：）\n\n``` objc\n2015-09-07 13:43:06.922 ObjMessage[5185:1441448] obj1 class is __NSPlaceholderArray\n2015-09-07 13:43:11.201 ObjMessage[5185:1441448] obj2 class is __NSArrayM\n2015-09-07 13:43:17.987 ObjMessage[5185:1441448] obj3 class is __NSPlaceholderArray\n2015-09-07 13:43:18.503 ObjMessage[5185:1441448] obj4 class is __NSArrayI\n2015-09-07 13:43:32.228 ObjMessage[5185:1441448] obj5 class is MyObject\n2015-09-07 13:43:33.478 ObjMessage[5185:1441448] obj6 class is MyObject\n```\n\n\n原因就是Objective-C语言这里使用`+alloc`方法返回某个类的对象，但随后`-init`方法又可能返回另一个类的对象。\n\n#### 那 objc\\_msgSend 方法都发生了什么呢？\n\n实际上`objc_msgSend()`方法内部发生了许多事情。如下我们有这样的代码：\n\n``` objc\n[self printMessageWithString:@\"Hello World!\"];\n```\n\n编译器会把其翻译成如下所示代码：\n\n``` objc\n\nobjc_msgSend(self, @selector(printMessageWithString:), @\"Hello World!\");\n\n```\n我们通过目标对象的isa指针来查询该类或者其继承体系中的父类是否能够响应 `@selector(printMessageWithString:)`。假设我们在类的派发表或者它的cache中找到了该selector，然后我们通过该函数指针来执行该方法。因此我们可以了解`objc_msgSend()`方法永远不会返回，它从执行开始，通过指针查找到你的方法执行，然后是你的方法执行之后返回，因此看起来好像`objc_msgSend()`方法返回似的。Bill Bumgarner对此过程有更多的细节探索（[Part 1](http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map), [Part 2](http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path) & [Part 3](http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage)）。\n\n我这里总结下他所讲的，也就是你会在运行时代码中看到的：\n1. 检查那些忽略掉的Selectors和Short Circut， 很明显如果我们运行在垃圾回收环境下，我们可以忽略掉针对`-retain`，`-release`等的调用；\n\n2. 检查那些nil的目标。不像其他语言，Objective-C中向nil派发消息是合法的。当然你肯定也有很多理由希望这样。这里假设我们有一个非空的目标；\n\n3. 接下来我们需要在该类中找到IMP，我们首先查找该类的缓存（cache），如果找到我们便通过缓存中的指针跳转到该函数执行处；\n\n4. 如果缓存中没有找到该IMP，我们便紧接着查找类的派发表（dispatch table），如果找到同样跳转到函数执行处；\n\n5. 如果类的派发表中也未找到我们就需要触发消息分发机制了，这意味着最终你得代码会被编译器转换成了C函数。因此一个如下方法：\n\n``` objc\n-(int)doComputeWithNum:(int)aNum \n```\n\n会被转换成如下：\n \n``` objc\nint aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) \n```\n\nObjective-C运行时通过触发指向这些方法的函数指针来调用你的方法。告诉你，你没法直接调用这些转换之后的方法，尽管Cocoa框架确实提供了能够获取这些指针的方法。\n\n``` objc\n//declare C function pointer\nint (computeNum *)(id,SEL,int);\n \n//methodForSelector is COCOA & not ObjC Runtime\n//gets the same function pointer objc_msgSend gets\ncomputeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(doComputeWithNum:)];\n \n//execute the C function pointer returned by the runtime\ncomputeNum(obj,@selector(doComputeWithNum:),aNum); \n```\n通过这个方法，你可以获取到在运行时直接获取该方法并调用它。甚至在你确认一个指定的方法需要被执行的时候可以绕过运行时机制。这也是Objective-C运行时如何调用你的方法的，但还是使用`objc_msgSend()`方法为好。\n\n#### Objective-C 消息转发\n\n在Objective-C中，向一个根本不知道怎么响应方法的对象发送方法是合法的（也可能是该语言内部设计哲理）。Apple这样做的其中一个原因就是模拟Objective-C语言原生不支持的多重继承。或者你也许想抽象化自己的设计，隐藏该消息响应背后的其他类或者对象。这对于运行时系统也是非常必要的。它的工作流程大体是这样：\n\n1. 运行时在该类或者其继承体系中的缓存中和派发表中查找，然后查找失败；\n\n2. Objective-C运行时在所属对象的类上调用`+ (BOOL) resolveInstanceMethod:(SEL)aSEL`类方法，该类给予你一次机会来新增一个处理选择子`aSEL`的方法，然后告诉运行时你已经解决了该方法，消息转发机制会找到该方法。\n\n如下示例，你定义了一个函数：\n\n``` objc\nvoid fooMethod(id obj, SEL _cmd) {\n    NSLog(@\"Doing Foo\");\n}\n```\n\n你可以使用`class_addMethod()`方法类解决它：\n\n``` objc\n+(BOOL)resolveInstanceMethod:(SEL)aSEL {\n    if(aSEL == @selector(doFoo:)) {\n        class_addMethod([self class],aSEL,(IMP)fooMethod,\"v@:\");\n        return YES;\n    }\n    return [super resolveInstanceMethod];\n}\n```\n\n其中方法`class_addMethod()`中的`v@:`标明了方法的返回类型以及其参数类型。你可以在运行时文档中[Type Encodings][10]分查看到详细的说明。\n\n3. 如果2中`+(BOOL)resolveInstanceMethod:(SEL)aSEL`返回NO表示无法解析该方法的话，运行时接着调用`- (id)forwardingTargetForSelector:(SEL) aSelector`来给你再一次机会是否能够将该消息转发给其他接收者来处理。这要比之后运行完整的消息转发`- (void)forwardInvocation:(NSInvocation *)anInvocation`要好。你可以这样执行：\n\n``` objc\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if(aSelector == @selector(mysteriousMethod:)) {\n        return alternateObject;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n\n很明显，你肯定不想返回 self，否则会引起死循环。\n\n4. 如果上一步没有找到合适的目标对象来执行上面的消息，接着运行时会尝试最后一步 `- (void)forwardInvocation:(NSInvocation *)anInvocation`。你可能没见过NSInvocation，它实际上是Objective-C语言中的消息类型。一旦你有一个NSInvocation，你基本上能够改变这个消息的任何东西，包括其目标、选择子以及参数。所以你可以这样做：\n\n``` objc\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    SEL invSEL = invocation.selector;\n \n    if([altObject respondsToSelector:invSEL]) {\n        [invocation invokeWithTarget:altObject];\n    } \n    else {\n        [self doesNotRecognizeSelector:invSEL];\n    }\n}\n```\n默认情况下，如果你继承自NSObject类，它所实现的`- (void)forwardInvocation:(NSInvocation *)anInvocation`内部仅仅简单的调用了`-doesNotRecognizeSelector:`方法，如果你想给自己最后一次机会做一些事情的话，你可以重载该方法。\n\n\n#### Non Fragile ivars (Modern Runtime)\n\n一个Modern Runtime新增加的概念就是Non Fragile ivars。当编译器编译我们的类时，编译器会生成一个变量布局来显示每次我们从什么位置去取我们的实例变量，其底层的实现细节是这样的，查看类成员变量和类对象指针指向位置的偏移，读取该变量大小的字节就可以将该变量读取出来。所以你得变量布局可能如下所示，左侧列标明字节偏移量：\n\n![NSObject 布局](https://i.imgur.com/35waSjN.png)\n\n\n这里我们有NSObject类型的变量布局，然后我们继承NSObject来扩展它，并添加自己的变量，这在Apple发布新版本OSX SDK之前都运行良好。\n\n![NSObject 布局](https://i.imgur.com/xPo1FAw.png)\n\n我们的代码就无法正常运行，我们自定义对象中的内容被擦出了，因为NSObject增加了两个成员变量，而MyObject类成员变量布局在编译时已经确定，有两个成员变量和基类的内存区域重叠。唯一能够阻止这个发生的就是Apple维持它之前的布局策略，但是一旦这样他们的框架就无法再往前发展了，因为它们的变量布局已经固化了。在这种情况下（也就是fragile ivars）你只能通过重新编译这些继承自Apple类的类来使得代码得以兼容。那在 non fragile ivars下会发生什么呢？\n\n![NSObject 布局](https://i.imgur.com/w9Fxvpa.png)\n\n在Non Fragile ivars下编译器虽然生成了和fragile ivars同样的布局，但是运行时会通过计算基类大小，动态调整MyObject类成员布局。结果如上图所示。\n\n#### Objective-C 关联对象\n\n最近引入Mac OS X 10.6系统有一个特性称作“关联引用”。Objective-C不像其他语言，其原生不支持向对象动态添加变量。所以到目前为止，你都必须要费很大的劲，编译整个体系结构来假装自己向类中添加一个变量。不过在Mac OS X 10.6系统中，Objective-C 运行时原生支持（动态添加变量）。如果我们想向每一个已经存在的类中添加一个变量，例如向NSView类中添加，如下所示：\n\n``` objc\n#import < Cocoa/Cocoa.h> //Cocoa\n#include < objc/runtime.h> //objc runtime api’s\n \n@interface NSView (CustomAdditions)\n@property(retain) NSImage *customImage;\n@end\n \n@implementation NSView (CustomAdditions)\n \nstatic char img_key; //has a unique address (identifier)\n \n-(NSImage *)customImage {\n    return objc_getAssociatedObject(self,&img_key);\n}\n \n-(void)setCustomImage:(NSImage *)image {\n    objc_setAssociatedObject(self,&img_key,image,\n                             OBJC_ASSOCIATION_RETAIN);\n}\n \n@end\n```\n\n你可以在[runtime.h][11]，（译者注：最新版 [runtime.h][12]）文件中看到向`objc_setAssociatedObject()`传递的几个选项：\n\n``` objc\n/* Associative References */\n\n/**\n * Policies related to associative references.\n * These are options to objc_setAssociatedObject()\n */\nenum {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n\n```\n\n这些和你通过`@property`方式传递的选项相吻合。\n\n#### 混合的虚表派生\n如果你查看Modern runtime 代码，你会在[objc-runtime-new.m]()（译者注： 最新版objc runtime源码为[objc-runtime-new.mm][14] 已经去掉了这个特性，译者发现从[objc4-551.1][15]版本开始就不支持了，不过读者还是可以借鉴下之前版本的实现方式。）中发现这个：\n\n``` objc\n/***********************************************************************\n* vtable dispatch\n* \n* Every class gets a vtable pointer. The vtable is an array of IMPs.\n* The selectors represented in the vtable are the same for all classes\n*   (i.e. no class has a bigger or smaller vtable).\n* Each vtable index has an associated trampoline which dispatches to \n*   the IMP at that index for the receiver class's vtable (after \n*   checking for NULL). Dispatch fixup uses these trampolines instead \n*   of objc_msgSend.\n* Fragility: The vtable size and list of selectors is chosen at launch \n*   time. No compiler-generated code depends on any particular vtable \n*   configuration, or even the use of vtable dispatch at all.\n* Memory size: If a class's vtable is identical to its superclass's \n*   (i.e. the class overrides none of the vtable selectors), then \n*   the class points directly to its superclass's vtable. This means \n*   selectors to be included in the vtable should be chosen so they are \n*   (1) frequently called, but (2) not too frequently overridden. In \n*   particular, -dealloc is a bad choice.\n* Forwarding: If a class doesn't implement some vtable selector, that \n*   selector's IMP is set to objc_msgSend in that class's vtable.\n* +initialize: Each class keeps the default vtable (which always \n*   redirects to objc_msgSend) until its +initialize is completed.\n*   Otherwise, the first message to a class could be a vtable dispatch, \n*   and the vtable trampoline doesn't include +initialize checking.\n* Changes: Categories, addMethod, and setImplementation all force vtable \n*   reconstruction for the class and all of its subclasses, if the \n*   vtable selectors are affected.\n**********************************************************************/\n```\n\n这背后的原理就是，运行时试图去存储你最近调用过的选择子（selector）以便能够为你的App加速，因为其比`objc_msgSend`方法使用更少的指令。这个`vTable`存储你最近全局调用的16个选择子，实际上，在代码文件往下接着看你就会看到垃圾回收和非垃圾回收类型的App的默认选择子（selectors）。\n \n``` objc\nstatic const char * const defaultVtable[] = {\n    \"allocWithZone:\", \n    \"alloc\", \n    \"class\", \n    \"self\", \n    \"isKindOfClass:\", \n    \"respondsToSelector:\", \n    \"isFlipped\", \n    \"length\", \n    \"objectForKey:\", \n    \"count\", \n    \"objectAtIndex:\", \n    \"isEqualToString:\", \n    \"isEqual:\", \n    \"retain\", \n    \"release\", \n    \"autorelease\", \n};\nstatic const char * const defaultVtableGC[] = {\n    \"allocWithZone:\", \n    \"alloc\", \n    \"class\", \n    \"self\", \n    \"isKindOfClass:\", \n    \"respondsToSelector:\", \n    \"isFlipped\", \n    \"length\", \n    \"objectForKey:\", \n    \"count\", \n    \"objectAtIndex:\", \n    \"isEqualToString:\", \n    \"isEqual:\", \n    \"hash\", \n    \"addObject:\", \n    \"countByEnumeratingWithState:objects:count:\", \n};\n```\n\n\n#### 因此你如何能知道你正在和它打交道呢？\n当你进行调试的时候，你会在你的调试栈中看到稍后讲解到的某些方法的身影。你就把这些方法按照`objc_msgSend()`方法来对待就行，不过这些方法都是为了调试，具体有如下几个方法。\n1.  当运行时正在将你所有调用的这些方法中的其中一个插入到虚表（vTable）中时，会调用`objc_msgSend_fixup`。\n\n2. 而当`objc_msgSend_fixedup`发生时，表明你当前所调用的一个方法本应该存在于虚表中`objc_msgSend_vtable[0-15]`的位置，但却并不在\n\n3. 你可能会看到`objc_msgSend_vtable5`类似的东西，其意味着你正在调用虚表中的一个方法。运行时可以根据需要动态调整虚表中的内容。因此你不应该期望这次代码循环调用的`objc_msgSend_vtable10`对应了`-length`方法，而之后每次代码循环还依然会这样。（因为vTable也在不断变化中）\n\n译者注：参考[[objc explain]: objc\\_msgSend\\_vtable](http://www.sealiesoftware.com/blog/archive/2011/06/17/objc\\_explain\\_objc\\_msgSend\\_vtable.html)\n\n#### 总结\n\n我希望你们能够喜欢以上这些东西，这篇文章主要讲述了我和Des Moines Cocoaheads关于Objective-C runtime的谈话（我们的讨论估计能打包一箩筐）。Objective-C Runtime是一项很了不起的工程，它为我们Cocoa/Objective-C下制作的Apps注入能量，使得我们能够实现很多我们认为理所当然的特性。希望你能够看一看Apple官方文档对Objective-C运行时的讲解，这样能够使你更好的利用Objective-C运行时。谢谢。\n\n\n\n####  参考链接\n[Objective-C Runtime Programming Guide](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html)\n[Objective-C Runtime Reference](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html)","slug":"Understanding-the-Objective-C-Runtime","published":1,"updated":"2018-10-07T11:09:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjrk2ftlt006u79poaj9e6mrq","content":"<blockquote>\n<p>翻译自：<a href=\"https://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"noopener\">Understanding the Objective-C Runtime</a><br>译者： <a href=\"http://weibo.com/hc2feifei\" target=\"_blank\" rel=\"noopener\">@这个昵称有点萌</a></p>\n</blockquote>\n<p>Objective-C 运行时对于刚刚踏入 Cocoa/Objective 世界的人是很容易忽<br>略的 Objective-C 语言的特性之一。原因就是尽管 Objective-C 是一门几个小时之内入门的语言，但是投身 Cocoa 的新手们会花费大量时间在 Cocoa 框架中，试图搞清楚他到底是怎么工作的。<a id=\"more\"></a> 我觉得每个开发者都应该对其有深入的了解，明白一些内部的实现细节，而不仅仅只知道代码 <code>[target doMethodWith:var]</code> 会被编译器转换成 <code>objc_msgSend(target,@selector(doMethodWith:),var1);</code> 而已。了解 Objective-C 运行时的原理有助于你对 Objective-C 语言有更深入的理解，清楚你得 App 是怎么运行的。我觉得这对无论是 Mac/iPhone 新手或者老手都会有所帮助。</p>\n<p>[TOC]</p>\n<h4 id=\"Objective-C运行时是开源的\"><a href=\"#Objective-C运行时是开源的\" class=\"headerlink\" title=\"Objective-C运行时是开源的\"></a>Objective-C运行时是开源的</h4><p>Objective-C 运行时是开源的，你可以随时从 <a href=\"http://opensource.apple.com\" target=\"_blank\" rel=\"noopener\">Apple</a> 获取到。实际上查看 Objective-C 运行时源码是我搞清楚这个语言是怎么运作的首选方法，而不是去查看和它相关的苹果文档。你可以到<a href=\"http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz\" target=\"_blank\" rel=\"noopener\">这里</a> 下载到运行时的源码（截止到译者翻译的时候，最新版本的文件是objc4-647.tar.gz）。</p>\n<h4 id=\"动态-Vs-静态\"><a href=\"#动态-Vs-静态\" class=\"headerlink\" title=\"动态 Vs. 静态\"></a>动态 Vs. 静态</h4><p>Objective-C 是一门动态的面向对象语言，这意味着它可以将编译链接时决定的事情推迟到运行时进行。这就给了你很大的灵活性，你可以按照自己的需要重定向消息到适当的对象上，你甚至可以交换方法实现（译者注：method swizzling，方法调配，开发者常用此技术向原有实现中添加新功能）。而运行时可以使对象明白自己可以响应哪些消息，不能响应哪些消息（译者注：introspect 内省），并正确的派发消息。</p>\n<blockquote>\n<p>译者注： 内省（introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。</p>\n<p>参考: <a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Introspection/Introspection.html\" target=\"_blank\" rel=\"noopener\">Objective-C 的 Introspection</a></p>\n</blockquote>\n<p>我们将这些特征和C语言进行对比来看，在C中，你从<code>main()</code>函数开始，然后按顺序从上往下写你的代码逻辑或者执行函数方法。C结构体是无法将请求转发到其他目标对象来执行方法的。你很可能写了如下类似的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt; stdio.h &gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv[]) &#123;</span><br><span class=\"line\">    printf(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译器解析、优化然后将优化后的代码转换成如下的汇编语言：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text</span><br><span class=\"line\"> .align <span class=\"number\">4</span>,<span class=\"number\">0x90</span></span><br><span class=\"line\"> .globl _main</span><br><span class=\"line\">_main:</span><br><span class=\"line\">Leh_func_begin1:</span><br><span class=\"line\"> pushq %rbp</span><br><span class=\"line\">Llabel1:</span><br><span class=\"line\"> movq %rsp, %rbp</span><br><span class=\"line\">Llabel2:</span><br><span class=\"line\"> subq $<span class=\"number\">16</span>, %rsp</span><br><span class=\"line\">Llabel3:</span><br><span class=\"line\"> movq %rsi, %rax</span><br><span class=\"line\"> movl %edi, %ecx</span><br><span class=\"line\"> movl %ecx, <span class=\"number\">-8</span>(%rbp)</span><br><span class=\"line\"> movq %rax, <span class=\"number\">-16</span>(%rbp)</span><br><span class=\"line\"> xorb %al, %al</span><br><span class=\"line\"> leaq LC(%rip), %rcx</span><br><span class=\"line\"> movq %rcx, %rdi</span><br><span class=\"line\"> call _printf</span><br><span class=\"line\"> movl $<span class=\"number\">0</span>, <span class=\"number\">-4</span>(%rbp)</span><br><span class=\"line\"> movl <span class=\"number\">-4</span>(%rbp), %eax</span><br><span class=\"line\"> addq $<span class=\"number\">16</span>, %rsp</span><br><span class=\"line\"> popq %rbp</span><br><span class=\"line\"> ret</span><br><span class=\"line\">Leh_func_end1:</span><br><span class=\"line\"> .cstring</span><br><span class=\"line\">LC:</span><br><span class=\"line\"> .asciz <span class=\"string\">\"Hello World!\"</span></span><br></pre></td></tr></table></figure>\n<p>然后将其和C库链接生成可执行文件。相比之下，Objective-C语言整个过程和上面类似，不过代码的产生依赖Objective-C运行时的具体表现（译者注：运行时按照不同情况，生成不同的代码吧）。当我们刚接触Objective-C语言的时候，我们可能被告知像如下代码</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> doSomethingWithVar:var1];</span><br></pre></td></tr></table></figure>\n<p>会被转换成</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(doSomethingWithVar:),var1);</span><br></pre></td></tr></table></figure>\n<p>而除了这些，我们似乎就不清楚运行时还干了什么。</p>\n<h4 id=\"什么是-Objective-C-运行时？\"><a href=\"#什么是-Objective-C-运行时？\" class=\"headerlink\" title=\"什么是 Objective-C 运行时？\"></a>什么是 Objective-C 运行时？</h4><p>Objective-C Runtime 是一个运行时库，主要是由C语言和汇编语言写成，为 C 语言添加面向对象的能力而创造了 Objective-C（译者注：正是 OC Runtime，才有 OC 这门语言）。这意味着它可以加载类信息，进行方法派发以及方法转发等等。Objective-C 运行时最重要的就是为Objective-C语言的面向对象特性的实现提供了所有的基础支撑。</p>\n<h4 id=\"Objective-C-运行时术语\"><a href=\"#Objective-C-运行时术语\" class=\"headerlink\" title=\"Objective-C 运行时术语\"></a>Objective-C 运行时术语</h4><p>在我们进一步了解整个运行时之前，需要先了解一些接下来出现的术语。截至目前Mac和iPhone的开发者关心的有两个运行时：Modern Runtime &amp; Legacy Runtime 。前者覆盖所有64位Mac OS X 的app和所有的iOS app，后者覆盖其余的（全部的Mac OS X 32位 App）。关于方法，这里有两种基本类型的方法，一种是实例方法（’-‘开头， 例如<code>-(void)doFoo</code>，作用于对象实例），另一种是类方法（’+’开头，例如<code>+(id)alloc</code>）。方法就像C语言中的函数类似，一段代码完成一个小的任务，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)movieTitle &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Futurama: Into the Wild Green Yonder\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Selector</strong><br>Objective-C中的Selector（选择子）是一个重要的C数据结构，用以标识你要一个对象执行的Objective-C方法。在运行时中，Selector的定义应该和下面这样类似：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector  *SEL;</span><br></pre></td></tr></table></figure>\n<p>用法就像下面这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">SEL aSel = <span class=\"keyword\">@selector</span>(movieTitle);</span><br></pre></td></tr></table></figure>\n<p><strong>Message</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[target getMovieTitleForObject:obj];</span><br></pre></td></tr></table></figure>\n<p>Objective-C中的方法由两个方括号[]组成，括号中间是你将要将消息发往的目标对象和你将要该对象执行的方法以及所需要发送的参数列表。Objective-C中的消息和C函数类似，但是又不同。你向一个对象发送消息并不意味着该对象就一定会执行它。这个对象会检查该消息的发送者，然后基于该发送者要么执行一个不同的方法或者将该消息转发给另外的不同的对象。</p>\n<p><strong>Class</strong><br>如果你看过Runtime中关于类的定义信息，你可能会遇到这样的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>这其中有一些事情要注意。<br>每一个Objective-C类拥有一个结构体，每一个对象也有一个结构体。所有的对象都包含一个isa指针。所有的Objective-C运行时需要这个isa指针，用以检查一个对象具体的类型是什么，然后判别其是否能够响应你所派发过来的消息。<br>最后我们还注意到了id指针，这个id指针仅仅告诉我们其指向的是Objective-C对象，仅此而已。当你拥有一个id指针，你可以查询该对象的类型，然后查看该类型是否可以响应某个方法等等。还有就是当你知道了当前所指向的具体对象的具体类别，你就可以做出更具体的动作。</p>\n<p><strong>Blocks</strong> </p>\n<p>你也可以在LLVM/Clang文档中对Blocks 的定义中发现和上面类似的东西。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> Block_literal_1 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *isa; <span class=\"comment\">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reserved; </span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor_1 &#123;</span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved; <span class=\"comment\">// NULL</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;  <span class=\"comment\">// sizeof(struct Block_literal_1)</span></span><br><span class=\"line\">         <span class=\"comment\">// optional helper functions</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> (*copy_helper)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</span><br><span class=\"line\">         <span class=\"keyword\">void</span> (*dispose_helper)(<span class=\"keyword\">void</span> *src); </span><br><span class=\"line\">    &#125; *descriptor;</span><br><span class=\"line\">    <span class=\"comment\">// imported variables</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Blocks被设计成能够与Objective-C运行时兼容，因此它们可以被当做对象处理，并可以响应消息（像<code>-retain</code>, <code>-release</code>, <code>-copy</code>等）。</p>\n<p><strong>IMP</strong>（Method Implementations）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">id</span> (*IMP)(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL _cmd,...);</span><br></pre></td></tr></table></figure>\n<p>IMP是编译器生成的函数指针，指向方法执行处。如果你刚接触Objective-C语言，你不需要直接和这些东西打交道，但是慢慢深入之后接触的就多了。后面我们会看到这也是Objective-C运行时唤醒方法的方式。</p>\n<p><strong>Objective-C Classes</strong> </p>\n<p>Objective-C 的类内部有些什么东西呢？一个Objective-C的类的样子大体如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// vars</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// methods</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)doFoo;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>但是运行时还会追加更多的内容以便跟踪（类每一时刻的状态）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到一个类中包含一个指向其父类的引用，该类的名字、实例变量、方法集合、缓存以及该类遵循的协议列表。运行时需要这些信息以便响应那些分发到该类或者类实例对象上得方法。</p>\n<h4 id=\"因此类定义了对象而不是对象本身，那这又是如何实现的？\"><a href=\"#因此类定义了对象而不是对象本身，那这又是如何实现的？\" class=\"headerlink\" title=\"因此类定义了对象而不是对象本身，那这又是如何实现的？\"></a>因此类定义了对象而不是对象本身，那这又是如何实现的？</h4><p>正如我前面说过的，Objective-C类本身也同样是对象（译者注：意味着你可以向一个类发送消息），运行时通过创建元类来处理它们。当你发送类似<code>[NSObject alloc]</code>的消息时，你实际上是向类对象发送了消息，而这个类对象需要是<strong>元类</strong>的实例，而元类本身又是<strong>根元类</strong>的一个实例。<br>当你说一个类继承自NSObject，那就意味着你的类指向NSObject作为其父类。而所有的元类指向根元类作为它们的父类，所有的元类都仅包含那些它能够响应的消息中的类方法。所以当你向一个类对象发送消息，例如<code>[NSObject alloc]</code>的时候，<code>objc_msgSend()</code>实际上会查看元类来确定该对象是否能够响应该消息，那如果找到了一个能响应该消息的方法，就在该对象上执行它。</p>\n<blockquote>\n<p>译者注：Objective-C类体系结构图如下所示：<img src=\"https://i.imgur.com/D7GUGKB.png\" alt=\"ios-runtime-class\"></p>\n</blockquote>\n<h4 id=\"为什么我们都要继承自Apple的类呢？\"><a href=\"#为什么我们都要继承自Apple的类呢？\" class=\"headerlink\" title=\"为什么我们都要继承自Apple的类呢？\"></a>为什么我们都要继承自Apple的类呢？</h4><p>当你刚踏入Cocoa开发的时候，很多代码例子都告诉你这样做：先继承NSObject类然后再进行其他编码。你也乐在其中，确实享受到了很多继承自Apple类所提供的便利。但是你甚至可能都没有发现实际上你的类在和Objective-C运行时打交道。当你为我们的类实例化的时候，像这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyObject *object = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure>\n<p>第一个你要执行的消息就是<code>+alloc</code>。如果你[查看文档][6]，里面会讲到“一个新生实例的isa实例会被初始化为一个描述该类信息的数据结构，其余的实例变量的内存均被设置为空。”所以通过继承自Apple的类，我们不仅继承了一些很棒的属性，同时也继承了这些在内存上分配空间（大小是我们类的大小），创建对象的能力（就是创建运行时所期望的带有isa指针的数据结构）。</p>\n<h4 id=\"类缓存（objc-cache-cache）是什么？\"><a href=\"#类缓存（objc-cache-cache）是什么？\" class=\"headerlink\" title=\"类缓存（objc_cache* cache）是什么？\"></a>类缓存（objc_cache* cache）是什么？</h4><p>当Objective-C运行时通过一个对象的isa指针检查对象的时候，它会找到能够执行很多方法的类。然后你只需要调用其中很小一部分，所以每次运行时在进行一次查询动作时需要查找类分发表中所有的selectors这个动作是毫无意义的。这就是为什么类会由cache这个东西，当你查询一个类体系中的派发表的时候，一旦找到对应的selector时，就将该selector放到cache中。当<code>objc_msgSend()</code>方法在一个类中查询selector时，会先在cache中查找，这个理论的基础就是如果你曾经调用过一个类的消息，你有很大可能在之后还调用同样的方法。（译者注：CACHE的局部性原理）。所以按照这样考虑，如果我们先在有一个NSObject的子类MyObject如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyObject *obj = [[MyObject alloc] init];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></span><br><span class=\"line\">-(<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setVarA:@”blah”];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>具体发生了以下几点：</p>\n<ol>\n<li><code>[MyObject alloc]</code>首先被执行，MyObject类没有实现该方法，因此在该类中没有找到<code>+alloc</code>方法，接着顺着superclass指针找到其父类<code>NSObject</code>；</li>\n<li>我们询问<code>NSObject</code>类是否能够响应<code>+alloc</code>方法，而它能够响应。<code>+alloc</code>方法检查接受者类（也就是<code>MyObject</code>），分配该类大小的一块内存空间，然后初始化其isa指针指向<code>MyObject</code>类，此时我们拥有一个实例了，同时稍早我们将<code>+alloc</code>方法放置于<code>NSObject</code>的类缓存（cache）中；</li>\n<li>到目前为止，我们都是在发送类方法，此刻我们需要向一个实例对象发送消息，这里简单的调用<code>-init</code>方法或者指定初始化方法（designated initializer），当然我们的类实现了该方法，因此我们将<code>-(id)init</code>方法放置于cache中；</li>\n<li>接下来<code>self = [super init]</code>被调用，<code>super</code>是一个神奇的关键字（<strong>magic keyword</strong>），其指向类的父类，也即<code>NSObject</code>，我们调用<code>NSObject</code>的<code>init</code>方法。这样做的目的是为了确保面向对象编程的集成体系能够正确运行，在你正确初始化自身变量之前需要先初始化该类的所有父类的变量，如果你需要，你还可以覆写父类的方法。在该例中，对于NSObject类来说并没有多少特别重要的操作要进行，不过这并不是常态。有时候初始化中会做非常重要的事情，考虑以下代码：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyObject</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *aString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSString</span> *aString;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">      [<span class=\"keyword\">self</span> setAString:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@synthesize</span> aString;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> main (<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAutoreleasePool</span> * pool = [[<span class=\"built_in\">NSAutoreleasePool</span> alloc] init];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSMutableArray</span> alloc];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj2 = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj3 = [<span class=\"built_in\">NSArray</span> alloc];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj4 = [[<span class=\"built_in\">NSArray</span> alloc] initWithObjects:<span class=\"string\">@\"Hello\"</span>,<span class=\"literal\">nil</span>];</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj1 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj1 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj2 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj2 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj3 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj3 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj4 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj4 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj5 = [MyObject alloc];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj6 = [[MyObject alloc] init];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj5 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj5 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj6 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj6 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">          </span><br><span class=\"line\">    [pool drain];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你是刚刚接触Cocoa，我让你猜以上代码打印结果是什么，你很可能会给出这样的结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> </span><br><span class=\"line\"><span class=\"built_in\">NSArray</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span></span><br><span class=\"line\">MyObject</span><br><span class=\"line\">MyObject</span><br></pre></td></tr></table></figure>\n<p>但实际上是如下结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">obj1 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\">obj2 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></span><br><span class=\"line\">obj3 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\">obj4 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></span><br><span class=\"line\">obj5 <span class=\"keyword\">class</span> is MyObject</span><br><span class=\"line\">obj6 <span class=\"keyword\">class</span> is MyObject</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>译者注：（本机XCode 7 beta6 运行结果如下：）</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">06.922</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj1 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">11.201</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj2 <span class=\"keyword\">class</span> is __NSArrayM</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">17.987</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj3 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">18.503</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj4 <span class=\"keyword\">class</span> is __NSArrayI</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">32.228</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj5 <span class=\"keyword\">class</span> is MyObject</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">33.478</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj6 <span class=\"keyword\">class</span> is MyObject</span><br></pre></td></tr></table></figure>\n<p>原因就是Objective-C语言这里使用<code>+alloc</code>方法返回某个类的对象，但随后<code>-init</code>方法又可能返回另一个类的对象。</p>\n<h4 id=\"那-objc-msgSend-方法都发生了什么呢？\"><a href=\"#那-objc-msgSend-方法都发生了什么呢？\" class=\"headerlink\" title=\"那 objc_msgSend 方法都发生了什么呢？\"></a>那 objc_msgSend 方法都发生了什么呢？</h4><p>实际上<code>objc_msgSend()</code>方法内部发生了许多事情。如下我们有这样的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> printMessageWithString:<span class=\"string\">@\"Hello World!\"</span>];</span><br></pre></td></tr></table></figure>\n<p>编译器会把其翻译成如下所示代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(printMessageWithString:), <span class=\"string\">@\"Hello World!\"</span>);</span><br></pre></td></tr></table></figure>\n<p>我们通过目标对象的isa指针来查询该类或者其继承体系中的父类是否能够响应 <code>@selector(printMessageWithString:)</code>。假设我们在类的派发表或者它的cache中找到了该selector，然后我们通过该函数指针来执行该方法。因此我们可以了解<code>objc_msgSend()</code>方法永远不会返回，它从执行开始，通过指针查找到你的方法执行，然后是你的方法执行之后返回，因此看起来好像<code>objc_msgSend()</code>方法返回似的。Bill Bumgarner对此过程有更多的细节探索（<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map\" target=\"_blank\" rel=\"noopener\">Part 1</a>, <a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path\" target=\"_blank\" rel=\"noopener\">Part 2</a> &amp; <a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage\" target=\"_blank\" rel=\"noopener\">Part 3</a>）。</p>\n<p>我这里总结下他所讲的，也就是你会在运行时代码中看到的：</p>\n<ol>\n<li><p>检查那些忽略掉的Selectors和Short Circut， 很明显如果我们运行在垃圾回收环境下，我们可以忽略掉针对<code>-retain</code>，<code>-release</code>等的调用；</p>\n</li>\n<li><p>检查那些nil的目标。不像其他语言，Objective-C中向nil派发消息是合法的。当然你肯定也有很多理由希望这样。这里假设我们有一个非空的目标；</p>\n</li>\n<li><p>接下来我们需要在该类中找到IMP，我们首先查找该类的缓存（cache），如果找到我们便通过缓存中的指针跳转到该函数执行处；</p>\n</li>\n<li><p>如果缓存中没有找到该IMP，我们便紧接着查找类的派发表（dispatch table），如果找到同样跳转到函数执行处；</p>\n</li>\n<li><p>如果类的派发表中也未找到我们就需要触发消息分发机制了，这意味着最终你得代码会被编译器转换成了C函数。因此一个如下方法：</p>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">int</span>)doComputeWithNum:(<span class=\"keyword\">int</span>)aNum</span><br></pre></td></tr></table></figure>\n<p>会被转换成如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> aClass_doComputeWithNum(aClass *<span class=\"keyword\">self</span>,SEL _cmd,<span class=\"keyword\">int</span> aNum)</span><br></pre></td></tr></table></figure>\n<p>Objective-C运行时通过触发指向这些方法的函数指针来调用你的方法。告诉你，你没法直接调用这些转换之后的方法，尽管Cocoa框架确实提供了能够获取这些指针的方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//declare C function pointer</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (computeNum *)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//methodForSelector is COCOA &amp; not ObjC Runtime</span></span><br><span class=\"line\"><span class=\"comment\">//gets the same function pointer objc_msgSend gets</span></span><br><span class=\"line\">computeNum = (<span class=\"keyword\">int</span> (*)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>))[target methodForSelector:<span class=\"keyword\">@selector</span>(doComputeWithNum:)];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//execute the C function pointer returned by the runtime</span></span><br><span class=\"line\">computeNum(obj,<span class=\"keyword\">@selector</span>(doComputeWithNum:),aNum);</span><br></pre></td></tr></table></figure>\n<p>通过这个方法，你可以获取到在运行时直接获取该方法并调用它。甚至在你确认一个指定的方法需要被执行的时候可以绕过运行时机制。这也是Objective-C运行时如何调用你的方法的，但还是使用<code>objc_msgSend()</code>方法为好。</p>\n<h4 id=\"Objective-C-消息转发\"><a href=\"#Objective-C-消息转发\" class=\"headerlink\" title=\"Objective-C 消息转发\"></a>Objective-C 消息转发</h4><p>在Objective-C中，向一个根本不知道怎么响应方法的对象发送方法是合法的（也可能是该语言内部设计哲理）。Apple这样做的其中一个原因就是模拟Objective-C语言原生不支持的多重继承。或者你也许想抽象化自己的设计，隐藏该消息响应背后的其他类或者对象。这对于运行时系统也是非常必要的。它的工作流程大体是这样：</p>\n<ol>\n<li><p>运行时在该类或者其继承体系中的缓存中和派发表中查找，然后查找失败；</p>\n</li>\n<li><p>Objective-C运行时在所属对象的类上调用<code>+ (BOOL) resolveInstanceMethod:(SEL)aSEL</code>类方法，该类给予你一次机会来新增一个处理选择子<code>aSEL</code>的方法，然后告诉运行时你已经解决了该方法，消息转发机制会找到该方法。</p>\n</li>\n</ol>\n<p>如下示例，你定义了一个函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> fooMethod(<span class=\"keyword\">id</span> obj, SEL _cmd) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Doing Foo\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以使用<code>class_addMethod()</code>方法类解决它：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(aSEL == <span class=\"keyword\">@selector</span>(doFoo:)) &#123;</span><br><span class=\"line\">        class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],aSEL,(IMP)fooMethod,<span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中方法<code>class_addMethod()</code>中的<code>v@:</code>标明了方法的返回类型以及其参数类型。你可以在运行时文档中[Type Encodings][10]分查看到详细的说明。</p>\n<ol start=\"3\">\n<li>如果2中<code>+(BOOL)resolveInstanceMethod:(SEL)aSEL</code>返回NO表示无法解析该方法的话，运行时接着调用<code>- (id)forwardingTargetForSelector:(SEL) aSelector</code>来给你再一次机会是否能够将该消息转发给其他接收者来处理。这要比之后运行完整的消息转发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>要好。你可以这样执行：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(aSelector == <span class=\"keyword\">@selector</span>(mysteriousMethod:)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> alternateObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很明显，你肯定不想返回 self，否则会引起死循环。</p>\n<ol start=\"4\">\n<li>如果上一步没有找到合适的目标对象来执行上面的消息，接着运行时会尝试最后一步 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>。你可能没见过NSInvocation，它实际上是Objective-C语言中的消息类型。一旦你有一个NSInvocation，你基本上能够改变这个消息的任何东西，包括其目标、选择子以及参数。所以你可以这样做：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation &#123;</span><br><span class=\"line\">    SEL invSEL = invocation.selector;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>([altObject respondsToSelector:invSEL]) &#123;</span><br><span class=\"line\">        [invocation invokeWithTarget:altObject];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doesNotRecognizeSelector:invSEL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，如果你继承自NSObject类，它所实现的<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>内部仅仅简单的调用了<code>-doesNotRecognizeSelector:</code>方法，如果你想给自己最后一次机会做一些事情的话，你可以重载该方法。</p>\n<h4 id=\"Non-Fragile-ivars-Modern-Runtime\"><a href=\"#Non-Fragile-ivars-Modern-Runtime\" class=\"headerlink\" title=\"Non Fragile ivars (Modern Runtime)\"></a>Non Fragile ivars (Modern Runtime)</h4><p>一个Modern Runtime新增加的概念就是Non Fragile ivars。当编译器编译我们的类时，编译器会生成一个变量布局来显示每次我们从什么位置去取我们的实例变量，其底层的实现细节是这样的，查看类成员变量和类对象指针指向位置的偏移，读取该变量大小的字节就可以将该变量读取出来。所以你得变量布局可能如下所示，左侧列标明字节偏移量：</p>\n<p><img src=\"https://i.imgur.com/35waSjN.png\" alt=\"NSObject 布局\"></p>\n<p>这里我们有NSObject类型的变量布局，然后我们继承NSObject来扩展它，并添加自己的变量，这在Apple发布新版本OSX SDK之前都运行良好。</p>\n<p><img src=\"https://i.imgur.com/xPo1FAw.png\" alt=\"NSObject 布局\"></p>\n<p>我们的代码就无法正常运行，我们自定义对象中的内容被擦出了，因为NSObject增加了两个成员变量，而MyObject类成员变量布局在编译时已经确定，有两个成员变量和基类的内存区域重叠。唯一能够阻止这个发生的就是Apple维持它之前的布局策略，但是一旦这样他们的框架就无法再往前发展了，因为它们的变量布局已经固化了。在这种情况下（也就是fragile ivars）你只能通过重新编译这些继承自Apple类的类来使得代码得以兼容。那在 non fragile ivars下会发生什么呢？</p>\n<p><img src=\"https://i.imgur.com/w9Fxvpa.png\" alt=\"NSObject 布局\"></p>\n<p>在Non Fragile ivars下编译器虽然生成了和fragile ivars同样的布局，但是运行时会通过计算基类大小，动态调整MyObject类成员布局。结果如上图所示。</p>\n<h4 id=\"Objective-C-关联对象\"><a href=\"#Objective-C-关联对象\" class=\"headerlink\" title=\"Objective-C 关联对象\"></a>Objective-C 关联对象</h4><p>最近引入Mac OS X 10.6系统有一个特性称作“关联引用”。Objective-C不像其他语言，其原生不支持向对象动态添加变量。所以到目前为止，你都必须要费很大的劲，编译整个体系结构来假装自己向类中添加一个变量。不过在Mac OS X 10.6系统中，Objective-C 运行时原生支持（动态添加变量）。如果我们想向每一个已经存在的类中添加一个变量，例如向NSView类中添加，如下所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Cocoa/Cocoa.h&gt;</span> //Cocoa</span></span><br><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt; objc/runtime.h&gt;</span> //objc runtime api’s</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSImage</span> *customImage;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> img_key; <span class=\"comment\">//has a unique address (identifier)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">-(<span class=\"built_in\">NSImage</span> *)customImage &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setCustomImage:(<span class=\"built_in\">NSImage</span> *)image &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key,image,</span><br><span class=\"line\">                             OBJC_ASSOCIATION_RETAIN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>你可以在[runtime.h][11]，（译者注：最新版 [runtime.h][12]）文件中看到向<code>objc_setAssociatedObject()</code>传递的几个选项：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Associative References */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Policies related to associative references.</span></span><br><span class=\"line\"><span class=\"comment\"> * These are options to objc_setAssociatedObject()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,           <span class=\"comment\">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>, <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is not made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,   <span class=\"comment\">/**&lt; Specifies that the associated object is copied. </span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is not made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,       <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span>          <span class=\"comment\">/**&lt; Specifies that the associated object is copied.</span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is made atomically. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这些和你通过<code>@property</code>方式传递的选项相吻合。</p>\n<h4 id=\"混合的虚表派生\"><a href=\"#混合的虚表派生\" class=\"headerlink\" title=\"混合的虚表派生\"></a>混合的虚表派生</h4><p>如果你查看Modern runtime 代码，你会在<a href=\"\">objc-runtime-new.m</a>（译者注： 最新版objc runtime源码为[objc-runtime-new.mm][14] 已经去掉了这个特性，译者发现从[objc4-551.1][15]版本开始就不支持了，不过读者还是可以借鉴下之前版本的实现方式。）中发现这个：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">* vtable dispatch</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span></span><br><span class=\"line\"><span class=\"comment\">* The selectors represented in the vtable are the same for all classes</span></span><br><span class=\"line\"><span class=\"comment\">*   (i.e. no class has a bigger or smaller vtable).</span></span><br><span class=\"line\"><span class=\"comment\">* Each vtable index has an associated trampoline which dispatches to </span></span><br><span class=\"line\"><span class=\"comment\">*   the IMP at that index for the receiver class's vtable (after </span></span><br><span class=\"line\"><span class=\"comment\">*   checking for NULL). Dispatch fixup uses these trampolines instead </span></span><br><span class=\"line\"><span class=\"comment\">*   of objc_msgSend.</span></span><br><span class=\"line\"><span class=\"comment\">* Fragility: The vtable size and list of selectors is chosen at launch </span></span><br><span class=\"line\"><span class=\"comment\">*   time. No compiler-generated code depends on any particular vtable </span></span><br><span class=\"line\"><span class=\"comment\">*   configuration, or even the use of vtable dispatch at all.</span></span><br><span class=\"line\"><span class=\"comment\">* Memory size: If a class's vtable is identical to its superclass's </span></span><br><span class=\"line\"><span class=\"comment\">*   (i.e. the class overrides none of the vtable selectors), then </span></span><br><span class=\"line\"><span class=\"comment\">*   the class points directly to its superclass's vtable. This means </span></span><br><span class=\"line\"><span class=\"comment\">*   selectors to be included in the vtable should be chosen so they are </span></span><br><span class=\"line\"><span class=\"comment\">*   (1) frequently called, but (2) not too frequently overridden. In </span></span><br><span class=\"line\"><span class=\"comment\">*   particular, -dealloc is a bad choice.</span></span><br><span class=\"line\"><span class=\"comment\">* Forwarding: If a class doesn't implement some vtable selector, that </span></span><br><span class=\"line\"><span class=\"comment\">*   selector's IMP is set to objc_msgSend in that class's vtable.</span></span><br><span class=\"line\"><span class=\"comment\">* +initialize: Each class keeps the default vtable (which always </span></span><br><span class=\"line\"><span class=\"comment\">*   redirects to objc_msgSend) until its +initialize is completed.</span></span><br><span class=\"line\"><span class=\"comment\">*   Otherwise, the first message to a class could be a vtable dispatch, </span></span><br><span class=\"line\"><span class=\"comment\">*   and the vtable trampoline doesn't include +initialize checking.</span></span><br><span class=\"line\"><span class=\"comment\">* Changes: Categories, addMethod, and setImplementation all force vtable </span></span><br><span class=\"line\"><span class=\"comment\">*   reconstruction for the class and all of its subclasses, if the </span></span><br><span class=\"line\"><span class=\"comment\">*   vtable selectors are affected.</span></span><br><span class=\"line\"><span class=\"comment\">**********************************************************************/</span></span><br></pre></td></tr></table></figure>\n<p>这背后的原理就是，运行时试图去存储你最近调用过的选择子（selector）以便能够为你的App加速，因为其比<code>objc_msgSend</code>方法使用更少的指令。这个<code>vTable</code>存储你最近全局调用的16个选择子，实际上，在代码文件往下接着看你就会看到垃圾回收和非垃圾回收类型的App的默认选择子（selectors）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtable[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"alloc\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"class\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"self\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"length\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"count\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"retain\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"release\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"autorelease\"</span>, </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtableGC[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"alloc\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"class\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"self\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"length\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"count\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"hash\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"addObject:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"countByEnumeratingWithState:objects:count:\"</span>, </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"因此你如何能知道你正在和它打交道呢？\"><a href=\"#因此你如何能知道你正在和它打交道呢？\" class=\"headerlink\" title=\"因此你如何能知道你正在和它打交道呢？\"></a>因此你如何能知道你正在和它打交道呢？</h4><p>当你进行调试的时候，你会在你的调试栈中看到稍后讲解到的某些方法的身影。你就把这些方法按照<code>objc_msgSend()</code>方法来对待就行，不过这些方法都是为了调试，具体有如下几个方法。</p>\n<ol>\n<li><p>当运行时正在将你所有调用的这些方法中的其中一个插入到虚表（vTable）中时，会调用<code>objc_msgSend_fixup</code>。</p>\n</li>\n<li><p>而当<code>objc_msgSend_fixedup</code>发生时，表明你当前所调用的一个方法本应该存在于虚表中<code>objc_msgSend_vtable[0-15]</code>的位置，但却并不在</p>\n</li>\n<li><p>你可能会看到<code>objc_msgSend_vtable5</code>类似的东西，其意味着你正在调用虚表中的一个方法。运行时可以根据需要动态调整虚表中的内容。因此你不应该期望这次代码循环调用的<code>objc_msgSend_vtable10</code>对应了<code>-length</code>方法，而之后每次代码循环还依然会这样。（因为vTable也在不断变化中）</p>\n</li>\n</ol>\n<p>译者注：参考<a href=\"http://www.sealiesoftware.com/blog/archive/2011/06/17/objc\\_explain\\_objc\\_msgSend\\_vtable.html\" target=\"_blank\" rel=\"noopener\">[objc explain]: objc_msgSend_vtable</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>我希望你们能够喜欢以上这些东西，这篇文章主要讲述了我和Des Moines Cocoaheads关于Objective-C runtime的谈话（我们的讨论估计能打包一箩筐）。Objective-C Runtime是一项很了不起的工程，它为我们Cocoa/Objective-C下制作的Apps注入能量，使得我们能够实现很多我们认为理所当然的特性。希望你能够看一看Apple官方文档对Objective-C运行时的讲解，这样能够使你更好的利用Objective-C运行时。谢谢。</p>\n<h4 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h4><p><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime Programming Guide</a><br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime Reference</a></p>\n","site":{"data":{"melody":{"language":"en","menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":null},"highlight_theme":"pale night","social":{"github":"https://github.com/hechen","twitter":"https://twitter.com/OgreMergO","weibo":"https://weibo.com/hc2feifei"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":false,"cdn":"https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":"b8b088e1ebab51ca1f8e3c11ac0476a1","google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200","top_img":true,"post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":100},"code_word_wrap":true,"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":true},"sharejs":{"enable":true,"disabled_sites":null},"disqus":{"enable":true,"shortname":"stoneman","count":true},"since":2014,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"rootConfig":{"title":"Writing, Thinking and Coding.","subtitle":null,"description":"I do stuff.","author":"Chen","language":"en","timezone":null,"url":"http://hechen.xyz","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"melody","deploy":{"type":"git","repo":"https://github.com/hechen/hechen.github.io","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"autoprefixer":{"exclude":["*.min.css"]},"hfc_useref":{"enable":true,"exclude":[],"concat":true},"hfc_html":{"enable":true,"exclude":[],"ignoreCustomComments":[{}],"removeComments":true,"removeCommentsFromCDATA":true,"collapseWhitespace":true,"collapseBooleanAttributes":true,"removeEmptyAttributes":true,"minifyJS":true,"minifyCSS":true},"hfc_css":{"enable":true,"exclude":["*.min.css"]},"hfc_js":{"enable":true,"mangle":true,"output":{},"compress":{},"exclude":["*.min.js"]},"hfc_img":{"enable":true,"exclude":[],"interlaced":false,"multipass":false,"optimizationLevel":3,"pngquant":false,"webp":true,"webpQuality":75,"gifslice":true,"jpegtran":true,"jpegrecompress":false,"jpegrecompressQuality":"medium","optipng":true,"svgo":true,"progressive":false},"hfc_favicons":{"enable":true,"src":"img/logo.png","target":"img/","icons":{"android":true,"appleIcon":true,"appleStartup":false,"coast":false,"favicons":true,"firefox":false,"opengraph":false,"windows":true,"yandex":false}},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}}}}},"excerpt":"<blockquote>\n<p>翻译自：<a href=\"https://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html\" target=\"_blank\" rel=\"noopener\">Understanding the Objective-C Runtime</a><br>译者： <a href=\"http://weibo.com/hc2feifei\" target=\"_blank\" rel=\"noopener\">@这个昵称有点萌</a></p>\n</blockquote>\n<p>Objective-C 运行时对于刚刚踏入 Cocoa/Objective 世界的人是很容易忽<br>略的 Objective-C 语言的特性之一。原因就是尽管 Objective-C 是一门几个小时之内入门的语言，但是投身 Cocoa 的新手们会花费大量时间在 Cocoa 框架中，试图搞清楚他到底是怎么工作的。","more":"我觉得每个开发者都应该对其有深入的了解，明白一些内部的实现细节，而不仅仅只知道代码 <code>[target doMethodWith:var]</code> 会被编译器转换成 <code>objc_msgSend(target,@selector(doMethodWith:),var1);</code> 而已。了解 Objective-C 运行时的原理有助于你对 Objective-C 语言有更深入的理解，清楚你得 App 是怎么运行的。我觉得这对无论是 Mac/iPhone 新手或者老手都会有所帮助。</p>\n<p>[TOC]</p>\n<h4 id=\"Objective-C运行时是开源的\"><a href=\"#Objective-C运行时是开源的\" class=\"headerlink\" title=\"Objective-C运行时是开源的\"></a>Objective-C运行时是开源的</h4><p>Objective-C 运行时是开源的，你可以随时从 <a href=\"http://opensource.apple.com\" target=\"_blank\" rel=\"noopener\">Apple</a> 获取到。实际上查看 Objective-C 运行时源码是我搞清楚这个语言是怎么运作的首选方法，而不是去查看和它相关的苹果文档。你可以到<a href=\"http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz\" target=\"_blank\" rel=\"noopener\">这里</a> 下载到运行时的源码（截止到译者翻译的时候，最新版本的文件是objc4-647.tar.gz）。</p>\n<h4 id=\"动态-Vs-静态\"><a href=\"#动态-Vs-静态\" class=\"headerlink\" title=\"动态 Vs. 静态\"></a>动态 Vs. 静态</h4><p>Objective-C 是一门动态的面向对象语言，这意味着它可以将编译链接时决定的事情推迟到运行时进行。这就给了你很大的灵活性，你可以按照自己的需要重定向消息到适当的对象上，你甚至可以交换方法实现（译者注：method swizzling，方法调配，开发者常用此技术向原有实现中添加新功能）。而运行时可以使对象明白自己可以响应哪些消息，不能响应哪些消息（译者注：introspect 内省），并正确的派发消息。</p>\n<blockquote>\n<p>译者注： 内省（introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。</p>\n<p>参考: <a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Introspection/Introspection.html\" target=\"_blank\" rel=\"noopener\">Objective-C 的 Introspection</a></p>\n</blockquote>\n<p>我们将这些特征和C语言进行对比来看，在C中，你从<code>main()</code>函数开始，然后按顺序从上往下写你的代码逻辑或者执行函数方法。C结构体是无法将请求转发到其他目标对象来执行方法的。你很可能写了如下类似的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt; stdio.h &gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> **argv[]) &#123;</span><br><span class=\"line\">    printf(<span class=\"string\">\"Hello World!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译器解析、优化然后将优化后的代码转换成如下的汇编语言：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text</span><br><span class=\"line\"> .align <span class=\"number\">4</span>,<span class=\"number\">0x90</span></span><br><span class=\"line\"> .globl _main</span><br><span class=\"line\">_main:</span><br><span class=\"line\">Leh_func_begin1:</span><br><span class=\"line\"> pushq %rbp</span><br><span class=\"line\">Llabel1:</span><br><span class=\"line\"> movq %rsp, %rbp</span><br><span class=\"line\">Llabel2:</span><br><span class=\"line\"> subq $<span class=\"number\">16</span>, %rsp</span><br><span class=\"line\">Llabel3:</span><br><span class=\"line\"> movq %rsi, %rax</span><br><span class=\"line\"> movl %edi, %ecx</span><br><span class=\"line\"> movl %ecx, <span class=\"number\">-8</span>(%rbp)</span><br><span class=\"line\"> movq %rax, <span class=\"number\">-16</span>(%rbp)</span><br><span class=\"line\"> xorb %al, %al</span><br><span class=\"line\"> leaq LC(%rip), %rcx</span><br><span class=\"line\"> movq %rcx, %rdi</span><br><span class=\"line\"> call _printf</span><br><span class=\"line\"> movl $<span class=\"number\">0</span>, <span class=\"number\">-4</span>(%rbp)</span><br><span class=\"line\"> movl <span class=\"number\">-4</span>(%rbp), %eax</span><br><span class=\"line\"> addq $<span class=\"number\">16</span>, %rsp</span><br><span class=\"line\"> popq %rbp</span><br><span class=\"line\"> ret</span><br><span class=\"line\">Leh_func_end1:</span><br><span class=\"line\"> .cstring</span><br><span class=\"line\">LC:</span><br><span class=\"line\"> .asciz <span class=\"string\">\"Hello World!\"</span></span><br></pre></td></tr></table></figure>\n<p>然后将其和C库链接生成可执行文件。相比之下，Objective-C语言整个过程和上面类似，不过代码的产生依赖Objective-C运行时的具体表现（译者注：运行时按照不同情况，生成不同的代码吧）。当我们刚接触Objective-C语言的时候，我们可能被告知像如下代码</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> doSomethingWithVar:var1];</span><br></pre></td></tr></table></figure>\n<p>会被转换成</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>,<span class=\"keyword\">@selector</span>(doSomethingWithVar:),var1);</span><br></pre></td></tr></table></figure>\n<p>而除了这些，我们似乎就不清楚运行时还干了什么。</p>\n<h4 id=\"什么是-Objective-C-运行时？\"><a href=\"#什么是-Objective-C-运行时？\" class=\"headerlink\" title=\"什么是 Objective-C 运行时？\"></a>什么是 Objective-C 运行时？</h4><p>Objective-C Runtime 是一个运行时库，主要是由C语言和汇编语言写成，为 C 语言添加面向对象的能力而创造了 Objective-C（译者注：正是 OC Runtime，才有 OC 这门语言）。这意味着它可以加载类信息，进行方法派发以及方法转发等等。Objective-C 运行时最重要的就是为Objective-C语言的面向对象特性的实现提供了所有的基础支撑。</p>\n<h4 id=\"Objective-C-运行时术语\"><a href=\"#Objective-C-运行时术语\" class=\"headerlink\" title=\"Objective-C 运行时术语\"></a>Objective-C 运行时术语</h4><p>在我们进一步了解整个运行时之前，需要先了解一些接下来出现的术语。截至目前Mac和iPhone的开发者关心的有两个运行时：Modern Runtime &amp; Legacy Runtime 。前者覆盖所有64位Mac OS X 的app和所有的iOS app，后者覆盖其余的（全部的Mac OS X 32位 App）。关于方法，这里有两种基本类型的方法，一种是实例方法（’-‘开头， 例如<code>-(void)doFoo</code>，作用于对象实例），另一种是类方法（’+’开头，例如<code>+(id)alloc</code>）。方法就像C语言中的函数类似，一段代码完成一个小的任务，如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)movieTitle &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">@\"Futurama: Into the Wild Green Yonder\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Selector</strong><br>Objective-C中的Selector（选择子）是一个重要的C数据结构，用以标识你要一个对象执行的Objective-C方法。在运行时中，Selector的定义应该和下面这样类似：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_selector  *SEL;</span><br></pre></td></tr></table></figure>\n<p>用法就像下面这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">SEL aSel = <span class=\"keyword\">@selector</span>(movieTitle);</span><br></pre></td></tr></table></figure>\n<p><strong>Message</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[target getMovieTitleForObject:obj];</span><br></pre></td></tr></table></figure>\n<p>Objective-C中的方法由两个方括号[]组成，括号中间是你将要将消息发往的目标对象和你将要该对象执行的方法以及所需要发送的参数列表。Objective-C中的消息和C函数类似，但是又不同。你向一个对象发送消息并不意味着该对象就一定会执行它。这个对象会检查该消息的发送者，然后基于该发送者要么执行一个不同的方法或者将该消息转发给另外的不同的对象。</p>\n<p><strong>Class</strong><br>如果你看过Runtime中关于类的定义信息，你可能会遇到这样的定义：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">&#125; *<span class=\"keyword\">id</span>;</span><br></pre></td></tr></table></figure>\n<p>这其中有一些事情要注意。<br>每一个Objective-C类拥有一个结构体，每一个对象也有一个结构体。所有的对象都包含一个isa指针。所有的Objective-C运行时需要这个isa指针，用以检查一个对象具体的类型是什么，然后判别其是否能够响应你所派发过来的消息。<br>最后我们还注意到了id指针，这个id指针仅仅告诉我们其指向的是Objective-C对象，仅此而已。当你拥有一个id指针，你可以查询该对象的类型，然后查看该类型是否可以响应某个方法等等。还有就是当你知道了当前所指向的具体对象的具体类别，你就可以做出更具体的动作。</p>\n<p><strong>Blocks</strong> </p>\n<p>你也可以在LLVM/Clang文档中对Blocks 的定义中发现和上面类似的东西。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> Block_literal_1 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *isa; <span class=\"comment\">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> reserved; </span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*invoke)(<span class=\"keyword\">void</span> *, ...);</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> Block_descriptor_1 &#123;</span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> reserved; <span class=\"comment\">// NULL</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> size;  <span class=\"comment\">// sizeof(struct Block_literal_1)</span></span><br><span class=\"line\">         <span class=\"comment\">// optional helper functions</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> (*copy_helper)(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> *src);</span><br><span class=\"line\">         <span class=\"keyword\">void</span> (*dispose_helper)(<span class=\"keyword\">void</span> *src); </span><br><span class=\"line\">    &#125; *descriptor;</span><br><span class=\"line\">    <span class=\"comment\">// imported variables</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Blocks被设计成能够与Objective-C运行时兼容，因此它们可以被当做对象处理，并可以响应消息（像<code>-retain</code>, <code>-release</code>, <code>-copy</code>等）。</p>\n<p><strong>IMP</strong>（Method Implementations）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">id</span> (*IMP)(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL _cmd,...);</span><br></pre></td></tr></table></figure>\n<p>IMP是编译器生成的函数指针，指向方法执行处。如果你刚接触Objective-C语言，你不需要直接和这些东西打交道，但是慢慢深入之后接触的就多了。后面我们会看到这也是Objective-C运行时唤醒方法的方式。</p>\n<p><strong>Objective-C Classes</strong> </p>\n<p>Objective-C 的类内部有些什么东西呢？一个Objective-C的类的样子大体如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyClass</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// vars</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// methods</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)doFoo;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>但是运行时还会追加更多的内容以便跟踪（类每一时刻的状态）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到一个类中包含一个指向其父类的引用，该类的名字、实例变量、方法集合、缓存以及该类遵循的协议列表。运行时需要这些信息以便响应那些分发到该类或者类实例对象上得方法。</p>\n<h4 id=\"因此类定义了对象而不是对象本身，那这又是如何实现的？\"><a href=\"#因此类定义了对象而不是对象本身，那这又是如何实现的？\" class=\"headerlink\" title=\"因此类定义了对象而不是对象本身，那这又是如何实现的？\"></a>因此类定义了对象而不是对象本身，那这又是如何实现的？</h4><p>正如我前面说过的，Objective-C类本身也同样是对象（译者注：意味着你可以向一个类发送消息），运行时通过创建元类来处理它们。当你发送类似<code>[NSObject alloc]</code>的消息时，你实际上是向类对象发送了消息，而这个类对象需要是<strong>元类</strong>的实例，而元类本身又是<strong>根元类</strong>的一个实例。<br>当你说一个类继承自NSObject，那就意味着你的类指向NSObject作为其父类。而所有的元类指向根元类作为它们的父类，所有的元类都仅包含那些它能够响应的消息中的类方法。所以当你向一个类对象发送消息，例如<code>[NSObject alloc]</code>的时候，<code>objc_msgSend()</code>实际上会查看元类来确定该对象是否能够响应该消息，那如果找到了一个能响应该消息的方法，就在该对象上执行它。</p>\n<blockquote>\n<p>译者注：Objective-C类体系结构图如下所示：<img src=\"https://i.imgur.com/D7GUGKB.png\" alt=\"ios-runtime-class\"></p>\n</blockquote>\n<h4 id=\"为什么我们都要继承自Apple的类呢？\"><a href=\"#为什么我们都要继承自Apple的类呢？\" class=\"headerlink\" title=\"为什么我们都要继承自Apple的类呢？\"></a>为什么我们都要继承自Apple的类呢？</h4><p>当你刚踏入Cocoa开发的时候，很多代码例子都告诉你这样做：先继承NSObject类然后再进行其他编码。你也乐在其中，确实享受到了很多继承自Apple类所提供的便利。但是你甚至可能都没有发现实际上你的类在和Objective-C运行时打交道。当你为我们的类实例化的时候，像这样：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyObject *object = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure>\n<p>第一个你要执行的消息就是<code>+alloc</code>。如果你[查看文档][6]，里面会讲到“一个新生实例的isa实例会被初始化为一个描述该类信息的数据结构，其余的实例变量的内存均被设置为空。”所以通过继承自Apple的类，我们不仅继承了一些很棒的属性，同时也继承了这些在内存上分配空间（大小是我们类的大小），创建对象的能力（就是创建运行时所期望的带有isa指针的数据结构）。</p>\n<h4 id=\"类缓存（objc-cache-cache）是什么？\"><a href=\"#类缓存（objc-cache-cache）是什么？\" class=\"headerlink\" title=\"类缓存（objc_cache* cache）是什么？\"></a>类缓存（objc_cache* cache）是什么？</h4><p>当Objective-C运行时通过一个对象的isa指针检查对象的时候，它会找到能够执行很多方法的类。然后你只需要调用其中很小一部分，所以每次运行时在进行一次查询动作时需要查找类分发表中所有的selectors这个动作是毫无意义的。这就是为什么类会由cache这个东西，当你查询一个类体系中的派发表的时候，一旦找到对应的selector时，就将该selector放到cache中。当<code>objc_msgSend()</code>方法在一个类中查询selector时，会先在cache中查找，这个理论的基础就是如果你曾经调用过一个类的消息，你有很大可能在之后还调用同样的方法。（译者注：CACHE的局部性原理）。所以按照这样考虑，如果我们先在有一个NSObject的子类MyObject如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyObject *obj = [[MyObject alloc] init];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></span><br><span class=\"line\">-(<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setVarA:@”blah”];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>具体发生了以下几点：</p>\n<ol>\n<li><code>[MyObject alloc]</code>首先被执行，MyObject类没有实现该方法，因此在该类中没有找到<code>+alloc</code>方法，接着顺着superclass指针找到其父类<code>NSObject</code>；</li>\n<li>我们询问<code>NSObject</code>类是否能够响应<code>+alloc</code>方法，而它能够响应。<code>+alloc</code>方法检查接受者类（也就是<code>MyObject</code>），分配该类大小的一块内存空间，然后初始化其isa指针指向<code>MyObject</code>类，此时我们拥有一个实例了，同时稍早我们将<code>+alloc</code>方法放置于<code>NSObject</code>的类缓存（cache）中；</li>\n<li>到目前为止，我们都是在发送类方法，此刻我们需要向一个实例对象发送消息，这里简单的调用<code>-init</code>方法或者指定初始化方法（designated initializer），当然我们的类实现了该方法，因此我们将<code>-(id)init</code>方法放置于cache中；</li>\n<li>接下来<code>self = [super init]</code>被调用，<code>super</code>是一个神奇的关键字（<strong>magic keyword</strong>），其指向类的父类，也即<code>NSObject</code>，我们调用<code>NSObject</code>的<code>init</code>方法。这样做的目的是为了确保面向对象编程的集成体系能够正确运行，在你正确初始化自身变量之前需要先初始化该类的所有父类的变量，如果你需要，你还可以覆写父类的方法。在该例中，对于NSObject类来说并没有多少特别重要的操作要进行，不过这并不是常态。有时候初始化中会做非常重要的事情，考虑以下代码：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyObject</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *aString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSString</span> *aString;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyObject</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">      [<span class=\"keyword\">self</span> setAString:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@synthesize</span> aString;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> main (<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAutoreleasePool</span> * pool = [[<span class=\"built_in\">NSAutoreleasePool</span> alloc] init];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj1 = [<span class=\"built_in\">NSMutableArray</span> alloc];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj2 = [[<span class=\"built_in\">NSMutableArray</span> alloc] init];</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj3 = [<span class=\"built_in\">NSArray</span> alloc];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj4 = [[<span class=\"built_in\">NSArray</span> alloc] initWithObjects:<span class=\"string\">@\"Hello\"</span>,<span class=\"literal\">nil</span>];</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj1 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj1 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj2 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj2 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj3 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj3 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj4 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj4 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj5 = [MyObject alloc];</span><br><span class=\"line\">    <span class=\"keyword\">id</span> obj6 = [[MyObject alloc] init];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj5 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj5 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"obj6 class is %@\"</span>,<span class=\"built_in\">NSStringFromClass</span>([obj6 <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">          </span><br><span class=\"line\">    [pool drain];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你是刚刚接触Cocoa，我让你猜以上代码打印结果是什么，你很可能会给出这样的结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableArray</span> </span><br><span class=\"line\"><span class=\"built_in\">NSArray</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span></span><br><span class=\"line\">MyObject</span><br><span class=\"line\">MyObject</span><br></pre></td></tr></table></figure>\n<p>但实际上是如下结果：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">obj1 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\">obj2 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></span><br><span class=\"line\">obj3 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\">obj4 <span class=\"keyword\">class</span> is <span class=\"built_in\">NSCFArray</span></span><br><span class=\"line\">obj5 <span class=\"keyword\">class</span> is MyObject</span><br><span class=\"line\">obj6 <span class=\"keyword\">class</span> is MyObject</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>译者注：（本机XCode 7 beta6 运行结果如下：）</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">06.922</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj1 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">11.201</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj2 <span class=\"keyword\">class</span> is __NSArrayM</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">17.987</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj3 <span class=\"keyword\">class</span> is __NSPlaceholderArray</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">18.503</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj4 <span class=\"keyword\">class</span> is __NSArrayI</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">32.228</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj5 <span class=\"keyword\">class</span> is MyObject</span><br><span class=\"line\"><span class=\"number\">2015</span><span class=\"number\">-09</span><span class=\"number\">-07</span> <span class=\"number\">13</span>:<span class=\"number\">43</span>:<span class=\"number\">33.478</span> ObjMessage[<span class=\"number\">5185</span>:<span class=\"number\">1441448</span>] obj6 <span class=\"keyword\">class</span> is MyObject</span><br></pre></td></tr></table></figure>\n<p>原因就是Objective-C语言这里使用<code>+alloc</code>方法返回某个类的对象，但随后<code>-init</code>方法又可能返回另一个类的对象。</p>\n<h4 id=\"那-objc-msgSend-方法都发生了什么呢？\"><a href=\"#那-objc-msgSend-方法都发生了什么呢？\" class=\"headerlink\" title=\"那 objc_msgSend 方法都发生了什么呢？\"></a>那 objc_msgSend 方法都发生了什么呢？</h4><p>实际上<code>objc_msgSend()</code>方法内部发生了许多事情。如下我们有这样的代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span> printMessageWithString:<span class=\"string\">@\"Hello World!\"</span>];</span><br></pre></td></tr></table></figure>\n<p>编译器会把其翻译成如下所示代码：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">objc_msgSend(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(printMessageWithString:), <span class=\"string\">@\"Hello World!\"</span>);</span><br></pre></td></tr></table></figure>\n<p>我们通过目标对象的isa指针来查询该类或者其继承体系中的父类是否能够响应 <code>@selector(printMessageWithString:)</code>。假设我们在类的派发表或者它的cache中找到了该selector，然后我们通过该函数指针来执行该方法。因此我们可以了解<code>objc_msgSend()</code>方法永远不会返回，它从执行开始，通过指针查找到你的方法执行，然后是你的方法执行之后返回，因此看起来好像<code>objc_msgSend()</code>方法返回似的。Bill Bumgarner对此过程有更多的细节探索（<a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map\" target=\"_blank\" rel=\"noopener\">Part 1</a>, <a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path\" target=\"_blank\" rel=\"noopener\">Part 2</a> &amp; <a href=\"http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage\" target=\"_blank\" rel=\"noopener\">Part 3</a>）。</p>\n<p>我这里总结下他所讲的，也就是你会在运行时代码中看到的：</p>\n<ol>\n<li><p>检查那些忽略掉的Selectors和Short Circut， 很明显如果我们运行在垃圾回收环境下，我们可以忽略掉针对<code>-retain</code>，<code>-release</code>等的调用；</p>\n</li>\n<li><p>检查那些nil的目标。不像其他语言，Objective-C中向nil派发消息是合法的。当然你肯定也有很多理由希望这样。这里假设我们有一个非空的目标；</p>\n</li>\n<li><p>接下来我们需要在该类中找到IMP，我们首先查找该类的缓存（cache），如果找到我们便通过缓存中的指针跳转到该函数执行处；</p>\n</li>\n<li><p>如果缓存中没有找到该IMP，我们便紧接着查找类的派发表（dispatch table），如果找到同样跳转到函数执行处；</p>\n</li>\n<li><p>如果类的派发表中也未找到我们就需要触发消息分发机制了，这意味着最终你得代码会被编译器转换成了C函数。因此一个如下方法：</p>\n</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">int</span>)doComputeWithNum:(<span class=\"keyword\">int</span>)aNum</span><br></pre></td></tr></table></figure>\n<p>会被转换成如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> aClass_doComputeWithNum(aClass *<span class=\"keyword\">self</span>,SEL _cmd,<span class=\"keyword\">int</span> aNum)</span><br></pre></td></tr></table></figure>\n<p>Objective-C运行时通过触发指向这些方法的函数指针来调用你的方法。告诉你，你没法直接调用这些转换之后的方法，尽管Cocoa框架确实提供了能够获取这些指针的方法。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//declare C function pointer</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (computeNum *)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//methodForSelector is COCOA &amp; not ObjC Runtime</span></span><br><span class=\"line\"><span class=\"comment\">//gets the same function pointer objc_msgSend gets</span></span><br><span class=\"line\">computeNum = (<span class=\"keyword\">int</span> (*)(<span class=\"keyword\">id</span>,SEL,<span class=\"keyword\">int</span>))[target methodForSelector:<span class=\"keyword\">@selector</span>(doComputeWithNum:)];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//execute the C function pointer returned by the runtime</span></span><br><span class=\"line\">computeNum(obj,<span class=\"keyword\">@selector</span>(doComputeWithNum:),aNum);</span><br></pre></td></tr></table></figure>\n<p>通过这个方法，你可以获取到在运行时直接获取该方法并调用它。甚至在你确认一个指定的方法需要被执行的时候可以绕过运行时机制。这也是Objective-C运行时如何调用你的方法的，但还是使用<code>objc_msgSend()</code>方法为好。</p>\n<h4 id=\"Objective-C-消息转发\"><a href=\"#Objective-C-消息转发\" class=\"headerlink\" title=\"Objective-C 消息转发\"></a>Objective-C 消息转发</h4><p>在Objective-C中，向一个根本不知道怎么响应方法的对象发送方法是合法的（也可能是该语言内部设计哲理）。Apple这样做的其中一个原因就是模拟Objective-C语言原生不支持的多重继承。或者你也许想抽象化自己的设计，隐藏该消息响应背后的其他类或者对象。这对于运行时系统也是非常必要的。它的工作流程大体是这样：</p>\n<ol>\n<li><p>运行时在该类或者其继承体系中的缓存中和派发表中查找，然后查找失败；</p>\n</li>\n<li><p>Objective-C运行时在所属对象的类上调用<code>+ (BOOL) resolveInstanceMethod:(SEL)aSEL</code>类方法，该类给予你一次机会来新增一个处理选择子<code>aSEL</code>的方法，然后告诉运行时你已经解决了该方法，消息转发机制会找到该方法。</p>\n</li>\n</ol>\n<p>如下示例，你定义了一个函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> fooMethod(<span class=\"keyword\">id</span> obj, SEL _cmd) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Doing Foo\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以使用<code>class_addMethod()</code>方法类解决它：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">+(<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(aSEL == <span class=\"keyword\">@selector</span>(doFoo:)) &#123;</span><br><span class=\"line\">        class_addMethod([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>],aSEL,(IMP)fooMethod,<span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中方法<code>class_addMethod()</code>中的<code>v@:</code>标明了方法的返回类型以及其参数类型。你可以在运行时文档中[Type Encodings][10]分查看到详细的说明。</p>\n<ol start=\"3\">\n<li>如果2中<code>+(BOOL)resolveInstanceMethod:(SEL)aSEL</code>返回NO表示无法解析该方法的话，运行时接着调用<code>- (id)forwardingTargetForSelector:(SEL) aSelector</code>来给你再一次机会是否能够将该消息转发给其他接收者来处理。这要比之后运行完整的消息转发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>要好。你可以这样执行：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(aSelector == <span class=\"keyword\">@selector</span>(mysteriousMethod:)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> alternateObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很明显，你肯定不想返回 self，否则会引起死循环。</p>\n<ol start=\"4\">\n<li>如果上一步没有找到合适的目标对象来执行上面的消息，接着运行时会尝试最后一步 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>。你可能没见过NSInvocation，它实际上是Objective-C语言中的消息类型。一旦你有一个NSInvocation，你基本上能够改变这个消息的任何东西，包括其目标、选择子以及参数。所以你可以这样做：</li>\n</ol>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation &#123;</span><br><span class=\"line\">    SEL invSEL = invocation.selector;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span>([altObject respondsToSelector:invSEL]) &#123;</span><br><span class=\"line\">        [invocation invokeWithTarget:altObject];</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> doesNotRecognizeSelector:invSEL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，如果你继承自NSObject类，它所实现的<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>内部仅仅简单的调用了<code>-doesNotRecognizeSelector:</code>方法，如果你想给自己最后一次机会做一些事情的话，你可以重载该方法。</p>\n<h4 id=\"Non-Fragile-ivars-Modern-Runtime\"><a href=\"#Non-Fragile-ivars-Modern-Runtime\" class=\"headerlink\" title=\"Non Fragile ivars (Modern Runtime)\"></a>Non Fragile ivars (Modern Runtime)</h4><p>一个Modern Runtime新增加的概念就是Non Fragile ivars。当编译器编译我们的类时，编译器会生成一个变量布局来显示每次我们从什么位置去取我们的实例变量，其底层的实现细节是这样的，查看类成员变量和类对象指针指向位置的偏移，读取该变量大小的字节就可以将该变量读取出来。所以你得变量布局可能如下所示，左侧列标明字节偏移量：</p>\n<p><img src=\"https://i.imgur.com/35waSjN.png\" alt=\"NSObject 布局\"></p>\n<p>这里我们有NSObject类型的变量布局，然后我们继承NSObject来扩展它，并添加自己的变量，这在Apple发布新版本OSX SDK之前都运行良好。</p>\n<p><img src=\"https://i.imgur.com/xPo1FAw.png\" alt=\"NSObject 布局\"></p>\n<p>我们的代码就无法正常运行，我们自定义对象中的内容被擦出了，因为NSObject增加了两个成员变量，而MyObject类成员变量布局在编译时已经确定，有两个成员变量和基类的内存区域重叠。唯一能够阻止这个发生的就是Apple维持它之前的布局策略，但是一旦这样他们的框架就无法再往前发展了，因为它们的变量布局已经固化了。在这种情况下（也就是fragile ivars）你只能通过重新编译这些继承自Apple类的类来使得代码得以兼容。那在 non fragile ivars下会发生什么呢？</p>\n<p><img src=\"https://i.imgur.com/w9Fxvpa.png\" alt=\"NSObject 布局\"></p>\n<p>在Non Fragile ivars下编译器虽然生成了和fragile ivars同样的布局，但是运行时会通过计算基类大小，动态调整MyObject类成员布局。结果如上图所示。</p>\n<h4 id=\"Objective-C-关联对象\"><a href=\"#Objective-C-关联对象\" class=\"headerlink\" title=\"Objective-C 关联对象\"></a>Objective-C 关联对象</h4><p>最近引入Mac OS X 10.6系统有一个特性称作“关联引用”。Objective-C不像其他语言，其原生不支持向对象动态添加变量。所以到目前为止，你都必须要费很大的劲，编译整个体系结构来假装自己向类中添加一个变量。不过在Mac OS X 10.6系统中，Objective-C 运行时原生支持（动态添加变量）。如果我们想向每一个已经存在的类中添加一个变量，例如向NSView类中添加，如下所示：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt; Cocoa/Cocoa.h&gt;</span> //Cocoa</span></span><br><span class=\"line\"><span class=\"meta\">#include <span class=\"meta-string\">&lt; objc/runtime.h&gt;</span> //objc runtime api’s</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">retain</span>) <span class=\"built_in\">NSImage</span> *customImage;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSView</span> (<span class=\"title\">CustomAdditions</span>)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> img_key; <span class=\"comment\">//has a unique address (identifier)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">-(<span class=\"built_in\">NSImage</span> *)customImage &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setCustomImage:(<span class=\"built_in\">NSImage</span> *)image &#123;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>,&amp;img_key,image,</span><br><span class=\"line\">                             OBJC_ASSOCIATION_RETAIN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>你可以在[runtime.h][11]，（译者注：最新版 [runtime.h][12]）文件中看到向<code>objc_setAssociatedObject()</code>传递的几个选项：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Associative References */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Policies related to associative references.</span></span><br><span class=\"line\"><span class=\"comment\"> * These are options to objc_setAssociatedObject()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    OBJC_ASSOCIATION_ASSIGN = <span class=\"number\">0</span>,           <span class=\"comment\">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class=\"number\">1</span>, <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is not made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class=\"number\">3</span>,   <span class=\"comment\">/**&lt; Specifies that the associated object is copied. </span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is not made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN = <span class=\"number\">01401</span>,       <span class=\"comment\">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is made atomically. */</span></span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY = <span class=\"number\">01403</span>          <span class=\"comment\">/**&lt; Specifies that the associated object is copied.</span></span><br><span class=\"line\"><span class=\"comment\">                                            *   The association is made atomically. */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这些和你通过<code>@property</code>方式传递的选项相吻合。</p>\n<h4 id=\"混合的虚表派生\"><a href=\"#混合的虚表派生\" class=\"headerlink\" title=\"混合的虚表派生\"></a>混合的虚表派生</h4><p>如果你查看Modern runtime 代码，你会在<a href=\"\">objc-runtime-new.m</a>（译者注： 最新版objc runtime源码为[objc-runtime-new.mm][14] 已经去掉了这个特性，译者发现从[objc4-551.1][15]版本开始就不支持了，不过读者还是可以借鉴下之前版本的实现方式。）中发现这个：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">* vtable dispatch</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span></span><br><span class=\"line\"><span class=\"comment\">* The selectors represented in the vtable are the same for all classes</span></span><br><span class=\"line\"><span class=\"comment\">*   (i.e. no class has a bigger or smaller vtable).</span></span><br><span class=\"line\"><span class=\"comment\">* Each vtable index has an associated trampoline which dispatches to </span></span><br><span class=\"line\"><span class=\"comment\">*   the IMP at that index for the receiver class's vtable (after </span></span><br><span class=\"line\"><span class=\"comment\">*   checking for NULL). Dispatch fixup uses these trampolines instead </span></span><br><span class=\"line\"><span class=\"comment\">*   of objc_msgSend.</span></span><br><span class=\"line\"><span class=\"comment\">* Fragility: The vtable size and list of selectors is chosen at launch </span></span><br><span class=\"line\"><span class=\"comment\">*   time. No compiler-generated code depends on any particular vtable </span></span><br><span class=\"line\"><span class=\"comment\">*   configuration, or even the use of vtable dispatch at all.</span></span><br><span class=\"line\"><span class=\"comment\">* Memory size: If a class's vtable is identical to its superclass's </span></span><br><span class=\"line\"><span class=\"comment\">*   (i.e. the class overrides none of the vtable selectors), then </span></span><br><span class=\"line\"><span class=\"comment\">*   the class points directly to its superclass's vtable. This means </span></span><br><span class=\"line\"><span class=\"comment\">*   selectors to be included in the vtable should be chosen so they are </span></span><br><span class=\"line\"><span class=\"comment\">*   (1) frequently called, but (2) not too frequently overridden. In </span></span><br><span class=\"line\"><span class=\"comment\">*   particular, -dealloc is a bad choice.</span></span><br><span class=\"line\"><span class=\"comment\">* Forwarding: If a class doesn't implement some vtable selector, that </span></span><br><span class=\"line\"><span class=\"comment\">*   selector's IMP is set to objc_msgSend in that class's vtable.</span></span><br><span class=\"line\"><span class=\"comment\">* +initialize: Each class keeps the default vtable (which always </span></span><br><span class=\"line\"><span class=\"comment\">*   redirects to objc_msgSend) until its +initialize is completed.</span></span><br><span class=\"line\"><span class=\"comment\">*   Otherwise, the first message to a class could be a vtable dispatch, </span></span><br><span class=\"line\"><span class=\"comment\">*   and the vtable trampoline doesn't include +initialize checking.</span></span><br><span class=\"line\"><span class=\"comment\">* Changes: Categories, addMethod, and setImplementation all force vtable </span></span><br><span class=\"line\"><span class=\"comment\">*   reconstruction for the class and all of its subclasses, if the </span></span><br><span class=\"line\"><span class=\"comment\">*   vtable selectors are affected.</span></span><br><span class=\"line\"><span class=\"comment\">**********************************************************************/</span></span><br></pre></td></tr></table></figure>\n<p>这背后的原理就是，运行时试图去存储你最近调用过的选择子（selector）以便能够为你的App加速，因为其比<code>objc_msgSend</code>方法使用更少的指令。这个<code>vTable</code>存储你最近全局调用的16个选择子，实际上，在代码文件往下接着看你就会看到垃圾回收和非垃圾回收类型的App的默认选择子（selectors）。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtable[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"alloc\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"class\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"self\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"length\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"count\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"retain\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"release\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"autorelease\"</span>, </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * <span class=\"keyword\">const</span> defaultVtableGC[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"allocWithZone:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"alloc\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"class\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"self\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isKindOfClass:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"respondsToSelector:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isFlipped\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"length\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectForKey:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"count\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"objectAtIndex:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqualToString:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"isEqual:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"hash\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"addObject:\"</span>, </span><br><span class=\"line\">    <span class=\"string\">\"countByEnumeratingWithState:objects:count:\"</span>, </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"因此你如何能知道你正在和它打交道呢？\"><a href=\"#因此你如何能知道你正在和它打交道呢？\" class=\"headerlink\" title=\"因此你如何能知道你正在和它打交道呢？\"></a>因此你如何能知道你正在和它打交道呢？</h4><p>当你进行调试的时候，你会在你的调试栈中看到稍后讲解到的某些方法的身影。你就把这些方法按照<code>objc_msgSend()</code>方法来对待就行，不过这些方法都是为了调试，具体有如下几个方法。</p>\n<ol>\n<li><p>当运行时正在将你所有调用的这些方法中的其中一个插入到虚表（vTable）中时，会调用<code>objc_msgSend_fixup</code>。</p>\n</li>\n<li><p>而当<code>objc_msgSend_fixedup</code>发生时，表明你当前所调用的一个方法本应该存在于虚表中<code>objc_msgSend_vtable[0-15]</code>的位置，但却并不在</p>\n</li>\n<li><p>你可能会看到<code>objc_msgSend_vtable5</code>类似的东西，其意味着你正在调用虚表中的一个方法。运行时可以根据需要动态调整虚表中的内容。因此你不应该期望这次代码循环调用的<code>objc_msgSend_vtable10</code>对应了<code>-length</code>方法，而之后每次代码循环还依然会这样。（因为vTable也在不断变化中）</p>\n</li>\n</ol>\n<p>译者注：参考<a href=\"http://www.sealiesoftware.com/blog/archive/2011/06/17/objc\\_explain\\_objc\\_msgSend\\_vtable.html\" target=\"_blank\" rel=\"noopener\">[objc explain]: objc_msgSend_vtable</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>我希望你们能够喜欢以上这些东西，这篇文章主要讲述了我和Des Moines Cocoaheads关于Objective-C runtime的谈话（我们的讨论估计能打包一箩筐）。Objective-C Runtime是一项很了不起的工程，它为我们Cocoa/Objective-C下制作的Apps注入能量，使得我们能够实现很多我们认为理所当然的特性。希望你能够看一看Apple官方文档对Objective-C运行时的讲解，这样能够使你更好的利用Objective-C运行时。谢谢。</p>\n<h4 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h4><p><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime Programming Guide</a><br><a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html\" target=\"_blank\" rel=\"noopener\">Objective-C Runtime Reference</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjrk2frvs000179pozajyi0qb","category_id":"cjrk2frw5000579pozc49wox2","_id":"cjrk2frwo000g79pon1sfsfuu"},{"post_id":"cjrk2frw8000779pofbwiovgx","category_id":"cjrk2frwj000c79podb9wcsjc","_id":"cjrk2frws000l79poh9snvex0"},{"post_id":"cjrk2frwb000979pohnbykp94","category_id":"cjrk2frwo000h79pojbtcmgyb","_id":"cjrk2frww000q79po0t24uchr"},{"post_id":"cjrk2frwg000b79po1flp3481","category_id":"cjrk2frws000m79po9rz6ecl3","_id":"cjrk2frx0000x79pofjaxsxy2"},{"post_id":"cjrk2frwu000p79poubxwooz6","category_id":"cjrk2frw5000579pozc49wox2","_id":"cjrk2frx2001179po7pxyp0cm"},{"post_id":"cjrk2frwk000e79poc6x2wkuu","category_id":"cjrk2frww000r79po7tcpb5br","_id":"cjrk2frx5001679pobx4fq950"},{"post_id":"cjrk2frwn000f79polub0f8ul","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2frx9001d79pooxl6gdch"},{"post_id":"cjrk2frwp000j79poiqpo48wx","category_id":"cjrk2frx5001779poqpaa1ygn","_id":"cjrk2frxe001k79powdomi96b"},{"post_id":"cjrk2frwr000k79polfyz297w","category_id":"cjrk2frxa001e79pobgi0jc45","_id":"cjrk2frxj001q79poe8x4783i"},{"post_id":"cjrk2frwt000o79po9dgsvja1","category_id":"cjrk2frxa001e79pobgi0jc45","_id":"cjrk2frxj001t79pobr40lrqi"},{"post_id":"cjrk2frww000t79powqopfvoq","category_id":"cjrk2frxi001p79pokq56q9kx","_id":"cjrk2frxl001z79pogl76g2qg"},{"post_id":"cjrk2frwy000v79po4kz32kdu","category_id":"cjrk2frxi001p79pokq56q9kx","_id":"cjrk2frxm002279po64zm1tmu"},{"post_id":"cjrk2frx0000y79pod614pi6w","category_id":"cjrk2frxi001p79pokq56q9kx","_id":"cjrk2frxo002679poihzrdyfq"},{"post_id":"cjrk2frx3001379po1qwwmx56","category_id":"cjrk2frxi001p79pokq56q9kx","_id":"cjrk2frxq002b79povsyqdv28"},{"post_id":"cjrk2frx4001579povrnpzvf1","category_id":"cjrk2frxi001p79pokq56q9kx","_id":"cjrk2frxs002f79pog98cyznv"},{"post_id":"cjrk2frx6001a79podbyv2b75","category_id":"cjrk2frxi001p79pokq56q9kx","_id":"cjrk2frxt002h79poe2edi8m1"},{"post_id":"cjrk2frx8001c79poyolcnhis","category_id":"cjrk2frxs002e79powrrh7du0","_id":"cjrk2frxv002n79potcssm9xt"},{"post_id":"cjrk2frxa001h79powf6zts7f","category_id":"cjrk2frxi001p79pokq56q9kx","_id":"cjrk2frxv002r79poomav57g7"},{"post_id":"cjrk2frxc001j79poca5dmhd6","category_id":"cjrk2frxu002m79pot6j5f5az","_id":"cjrk2frxx002w79pomcjhl5ut"},{"post_id":"cjrk2frxf001o79poal6a5zb6","category_id":"cjrk2frxw002t79pomcngpw8m","_id":"cjrk2frxy003079pozlxc9lfx"},{"post_id":"cjrk2ftb5004579pow0vtm2vc","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftbf004c79pok2ab4z2p"},{"post_id":"cjrk2ftb8004679pom5252una","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftbh004f79pokjst2ifk"},{"post_id":"cjrk2ftbb004879podrr69o5v","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftbk004j79po64cqoyh2"},{"post_id":"cjrk2ftbe004b79ponhhil6l3","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftbn004m79pognte4g2d"},{"post_id":"cjrk2ftbg004e79pox2llc0kl","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftbr004p79poeleqqieh"},{"post_id":"cjrk2ftbi004h79po2sohtkxj","category_id":"cjrk2frxa001e79pobgi0jc45","_id":"cjrk2ftbu004u79poqpvtx0j0"},{"post_id":"cjrk2ftbn004o79pognji6y17","category_id":"cjrk2frxa001e79pobgi0jc45","_id":"cjrk2ftbz005079po8l3fbzvh"},{"post_id":"cjrk2ftbt004t79pokb7sn0ef","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftc1005279poyz22piqt"},{"post_id":"cjrk2ftbv004w79pohzr25buw","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftc2005679pork2sbga1"},{"post_id":"cjrk2ftbl004l79po4p9yrfm6","category_id":"cjrk2ftbs004r79po2ccza15r","_id":"cjrk2ftc3005879po8nlvs9id"},{"post_id":"cjrk2ftby004z79po8nt5gq3k","category_id":"cjrk2ftc2005379pocczo25t4","_id":"cjrk2ftc5005d79pohc5v8qfd"},{"post_id":"cjrk2ftcx006179poq5um46oo","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftd3006679ponbs1ari3"},{"post_id":"cjrk2ftcy006279po5f7dzvcq","category_id":"cjrk2frxa001e79pobgi0jc45","_id":"cjrk2ftd5006979pongciuszr"},{"post_id":"cjrk2ftd0006479pouikreom4","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftd6006c79poo6dxhgxj"},{"post_id":"cjrk2ftd2006579po5dh9pf1e","category_id":"cjrk2frxa001e79pobgi0jc45","_id":"cjrk2ftd7006e79po0jg1gixa"},{"post_id":"cjrk2ftd4006879poh4v8swx0","category_id":"cjrk2frxa001e79pobgi0jc45","_id":"cjrk2ftd8006h79poxeoq1quw"},{"post_id":"cjrk2ftlt006u79poaj9e6mrq","category_id":"cjrk2frx1000z79po1my5gt66","_id":"cjrk2ftlw006w79poxev2uiho"}],"PostTag":[{"post_id":"cjrk2frwu000p79poubxwooz6","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2frwy000u79pobb4mgh9j"},{"post_id":"cjrk2frwu000p79poubxwooz6","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2frx0000w79poksucv465"},{"post_id":"cjrk2frvs000179pozajyi0qb","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2frx2001279po8bbb2tri"},{"post_id":"cjrk2frvs000179pozajyi0qb","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2frx4001479pouddfimlf"},{"post_id":"cjrk2frvs000179pozajyi0qb","tag_id":"cjrk2frwo000i79pooh8p9tra","_id":"cjrk2frx6001979pooi83fei6"},{"post_id":"cjrk2frvs000179pozajyi0qb","tag_id":"cjrk2frwt000n79pob868u6xh","_id":"cjrk2frx8001b79pogjn7t0q0"},{"post_id":"cjrk2frvs000179pozajyi0qb","tag_id":"cjrk2frww000s79po4sxfiau4","_id":"cjrk2frxa001g79pob2hri2js"},{"post_id":"cjrk2frw0000379podqu03cf3","tag_id":"cjrk2frx1001079poor9bwiga","_id":"cjrk2frxc001i79po88hh6rtv"},{"post_id":"cjrk2frw8000779pofbwiovgx","tag_id":"cjrk2frx6001879popbelqghz","_id":"cjrk2frxf001n79pop2vuf33y"},{"post_id":"cjrk2frwb000979pohnbykp94","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2frxj001s79povcuois1f"},{"post_id":"cjrk2frwb000979pohnbykp94","tag_id":"cjrk2frxa001f79poea0g5zdh","_id":"cjrk2frxk001u79po8hae6bkj"},{"post_id":"cjrk2frwb000979pohnbykp94","tag_id":"cjrk2frxf001m79poixrgltz8","_id":"cjrk2frxl001x79poz6v3p3vn"},{"post_id":"cjrk2frwg000b79po1flp3481","tag_id":"cjrk2frxj001r79poxrvbtr6o","_id":"cjrk2frxo002479pof051regt"},{"post_id":"cjrk2frwg000b79po1flp3481","tag_id":"cjrk2frxk001w79povmnlvvif","_id":"cjrk2frxp002779pos8kvgwrr"},{"post_id":"cjrk2frwg000b79po1flp3481","tag_id":"cjrk2frxm002079poqx8psvfe","_id":"cjrk2frxq002979podt4gdv9d"},{"post_id":"cjrk2frwk000e79poc6x2wkuu","tag_id":"cjrk2frxn002379pou6vku24s","_id":"cjrk2frxr002c79po513qiqy7"},{"post_id":"cjrk2frwn000f79polub0f8ul","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2frxt002j79pofrqyxlu2"},{"post_id":"cjrk2frwn000f79polub0f8ul","tag_id":"cjrk2frxq002879pot5h0jqq5","_id":"cjrk2frxu002k79po97nbndw3"},{"post_id":"cjrk2frwn000f79polub0f8ul","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2frxv002o79poerz6rgf0"},{"post_id":"cjrk2frwn000f79polub0f8ul","tag_id":"cjrk2frxr002d79pohw6g17fs","_id":"cjrk2frxv002p79poh5o6ipjb"},{"post_id":"cjrk2frwp000j79poiqpo48wx","tag_id":"cjrk2frxs002g79po9nns9jl4","_id":"cjrk2frxv002s79pobuc6sygt"},{"post_id":"cjrk2frwp000j79poiqpo48wx","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2frxw002u79pohqy7kwy9"},{"post_id":"cjrk2frwr000k79polfyz297w","tag_id":"cjrk2frxu002l79po29n6yk4t","_id":"cjrk2frxx002x79pod27fimhs"},{"post_id":"cjrk2frwr000k79polfyz297w","tag_id":"cjrk2frxv002q79pou5s5sa03","_id":"cjrk2frxx002y79po5hogqcit"},{"post_id":"cjrk2frwt000o79po9dgsvja1","tag_id":"cjrk2frxx002v79pors2xzpvq","_id":"cjrk2frxy003179po4tjgevzw"},{"post_id":"cjrk2frww000t79powqopfvoq","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2frxz003479po7ca7xk71"},{"post_id":"cjrk2frww000t79powqopfvoq","tag_id":"cjrk2frxy003279po972u5npz","_id":"cjrk2frxz003579ponpdi21m6"},{"post_id":"cjrk2frwy000v79po4kz32kdu","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2fry1003879po2sknwcl4"},{"post_id":"cjrk2frwy000v79po4kz32kdu","tag_id":"cjrk2fry0003679pofwjyrl8d","_id":"cjrk2fry1003979polv6j67kt"},{"post_id":"cjrk2frx0000y79pod614pi6w","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2fry2003c79po20eewev9"},{"post_id":"cjrk2frx0000y79pod614pi6w","tag_id":"cjrk2fry1003a79potjv0kh0q","_id":"cjrk2fry2003d79po829ouv3e"},{"post_id":"cjrk2frx3001379po1qwwmx56","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2fry4003g79poxis2sein"},{"post_id":"cjrk2frx3001379po1qwwmx56","tag_id":"cjrk2frxy003279po972u5npz","_id":"cjrk2fry4003h79poi95ujv8k"},{"post_id":"cjrk2frx4001579povrnpzvf1","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2fry6003k79pozt62u44d"},{"post_id":"cjrk2frx4001579povrnpzvf1","tag_id":"cjrk2fry0003679pofwjyrl8d","_id":"cjrk2fry6003l79poz5aj0ixl"},{"post_id":"cjrk2frx6001a79podbyv2b75","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2fry7003o79po0dz9532x"},{"post_id":"cjrk2frx6001a79podbyv2b75","tag_id":"cjrk2fry0003679pofwjyrl8d","_id":"cjrk2fry7003p79polfw4nzat"},{"post_id":"cjrk2frx8001c79poyolcnhis","tag_id":"cjrk2fry7003n79poskwljni0","_id":"cjrk2fry9003s79po9p4gn7bb"},{"post_id":"cjrk2frx8001c79poyolcnhis","tag_id":"cjrk2fry8003q79po1jm5c47f","_id":"cjrk2fry9003t79pojgit8695"},{"post_id":"cjrk2frxa001h79powf6zts7f","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2frya003w79pobhqqwmeo"},{"post_id":"cjrk2frxa001h79powf6zts7f","tag_id":"cjrk2fry0003679pofwjyrl8d","_id":"cjrk2frya003x79pob9rcvks8"},{"post_id":"cjrk2frxc001j79poca5dmhd6","tag_id":"cjrk2frya003v79po7l8ymfms","_id":"cjrk2fryc004079pofgc9tdkx"},{"post_id":"cjrk2frxc001j79poca5dmhd6","tag_id":"cjrk2frxx002z79pov2rpd0os","_id":"cjrk2fryc004179poomxw1iue"},{"post_id":"cjrk2frxf001o79poal6a5zb6","tag_id":"cjrk2fryb003z79pot45zcqyp","_id":"cjrk2fryc004379pofrlbq6xx"},{"post_id":"cjrk2frxf001o79poal6a5zb6","tag_id":"cjrk2fryc004279poj9cm7oug","_id":"cjrk2fryd004479poxbwavo7h"},{"post_id":"cjrk2ftb5004579pow0vtm2vc","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftba004779polgcba3d9"},{"post_id":"cjrk2ftb5004579pow0vtm2vc","tag_id":"cjrk2frxq002879pot5h0jqq5","_id":"cjrk2ftbd004a79poiy01etxl"},{"post_id":"cjrk2ftb5004579pow0vtm2vc","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2ftbf004d79po1nrdiw3i"},{"post_id":"cjrk2ftb5004579pow0vtm2vc","tag_id":"cjrk2frxr002d79pohw6g17fs","_id":"cjrk2ftbi004g79pomdg6yeil"},{"post_id":"cjrk2ftbe004b79ponhhil6l3","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftbl004k79po64dx2ned"},{"post_id":"cjrk2ftbe004b79ponhhil6l3","tag_id":"cjrk2frxq002879pot5h0jqq5","_id":"cjrk2ftbn004n79podjb92im6"},{"post_id":"cjrk2ftbe004b79ponhhil6l3","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2ftbt004s79po2palk8a5"},{"post_id":"cjrk2ftb8004679pom5252una","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftbv004v79po1hd9v61d"},{"post_id":"cjrk2ftb8004679pom5252una","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2ftby004y79pomvgib3a2"},{"post_id":"cjrk2ftb8004679pom5252una","tag_id":"cjrk2ftbd004979pop71etvkb","_id":"cjrk2ftc0005179poht4azeem"},{"post_id":"cjrk2ftbb004879podrr69o5v","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftc2005579poynxnppqr"},{"post_id":"cjrk2ftbb004879podrr69o5v","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2ftc3005779pookzxws4b"},{"post_id":"cjrk2ftbb004879podrr69o5v","tag_id":"cjrk2ftbj004i79po0v8lsnp9","_id":"cjrk2ftc4005979po5hvpilgo"},{"post_id":"cjrk2ftbt004t79pokb7sn0ef","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftc4005b79podwq73rmu"},{"post_id":"cjrk2ftbt004t79pokb7sn0ef","tag_id":"cjrk2frxq002879pot5h0jqq5","_id":"cjrk2ftc5005c79pohvr98hfs"},{"post_id":"cjrk2ftbt004t79pokb7sn0ef","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2ftc5005f79poxirw0dgp"},{"post_id":"cjrk2ftbg004e79pox2llc0kl","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftc6005g79pod0y5f4m5"},{"post_id":"cjrk2ftbg004e79pox2llc0kl","tag_id":"cjrk2ftbs004q79poe79t923h","_id":"cjrk2ftc6005i79pognmpzj6n"},{"post_id":"cjrk2ftbg004e79pox2llc0kl","tag_id":"cjrk2frxf001m79poixrgltz8","_id":"cjrk2ftc7005j79poqq8hz8li"},{"post_id":"cjrk2ftbi004h79po2sohtkxj","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftc7005l79po7sibvcc3"},{"post_id":"cjrk2ftbi004h79po2sohtkxj","tag_id":"cjrk2ftbx004x79po4dcldbmm","_id":"cjrk2ftc8005m79po8m8ww9h2"},{"post_id":"cjrk2ftbi004h79po2sohtkxj","tag_id":"cjrk2ftc2005479pomux7wk4o","_id":"cjrk2ftc8005n79po13zbxgui"},{"post_id":"cjrk2ftbl004l79po4p9yrfm6","tag_id":"cjrk2ftc4005a79pocd8u1kno","_id":"cjrk2ftc9005p79poa63ntfjy"},{"post_id":"cjrk2ftbl004l79po4p9yrfm6","tag_id":"cjrk2ftc5005e79po37d82sxo","_id":"cjrk2ftc9005q79podahpjmax"},{"post_id":"cjrk2ftbn004o79pognji6y17","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftcb005s79po39q917jg"},{"post_id":"cjrk2ftbn004o79pognji6y17","tag_id":"cjrk2ftc6005h79pogrrvm5u4","_id":"cjrk2ftcc005t79po6ri5efn1"},{"post_id":"cjrk2ftbv004w79pohzr25buw","tag_id":"cjrk2ftc7005k79popsgghphd","_id":"cjrk2ftce005w79poe07ddjgf"},{"post_id":"cjrk2ftbv004w79pohzr25buw","tag_id":"cjrk2ftc8005o79pojac7x5i5","_id":"cjrk2ftcf005x79poezh1m9dr"},{"post_id":"cjrk2ftbv004w79pohzr25buw","tag_id":"cjrk2ftc9005r79pofrvbr92i","_id":"cjrk2ftcf005y79por31vx06c"},{"post_id":"cjrk2ftbv004w79pohzr25buw","tag_id":"cjrk2ftcc005u79pou970z8vv","_id":"cjrk2ftcf005z79pov1s0hrb0"},{"post_id":"cjrk2ftby004z79po8nt5gq3k","tag_id":"cjrk2ftcd005v79powk2tfsb9","_id":"cjrk2ftcg006079po0wb0xbon"},{"post_id":"cjrk2ftd0006479pouikreom4","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftd4006779posturmhck"},{"post_id":"cjrk2ftd0006479pouikreom4","tag_id":"cjrk2ftbs004q79poe79t923h","_id":"cjrk2ftd6006b79po3dca4tct"},{"post_id":"cjrk2ftd0006479pouikreom4","tag_id":"cjrk2frxf001m79poixrgltz8","_id":"cjrk2ftd7006d79poyfytt27g"},{"post_id":"cjrk2ftd0006479pouikreom4","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2ftd8006g79portm1l96d"},{"post_id":"cjrk2ftcx006179poq5um46oo","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftd9006i79poadanq8l8"},{"post_id":"cjrk2ftcx006179poq5um46oo","tag_id":"cjrk2frxq002879pot5h0jqq5","_id":"cjrk2ftd9006k79po4eqf7b7f"},{"post_id":"cjrk2ftcx006179poq5um46oo","tag_id":"cjrk2ftd0006379poy3gglz88","_id":"cjrk2ftd9006l79po95di7guw"},{"post_id":"cjrk2ftcx006179poq5um46oo","tag_id":"cjrk2ftd5006a79pow53pv999","_id":"cjrk2ftd9006m79po3qewd0ge"},{"post_id":"cjrk2ftcy006279po5f7dzvcq","tag_id":"cjrk2ftd7006f79po8w35h49s","_id":"cjrk2ftda006o79poj1afnxi3"},{"post_id":"cjrk2ftd2006579po5dh9pf1e","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftda006p79pow92bmoz6"},{"post_id":"cjrk2ftd2006579po5dh9pf1e","tag_id":"cjrk2ftd9006j79po580xqcjl","_id":"cjrk2ftdb006q79pok1v69l35"},{"post_id":"cjrk2ftd4006879poh4v8swx0","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftdb006r79poucj7gfsc"},{"post_id":"cjrk2ftd4006879poh4v8swx0","tag_id":"cjrk2frwj000d79poenpg4aal","_id":"cjrk2ftdb006s79pob75brbej"},{"post_id":"cjrk2ftd4006879poh4v8swx0","tag_id":"cjrk2ftd9006n79po4dyk6t9l","_id":"cjrk2ftdb006t79poee06ytvh"},{"post_id":"cjrk2ftlt006u79poaj9e6mrq","tag_id":"cjrk2frw7000679poenxpmj3e","_id":"cjrk2ftlx006x79pov8232h0z"},{"post_id":"cjrk2ftlt006u79poaj9e6mrq","tag_id":"cjrk2frxf001m79poixrgltz8","_id":"cjrk2ftlx006y79poqxnqy7bl"},{"post_id":"cjrk2ftlt006u79poaj9e6mrq","tag_id":"cjrk2ftlw006v79po4jynpjcf","_id":"cjrk2ftlx006z79pol9xtso0u"}],"Tag":[{"name":"iOS","_id":"cjrk2frw7000679poenxpmj3e"},{"name":"Swift","_id":"cjrk2frwj000d79poenpg4aal"},{"name":"Initializer","_id":"cjrk2frwo000i79pooh8p9tra"},{"name":"Designated Initializer","_id":"cjrk2frwt000n79pob868u6xh"},{"name":"Convenience Initializers","_id":"cjrk2frww000s79po4sxfiau4"},{"name":"感悟","_id":"cjrk2frx1001079poor9bwiga"},{"name":"DEVONThink, MarginNote, PDFExpert","_id":"cjrk2frx6001879popbelqghz"},{"name":"Github","_id":"cjrk2frxa001f79poea0g5zdh"},{"name":"Objective-C","_id":"cjrk2frxf001m79poixrgltz8"},{"name":"Garbage Collection","_id":"cjrk2frxj001r79poxrvbtr6o"},{"name":"Python","_id":"cjrk2frxk001w79povmnlvvif"},{"name":"Book","_id":"cjrk2frxm002079poqx8psvfe"},{"name":"Bookmark,2Do,Productivity,Things","_id":"cjrk2frxn002379pou6vku24s"},{"name":"XCode","_id":"cjrk2frxq002879pot5h0jqq5"},{"name":"Singleton","_id":"cjrk2frxr002d79pohw6g17fs"},{"name":"Thread","_id":"cjrk2frxs002g79po9nns9jl4"},{"name":"UIResponder","_id":"cjrk2frxu002l79po29n6yk4t"},{"name":"UIGestureRecognizer","_id":"cjrk2frxv002q79pou5s5sa03"},{"name":"UserDefaults,Keychain","_id":"cjrk2frxx002v79pors2xzpvq"},{"name":"Algorithm","_id":"cjrk2frxx002z79pov2rpd0os"},{"name":"Array","_id":"cjrk2frxy003279po972u5npz"},{"name":"String","_id":"cjrk2fry0003679pofwjyrl8d"},{"name":"Linked list","_id":"cjrk2fry1003a79potjv0kh0q"},{"name":"Safari","_id":"cjrk2fry7003n79poskwljni0"},{"name":"Traffic","_id":"cjrk2fry8003q79po1jm5c47f"},{"name":"Data Structure","_id":"cjrk2frya003v79po7l8ymfms"},{"name":"C++11","_id":"cjrk2fryb003z79pot45zcqyp"},{"name":"Lambda","_id":"cjrk2fryc004279poj9cm7oug"},{"name":"Closure","_id":"cjrk2ftbd004979pop71etvkb"},{"name":"Optional","_id":"cjrk2ftbj004i79po0v8lsnp9"},{"name":"Animation","_id":"cjrk2ftbs004q79poe79t923h"},{"name":"IAP","_id":"cjrk2ftbx004x79po4dcldbmm"},{"name":"Receipt","_id":"cjrk2ftc2005479pomux7wk4o"},{"name":"App","_id":"cjrk2ftc4005a79pocd8u1kno"},{"name":"Mac","_id":"cjrk2ftc5005e79po37d82sxo"},{"name":"Category","_id":"cjrk2ftc6005h79pogrrvm5u4"},{"name":"LLVM","_id":"cjrk2ftc7005k79popsgghphd"},{"name":"Compiler","_id":"cjrk2ftc8005o79pojac7x5i5"},{"name":"Swfit","_id":"cjrk2ftc9005r79pofrvbr92i"},{"name":"IR","_id":"cjrk2ftcc005u79pou970z8vv"},{"name":"scala","_id":"cjrk2ftcd005v79powk2tfsb9"},{"name":"CocoaPods","_id":"cjrk2ftd0006379poy3gglz88"},{"name":"Carthage","_id":"cjrk2ftd5006a79pow53pv999"},{"name":"Swift, Module, CocoaPods","_id":"cjrk2ftd7006f79po8w35h49s"},{"name":"Push Notification","_id":"cjrk2ftd9006j79po580xqcjl"},{"name":"Notification","_id":"cjrk2ftd9006n79po4dyk6t9l"},{"name":"Runtime","_id":"cjrk2ftlw006v79po4jynpjcf"}]}}