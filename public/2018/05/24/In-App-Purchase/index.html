<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="In App Purchase"><meta name="keywords" content="iOS,IAP,Receipt"><meta name="author" content="Chen,undefined"><meta name="copyright" content="Chen"><title>In App Purchase | Writing, Thinking and Coding.</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b8b088e1ebab51ca1f8e3c11ac0476a1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#In-App-Purchase-的整体流程"><span class="toc-number">1.</span> <span class="toc-text">In App Purchase 的整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阶段-1"><span class="toc-number">1.1.</span> <span class="toc-text">阶段 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阶段-2"><span class="toc-number">1.2.</span> <span class="toc-text">阶段 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阶段-3"><span class="toc-number">1.3.</span> <span class="toc-text">阶段 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册商品"><span class="toc-number">1.4.</span> <span class="toc-text">注册商品</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#商品类型"><span class="toc-number">1.4.1.</span> <span class="toc-text">商品类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取-Product-ID"><span class="toc-number">1.5.</span> <span class="toc-text">获取 Product ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取商品信息"><span class="toc-number">1.6.</span> <span class="toc-text">获取商品信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#展示支付-UI"><span class="toc-number">2.</span> <span class="toc-text">展示支付 UI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发出购买请求"><span class="toc-number">3.</span> <span class="toc-text">发出购买请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理购买结果"><span class="toc-number">4.</span> <span class="toc-text">处理购买结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final，投递商品"><span class="toc-number">5.</span> <span class="toc-text">Final，投递商品</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束交易"><span class="toc-number">6.</span> <span class="toc-text">结束交易</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于-Transaction-和-Receipt-的区别和联系"><span class="toc-number">6.1.</span> <span class="toc-text">关于 Transaction 和 Receipt 的区别和联系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于-Transaction"><span class="toc-number">6.1.1.</span> <span class="toc-text">关于 Transaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于-Receipt"><span class="toc-number">6.1.2.</span> <span class="toc-text">关于 Receipt</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#这里有几个需要注意的点："><span class="toc-number">7.</span> <span class="toc-text">这里有几个需要注意的点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#恢复已经购买的商品"><span class="toc-number">7.1.</span> <span class="toc-text">恢复已经购买的商品</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料："><span class="toc-number">8.</span> <span class="toc-text">参考资料：</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200"></div><div class="author-info__name text-center">Chen</div><div class="author-info__description text-center">I do stuff.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image:url(true)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Writing, Thinking and Coding.</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">In App Purchase</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/05/24/In-App-Purchase/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/05/24/In-App-Purchase/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,815</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>对于在 App Store 中上架的应⽤来说，应⽤内购买(In-App Purchase，简称 IAP) 应该是一个避不开的话题，尤其是去年微信打赏和 Apple 之间的争执更让 IAP 火了一把，不仅仅大公司，作为个人开发者来讲，IAP 也是非常重要的，说不定就是你养家糊口的工具呢。</p><a id="more"></a><p>整个 IAP 的过程，在客户端的实现依赖于 <code>StoreKit</code> 这个框架，所有的支付相关操作都是交由 StoreKit 来完成的。</p><p>首先，我们先复习一下 IAP 的整个流程。</p><h2 id="In-App-Purchase-的整体流程"><a href="#In-App-Purchase-的整体流程" class="headerlink" title="In App Purchase 的整体流程"></a>In App Purchase 的整体流程</h2><h3 id="阶段-1"><a href="#阶段-1" class="headerlink" title="阶段 1"></a>阶段 1</h3><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-4DDE8387-EDB1-42CC-B18C-3DC6CA1DC688.png" alt="In App Purchase 过程"></p><ol><li>加载 In-App Identifier</li><li>客户端从 AppStore 中获取本地化的商品信息。</li><li>把 IAP 的购买界⾯面展示给⽤用户，⽤用户可以同意购买并点击购买按钮。</li><li>⽤用户授权购买，客户端向服务器器发送购买请求。</li><li>服务器器处理理购买请求，并把结果返回给 StoreKit。</li><li>如果购买请求验证通过，客户端此时解锁内容或者提供⾦金金币。</li><li>至此，整个交易易流程结束。</li></ol><h3 id="阶段-2"><a href="#阶段-2" class="headerlink" title="阶段 2"></a>阶段 2</h3><p>具体到和 Apple Store 打交道的话，如下所示：</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/2018-08-27-intro_2x.png" alt="IAP With App Store"></p><h3 id="阶段-3"><a href="#阶段-3" class="headerlink" title="阶段 3"></a>阶段 3</h3><p>如果涉及到自己 App 端 Server 的参与，基本如下图所示：</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/2018-08-29-1*MwLeHUGSupbb9j-oYQyflw.png" alt="IAP With Business Server"></p><p>正常多出的几步：</p><ol><li>获取 Product 标识列表；</li><li>客户端上传 Receipt 数据给 Server，Server 自行校验或者使用 Apple 的接口校验；</li><li>Server 端告知给客户端付费内容</li></ol><h3 id="注册商品"><a href="#注册商品" class="headerlink" title="注册商品"></a>注册商品</h3><p>商品注册是通过 iTunes Connect 后台进行的，其中商品类型需要提前明确好。</p><h4 id="商品类型"><a href="#商品类型" class="headerlink" title="商品类型"></a>商品类型</h4><p>参与 App 内支付动作的商品有四种类型：</p><ul><li>Consumable products （消耗型商品）</li><li>Non-consumable products （非消耗型商品）</li><li>Auto-renewable subscriptions （自动续约订阅）</li><li>Non-renewable subscriptions （非自动续约订阅）</li></ul><p>其中关于非自动续约订阅，App 的开发者有义务同步服务到用户的所有设备上。</p><p>如下，是官方文档列出来的四种商品类型的一些主要属性。</p><table><thead><tr><th>Product type</th><th>Non-consumable</th><th>Consumable</th><th>Auto-renewable</th><th>Non-renewing</th></tr></thead><tbody><tr><td>Users can buy</td><td>Once</td><td>Multiple times</td><td>Multiple times</td><td>Multiple times</td></tr><tr><td>Appears in the receipt</td><td>Always</td><td>Once</td><td>Always</td><td>Always</td></tr><tr><td>Synced across devices</td><td>By the system</td><td>Not synced</td><td>By the system</td><td>By your app</td></tr><tr><td>Restored</td><td>By the system</td><td>Not restored</td><td>By the system</td><td>By your app</td></tr></tbody></table><p>其中需要注意的几点：</p><ol><li>除了非消耗型商品只能买一次，再次购买应该会失败以外，其他三种类型（消耗型，连续/非连续订阅）都是可以无限制购买的，Apple 是不会报错的；</li><li>除了消耗型商品在 Receipt 中出现一次，其他三种类型（非消耗型，连续/非连续订阅）是始终都会在其中的，这也是后续做订阅校验至关重要的一环；</li></ol><h3 id="获取-Product-ID"><a href="#获取-Product-ID" class="headerlink" title="获取 Product ID"></a>获取 Product ID</h3><p>这里获取的是 Product 在 iTunes Connect 后台注册商品时填写的 Product ID</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-15359854946888.png" alt="Product ID"></p><p>In-App Identifier 为每个可销售的商品提供一个唯一标识。在客户端上，我们可以直接写死代码:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> identifiers = [<span class="string">"com.myCompany.myApp.product1"</span>, <span class="string">"com.myCompany.myApp.product2"</span> ]</span><br></pre></td></tr></table></figure><p>或者从 Server 端获取。</p><h3 id="获取商品信息"><a href="#获取商品信息" class="headerlink" title="获取商品信息"></a>获取商品信息</h3><p>然后通过上一步取得的 Product ID 来获取具体某个 Product 的详细信息，包括价格，描述等等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取一批商品的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> request = <span class="type">SKProductsRequest</span>(productIdentifiers: identifierSet) </span><br><span class="line"></span><br><span class="line">request.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">request.start()</span><br></pre></td></tr></table></figure><p>在代理回调中处理获取的结果，进行展示或者 Cache。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productRequest</span><span class="params">(<span class="number">_</span> request: SKProductsRequest, didReceive response: SKProductsResponse)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> product <span class="keyword">in</span> response.products &#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方建议是不要进行缓存，因为 Product 的信息有可能会更新，比如用户切换 AppStore 的区域，价格信息也会因为相应的汇率发生变化。不过！在国内，被牺牲最大的用户体验不是这种边界情况，而是获取 Product 信息是需要和 Apple Server 打交道的，这就有个问题 —— 慢！</p><p>我们会在开机的时候提前预取所有 Product 信息，并且缓存起来。下次弹出充值面板的时候就直接列出商品信息即可。</p><h2 id="展示支付-UI"><a href="#展示支付-UI" class="headerlink" title="展示支付 UI"></a>展示支付 UI</h2><p>接下来就看什么时候进行购买了，展示商品面板进行购买。用户在面板上进行选择之后，就进入了下一阶段 ── 支付</p><h2 id="发出购买请求"><a href="#发出购买请求" class="headerlink" title="发出购买请求"></a>发出购买请求</h2><p>这⼀步也很简单， 两⾏行代码就可以搞定。只需要把之前拿到的商品对象传到 <code>SKPayment</code> 的初始化方法中，构造一个 <code>SKPayment</code> 实例，再把这个实例加⼊到购买队列中即可:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> payment = <span class="type">SKPayment</span>(product: product) <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().add(payment)</span><br></pre></td></tr></table></figure><p>之后就交给 Apple 了，此时应用内会弹出苹果设计的购买窗口，用户只要使⽤指纹或者输入密码即可同意付款。</p><h2 id="处理购买结果"><a href="#处理购买结果" class="headerlink" title="处理购买结果"></a>处理购买结果</h2><p>当⽤户的购买请求经过 <code>StoreKit</code> 和苹果服务器的验证后，开发者可以在回调函数中接收到。Apple 具体的回调会通过 <code>SKPaymentQueue</code> 来进行，如下，我们需要在支付之前就向 <code>SKPaymentQueue</code> 中加入代理监听。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().add(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p>你可以把具体的监听放在一个独立的类中完成。在该 Observer 中，实现代理方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理理 SKPaymentQueueObserver 事件</span></span><br><span class="line"><span class="comment">// MARK: - SKPaymentTransactionObserver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paymentQueue</span><span class="params">(<span class="number">_</span> queue: SKPaymentQueue, updatedTransactions transactions:[SK PaymentTransaction])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> transactions &#123;</span><br><span class="line">        <span class="keyword">switch</span> transaction.transactionState &#123; </span><br><span class="line">            <span class="keyword">case</span> .purchased:</span><br><span class="line">            <span class="comment">// Validate the purchase</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Locate the file</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.appStoreReceiptURL <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Handle failure</span></span><br><span class="line">                <span class="keyword">return</span>    </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the contents</span></span><br><span class="line">            <span class="keyword">let</span> receipt = <span class="type">Data</span>(contentsOf: url)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个你提交的 Payment，就一定会有一个相应的 Transaction 生成以便其后续处理。通过检查 transaction 的状态，我们可以指定每种状态下的处理逻辑。如果状态显示已购买， 我们还是应该和⾃己的服务器器进行一次校验，确保交易真实有效⽽而不是通过越狱后的某些插件完成的。被检验的，是一种被苹果称之为收据(receipt)的凭证，就像我们在超市购物或者饭店就餐后拿到的收据一样，每⼀个购买的商品都有⾃己的收据。这个收据由苹果签发，保存在客户端本地。</p><p>目前 Apple 官方提供两种方式，一种是本机校验，一种是 Server 端校验。</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-E9DC4D03-7F18-49CC-B21D-835904E2B39F.png" alt="Receipt Validation Ways"></p><h2 id="Final，投递商品"><a href="#Final，投递商品" class="headerlink" title="Final，投递商品"></a>Final，投递商品</h2><p>当 Server 端检验完成之后，说明本地交易已经成功完成，因此将用户购买的内容提供给用户使用。当然，对于业务方，购买完成不代表业务完成，因此大多数情况下还有一步进行商品业务校验的过程。</p><p>需要注意的一点是：</p><p>Apple 也明确告诉开发者有几个关键的路径节点需要注意：</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-C1BB8495-728D-43E7-9C40-8EC9B3A22905.png" alt="关键路径"></p><p>监听交易状态的代码一定要越早越好，比如在 App 完成启动之后进行注册，确保整个生命周期内都有代码逻辑来处理监听到的交易，根据监听到的 Transaction 的状态来分发处理逻辑。因为很有可能你监听的时机太晚，导致 Apple 通知有一些之前未完成的交易的时候你无法捕获。说白了就是用户的购买流程跟 App 生命周期不挂钩导致的，典型的有以下几个场景</p><ol><li>用户杀死了 App</li><li>用户需要更新帐号中的付费信息（此时已跳出 App ）</li><li>App 闪退</li><li>用户进行了订阅续期</li><li>用户进入了推介促销价的流程</li><li>用户跳出 App 输入推广码</li></ol><h2 id="结束交易"><a href="#结束交易" class="headerlink" title="结束交易"></a>结束交易</h2><p>在最后一步中，如果是正常的交易，那么简单的结束它们就⾏了。但对于其他异常的交易易，⽐比如出现了一些 error，也要妥善的结束它们。如果是⾃动续期的订阅，也会经过这一步。如果 交易没有被正确的结束，它们会一直停留留在上文提到的队列中，每次回调函数被调用时，队列 中都会有这些没有被结束的交易。也就是为什么需要提前监听的原因了。</p><p>结束交易的代码⾮常简单，只有一行:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br></pre></td></tr></table></figure><h3 id="关于-Transaction-和-Receipt-的区别和联系"><a href="#关于-Transaction-和-Receipt-的区别和联系" class="headerlink" title="关于 Transaction 和 Receipt 的区别和联系"></a>关于 Transaction 和 Receipt 的区别和联系</h3><p>很多同学在进行 IAP 开发的时候常常有一个很大的困惑就是 Transaction 和 Receipt 傻傻分不清楚，这里重新梳理了一下。</p><h4 id="关于-Transaction"><a href="#关于-Transaction" class="headerlink" title="关于 Transaction"></a>关于 Transaction</h4><p>其实前面讲 Payment 的操作的时候已经表明了， Transaction 是和具体的一次 Payment 对应的，也就是发生一次 Payment 就会生成 Transaction，但是，并不是 1 对 1 的关系，比如本次 Payment 对应的 Transaction 已经被 finish 了，用户换了手机，登陆同样 AppleID 的时候使用 Restore 功能，Apple 会生成 Transaction 给你，本次的 Transaction 就对应的之前的 Payment，只是状态标记为 .restored。</p><p>Transaction 的状态主要有以下这么几种：</p><table><thead><tr><th style="text-align:left">状态</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">.purchasing</td><td style="text-align:left">不需要做什么，继续等待 SKPaymentTransactionState 的状态流转</td></tr><tr><td style="text-align:left">.purchased</td><td style="text-align:left">用户已完成付费，处理付费后的流程并调用 finishTransaction 方法</td></tr><tr><td style="text-align:left">.failed</td><td style="text-align:left">用户付费失败，处理付费失败的流程并调用 finishTransaction 方法</td></tr><tr><td style="text-align:left">.restored</td><td style="text-align:left">用户付费成功，处理付费后的流程并调用 finishTransaction 方法</td></tr><tr><td style="text-align:left">.deferred</td><td style="text-align:left">不需要做什么，继续等待 SKPaymentTransactionState 的状态流转</td></tr></tbody></table><p><strong>Note</strong>: 对于 <code>finishTransaction</code> 的几点说明：</p><ol><li>对于那些依赖苹果下载服务的，比如存储在 iTunes Connect 上的付费内容要下载到本地，如果下载完成之前就进行了 finish 动作会导致 Apple 阻断所有的下载流程，并且无法重新下载；</li><li>Transaction 需要配合 Receipt 验证是否合法，单纯靠前端是不靠谱的，因此交由业务后端验证 Receipt 更安全合理，业务后端来决定是否需要 finish</li><li>文档里说：Your app needs to finish every transaction, regardless of whether the transaction succeeded or failed. 所以我们需要将 Transaction Finish 掉，否则会始终出现在 PaymentQueue 里，BUT，中间态的交易是不需要 finish 的，比如 .purchasing 和 .deferred</li></ol><h4 id="关于-Receipt"><a href="#关于-Receipt" class="headerlink" title="关于 Receipt"></a>关于 Receipt</h4><p>Receipt 是 App Store 签发的，是你的 App 上和该 App 上发生的支付行为记录。它存储在设备上的某个固定地址，StoreKit 并不会生成它，它是从 App Store 拉取下来的一个文件。如图所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.appStoreReceiptURL <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handle failure</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the contents</span></span><br><span class="line"><span class="keyword">let</span> receipt = <span class="type">Data</span>(contentsOf: url)</span><br></pre></td></tr></table></figure><p>如果本地该地址里没有，我们还可以进行刷新，实质上就是从 App Store 请求 Receipt 数据。请求如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="type">SKReceiptRefreshRequest</span>()</span><br><span class="line"></span><br><span class="line">request.delegate = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">request.start()</span><br></pre></td></tr></table></figure><h2 id="这里有几个需要注意的点："><a href="#这里有几个需要注意的点：" class="headerlink" title="这里有几个需要注意的点："></a>这里有几个需要注意的点：</h2><h3 id="恢复已经购买的商品"><a href="#恢复已经购买的商品" class="headerlink" title="恢复已经购买的商品"></a>恢复已经购买的商品</h3><p>这里有一个需要注意的事情就是：如果一个用户试图去购买一个之前购买过的商品，而不是使用你App 提供的 Restore 功能恢复的话，App Store 会依然创建一个正常的新交易。用户是不会被再次收费的，这里的问题是，Transaction 的状态可不是 restored，而是完全新的 Transaction，你可以按照之前的正常流程走，当然对于自带账户体系的 App 来讲，需要自行判断和计算。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol><li><a href="https://developer.apple.com/in-app-purchase/" target="_blank" rel="noopener">In App Purchase</a></li><li><a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Introduction.html" target="_blank" rel="noopener">In-App Purchase Programming Guide</a></li><li><a href="https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html" target="_blank" rel="noopener">Receipt Validation Programming Guide</a></li><li><a href="https://forums.developer.apple.com/thread/46737" target="_blank" rel="noopener">How to detect refunded IAPs from receipts?</a></li><li><a href="https://stackoverflow.com/questions/10771240/check-if-a-non-renewable-subscription-was-refunded-by-apple" target="_blank" rel="noopener">Check if a non-renewable subscription was refunded by Apple?</a></li><li><a href="https://stackoverflow.com/questions/6439482/how-does-apple-notify-ios-apps-of-refunds-of-in-app-purchases-iap" target="_blank" rel="noopener">How does Apple notify iOS apps of refunds of in-app purchases (IAP)?</a></li></ol></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://hechen.xyz/2018/05/24/In-App-Purchase/">http://hechen.xyz/2018/05/24/In-App-Purchase/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/IAP/">IAP</a><a class="post-meta__tags" href="/tags/Receipt/">Receipt</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/10/What-is-LLVM/"><i class="fa fa-chevron-left"></i><span>What is LLVM</span></a></div><div class="next-post pull-right"><a href="/2017/11/19/Modular-Xcode-projects/"><span>模块化 Xcode 工程</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused=null,disqus_config=function(){this.page.url="http://hechen.xyz/2018/05/24/In-App-Purchase/",this.page.identifier="2018/05/24/In-App-Purchase/",this.page.title="In App Purchase"},d=document,s=d.createElement("script");s.src="https://stoneman.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script id="dsq-count-src" src="https://stoneman.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2019 By Chen</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>