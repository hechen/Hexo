<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="在 Swift Framework 中使用 C 文件的过程探索"><meta name="keywords" content="Swift, Module, CocoaPods"><meta name="author" content="Chen,undefined"><meta name="copyright" content="Chen"><title>在 Swift Framework 中使用 C 文件的过程探索 | Writing, Thinking and Coding.</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b8b088e1ebab51ca1f8e3c11ac0476a1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题描述"><span class="toc-number">1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几个概念"><span class="toc-number">2.</span> <span class="toc-text">几个概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Modules"><span class="toc-number">2.1.</span> <span class="toc-text">Modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Umbrella-Header"><span class="toc-number">2.2.</span> <span class="toc-text">Umbrella Header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cocoapods"><span class="toc-number">2.3.</span> <span class="toc-text">Cocoapods</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题原因"><span class="toc-number">3.</span> <span class="toc-text">问题原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决过程"><span class="toc-number">4.</span> <span class="toc-text">解决过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题解惑"><span class="toc-number">4.1.</span> <span class="toc-text">问题解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于某些"><span class="toc-number">4.1.1.</span> <span class="toc-text">关于某些</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200"></div><div class="author-info__name text-center">Chen</div><div class="author-info__description text-center">I do stuff.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://i.imgur.com/NJi1fs6.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Writing, Thinking and Coding.</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">在 Swift Framework 中使用 C 文件的过程探索</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2019/01/03/Swift-and-Modules/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2019/01/03/Swift-and-Modules/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3,616</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Swift 真香！</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们在开发线上诊断工具需求的时候，是以单个 Pod 的形式提供支持，并且代码文件中只有纯 Swift 文件，但是其中需要用到系统的 C 库的一些功能，本次就是使用了系统 C 库中 <code>resolv.h</code> 这个文件来进行 DNS 解析所用。</p><p>当后期 Pod 功能完善之后，在 Example 工程中也已经编译通过之后，接入主项目中之后遇到了下面这个编译错误：</p><p><img src="https://i.imgur.com/ADh0sy6.png" alt="Error When Compile"></p><p>具体文字错误信息如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Users/chen/Repos/Work/ZHDiagnosisTool/ZHDiagnosisTool/Classes/Core/Network/ZHDiagnosisTool-Network-Header.h:8:10: </span><br><span class="line">    Include of non-modular header inside framework module &apos;Diagnosis.ZHDiagnosisTool_Network_Header&apos;: &apos;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk/usr/include/resolv.h&apos;</span><br></pre></td></tr></table></figure><p>大概的意思就是在 Umbrella Header 中加入的 Briding header 指定了 include 一个 C 文件，而该 C 文件本身并不是 Modular Header， 因此编译无法通过。这就涉及了目前 iOS 生态中普遍使用的 Modules 概念。</p><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>Modules 的概念是 XCode 5 带到 iOS 开发者面前的，从那时起 LLVM 编译器就已经内在支持了，具体关于其历史在 <a href="https://onevcat.com/2013/06/new-in-xcode5-and-objc/" target="_blank" rel="noopener">WWDC 2013 Session笔记 - Xcode5和ObjC新特性</a> 这篇文章中已经讲解的非常详细了，不再赘述，总结一句话就是：</p><blockquote><p>Modules 是被引入 LLVM 层面的，用以解决之前 C/C++ 系中 #include 和 #import 带来的引用泛滥以及编译时间过长的问题的一种手段。</p></blockquote><p>尤其是在 Swift 引入之后，Module 的概念应该已经深入人心。大家可能已经习惯直接使用 @import 来引用某个 Module，或者其中某个逻辑单元。尤其是使用 CocoaPods 集成开发的时候，其也帮你底层做了一些 Modules 的工作， module 的属性是由定义它的 <code>.modulemap</code> 文件来决定的，在 Pods 的工程目录结构中充斥着 <code>.modulemap</code> 的身影，其语法大概如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module module_name [system] &#123;</span><br><span class="line">    header "header.h"</span><br><span class="line">    link "linked_library"</span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对其中 <a href="https://clang.llvm.org/docs/Modules.html#module-map-language" target="_blank" rel="noopener">Modules 的语法</a>感兴趣，可以到 Clang 的官方文档下通读下，你肯定会对 Modules 这一套有更清楚的认识。</p><h3 id="Umbrella-Header"><a href="#Umbrella-Header" class="headerlink" title="Umbrella Header"></a>Umbrella Header</h3><p>说起来，Umbrella Header 是在 Framework 的概念被引入的，你可以理解为一个模块均存在一个 Umbrella Header 用来将那些你想暴露给模块外界调用的头文件包裹在一起。避免使用者在使用该模块的时候需要手动输入多个 Header 的一种解决方案。 iOS 中特指 iOS 8 系统官方加入 Dynamic Framework 之后引入的。</p><p>如下所示，没有 Umbrella Header 的情况下你需要将所有需要引入的头文件依次写出。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;XYZModule/XYZCustomCell.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XYZModule/XYZCustomView.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;XYZModule/XYZCustomViewController.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>在使用了 Umbrella Header 之后，你只需要下面一行即可。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;XYZModule/XYZModule.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>当然，还存在 umbrella framework，感兴趣大家可以到<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC" target="_blank" rel="noopener">官方文档</a>下观看。</p><ul><li>Bridging-Header</li></ul><p>桥接文件是在 Swift 推出之后，Apple 引入目前iOS 生态的一个概念用以桥接 Swift 和 Objective-C 的一种方式 （Mix and Match），如下图所示，如果在 Swift 中想使用 Objective-C 类定义的内容，就需要建立 Bridging Header，然后在其中定义你想要暴露的 OC 头文件。</p><p><img src="https://i.imgur.com/YwqHEKJ.png" alt="Bridging Header"></p><p>具体的操作在<a href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift" target="_blank" rel="noopener">官方文档</a>有针对在同一个 App Target 和在同一个 Framework 内两种情况均有说明。</p><blockquote><p>在梳理这些概念的过程中，发现自己之前对桥接文件有个误区，如果你在 App 的主 Target 中需要进行 OC 和 Swift 的混编，使用 Bridging Header 是必选，如果你是在同一个 Framework 中进行的混编，Bridging-Header 是并不需要的，你需要做的只是在 Umbrella Header 里加入你想暴露给 Swift 文件使用的 OC 头文件即可，之前自己一直是显式的建立一个 Bridging-Header，然后在 Umbrella Header 中引入该头文件，想来这种方式只是将你想暴露在外的头文件进行了二次包裹而已，因为 Cocoapods 是将所有 public header 均加入到 umbrella header 里了，因此单个 framework 内部开发，即使没有 bridge header 也是能够将符号暴露给 Swift 的。</p></blockquote><h3 id="Cocoapods"><a href="#Cocoapods" class="headerlink" title="Cocoapods"></a>Cocoapods</h3><p>我们每次执行 <code>pod install</code> 的时候，如果你使用 —verbose 来看详细安装过程就能看到，针对每一个将要被安装的 Pod 均会执行生成 module map 和 umbrella header 这两个阶段，如下所示部分 Install 指令的代码，代码位于 <code>lib/cocoapods/installer/xcode/pods_project_generator/aggregate_target_installer.rb</code></p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">install!</span></span></span><br><span class="line">       UI.message <span class="string">"- Installing target `<span class="subst">#&#123;target.name&#125;</span>` <span class="subst">#&#123;target.platform&#125;</span>"</span> <span class="keyword">do</span></span><br><span class="line">       native_target = add_target</span><br><span class="line">       create_support_files_dir</span><br><span class="line">       create_support_files_group</span><br><span class="line">       create_xcconfig_file(native_target)</span><br><span class="line">       <span class="keyword">if</span> target.host_requires_frameworks?</span><br><span class="line">          create_info_plist_file(target.info_plist_path, native_target, target.version, target.platform)</span><br><span class="line">    	    create_module_map(native_target)</span><br><span class="line">          create_umbrella_header(native_target)</span><br><span class="line">       <span class="keyword">elsif</span> target.uses_swift?</span><br><span class="line">          create_module_map(native_target)</span><br><span class="line">    			create_umbrella_header(native_target)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">     <span class="comment"># Some Code</span></span><br><span class="line">     <span class="comment"># Some Code</span></span><br><span class="line">     <span class="comment"># Some Code      </span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>很明确，Cocoapods 在 install 某个 Pod 的时候会执行创建 module map 文件以及 umbrella header 文件的工作。详细的代码大家可以直接到 Cocoapods 源码下 <code>lib/cocoapods/generator</code> 目录下看，分别是 <code>module_map.rb</code> 和 <code>umbrella_header.rb</code> 文件。</p><p>其中在各自文件的注释部分也有针对生成文件的说明，比如 <code>module_map.rb</code> 中说明了 module map 的作用，</p><blockquote><p>Generates LLVM module map files. A module map file is generated for each Pod and for each Pod target definition that is built as a framework. It specifies a different umbrella header than usual to avoid name conflicts with existing headers of the podspec.</p></blockquote><p>在 <code>umbrella_header.rb</code> 中说明了 umbrella header 的作用，</p><blockquote><p>Generates an umbrella header file for clang modules, which are used by dynamic frameworks on iOS 8 and OSX 10.10 under the hood. If the target is a +PodTarget+, then the umbrella header is required to make all public headers in a convenient manner available without the need to write out header declarations for every library header.</p></blockquote><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>首先先解答：为什么 Example 工程能够编译通过 而用了主工程是无法编译通过？</p><p>因为目前主工程都要求我们自行开发的 pod 以动态 framework 的形式参与，但是在 Example 工程开发的时候我们的 <code>podfile</code> 并未指定 <code>use_frameworks!</code> 用以产出动态 framework，因此未暴露出该问题，也就是说只有以 framework 的形式的 module 才会有该问题，准确的说，应该是 <code>Dynamic Framework</code></p><p>了解了以上概念之后，我们再来看我们的问题，首先我们的问题是在 framework 内部调用系统 C 库代码出现的问题，从 Xcode 的报错，我们知道我们通过 bridging header 引入的 C 文件并不以 module 的形式存在，因此编译器报错。</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>其实吧，大家都能想到，使用 Objective-C 做个封装，或者干脆直接调用 C 文件的类用 OC 重写不就完了么，可是如果下次你再遇到了呢？ 或者要改造了一个纯 Swift 库呢？知其所以然，才能避免再次落坑吧。</p><blockquote><p>因为 Objective-C 自身编译器是帮你做了 modular 化的，当然，如果你选择了前者，还有个限制，你并不能把上面 C 的头文件放到你的 Objective-C 的头文件中，因为本质上，最后这个头文件还是要暴露给 Umbrella Header 的。</p></blockquote><p>首先，能否允许编译器支持在 module 中引入非 modular 的头文件呢？</p><p>Xcode 在 build setting 中提供了 <code>Allow Non-modular Includes In Framework Modules</code> 来控制是否允许在当前 framework 中支持非 modular 头文件引入，其并不适用于纯 Swift 项目，而且即使适用，其会导致所有用到该 framework 的地方也不能再适用 module 形式引入头文件了，也就是必须适用平坦式的 <code>#include &quot;&quot;</code></p><p><img src="https://i.imgur.com/S4i2chx.png" alt="Build Setting"></p><p>最后，通过只能从根源上来解决该问题了，既然需要引入的文件是 modular header，我们就要想办法来将其包裹为 module。 在查找解决方案的过程中发现，就在 Swift 刚推出的时候，大家已经遇到这个问题了，遇到最多的就是<code>CommonCrypto</code> 经常被使用到的 C 库，常见的 MD5 计算就是其提供的 API，但是在前几年官方并未将该动态库 module 化，因此导致你无法在 Swift 文件中直接使用类似 <code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code> 这种写法。自然而言多了很多解决方案，如下出自 StackOverflow 上 <a href="https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785" target="_blank" rel="noopener">Importing CommonCrypto in a Swift framework</a> 的帖子下面就提供了多种解决方案：</p><blockquote><p>还是那句话，你是可以通过 Objective-C 做桥接来达到同样效果的。毕竟 Swift 本身就是一门心思想抛开 C 的历史包袱，因此想拥有一个纯纯的 Swift 代码不沾染一点 C 文件气息，你就要做一些工作。</p></blockquote><p>其中根本问题就是为 <code>CommonCrypto</code> 这个 C 编译单元定义 module，上面也提到了 LLVM 是通过 <code>modulemap</code> 文件来识别的，所以只要通过 <code>.modulemap</code> 来定义即可，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module CommonCrypto [system] &#123;</span><br><span class="line">    header &quot;/usr/include/CommonCrypto/CommonCrypto.h&quot;</span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的 modulemap 自然可以放到任意目录，只要让编译单元在编译的时候能够搜索的到即可，Xcode 选项的 Build Settings 下的 Swift Compiler - Search Paths 。添加 .modulemap 文件所在路径即可。在编译的时候 LLVM 自然会查找到 .modulemap 文件自动生成 Module 信息。你此时就可以在使用 CommonCrypto 的地方使用 modular header 了。</p><p>过了几年之后，官方才将该库定义为 module，在 Xcode 自带的 iOS SDK 中 <code>/usr/include/CommonCrypto</code> 下可以看到 <code>module.modulemap</code> 文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module CommonCrypto [system] [extern_c] &#123;</span><br><span class="line">      umbrella header &quot;CommonCrypto.h&quot;</span><br><span class="line">      export *</span><br><span class="line">      module * &#123; export * &#125;</span><br><span class="line">      </span><br><span class="line">      module Error &#123;</span><br><span class="line">          header &quot;CommonCryptoError.h&quot;</span><br><span class="line">          export *</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      module Random &#123;</span><br><span class="line">          header &quot;CommonRandom.h&quot;</span><br><span class="line">          export *</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>大家也注意到了在 CommonCrypto 的同级目录中实际上还有很多的系统 C 库代码，并且也有一个 module.modulemap 文件，我裁剪一段代码大家看下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module Compression [system] [extern_c] &#123;</span><br><span class="line">    header &quot;compression.h&quot;</span><br><span class="line">    export *</span><br><span class="line">    link &quot;compression&quot;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">module Darwin [system] [extern_c] [no_undeclared_includes] &#123;</span><br><span class="line">    // Headers that are repeatedly included, and therefore should not be</span><br><span class="line">    	// assigned to any given module.</span><br><span class="line">    	exclude header &quot;_structs.h&quot;</span><br><span class="line">    	exclude header &quot;sys/_structs.h&quot;</span><br><span class="line">    </span><br><span class="line">    	// C standard library</span><br><span class="line">    	module C &#123;</span><br><span class="line">    		textual header &quot;assert.h&quot;</span><br><span class="line">    </span><br><span class="line">    	  module setjmp &#123;</span><br><span class="line">    			header &quot;setjmp.h&quot;</span><br><span class="line">    			export *</span><br><span class="line">    		&#125;</span><br><span class="line">    </span><br><span class="line">    		module signal &#123;</span><br><span class="line">    			header &quot;signal.h&quot;</span><br><span class="line">    			export *</span><br><span class="line">    		&#125;</span><br><span class="line">    </span><br><span class="line">    		module stdio &#123;</span><br><span class="line">    			header &quot;stdio.h&quot;</span><br><span class="line">    			export *</span><br><span class="line">    		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    module zlib [system] [extern_c] &#123;</span><br><span class="line">    	header &quot;zlib.h&quot;</span><br><span class="line">    	export *</span><br><span class="line">    	link &quot;z&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    module SQLite3 [system] [extern_c] &#123;</span><br><span class="line">    	header &quot;sqlite3.h&quot;</span><br><span class="line">    	link &quot;sqlite3&quot;</span><br><span class="line">    	explicit module Ext &#123;</span><br><span class="line">    		header &quot;sqlite3ext.h&quot;</span><br><span class="line">    		export *</span><br><span class="line">    	&#125;</span><br><span class="line">    	export *</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这也是为什么我们在 Swift 代码里可以直接使用类似 <code>import Darwin.C.stdio</code> 写法的原因。但是还是存在一些 C 库并没有被定义为 module，而本次用来做 DNS 解析的 <code>resolv.h</code> 就是其中一员。</p><p>具体到我们开发流程里说，是要解决 modulemap 如何定义，如何和我们目前使用的 Cocoapods 整合的问题了。既然是在作为 Pod 进行开发，自然是需要将 module map 文件加入到 pod 的代码管理中去。比如将其放置于单个 pod 根目录下，然后在 podspec 中配置好路径以便编译的时候 Swift Search Paths 中有它。自然，我们可以建立 resolv.modulemap 如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module Resolv [system] &#123;</span><br><span class="line">    header "/usr/include/resolv.h"</span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在对应的 podspec 文件中配置 build setting 中的参数，如下所示</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.subspec <span class="string">'Core'</span> <span class="keyword">do</span> <span class="params">|core|</span></span><br><span class="line">    core.source_files   = [<span class="string">'ZHDiagnosisTool/Classes/Core/**/*'</span>] </span><br><span class="line">    core.preserve_paths = <span class="string">'ZHDiagnosisTool/Classes/Core/ModuleMap'</span></span><br><span class="line">    core.pod_target_xcconfig = &#123;</span><br><span class="line">        <span class="string">'SWIFT_INCLUDE_PATHS[sdk=macosx*]'</span>           =&gt; <span class="string">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class="line">        <span class="string">'SWIFT_INCLUDE_PATHS[sdk=iphoneos*]'</span>         =&gt; <span class="string">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class="line">        <span class="string">'SWIFT_INCLUDE_PATHS[sdk=iphonesimulator*]'</span>  =&gt; <span class="string">'$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap'</span>,</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可是，问题出在 PODS_ROOTS 这个路径上，如果我们进行本地开发，该路径就是 Cocoapods 执行完毕之后生成的临时 Pods 目录，并不是原始 podspec 文件所在的地方，而官方也表明了，不会对这种 Local Pods 特定提供一个环境变量来获取， 如下链接可以看到：</p><p><a href="https://github.com/CocoaPods/CocoaPods/issues/809" target="_blank" rel="noopener">local pod development on a project that includes libraries · Issue #809 · CocoaPods/CocoaPods</a></p><p>如图中，指定 $(PODS_ROOT) 路径实际上在开发 Local Pod 的时候就会找不到，所以就需要按照上面链接中的方式自行手动拼接路径，所以，我们尽可能不用 PODS_ROOT 这个路径，需要另外找一个不会因为 Pod 位置而变化的路径。</p><p>最终参考了以下 repo 中工程的解决方案，</p><p><a href="https://github.com/onmyway133/Arcane" target="_blank" rel="noopener">onmyway133/Arcane</a></p><p>其中作者使用 Pod 的 script phase 来完成 .modulemap 的操作，这样会更加灵活。</p><p>这样，针对我们自己本次的需求来看，.podspec 中的 script 如下所写即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Create</span><br><span class="line">FRAMEWORK_DIR="$&#123;BUILT_PRODUCTS_DIR&#125;/RESOLV.framework"</span><br><span class="line">          </span><br><span class="line">if [ -d "$&#123;FRAMEWORK_DIR&#125;" ]; then</span><br><span class="line">    echo "$&#123;FRAMEWORK_DIR&#125; already exists, so skipping the rest of the script."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line">          </span><br><span class="line">mkdir -p "$&#123;FRAMEWORK_DIR&#125;/Modules"</span><br><span class="line">          </span><br><span class="line">echo "module RESOLV [system] &#123;</span><br><span class="line">    header \"$&#123;SDKROOT&#125;/usr/include/resolv.h\"</span><br><span class="line">    export *</span><br><span class="line">&#125;" &gt; "$&#123;FRAMEWORK_DIR&#125;/Modules/module.modulemap"</span><br><span class="line">               </span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> Generate fake header...</span><br><span class="line">[ -d "$&#123;FRAMEWORK_DIR&#125;/Headers" ] || mkdir "$&#123;FRAMEWORK_DIR&#125;/Headers"</span><br><span class="line">touch "$&#123;FRAMEWORK_DIR&#125;/Headers/resolv.h"</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> Soft link C header to local framework Headers</span><br><span class="line">ln -sf "$&#123;SDKROOT&#125;/usr/include/resolv.h" "$&#123;FRAMEWORK_DIR&#125;/Headers/resolv.h"</span><br></pre></td></tr></table></figure><p>每次在编译运行前，我们会自行创建一个 <code>Resolv.framework</code>，其中 Header 目录中我们放一个空白文件并且软链接到真正想要链接的头文件上，然后在该 framework 中创建 modulemap 文件。</p><p>之后，我们在 .podspec 中指定 script phase 为编译前即可，如下所示，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">s.script_phase = &#123;</span><br><span class="line">    <span class="symbol">:name</span> =&gt; <span class="string">'Resolv'</span>,</span><br><span class="line">    <span class="symbol">:script</span> =&gt; script_above,</span><br><span class="line">    <span class="symbol">:execution_position</span> =&gt; <span class="symbol">:before_compile</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过 <code>Resolv.framework</code> 的桥接，Swift 代码中就可以直接通过 <code>import RESOLV</code> 来使用了。当然，链接这一环你可以通过以下两种形式达到：</p><ol><li>直接在 podspec 文件中指定依赖，如 <code>core.library = &quot;resolv&quot;</code></li><li>在 <code>.modulemap</code> 文件中显式的 link，如下所示：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module Resolv [system] &#123;</span><br><span class="line">    header "/usr/include/resolv.h"</span><br><span class="line">    link "resolv"</span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且通过将 module map 文件放置于 product 产出目录这里也解决了路径指定的问题，因为 product folder 是默认在编译的搜索路径下的。</p><h3 id="问题解惑"><a href="#问题解惑" class="headerlink" title="问题解惑"></a>问题解惑</h3><h4 id="关于某些"><a href="#关于某些" class="headerlink" title="关于某些"></a>关于某些</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结来看，就是想要在纯 Swift 的项目中引入系统 C 库文件（这里指的是未被 modular 化的文件，因为有些 C 文件已经被系统默认封装成了 module 了）。以上只是一些简单的概念讲解，整个编译系统以及套件都是长时间不断演化的结果，这里也只是简单的讲述，有一些概念实际上也只是点到为止，大家如果感兴趣可以多找一些相关资料阅读下，亲自试一试。当然，当然刚开始直接用 Objective-C 来写不就好了，确实，不过通过本次解决这个问题，对 iOS 开发过程中遇到的某些司空见惯的概念（充斥在整个开发周期中）有了更清楚的了解，不是更好。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf" target="_blank" rel="noopener">Modules</a></li><li><a href="https://zh.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM - 维基百科，自由的百科全书</a></li><li><a href="https://clang.llvm.org/docs/Modules.html#introduction" target="_blank" rel="noopener">Modules - Clang 8 documentation</a></li><li><a href="https://onevcat.com/2013/06/new-in-xcode5-and-objc/" target="_blank" rel="noopener">WWDC 2013 Session笔记 - Xcode5和ObjC新特性</a></li><li><a href="https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785" target="_blank" rel="noopener">Importing CommonCrypto in a Swift framework</a></li><li><a href="https://forums.developer.apple.com/thread/46477" target="_blank" rel="noopener">Adding CommonCrypto to custom Swift framework |Apple Developer Forums</a></li><li><a href="https://theswiftdev.com/2018/01/15/how-to-call-c-code-from-swift/" target="_blank" rel="noopener">How to call C code from Swift - The.Swift.Dev.</a></li><li><a href="https://medium.com/swift-and-ios-writing/using-a-c-library-inside-a-swift-framework-d041d7b701d9/" target="_blank" rel="noopener">Using a C library inside a Swift framework - Swift and iOS Writing - Medium</a></li></ol></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://hechen.xyz/2019/01/03/Swift-and-Modules/">http://hechen.xyz/2019/01/03/Swift-and-Modules/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Swift-Module-CocoaPods/">Swift, Module, CocoaPods</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/01/28/关于-SS-流量丢失的原因探索/"><i class="fa fa-chevron-left"></i><span>关于 SS 流量丢失的原因探索</span></a></div><div class="next-post pull-right"><a href="/2018/12/21/UserDefaults-and-Keychain/"><span>UserDefaults and Keychain</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused=null,disqus_config=function(){this.page.url="http://hechen.xyz/2019/01/03/Swift-and-Modules/",this.page.identifier="2019/01/03/Swift-and-Modules/",this.page.title="在 Swift Framework 中使用 C 文件的过程探索"},d=document,s=d.createElement("script");s.src="https://stoneman.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script id="dsq-count-src" src="https://stoneman.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2019 By Chen</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>