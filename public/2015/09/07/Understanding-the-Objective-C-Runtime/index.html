<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="理解Objective-C运行时"><meta name="keywords" content="iOS,Objective-C,Runtime"><meta name="author" content="Chen,undefined"><meta name="copyright" content="Chen"><title>理解Objective-C运行时 | Writing, Thinking and Coding.</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b8b088e1ebab51ca1f8e3c11ac0476a1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Objective-C运行时是开源的"><span class="toc-number">1.</span> <span class="toc-text">Objective-C运行时是开源的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态-Vs-静态"><span class="toc-number">2.</span> <span class="toc-text">动态 Vs. 静态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-Objective-C-运行时？"><span class="toc-number">3.</span> <span class="toc-text">什么是 Objective-C 运行时？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Objective-C-运行时术语"><span class="toc-number">4.</span> <span class="toc-text">Objective-C 运行时术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#因此类定义了对象而不是对象本身，那这又是如何实现的？"><span class="toc-number">5.</span> <span class="toc-text">因此类定义了对象而不是对象本身，那这又是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么我们都要继承自Apple的类呢？"><span class="toc-number">6.</span> <span class="toc-text">为什么我们都要继承自Apple的类呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类缓存（objc-cache-cache）是什么？"><span class="toc-number">7.</span> <span class="toc-text">类缓存（objc_cache* cache）是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#那-objc-msgSend-方法都发生了什么呢？"><span class="toc-number">8.</span> <span class="toc-text">那 objc_msgSend 方法都发生了什么呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Objective-C-消息转发"><span class="toc-number">9.</span> <span class="toc-text">Objective-C 消息转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-Fragile-ivars-Modern-Runtime"><span class="toc-number">10.</span> <span class="toc-text">Non Fragile ivars (Modern Runtime)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Objective-C-关联对象"><span class="toc-number">11.</span> <span class="toc-text">Objective-C 关联对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#混合的虚表派生"><span class="toc-number">12.</span> <span class="toc-text">混合的虚表派生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#因此你如何能知道你正在和它打交道呢？"><span class="toc-number">13.</span> <span class="toc-text">因此你如何能知道你正在和它打交道呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">14.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考链接"><span class="toc-number">15.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200"></div><div class="author-info__name text-center">Chen</div><div class="author-info__description text-center">I do stuff.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://i.imgur.com/5SKmTN3.png)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Writing, Thinking and Coding.</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">理解Objective-C运行时</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/翻译/">翻译</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2015/09/07/Understanding-the-Objective-C-Runtime/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2015/09/07/Understanding-the-Objective-C-Runtime/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">6,670</span><span class="post-meta__separator">|</span><span>Reading time: 24 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote><p>翻译自：<a href="https://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="noopener">Understanding the Objective-C Runtime</a><br>译者： <a href="http://weibo.com/hc2feifei" target="_blank" rel="noopener">@这个昵称有点萌</a></p></blockquote><p>Objective-C 运行时对于刚刚踏入 Cocoa/Objective 世界的人是很容易忽<br>略的 Objective-C 语言的特性之一。原因就是尽管 Objective-C 是一门几个小时之内入门的语言，但是投身 Cocoa 的新手们会花费大量时间在 Cocoa 框架中，试图搞清楚他到底是怎么工作的。<a id="more"></a> 我觉得每个开发者都应该对其有深入的了解，明白一些内部的实现细节，而不仅仅只知道代码 <code>[target doMethodWith:var]</code> 会被编译器转换成 <code>objc_msgSend(target,@selector(doMethodWith:),var1);</code> 而已。了解 Objective-C 运行时的原理有助于你对 Objective-C 语言有更深入的理解，清楚你得 App 是怎么运行的。我觉得这对无论是 Mac/iPhone 新手或者老手都会有所帮助。</p><p>[TOC]</p><h4 id="Objective-C运行时是开源的"><a href="#Objective-C运行时是开源的" class="headerlink" title="Objective-C运行时是开源的"></a>Objective-C运行时是开源的</h4><p>Objective-C 运行时是开源的，你可以随时从 <a href="http://opensource.apple.com" target="_blank" rel="noopener">Apple</a> 获取到。实际上查看 Objective-C 运行时源码是我搞清楚这个语言是怎么运作的首选方法，而不是去查看和它相关的苹果文档。你可以到<a href="http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz" target="_blank" rel="noopener">这里</a> 下载到运行时的源码（截止到译者翻译的时候，最新版本的文件是objc4-647.tar.gz）。</p><h4 id="动态-Vs-静态"><a href="#动态-Vs-静态" class="headerlink" title="动态 Vs. 静态"></a>动态 Vs. 静态</h4><p>Objective-C 是一门动态的面向对象语言，这意味着它可以将编译链接时决定的事情推迟到运行时进行。这就给了你很大的灵活性，你可以按照自己的需要重定向消息到适当的对象上，你甚至可以交换方法实现（译者注：method swizzling，方法调配，开发者常用此技术向原有实现中添加新功能）。而运行时可以使对象明白自己可以响应哪些消息，不能响应哪些消息（译者注：introspect 内省），并正确的派发消息。</p><blockquote><p>译者注： 内省（introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。</p><p>参考: <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Introspection/Introspection.html" target="_blank" rel="noopener">Objective-C 的 Introspection</a></p></blockquote><p>我们将这些特征和C语言进行对比来看，在C中，你从<code>main()</code>函数开始，然后按顺序从上往下写你的代码逻辑或者执行函数方法。C结构体是无法将请求转发到其他目标对象来执行方法的。你很可能写了如下类似的代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt; stdio.h &gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv[]) &#123;</span><br><span class="line">    printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器解析、优化然后将优化后的代码转换成如下的汇编语言：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line"> .align <span class="number">4</span>,<span class="number">0x90</span></span><br><span class="line"> .globl _main</span><br><span class="line">_main:</span><br><span class="line">Leh_func_begin1:</span><br><span class="line"> pushq %rbp</span><br><span class="line">Llabel1:</span><br><span class="line"> movq %rsp, %rbp</span><br><span class="line">Llabel2:</span><br><span class="line"> subq $<span class="number">16</span>, %rsp</span><br><span class="line">Llabel3:</span><br><span class="line"> movq %rsi, %rax</span><br><span class="line"> movl %edi, %ecx</span><br><span class="line"> movl %ecx, <span class="number">-8</span>(%rbp)</span><br><span class="line"> movq %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line"> xorb %al, %al</span><br><span class="line"> leaq LC(%rip), %rcx</span><br><span class="line"> movq %rcx, %rdi</span><br><span class="line"> call _printf</span><br><span class="line"> movl $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line"> movl <span class="number">-4</span>(%rbp), %eax</span><br><span class="line"> addq $<span class="number">16</span>, %rsp</span><br><span class="line"> popq %rbp</span><br><span class="line"> ret</span><br><span class="line">Leh_func_end1:</span><br><span class="line"> .cstring</span><br><span class="line">LC:</span><br><span class="line"> .asciz <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure><p>然后将其和C库链接生成可执行文件。相比之下，Objective-C语言整个过程和上面类似，不过代码的产生依赖Objective-C运行时的具体表现（译者注：运行时按照不同情况，生成不同的代码吧）。当我们刚接触Objective-C语言的时候，我们可能被告知像如下代码</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> doSomethingWithVar:var1];</span><br></pre></td></tr></table></figure><p>会被转换成</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc_msgSend(<span class="keyword">self</span>,<span class="keyword">@selector</span>(doSomethingWithVar:),var1);</span><br></pre></td></tr></table></figure><p>而除了这些，我们似乎就不清楚运行时还干了什么。</p><h4 id="什么是-Objective-C-运行时？"><a href="#什么是-Objective-C-运行时？" class="headerlink" title="什么是 Objective-C 运行时？"></a>什么是 Objective-C 运行时？</h4><p>Objective-C Runtime 是一个运行时库，主要是由C语言和汇编语言写成，为 C 语言添加面向对象的能力而创造了 Objective-C（译者注：正是 OC Runtime，才有 OC 这门语言）。这意味着它可以加载类信息，进行方法派发以及方法转发等等。Objective-C 运行时最重要的就是为Objective-C语言的面向对象特性的实现提供了所有的基础支撑。</p><h4 id="Objective-C-运行时术语"><a href="#Objective-C-运行时术语" class="headerlink" title="Objective-C 运行时术语"></a>Objective-C 运行时术语</h4><p>在我们进一步了解整个运行时之前，需要先了解一些接下来出现的术语。截至目前Mac和iPhone的开发者关心的有两个运行时：Modern Runtime &amp; Legacy Runtime 。前者覆盖所有64位Mac OS X 的app和所有的iOS app，后者覆盖其余的（全部的Mac OS X 32位 App）。关于方法，这里有两种基本类型的方法，一种是实例方法（’-‘开头， 例如<code>-(void)doFoo</code>，作用于对象实例），另一种是类方法（’+’开头，例如<code>+(id)alloc</code>）。方法就像C语言中的函数类似，一段代码完成一个小的任务，如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)movieTitle &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"Futurama: Into the Wild Green Yonder"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Selector</strong><br>Objective-C中的Selector（选择子）是一个重要的C数据结构，用以标识你要一个对象执行的Objective-C方法。在运行时中，Selector的定义应该和下面这样类似：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector  *SEL;</span><br></pre></td></tr></table></figure><p>用法就像下面这样：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">SEL aSel = <span class="keyword">@selector</span>(movieTitle);</span><br></pre></td></tr></table></figure><p><strong>Message</strong></p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[target getMovieTitleForObject:obj];</span><br></pre></td></tr></table></figure><p>Objective-C中的方法由两个方括号[]组成，括号中间是你将要将消息发往的目标对象和你将要该对象执行的方法以及所需要发送的参数列表。Objective-C中的消息和C函数类似，但是又不同。你向一个对象发送消息并不意味着该对象就一定会执行它。这个对象会检查该消息的发送者，然后基于该发送者要么执行一个不同的方法或者将该消息转发给另外的不同的对象。</p><p><strong>Class</strong><br>如果你看过Runtime中关于类的定义信息，你可能会遇到这样的定义：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><p>这其中有一些事情要注意。<br>每一个Objective-C类拥有一个结构体，每一个对象也有一个结构体。所有的对象都包含一个isa指针。所有的Objective-C运行时需要这个isa指针，用以检查一个对象具体的类型是什么，然后判别其是否能够响应你所派发过来的消息。<br>最后我们还注意到了id指针，这个id指针仅仅告诉我们其指向的是Objective-C对象，仅此而已。当你拥有一个id指针，你可以查询该对象的类型，然后查看该类型是否可以响应某个方法等等。还有就是当你知道了当前所指向的具体对象的具体类别，你就可以做出更具体的动作。</p><p><strong>Blocks</strong></p><p>你也可以在LLVM/Clang文档中对Blocks 的定义中发现和上面类似的东西。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_literal_1 &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved; <span class="comment">// NULL</span></span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;  <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line">         <span class="comment">// optional helper functions</span></span><br><span class="line">         <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">         <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src); </span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Blocks被设计成能够与Objective-C运行时兼容，因此它们可以被当做对象处理，并可以响应消息（像<code>-retain</code>, <code>-release</code>, <code>-copy</code>等）。</p><p><strong>IMP</strong>（Method Implementations）</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,...);</span><br></pre></td></tr></table></figure><p>IMP是编译器生成的函数指针，指向方法执行处。如果你刚接触Objective-C语言，你不需要直接和这些东西打交道，但是慢慢深入之后接触的就多了。后面我们会看到这也是Objective-C运行时唤醒方法的方式。</p><p><strong>Objective-C Classes</strong></p><p>Objective-C 的类内部有些什么东西呢？一个Objective-C的类的样子大体如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vars</span></span><br><span class="line">    <span class="built_in">NSInteger</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// methods</span></span><br><span class="line">-(<span class="keyword">void</span>)doFoo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>但是运行时还会追加更多的内容以便跟踪（类每一时刻的状态）。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>我们可以看到一个类中包含一个指向其父类的引用，该类的名字、实例变量、方法集合、缓存以及该类遵循的协议列表。运行时需要这些信息以便响应那些分发到该类或者类实例对象上得方法。</p><h4 id="因此类定义了对象而不是对象本身，那这又是如何实现的？"><a href="#因此类定义了对象而不是对象本身，那这又是如何实现的？" class="headerlink" title="因此类定义了对象而不是对象本身，那这又是如何实现的？"></a>因此类定义了对象而不是对象本身，那这又是如何实现的？</h4><p>正如我前面说过的，Objective-C类本身也同样是对象（译者注：意味着你可以向一个类发送消息），运行时通过创建元类来处理它们。当你发送类似<code>[NSObject alloc]</code>的消息时，你实际上是向类对象发送了消息，而这个类对象需要是<strong>元类</strong>的实例，而元类本身又是<strong>根元类</strong>的一个实例。<br>当你说一个类继承自NSObject，那就意味着你的类指向NSObject作为其父类。而所有的元类指向根元类作为它们的父类，所有的元类都仅包含那些它能够响应的消息中的类方法。所以当你向一个类对象发送消息，例如<code>[NSObject alloc]</code>的时候，<code>objc_msgSend()</code>实际上会查看元类来确定该对象是否能够响应该消息，那如果找到了一个能响应该消息的方法，就在该对象上执行它。</p><blockquote><p>译者注：Objective-C类体系结构图如下所示：<img src="https://i.imgur.com/D7GUGKB.png" alt="ios-runtime-class"></p></blockquote><h4 id="为什么我们都要继承自Apple的类呢？"><a href="#为什么我们都要继承自Apple的类呢？" class="headerlink" title="为什么我们都要继承自Apple的类呢？"></a>为什么我们都要继承自Apple的类呢？</h4><p>当你刚踏入Cocoa开发的时候，很多代码例子都告诉你这样做：先继承NSObject类然后再进行其他编码。你也乐在其中，确实享受到了很多继承自Apple类所提供的便利。但是你甚至可能都没有发现实际上你的类在和Objective-C运行时打交道。当你为我们的类实例化的时候，像这样：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyObject *object = [[MyObject alloc] init];</span><br></pre></td></tr></table></figure><p>第一个你要执行的消息就是<code>+alloc</code>。如果你[查看文档][6]，里面会讲到“一个新生实例的isa实例会被初始化为一个描述该类信息的数据结构，其余的实例变量的内存均被设置为空。”所以通过继承自Apple的类，我们不仅继承了一些很棒的属性，同时也继承了这些在内存上分配空间（大小是我们类的大小），创建对象的能力（就是创建运行时所期望的带有isa指针的数据结构）。</p><h4 id="类缓存（objc-cache-cache）是什么？"><a href="#类缓存（objc-cache-cache）是什么？" class="headerlink" title="类缓存（objc_cache* cache）是什么？"></a>类缓存（objc_cache* cache）是什么？</h4><p>当Objective-C运行时通过一个对象的isa指针检查对象的时候，它会找到能够执行很多方法的类。然后你只需要调用其中很小一部分，所以每次运行时在进行一次查询动作时需要查找类分发表中所有的selectors这个动作是毫无意义的。这就是为什么类会由cache这个东西，当你查询一个类体系中的派发表的时候，一旦找到对应的selector时，就将该selector放到cache中。当<code>objc_msgSend()</code>方法在一个类中查询selector时，会先在cache中查找，这个理论的基础就是如果你曾经调用过一个类的消息，你有很大可能在之后还调用同样的方法。（译者注：CACHE的局部性原理）。所以按照这样考虑，如果我们先在有一个NSObject的子类MyObject如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">-(<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setVarA:@”blah”];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>具体发生了以下几点：</p><ol><li><code>[MyObject alloc]</code>首先被执行，MyObject类没有实现该方法，因此在该类中没有找到<code>+alloc</code>方法，接着顺着superclass指针找到其父类<code>NSObject</code>；</li><li>我们询问<code>NSObject</code>类是否能够响应<code>+alloc</code>方法，而它能够响应。<code>+alloc</code>方法检查接受者类（也就是<code>MyObject</code>），分配该类大小的一块内存空间，然后初始化其isa指针指向<code>MyObject</code>类，此时我们拥有一个实例了，同时稍早我们将<code>+alloc</code>方法放置于<code>NSObject</code>的类缓存（cache）中；</li><li>到目前为止，我们都是在发送类方法，此刻我们需要向一个实例对象发送消息，这里简单的调用<code>-init</code>方法或者指定初始化方法（designated initializer），当然我们的类实现了该方法，因此我们将<code>-(id)init</code>方法放置于cache中；</li><li>接下来<code>self = [super init]</code>被调用，<code>super</code>是一个神奇的关键字（<strong>magic keyword</strong>），其指向类的父类，也即<code>NSObject</code>，我们调用<code>NSObject</code>的<code>init</code>方法。这样做的目的是为了确保面向对象编程的集成体系能够正确运行，在你正确初始化自身变量之前需要先初始化该类的所有父类的变量，如果你需要，你还可以覆写父类的方法。在该例中，对于NSObject类来说并没有多少特别重要的操作要进行，不过这并不是常态。有时候初始化中会做非常重要的事情，考虑以下代码：</li></ol><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt; Foundation/Foundation.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *aString;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSString</span> *aString;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">      [<span class="keyword">self</span> setAString:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@synthesize</span> aString;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> * pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> obj1 = [<span class="built_in">NSMutableArray</span> alloc];</span><br><span class="line">    <span class="keyword">id</span> obj2 = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> obj3 = [<span class="built_in">NSArray</span> alloc];</span><br><span class="line">    <span class="keyword">id</span> obj4 = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"Hello"</span>,<span class="literal">nil</span>];</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj1 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj1 <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj2 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj2 <span class="keyword">class</span>]));</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj3 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj3 <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj4 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj4 <span class="keyword">class</span>]));</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">id</span> obj5 = [MyObject alloc];</span><br><span class="line">    <span class="keyword">id</span> obj6 = [[MyObject alloc] init];</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj5 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj5 <span class="keyword">class</span>]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj6 class is %@"</span>,<span class="built_in">NSStringFromClass</span>([obj6 <span class="keyword">class</span>]));</span><br><span class="line">          </span><br><span class="line">    [pool drain];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你是刚刚接触Cocoa，我让你猜以上代码打印结果是什么，你很可能会给出这样的结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> </span><br><span class="line"><span class="built_in">NSArray</span></span><br><span class="line"><span class="built_in">NSArray</span></span><br><span class="line">MyObject</span><br><span class="line">MyObject</span><br></pre></td></tr></table></figure><p>但实际上是如下结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">obj1 <span class="keyword">class</span> is __NSPlaceholderArray</span><br><span class="line">obj2 <span class="keyword">class</span> is <span class="built_in">NSCFArray</span></span><br><span class="line">obj3 <span class="keyword">class</span> is __NSPlaceholderArray</span><br><span class="line">obj4 <span class="keyword">class</span> is <span class="built_in">NSCFArray</span></span><br><span class="line">obj5 <span class="keyword">class</span> is MyObject</span><br><span class="line">obj6 <span class="keyword">class</span> is MyObject</span><br></pre></td></tr></table></figure><blockquote><p>译者注：（本机XCode 7 beta6 运行结果如下：）</p></blockquote><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">43</span>:<span class="number">06.922</span> ObjMessage[<span class="number">5185</span>:<span class="number">1441448</span>] obj1 <span class="keyword">class</span> is __NSPlaceholderArray</span><br><span class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">43</span>:<span class="number">11.201</span> ObjMessage[<span class="number">5185</span>:<span class="number">1441448</span>] obj2 <span class="keyword">class</span> is __NSArrayM</span><br><span class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">43</span>:<span class="number">17.987</span> ObjMessage[<span class="number">5185</span>:<span class="number">1441448</span>] obj3 <span class="keyword">class</span> is __NSPlaceholderArray</span><br><span class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">43</span>:<span class="number">18.503</span> ObjMessage[<span class="number">5185</span>:<span class="number">1441448</span>] obj4 <span class="keyword">class</span> is __NSArrayI</span><br><span class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">43</span>:<span class="number">32.228</span> ObjMessage[<span class="number">5185</span>:<span class="number">1441448</span>] obj5 <span class="keyword">class</span> is MyObject</span><br><span class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-07</span> <span class="number">13</span>:<span class="number">43</span>:<span class="number">33.478</span> ObjMessage[<span class="number">5185</span>:<span class="number">1441448</span>] obj6 <span class="keyword">class</span> is MyObject</span><br></pre></td></tr></table></figure><p>原因就是Objective-C语言这里使用<code>+alloc</code>方法返回某个类的对象，但随后<code>-init</code>方法又可能返回另一个类的对象。</p><h4 id="那-objc-msgSend-方法都发生了什么呢？"><a href="#那-objc-msgSend-方法都发生了什么呢？" class="headerlink" title="那 objc_msgSend 方法都发生了什么呢？"></a>那 objc_msgSend 方法都发生了什么呢？</h4><p>实际上<code>objc_msgSend()</code>方法内部发生了许多事情。如下我们有这样的代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> printMessageWithString:<span class="string">@"Hello World!"</span>];</span><br></pre></td></tr></table></figure><p>编译器会把其翻译成如下所示代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">objc_msgSend(<span class="keyword">self</span>, <span class="keyword">@selector</span>(printMessageWithString:), <span class="string">@"Hello World!"</span>);</span><br></pre></td></tr></table></figure><p>我们通过目标对象的isa指针来查询该类或者其继承体系中的父类是否能够响应 <code>@selector(printMessageWithString:)</code>。假设我们在类的派发表或者它的cache中找到了该selector，然后我们通过该函数指针来执行该方法。因此我们可以了解<code>objc_msgSend()</code>方法永远不会返回，它从执行开始，通过指针查找到你的方法执行，然后是你的方法执行之后返回，因此看起来好像<code>objc_msgSend()</code>方法返回似的。Bill Bumgarner对此过程有更多的细节探索（<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map" target="_blank" rel="noopener">Part 1</a>, <a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path" target="_blank" rel="noopener">Part 2</a> &amp; <a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage" target="_blank" rel="noopener">Part 3</a>）。</p><p>我这里总结下他所讲的，也就是你会在运行时代码中看到的：</p><ol><li><p>检查那些忽略掉的Selectors和Short Circut， 很明显如果我们运行在垃圾回收环境下，我们可以忽略掉针对<code>-retain</code>，<code>-release</code>等的调用；</p></li><li><p>检查那些nil的目标。不像其他语言，Objective-C中向nil派发消息是合法的。当然你肯定也有很多理由希望这样。这里假设我们有一个非空的目标；</p></li><li><p>接下来我们需要在该类中找到IMP，我们首先查找该类的缓存（cache），如果找到我们便通过缓存中的指针跳转到该函数执行处；</p></li><li><p>如果缓存中没有找到该IMP，我们便紧接着查找类的派发表（dispatch table），如果找到同样跳转到函数执行处；</p></li><li><p>如果类的派发表中也未找到我们就需要触发消息分发机制了，这意味着最终你得代码会被编译器转换成了C函数。因此一个如下方法：</p></li></ol><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">int</span>)doComputeWithNum:(<span class="keyword">int</span>)aNum</span><br></pre></td></tr></table></figure><p>会被转换成如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aClass_doComputeWithNum(aClass *<span class="keyword">self</span>,SEL _cmd,<span class="keyword">int</span> aNum)</span><br></pre></td></tr></table></figure><p>Objective-C运行时通过触发指向这些方法的函数指针来调用你的方法。告诉你，你没法直接调用这些转换之后的方法，尽管Cocoa框架确实提供了能够获取这些指针的方法。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//declare C function pointer</span></span><br><span class="line"><span class="keyword">int</span> (computeNum *)(<span class="keyword">id</span>,SEL,<span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//methodForSelector is COCOA &amp; not ObjC Runtime</span></span><br><span class="line"><span class="comment">//gets the same function pointer objc_msgSend gets</span></span><br><span class="line">computeNum = (<span class="keyword">int</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">int</span>))[target methodForSelector:<span class="keyword">@selector</span>(doComputeWithNum:)];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//execute the C function pointer returned by the runtime</span></span><br><span class="line">computeNum(obj,<span class="keyword">@selector</span>(doComputeWithNum:),aNum);</span><br></pre></td></tr></table></figure><p>通过这个方法，你可以获取到在运行时直接获取该方法并调用它。甚至在你确认一个指定的方法需要被执行的时候可以绕过运行时机制。这也是Objective-C运行时如何调用你的方法的，但还是使用<code>objc_msgSend()</code>方法为好。</p><h4 id="Objective-C-消息转发"><a href="#Objective-C-消息转发" class="headerlink" title="Objective-C 消息转发"></a>Objective-C 消息转发</h4><p>在Objective-C中，向一个根本不知道怎么响应方法的对象发送方法是合法的（也可能是该语言内部设计哲理）。Apple这样做的其中一个原因就是模拟Objective-C语言原生不支持的多重继承。或者你也许想抽象化自己的设计，隐藏该消息响应背后的其他类或者对象。这对于运行时系统也是非常必要的。它的工作流程大体是这样：</p><ol><li><p>运行时在该类或者其继承体系中的缓存中和派发表中查找，然后查找失败；</p></li><li><p>Objective-C运行时在所属对象的类上调用<code>+ (BOOL) resolveInstanceMethod:(SEL)aSEL</code>类方法，该类给予你一次机会来新增一个处理选择子<code>aSEL</code>的方法，然后告诉运行时你已经解决了该方法，消息转发机制会找到该方法。</p></li></ol><p>如下示例，你定义了一个函数：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing Foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用<code>class_addMethod()</code>方法类解决它：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    <span class="keyword">if</span>(aSEL == <span class="keyword">@selector</span>(doFoo:)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>],aSEL,(IMP)fooMethod,<span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中方法<code>class_addMethod()</code>中的<code>v@:</code>标明了方法的返回类型以及其参数类型。你可以在运行时文档中[Type Encodings][10]分查看到详细的说明。</p><ol start="3"><li>如果2中<code>+(BOOL)resolveInstanceMethod:(SEL)aSEL</code>返回NO表示无法解析该方法的话，运行时接着调用<code>- (id)forwardingTargetForSelector:(SEL) aSelector</code>来给你再一次机会是否能够将该消息转发给其他接收者来处理。这要比之后运行完整的消息转发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>要好。你可以这样执行：</li></ol><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:)) &#123;</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，你肯定不想返回 self，否则会引起死循环。</p><ol start="4"><li>如果上一步没有找到合适的目标对象来执行上面的消息，接着运行时会尝试最后一步 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>。你可能没见过NSInvocation，它实际上是Objective-C语言中的消息类型。一旦你有一个NSInvocation，你基本上能够改变这个消息的任何东西，包括其目标、选择子以及参数。所以你可以这样做：</li></ol><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    SEL invSEL = invocation.selector;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>([altObject respondsToSelector:invSEL]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:altObject];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:invSEL];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，如果你继承自NSObject类，它所实现的<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>内部仅仅简单的调用了<code>-doesNotRecognizeSelector:</code>方法，如果你想给自己最后一次机会做一些事情的话，你可以重载该方法。</p><h4 id="Non-Fragile-ivars-Modern-Runtime"><a href="#Non-Fragile-ivars-Modern-Runtime" class="headerlink" title="Non Fragile ivars (Modern Runtime)"></a>Non Fragile ivars (Modern Runtime)</h4><p>一个Modern Runtime新增加的概念就是Non Fragile ivars。当编译器编译我们的类时，编译器会生成一个变量布局来显示每次我们从什么位置去取我们的实例变量，其底层的实现细节是这样的，查看类成员变量和类对象指针指向位置的偏移，读取该变量大小的字节就可以将该变量读取出来。所以你得变量布局可能如下所示，左侧列标明字节偏移量：</p><p><img src="https://i.imgur.com/35waSjN.png" alt="NSObject 布局"></p><p>这里我们有NSObject类型的变量布局，然后我们继承NSObject来扩展它，并添加自己的变量，这在Apple发布新版本OSX SDK之前都运行良好。</p><p><img src="https://i.imgur.com/xPo1FAw.png" alt="NSObject 布局"></p><p>我们的代码就无法正常运行，我们自定义对象中的内容被擦出了，因为NSObject增加了两个成员变量，而MyObject类成员变量布局在编译时已经确定，有两个成员变量和基类的内存区域重叠。唯一能够阻止这个发生的就是Apple维持它之前的布局策略，但是一旦这样他们的框架就无法再往前发展了，因为它们的变量布局已经固化了。在这种情况下（也就是fragile ivars）你只能通过重新编译这些继承自Apple类的类来使得代码得以兼容。那在 non fragile ivars下会发生什么呢？</p><p><img src="https://i.imgur.com/w9Fxvpa.png" alt="NSObject 布局"></p><p>在Non Fragile ivars下编译器虽然生成了和fragile ivars同样的布局，但是运行时会通过计算基类大小，动态调整MyObject类成员布局。结果如上图所示。</p><h4 id="Objective-C-关联对象"><a href="#Objective-C-关联对象" class="headerlink" title="Objective-C 关联对象"></a>Objective-C 关联对象</h4><p>最近引入Mac OS X 10.6系统有一个特性称作“关联引用”。Objective-C不像其他语言，其原生不支持向对象动态添加变量。所以到目前为止，你都必须要费很大的劲，编译整个体系结构来假装自己向类中添加一个变量。不过在Mac OS X 10.6系统中，Objective-C 运行时原生支持（动态添加变量）。如果我们想向每一个已经存在的类中添加一个变量，例如向NSView类中添加，如下所示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt; Cocoa/Cocoa.h&gt;</span> //Cocoa</span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt; objc/runtime.h&gt;</span> //objc runtime api’s</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSView</span> (<span class="title">CustomAdditions</span>)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSImage</span> *customImage;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSView</span> (<span class="title">CustomAdditions</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> img_key; <span class="comment">//has a unique address (identifier)</span></span><br><span class="line"> </span><br><span class="line">-(<span class="built_in">NSImage</span> *)customImage &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,&amp;img_key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(<span class="keyword">void</span>)setCustomImage:(<span class="built_in">NSImage</span> *)image &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,&amp;img_key,image,</span><br><span class="line">                             OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>你可以在[runtime.h][11]，（译者注：最新版 [runtime.h][12]）文件中看到向<code>objc_setAssociatedObject()</code>传递的几个选项：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Associative References */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Policies related to associative references.</span></span><br><span class="line"><span class="comment"> * These are options to objc_setAssociatedObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些和你通过<code>@property</code>方式传递的选项相吻合。</p><h4 id="混合的虚表派生"><a href="#混合的虚表派生" class="headerlink" title="混合的虚表派生"></a>混合的虚表派生</h4><p>如果你查看Modern runtime 代码，你会在<a href="">objc-runtime-new.m</a>（译者注： 最新版objc runtime源码为[objc-runtime-new.mm][14] 已经去掉了这个特性，译者发现从[objc4-551.1][15]版本开始就不支持了，不过读者还是可以借鉴下之前版本的实现方式。）中发现这个：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* vtable dispatch</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Every class gets a vtable pointer. The vtable is an array of IMPs.</span></span><br><span class="line"><span class="comment">* The selectors represented in the vtable are the same for all classes</span></span><br><span class="line"><span class="comment">*   (i.e. no class has a bigger or smaller vtable).</span></span><br><span class="line"><span class="comment">* Each vtable index has an associated trampoline which dispatches to </span></span><br><span class="line"><span class="comment">*   the IMP at that index for the receiver class's vtable (after </span></span><br><span class="line"><span class="comment">*   checking for NULL). Dispatch fixup uses these trampolines instead </span></span><br><span class="line"><span class="comment">*   of objc_msgSend.</span></span><br><span class="line"><span class="comment">* Fragility: The vtable size and list of selectors is chosen at launch </span></span><br><span class="line"><span class="comment">*   time. No compiler-generated code depends on any particular vtable </span></span><br><span class="line"><span class="comment">*   configuration, or even the use of vtable dispatch at all.</span></span><br><span class="line"><span class="comment">* Memory size: If a class's vtable is identical to its superclass's </span></span><br><span class="line"><span class="comment">*   (i.e. the class overrides none of the vtable selectors), then </span></span><br><span class="line"><span class="comment">*   the class points directly to its superclass's vtable. This means </span></span><br><span class="line"><span class="comment">*   selectors to be included in the vtable should be chosen so they are </span></span><br><span class="line"><span class="comment">*   (1) frequently called, but (2) not too frequently overridden. In </span></span><br><span class="line"><span class="comment">*   particular, -dealloc is a bad choice.</span></span><br><span class="line"><span class="comment">* Forwarding: If a class doesn't implement some vtable selector, that </span></span><br><span class="line"><span class="comment">*   selector's IMP is set to objc_msgSend in that class's vtable.</span></span><br><span class="line"><span class="comment">* +initialize: Each class keeps the default vtable (which always </span></span><br><span class="line"><span class="comment">*   redirects to objc_msgSend) until its +initialize is completed.</span></span><br><span class="line"><span class="comment">*   Otherwise, the first message to a class could be a vtable dispatch, </span></span><br><span class="line"><span class="comment">*   and the vtable trampoline doesn't include +initialize checking.</span></span><br><span class="line"><span class="comment">* Changes: Categories, addMethod, and setImplementation all force vtable </span></span><br><span class="line"><span class="comment">*   reconstruction for the class and all of its subclasses, if the </span></span><br><span class="line"><span class="comment">*   vtable selectors are affected.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br></pre></td></tr></table></figure><p>这背后的原理就是，运行时试图去存储你最近调用过的选择子（selector）以便能够为你的App加速，因为其比<code>objc_msgSend</code>方法使用更少的指令。这个<code>vTable</code>存储你最近全局调用的16个选择子，实际上，在代码文件往下接着看你就会看到垃圾回收和非垃圾回收类型的App的默认选择子（selectors）。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtable[] = &#123;</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"retain"</span>, </span><br><span class="line">    <span class="string">"release"</span>, </span><br><span class="line">    <span class="string">"autorelease"</span>, </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> defaultVtableGC[] = &#123;</span><br><span class="line">    <span class="string">"allocWithZone:"</span>, </span><br><span class="line">    <span class="string">"alloc"</span>, </span><br><span class="line">    <span class="string">"class"</span>, </span><br><span class="line">    <span class="string">"self"</span>, </span><br><span class="line">    <span class="string">"isKindOfClass:"</span>, </span><br><span class="line">    <span class="string">"respondsToSelector:"</span>, </span><br><span class="line">    <span class="string">"isFlipped"</span>, </span><br><span class="line">    <span class="string">"length"</span>, </span><br><span class="line">    <span class="string">"objectForKey:"</span>, </span><br><span class="line">    <span class="string">"count"</span>, </span><br><span class="line">    <span class="string">"objectAtIndex:"</span>, </span><br><span class="line">    <span class="string">"isEqualToString:"</span>, </span><br><span class="line">    <span class="string">"isEqual:"</span>, </span><br><span class="line">    <span class="string">"hash"</span>, </span><br><span class="line">    <span class="string">"addObject:"</span>, </span><br><span class="line">    <span class="string">"countByEnumeratingWithState:objects:count:"</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="因此你如何能知道你正在和它打交道呢？"><a href="#因此你如何能知道你正在和它打交道呢？" class="headerlink" title="因此你如何能知道你正在和它打交道呢？"></a>因此你如何能知道你正在和它打交道呢？</h4><p>当你进行调试的时候，你会在你的调试栈中看到稍后讲解到的某些方法的身影。你就把这些方法按照<code>objc_msgSend()</code>方法来对待就行，不过这些方法都是为了调试，具体有如下几个方法。</p><ol><li><p>当运行时正在将你所有调用的这些方法中的其中一个插入到虚表（vTable）中时，会调用<code>objc_msgSend_fixup</code>。</p></li><li><p>而当<code>objc_msgSend_fixedup</code>发生时，表明你当前所调用的一个方法本应该存在于虚表中<code>objc_msgSend_vtable[0-15]</code>的位置，但却并不在</p></li><li><p>你可能会看到<code>objc_msgSend_vtable5</code>类似的东西，其意味着你正在调用虚表中的一个方法。运行时可以根据需要动态调整虚表中的内容。因此你不应该期望这次代码循环调用的<code>objc_msgSend_vtable10</code>对应了<code>-length</code>方法，而之后每次代码循环还依然会这样。（因为vTable也在不断变化中）</p></li></ol><p>译者注：参考<a href="http://www.sealiesoftware.com/blog/archive/2011/06/17/objc\_explain\_objc\_msgSend\_vtable.html" target="_blank" rel="noopener">[objc explain]: objc_msgSend_vtable</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我希望你们能够喜欢以上这些东西，这篇文章主要讲述了我和Des Moines Cocoaheads关于Objective-C runtime的谈话（我们的讨论估计能打包一箩筐）。Objective-C Runtime是一项很了不起的工程，它为我们Cocoa/Objective-C下制作的Apps注入能量，使得我们能够实现很多我们认为理所当然的特性。希望你能够看一看Apple官方文档对Objective-C运行时的讲解，这样能够使你更好的利用Objective-C运行时。谢谢。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a><br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="noopener">Objective-C Runtime Reference</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://hechen.xyz/2015/09/07/Understanding-the-Objective-C-Runtime/">http://hechen.xyz/2015/09/07/Understanding-the-Objective-C-Runtime/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/Objective-C/">Objective-C</a><a class="post-meta__tags" href="/tags/Runtime/">Runtime</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2015/09/14/Objective-C中Category的一点东西/"><i class="fa fa-chevron-left"></i><span>Objective-C中Category的一点东西</span></a></div><div class="next-post pull-right"><a href="/2015/09/01/How-We-Created-Guillotine-Menu-Animation-for-iOS/"><span>我们是如何创建iOS版的Guillotine菜单动画的</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused=null,disqus_config=function(){this.page.url="http://hechen.xyz/2015/09/07/Understanding-the-Objective-C-Runtime/",this.page.identifier="2015/09/07/Understanding-the-Objective-C-Runtime/",this.page.title="理解Objective-C运行时"},d=document,s=d.createElement("script");s.src="https://stoneman.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script id="dsq-count-src" src="https://stoneman.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2019 By Chen</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>