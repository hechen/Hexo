<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="如何使用UIBezierPath实现一个弹性视图动画"><meta name="keywords" content="iOS,Swift,Objective-C,Animation"><meta name="author" content="Chen,undefined"><meta name="copyright" content="Chen"><title>如何使用UIBezierPath实现一个弹性视图动画 | Writing, Thinking and Coding.</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b8b088e1ebab51ca1f8e3c11ac0476a1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解业务逻辑"><span class="toc-number">1.</span> <span class="toc-text">理解业务逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Build"><span class="toc-number">2.</span> <span class="toc-text">Build</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200"></div><div class="author-info__name text-center">Chen</div><div class="author-info__description text-center">I do stuff.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image:url(true)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Writing, Thinking and Coding.</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">如何使用UIBezierPath实现一个弹性视图动画</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-05-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/翻译/">翻译</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2015/12/02/Elastic-view-animation-using-UIBezierPath/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2015/12/02/Elastic-view-animation-using-UIBezierPath/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2,776</span><span class="post-meta__separator">|</span><span>Reading time: 11 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote><p>翻译自：<a href="http://iostuts.io/2015/10/17/elastic-bounce-using-uibezierpath-and-pan-gesture/" target="_blank" rel="noopener">Elastic view animation using UIBezierPath</a><br>译者：<a href="http://weibo.com/hc2feifei" target="_blank" rel="noopener">@这个昵称有点萌</a></p></blockquote><p>Hey！<br><a href="https://github.com/gontovnik/DGElasticPullToRefresh" target="_blank" rel="noopener">DGElasticPullToRefresh</a>展示如何实现一个弹性效果。效果如下图所示：</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshDGElasticPullToRefresh1.gif" alt="DGElasticPullToRefresh.gif"></p><a id="more"></a><p>开发环境：<br>Xcode 7<br>Swift 2.0</p><p>要求：<br>开发者至少对UIBezierPath和UIGestureRecognizer有一定的了解.</p><h3 id="理解业务逻辑"><a href="#理解业务逻辑" class="headerlink" title="理解业务逻辑"></a>理解业务逻辑</h3><p>你可能从上面的效果图上可以看到一些端倪，这个动画中我们主要使用到了UIBezierPath来实现上面这种效果。<br>我们首先创建一个贝塞尔曲线路径的CAShapeLayer，然后当你的手指在屏幕上移动的时候我们将移动所有的控制点来呈现动画。每一个控制点会使用一个可见的UIView来表示。下面有几张图来演示它们是如何工作的，我将所有的控制点标识成了红色：<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints1.png" alt="ControlPoints1"><br><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshControlPoints2.png" alt="ControlPoints2"></p><p>第二章图片中将每个表示控制点的View的变量名称标记出来了，如L3，L2等。</p><p>当你的手指释放的时候，我们就播放Spring动画，让所有的控制点向其初始位置以一定的回弹效果移动。当所有的视图在动画播放过程中，我们需要时刻计算并我们的贝塞尔曲线（每一帧都进行计算）。因此，我们准备使用CADisplayLink，CADisplayLink在主循环中运行而且每一帧都会去执行指定的方法。</p><blockquote><p>A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display. - Apple doc</p></blockquote><p>让我们开始Code吧~</p><hr><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><p>创建一个单视图控制器，然后将下面这些代码粘贴到viewController.swift文件的类声明中。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MARK: -</span><br><span class="line">// MARK: Vars</span><br><span class="line"></span><br><span class="line">private let minimalHeight: CGFloat = 50.0  </span><br><span class="line">private let shapeLayer = CAShapeLayer()</span><br><span class="line"></span><br><span class="line">// MARK: -</span><br><span class="line"></span><br><span class="line">override func loadView() &#123;  </span><br><span class="line">    super.loadView()</span><br><span class="line"></span><br><span class="line">    shapeLayer.frame = CGRect(x: 0.0, y: 0.0, width: view.bounds.width, height: minimalHeight)</span><br><span class="line">    shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br><span class="line">    view.layer.addSublayer(shapeLayer)</span><br><span class="line"></span><br><span class="line">    view.addGestureRecognizer(UIPanGestureRecognizer(target: self, action: &quot;panGestureDidMove:&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MARK: -</span><br><span class="line">// MARK: Methods</span><br><span class="line"></span><br><span class="line">func panGestureDidMove(gesture: UIPanGestureRecognizer) &#123;  </span><br><span class="line">    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        shapeLayer.frame.size.height = minimalHeight + max(gesture.translationInView(view).y, 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func preferredStatusBarStyle() -&gt; UIStatusBarStyle &#123;  </span><br><span class="line">    return .LightContent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，我们做的工作主要有以下几点：</p><ol><li>声明了两个变量：shapeLayer 和 minimalHeight。前者是用来表示贝塞尔曲线的，后者是用来定义shapeLayer最小的高度值；</li><li>将shapeLayer添加到view的layer中；</li><li>添加了一个pan手势到view中，并为该手势添加panGestureDidMove目标方法，当手指移动的时候就会被调用，我们在该方法中修改shapeLayer的高度；</li><li>重写父类的preferredStatusBarStyle方法来确保我们的UI更美观一些。</li></ol><p>然后编译你的程序，确保实现了以下效果：<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds1.gif" alt="Builds1"></p><p>每件事情都在按着我们期待的呈现，不过有一点瑕疵。那就是shapeLayer的高度变化有一定的延迟（动画），那是因为隐式动画的原因。我们确定不需要这样的动画，因此在将shapeLayer添加到view的sublayers中之前禁用该layer关于position、bounds以及path的隐式动画。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shapeLayer.actions = [&quot;position&quot; : NSNull(), &quot;bounds&quot; : NSNull(), &quot;path&quot; : NSNull()]</span><br></pre></td></tr></table></figure><p>然后再次运行，会看到延迟的动画效果没有了。</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds2.gif" alt="Builds2"></p><p>接下来，我们就需要将最开始所说的那些控制点（L3, L2, L1, C, R1, R2, R3）加入到程序里，然后加入必要的逻辑。</p><p>让我们一步一步来：</p><ul><li><p>首先，声明一个maxWaveHeight变量，定义这个变量的原因仅仅是希望让我们最终的效果好看一些而已。如果你不指定这个最大值，最终的效果会看起来很丑的；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private let maxWaveHeight: CGFloat = 100.0</span><br></pre></td></tr></table></figure></li><li><p>为我们的控制点视图声明变量；</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private let l3ControlPointView = UIView()  </span><br><span class="line">private let l2ControlPointView = UIView()  </span><br><span class="line">private let l1ControlPointView = UIView()  </span><br><span class="line">private let cControlPointView = UIView()  </span><br><span class="line">private let r1ControlPointView = UIView()  </span><br><span class="line">private let r2ControlPointView = UIView()  </span><br><span class="line">private let r3ControlPointView = UIView()</span><br></pre></td></tr></table></figure><ul><li>将上面定义的控制点视图设置为3*3的size，然后背景色设置为红色（这里我们只是暂时希望能够更方便演示，最终完成的时候会让它们不可见的），然后将这些控制点添加到View子视图中。将下面这些代码拷贝到loadView方法的尾部；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class="line">l2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class="line">l1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class="line">cControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class="line">r1ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class="line">r2ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)  </span><br><span class="line">r3ControlPointView.frame = CGRect(x: 0.0, y: 0.0, width: 3.0, height: 3.0)</span><br><span class="line"></span><br><span class="line">l3ControlPointView.backgroundColor = .redColor()  </span><br><span class="line">l2ControlPointView.backgroundColor = .redColor()  </span><br><span class="line">l1ControlPointView.backgroundColor = .redColor()  </span><br><span class="line">cControlPointView.backgroundColor = .redColor()  </span><br><span class="line">r1ControlPointView.backgroundColor = .redColor()  </span><br><span class="line">r2ControlPointView.backgroundColor = .redColor()  </span><br><span class="line">r3ControlPointView.backgroundColor = .redColor()</span><br><span class="line"></span><br><span class="line">view.addSubview(l3ControlPointView)  </span><br><span class="line">view.addSubview(l2ControlPointView)  </span><br><span class="line">view.addSubview(l1ControlPointView)  </span><br><span class="line">view.addSubview(cControlPointView)  </span><br><span class="line">view.addSubview(r1ControlPointView)  </span><br><span class="line">view.addSubview(r2ControlPointView)  </span><br><span class="line">view.addSubview(r3ControlPointView)</span><br></pre></td></tr></table></figure><ul><li>创建一个UIView的扩展，将其放到ViewController的声明上方；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension UIView &#123;  </span><br><span class="line">    func dg_center(usePresentationLayerIfPossible: Bool) -&gt; CGPoint &#123;</span><br><span class="line">        if usePresentationLayerIfPossible, let presentationLayer = layer.presentationLayer() as? CALayer &#123;</span><br><span class="line">            return presentationLayer.position</span><br><span class="line">        &#125;</span><br><span class="line">        return center</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当UIView从一帧到另外一帧进行动画的时候，你会试图去取得UIView.frame，而UIView.center会提供给你动画最终的值而不是每一帧的过渡值。因此我们需要定义一个扩展方法提供给我们UIView.layer.presentationLayer的实时位置；</p><blockquote><p>presentationLayer的详细信息可以在<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/#//apple_ref/occ/instm/CALayer/presentationLayer" target="_blank" rel="noopener">官方文档</a> 中查看</p></blockquote></li><li><p>声明一个currentPath()方法；</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private func currentPath() -&gt; CGPath &#123;  </span><br><span class="line">    let width = view.bounds.width</span><br><span class="line"></span><br><span class="line">    let bezierPath = UIBezierPath()</span><br><span class="line"></span><br><span class="line">    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))</span><br><span class="line">    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(false).y))</span><br><span class="line">    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(false), controlPoint1: l3ControlPointView.dg_center(false), controlPoint2: l2ControlPointView.dg_center(false))</span><br><span class="line">    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(false), controlPoint1: cControlPointView.dg_center(false), controlPoint2: r1ControlPointView.dg_center(false))</span><br><span class="line">    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(false), controlPoint1: r1ControlPointView.dg_center(false), controlPoint2: r2ControlPointView.dg_center(false))</span><br><span class="line">    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))</span><br><span class="line"></span><br><span class="line">    bezierPath.closePath()</span><br><span class="line"></span><br><span class="line">    return bezierPath.CGPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回shapeLayer当前的CGPath。它用到了我们前面所定义和讨论的控制点。</p><ul><li>声明updateShapeLayer方法；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func updateShapeLayer() &#123;  </span><br><span class="line">    shapeLayer.path = currentPath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This function will be called when we need shapeLayer to be updated. It is not a private func because we are going to use Selector() for CADisplayLink.</p><p>这个方法会在shapeLayer需要更新的时候调用。</p><ul><li>声明layoutControlPoints方法；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private func layoutControlPoints(baseHeight baseHeight: CGFloat, waveHeight: CGFloat, locationX: CGFloat) &#123;  </span><br><span class="line">    let width = view.bounds.width</span><br><span class="line"></span><br><span class="line">    let minLeftX = min((locationX - width / 2.0) * 0.28, 0.0)</span><br><span class="line">    let maxRightX = max(width + (locationX - width / 2.0) * 0.28, width)</span><br><span class="line"></span><br><span class="line">    let leftPartWidth = locationX - minLeftX</span><br><span class="line">    let rightPartWidth = maxRightX - locationX</span><br><span class="line"></span><br><span class="line">    l3ControlPointView.center = CGPoint(x: minLeftX, y: baseHeight)</span><br><span class="line">    l2ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.44, y: baseHeight)</span><br><span class="line">    l1ControlPointView.center = CGPoint(x: minLeftX + leftPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)</span><br><span class="line">    cControlPointView.center = CGPoint(x: locationX , y: baseHeight + waveHeight * 1.36)</span><br><span class="line">    r1ControlPointView.center = CGPoint(x: maxRightX - rightPartWidth * 0.71, y: baseHeight + waveHeight * 0.64)</span><br><span class="line">    r2ControlPointView.center = CGPoint(x: maxRightX - (rightPartWidth * 0.44), y: baseHeight)</span><br><span class="line">    r3ControlPointView.center = CGPoint(x: maxRightX, y: baseHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分可能需要解释下这些变量的职责：</p><ol><li>baseHeight - base的高度。 baseHeight + waveHeight = 我们所需要的总高度；</li><li>waveHeight - 曲线的波浪高度，我们前面的maxWaveHeight为其设定一个最大值；</li><li>locationX - 手指在视图中的位置的X坐标</li><li>width - 显而易见，我们视图的宽度；</li><li>minLeftX - 定义l3ControlPointView的坐标X值的最小值，这个值可以是负值；</li><li>maxRightX - 和minLeftX类似，定义r3ControlPointView的坐标X值的最大值；</li><li>leftPartWidth - 定义 minLeftX 和 locationX之间的距离；</li><li>rightPartWidth - 定义 locationX 和 maxRightX之间的距离；</li></ol><p>你可能会问，为什么我们要使用这些值来设定我们的控制点呢？答案很简单，我使用了PaintCode，然后内部建立贝塞尔曲线，不断的试直到令我满意<br>的效果时，我就将这些值替换到程序中即可。</p><ul><li>更新我们的panGestureDidMove方法，这样当我们手指移动的时候所有的控制点也能移动。用以下的代码替换panGestureDidMove方法中的内容；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func panGestureDidMove(gesture: UIPanGestureRecognizer) &#123;  </span><br><span class="line">    if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let additionalHeight = max(gesture.translationInView(view).y, 0)</span><br><span class="line"></span><br><span class="line">        let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)</span><br><span class="line">        let baseHeight = minimalHeight + additionalHeight - waveHeight</span><br><span class="line"></span><br><span class="line">        let locationX = gesture.locationInView(gesture.view).x</span><br><span class="line"></span><br><span class="line">        layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)</span><br><span class="line">        updateShapeLayer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所做的就是计算wave高度，基础高度以及手指的位置，然后调用layoutControlPoints去布局各个控制点，然后调用updateShapeLayer来更新我们的shapeLayer的path。</p><p>What we do is calculate wave height, base height, location of the finger and call our function: layoutControlPoints to layout control points and updateShapeLayer to update our shape layer path.</p><ul><li>在loadView方法尾部添加两行代码，使得我们在打开app的时候正确的显示；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layoutControlPoints(baseHeight: minimalHeight, waveHeight: 0.0, locationX: view.bounds.width / 2.0)  </span><br><span class="line">updateShapeLayer()</span><br></pre></td></tr></table></figure><ul><li>修改<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shapeLayer.backgroundColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br></pre></td></tr></table></figure></li></ul><p>为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shapeLayer.fillColor = UIColor(red: 57/255.0, green: 67/255.0, blue: 89/255.0, alpha: 1.0).CGColor</span><br></pre></td></tr></table></figure><p>到这里，效果应该如下所示：</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds3.gif" alt="Build3"></p><p>最后一件要做的事情就是，把我们释放手指之后的回弹动画整合进去。<br>还是让我们一步一步来吧：</p><ul><li>定义displayLink变量；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private var displayLink: CADisplayLink!</span><br></pre></td></tr></table></figure><p>在loadView方法的末尾进行初始化：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">displayLink = CADisplayLink(target: self, selector: Selector(&quot;updateShapeLayer&quot;))  </span><br><span class="line">        displayLink.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode)</span><br><span class="line">        displayLink.paused = true</span><br></pre></td></tr></table></figure><p>前面我们也提到过，我们的CADisplayLink对象会在每一帧都调用指定的方法（这里就是指定的updateShapeLayer），因此我们就可以在UIView的动画期间实时的更新shapeLayer的path了。</p><ul><li>定义animating变量；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private var animating = false &#123;  </span><br><span class="line">    didSet &#123;</span><br><span class="line">        view.userInteractionEnabled = !animating</span><br><span class="line">        displayLink.paused = !animating</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个可以控制用户交互是否开启以及displayLink的停止和播放（动画播放期间你肯定不希望用户的交互直接就把动画效果给破坏了。）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private func currentPath() -&gt; CGPath &#123;  </span><br><span class="line">    let width = view.bounds.width</span><br><span class="line"></span><br><span class="line">    let bezierPath = UIBezierPath()</span><br><span class="line"></span><br><span class="line">    bezierPath.moveToPoint(CGPoint(x: 0.0, y: 0.0))</span><br><span class="line">    bezierPath.addLineToPoint(CGPoint(x: 0.0, y: l3ControlPointView.dg_center(animating).y))</span><br><span class="line">    bezierPath.addCurveToPoint(l1ControlPointView.dg_center(animating), controlPoint1: l3ControlPointView.dg_center(animating), controlPoint2: l2ControlPointView.dg_center(animating))</span><br><span class="line">    bezierPath.addCurveToPoint(r1ControlPointView.dg_center(animating), controlPoint1: cControlPointView.dg_center(animating), controlPoint2: r1ControlPointView.dg_center(animating))</span><br><span class="line">    bezierPath.addCurveToPoint(r3ControlPointView.dg_center(animating), controlPoint1: r1ControlPointView.dg_center(animating), controlPoint2: r2ControlPointView.dg_center(animating))</span><br><span class="line">    bezierPath.addLineToPoint(CGPoint(x: width, y: 0.0))</span><br><span class="line"></span><br><span class="line">    bezierPath.closePath()</span><br><span class="line"></span><br><span class="line">    return bezierPath.CGPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新currentPath方法，将dg_center方法参数换为animating参数仅当动画需要的时候才提供layer的准确过渡值。</p><ul><li>最后一步就是需要更新panGestureDidMove方法中的if判断语句；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if gesture.state == .Ended || gesture.state == .Failed || gesture.state == .Cancelled &#123;  </span><br><span class="line">    let centerY = minimalHeight</span><br><span class="line"></span><br><span class="line">    animating = true</span><br><span class="line">    UIView.animateWithDuration(0.9, delay: 0.0, usingSpringWithDamping: 0.57, initialSpringVelocity: 0.0, options: [], animations: &#123; () -&gt; Void in</span><br><span class="line">        self.l3ControlPointView.center.y = centerY</span><br><span class="line">        self.l2ControlPointView.center.y = centerY</span><br><span class="line">        self.l1ControlPointView.center.y = centerY</span><br><span class="line">        self.cControlPointView.center.y = centerY</span><br><span class="line">        self.r1ControlPointView.center.y = centerY</span><br><span class="line">        self.r2ControlPointView.center.y = centerY</span><br><span class="line">        self.r3ControlPointView.center.y = centerY</span><br><span class="line">        &#125;, completion: &#123; _ in</span><br><span class="line">            self.animating = false</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    let additionalHeight = max(gesture.translationInView(view).y, 0)</span><br><span class="line"></span><br><span class="line">    let waveHeight = min(additionalHeight * 0.6, maxWaveHeight)</span><br><span class="line">    let baseHeight = minimalHeight + additionalHeight - waveHeight</span><br><span class="line"></span><br><span class="line">    let locationX = gesture.locationInView(gesture.view).x</span><br><span class="line"></span><br><span class="line">    layoutControlPoints(baseHeight: baseHeight, waveHeight: waveHeight, locationX: locationX)</span><br><span class="line">    updateShapeLayer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经为UIView添加了Sprint动画，让我们的控制点能够通过很优雅的回弹效果回到它们的位置。你可以修改以上的变量值来使你的动画看起来更优美，更好看。</p><p>让我们在设备上运行下看看能够让你震惊的效果：<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds4.gif" alt="Build4"><br>当然，我们可能不太想显示这些红色的点。你可以在loadView方法中移除那些设置这些控制点的frame以及背景色的代码。</p><p>再次运行代码效果如下：</p><p><img src="http://7xilk1.com1.z0.glb.clouddn.com/DGElasticPullToRefreshBuilds5.gif" alt="Build5"></p><p>效果很完美，但是，在这个例子中有一件事情我们忘记做了，就是我们没有改变shapeLayer的高度，我们仅仅修改了path的高度。这个不够完美，需要修复它。我想这个对于你来说应该是不错的作业。尽情修改frame、path以及所有变量的值吧！</p><blockquote><p>这个Demo的源码在<a href="https://github.com/gontovnik/DGElasticBounceTutorial" target="_blank" rel="noopener">这里</a><br><a href="https://github.com/gontovnik/DGElasticPullToRefresh" target="_blank" rel="noopener">DGElasticPullToRefresh</a>的源码在这里</p></blockquote></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://hechen.xyz/2015/12/02/Elastic-view-animation-using-UIBezierPath/">http://hechen.xyz/2015/12/02/Elastic-view-animation-using-UIBezierPath/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/Swift/">Swift</a><a class="post-meta__tags" href="/tags/Objective-C/">Objective-C</a><a class="post-meta__tags" href="/tags/Animation/">Animation</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/02/12/Read-SourceCode-of-PNChart/"><i class="fa fa-chevron-left"></i><span>解析 PNChart 第三方库</span></a></div><div class="next-post pull-right"><a href="/2015/09/14/Objective-C中Category的一点东西/"><span>Objective-C中Category的一点东西</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused=null,disqus_config=function(){this.page.url="http://hechen.xyz/2015/12/02/Elastic-view-animation-using-UIBezierPath/",this.page.identifier="2015/12/02/Elastic-view-animation-using-UIBezierPath/",this.page.title="如何使用UIBezierPath实现一个弹性视图动画"},d=document,s=d.createElement("script");s.src="https://stoneman.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script id="dsq-count-src" src="https://stoneman.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2019 By Chen</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>