<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="iOS 远端推送部署详解"><meta name="keywords" content="iOS,Push Notification"><meta name="author" content="Chen,undefined"><meta name="copyright" content="Chen"><title>iOS 远端推送部署详解 | Writing, Thinking and Coding.</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b8b088e1ebab51ca1f8e3c11ac0476a1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#iOS远端推送机制"><span class="toc-number">1.</span> <span class="toc-text">iOS远端推送机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本地推送证书配置"><span class="toc-number">2.</span> <span class="toc-text">本地推送证书配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#APP-ID"><span class="toc-number">2.1.</span> <span class="toc-text">APP ID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Certificates"><span class="toc-number">2.2.</span> <span class="toc-text">Certificates</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Provisioning-Profiles"><span class="toc-number">2.3.</span> <span class="toc-text">Provisioning Profiles</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#开发环境配置"><span class="toc-number">3.</span> <span class="toc-text">开发环境配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#远端推送通知的代码实现"><span class="toc-number">4.</span> <span class="toc-text">远端推送通知的代码实现</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://en.gravatar.com/userimage/112198960/798360714fd6208c863662c667290d7d.jpg?size=200"></div><div class="author-info__name text-center">Chen</div><div class="author-info__description text-center">I do stuff.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">47</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image:url(true)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Writing, Thinking and Coding.</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">iOS 远端推送部署详解</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-05-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2015/07/30/iOS-Push-Notification/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2015/07/30/iOS-Push-Notification/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3,251</span><span class="post-meta__separator">|</span><span>Reading time: 12 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>最近几天被iOS的推送部署给搞懵了，现在特地整理下和大家进行分享。</p><h4 id="iOS远端推送机制"><a href="#iOS远端推送机制" class="headerlink" title="iOS远端推送机制"></a>iOS远端推送机制</h4><p>APNS，全称为Apple Push Notification service，是苹果通知推送服务中最重要的一环。它是苹果通知推送服务器，为所有iOS设备以及OS X设备提供强大并且可靠的推送通知服务。每个注册通知服务的设备都会和该服务器进行长连接，从而实时获取推送通知。即使当前APP不在运行状态，当通知到达的时候也会有提示发生，最常见的就是短信服务。</p><a id="more"></a><p>每一个App必须向APNs注册通知服务，APNs会返回给设备一个DeviceToken，该Token为APNs上针对该设备的唯一标示符。App需要将该DeviceToken返给自身的Server端保存后续使用，如下所示。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushshare%20the%20device%20Token.png" alt="DeviceToken的操作流程"></p><p>当App开发者的server需要向特定设备推送通知时，就使用DeviceToken和固定格式数据（Push payload）发给APNs，然后APNs就会向DeviceToken指定的设备推送通知了，具体流程如下所示，单一推送<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20a%20remote%20notification%20from%20a%20provider%20to%20a%20client%20app.png" alt="通知方推送一条远端通知给客户端代码的整个流程"><br>或者多方通知，APNs都能一一对应，靠的就是之前我们提供给它的DeviceToken。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushPushing%20remote%20notifications%20from%20multiple%20providers%20to%20multiple%20devices.png" alt="多个通知方向向不同的客户端推送通知的流程示意"></p><hr><h4 id="本地推送证书配置"><a href="#本地推送证书配置" class="headerlink" title="本地推送证书配置"></a>本地推送证书配置</h4><p>打开你mac的钥匙串访问，然后点击钥匙串访问<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush钥匙串.png" alt="打开钥匙串"><br>随后它会弹出一个窗口 用户电子邮件信息<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书1.png" alt="生成CSR文件"><br>就填写你苹果开发者账号的名称即可（应该是一个邮件名称），点击保存到磁盘的选项，点击继续，点击存储，文件名为：CertificateSigningRequest.certSigningRequest。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书2.png" alt="保存生成的CSR文件"></p><p>然后我们打开<a href="developer.apple.com">苹果开发者中心</a> 进入Member Center<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书3.png" alt="苹果开发者中心"><br>然后点击左侧列表中任意一项进入详情页面，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书4.png" alt="开发者个人首页选项"><br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书5.png" alt="选择IOS Apps中列表项"></p><h5 id="APP-ID"><a href="#APP-ID" class="headerlink" title="APP ID"></a>APP ID</h5><p>首先我们需要为我们要开发的APP建立身份信息，就是AppID，如图所示，点击左侧<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID1.png" alt="添加AppID"><br>点击添加按钮进入注册页面，我们需要输入App Id的名字以及BundleID，其中BundleID不能有通配符，否则无法具备推送功能，然后在下面的APP Service中勾选Push Notification一项<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID2.png" alt="填写BundleID以及App ID Description"><br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushAPPID3.png" alt="选择App Service"><br>点击下一步，然后确认提交即可，大家注意到Push Notification一项为Configurable，这是因为我们还没有为该AppID生成推送证书，等推送证书生成完毕之后可以再回来查看该AppID 的状态。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书13.jpg" alt="确认提交App ID"></p><h5 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h5><p>其次，我们需要生成开发者证书和推送证书，如下图所示，点击左侧Cerifications列表，选择添加进入下一页面，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书11.png" alt="添加证书"></p><p>如果您的页面如图所示为灰色不可选，说明您已经拥有了开发者证书。就不需要再次生成了，如果可选就选择该选项，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书7.png" alt="选择证书类型"></p><p>接下来进入以下界面，选择你之前添加的AppID，之后点击Continue即可，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书8.png" alt="选择需要绑定证书的App ID"></p><p>然后选择之前我们保存在本地的CSR文件CertificateSigningRequest.certSigningRequest，点击Generate就生成了开发者的证书。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书9.png" alt="上传本机CSR文件"></p><p>同理我们需要生成推送测试证书，生成流程和开发者证书类似，只是在证书类型页面，选择的证书类型换成了Apple Push Notification service SSL。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书10.png" alt="选择生成证书类型"></p><p>当我们生成好推送证书之后再回头看我们之前创建的AppId，能够看Push Notifications一项已经为Enabled了。当然发布推送证书配置完毕之后，Distribution一项也显示为Enable。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书12.jpg" alt="再次查看APPID 状态"></p><h5 id="Provisioning-Profiles"><a href="#Provisioning-Profiles" class="headerlink" title="Provisioning Profiles"></a>Provisioning Profiles</h5><p>第三步，需要生成Provisioning Profiles，该文件其实就是以上的证书、AppId以及设备信息的打包集合，我们只要在不同的场景下生成不同类型Provisioning Profiles即可，它会在后续打包ipa文件的时候被嵌入安装包内。<br>首先我们选择左侧列表中的Provisioning Profiles中的All选项，选择添加<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision1.png" alt="添加Provisioning Profiles文件"></p><p>之后选择生成类型，我们这里以开发类型为例，下面还有发布的两种类型，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision2.png" alt="选择生成PP文件类型"></p><p>之后点击Continue，进入下一页面，同样选择我们之前创建的具有Push服务的AppId，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision3.png" alt="选择绑定的App ID"></p><p>接下来，选择上面生成的开发证书（一一对应的，如果你选择生成的是发布Provisioning Profiles，则会出现发布证书），<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision4.png" alt="选择之前生成的对应证书"></p><p>紧接着，我们选择授权设备，即你需要进行开发的设备，该设备可以在左侧Devices列表中添加，需要提供设备的UUID，这里我们选择所有设备，点击Continue，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision5.png" alt="选择授权设备"></p><p>最后一步，我们给Provisioning Profiles添加名称，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushProvision6.png" alt="添加Provisioning Profiles名称"><br>点击Generate即生成我们所需要的Provisioning Profile。</p><p>其实同理，我们可以生成发布版的开发者证书，推送证书以及对应的Provisioning Profiles。最后的文件我们都放到同一个文件夹里，如图所示，其中我把发布的两种（Ad Hoc 和 Distribution）都一起搞出来。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPush证书200.png" alt="生成的各个证书以及Provisioning Profile文件"></p><p>其中Push.p12文件后续会提及~</p><hr><h4 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h4><p>我们将上一步生成的开发者证书<code>ios_development.cer</code>以及推送证书<code>aps_development.cer</code>在最初生成CSR文件的MAC机上安装，双击即可安装，同时会打开钥匙串页面，安装之后我们找到之前生成CSR文件时生成的专用密钥，名称就是我们之前生成CSR文件时填写的，选择该专用密钥，同时选中刚刚安装成功的推送证书，（<strong>必须注意，同时选择，我们需要将专用密钥以及安装成功的推送证书同时导出成一个文件</strong>）右键菜单导出，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode6.png" alt="导出专用密钥和本地安装的推送证书"><br>如图我们命名Push，点击存储，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode7.png" alt="保存到本地"><br>接下来需要为证书添加密码，这个密码是需要提供给服务器的。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode8.png" alt="添加证书密码"></p><p>最后我们需要配置我们本地的开发环境，也就是XCode，第一步我们点击XCode的Preference打开XCode的首选项菜单，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode1.png" alt="打开Preference选项"></p><p>在Account选项中添加我们的开发者账户，如果之前已经登录就会看到该账户信息，然后点击下方的View Details，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode5.png" alt="查看账户信息"></p><p>之后会显示该开发者账户的证书和Provisioning Profiles等信息，该信息会和你开发者账号里面显示的一致，如果不一致就点击刷新，<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode3.png" alt="刷新账户信息"></p><p>不久就会出现我们之前创建的Provisioning Profiles，接下来，我们在XCode中Build Settings -&gt; Code Signing中选择我们需要的Provisioning Profiles文件即可<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode4.png" alt="XCode选择对应的Provisioning Profile文件"></p><p>此时本地开发环境已经配置完毕。接下来就开始Coding，Coding，Coding。。。。</p><h4 id="远端推送通知的代码实现"><a href="#远端推送通知的代码实现" class="headerlink" title="远端推送通知的代码实现"></a>远端推送通知的代码实现</h4><p>首先我们需要注册推送通知服务并获取DeviceToken；</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)initPushNotificationWithApp: (<span class="built_in">UIApplication</span>*)application &#123;</span><br><span class="line">    <span class="comment">// 注册通知服务</span></span><br><span class="line">    <span class="keyword">if</span>([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &lt; <span class="number">8.0</span>) &#123;</span><br><span class="line">        [application registerForRemoteNotificationTypes:(<span class="built_in">UIRemoteNotificationTypeBadge</span></span><br><span class="line">                                                       | <span class="built_in">UIRemoteNotificationTypeSound</span></span><br><span class="line">                                                       | <span class="built_in">UIRemoteNotificationTypeAlert</span>)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// IOS8.0以上版本的注册推送方式和以往不同</span></span><br><span class="line">        <span class="built_in">UIUserNotificationSettings</span>* settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:(<span class="built_in">UIRemoteNotificationTypeBadge</span></span><br><span class="line">                                                                                           | <span class="built_in">UIRemoteNotificationTypeSound</span></span><br><span class="line">                                                                                           | <span class="built_in">UIRemoteNotificationTypeAlert</span>)</span><br><span class="line">                                                                                 categories:<span class="literal">nil</span>];</span><br><span class="line">        [application registerUserNotificationSettings:settings];</span><br><span class="line">        [application registerForRemoteNotifications];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果注册成功，APNs会返回给你设备的token，iOS系统会把它传递给app delegate代理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如果注册成功，则会收到DeviceToken，我们需要将该Token发给服务器保存</span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken &#123;</span><br><span class="line">    PRINT_FUNC</span><br><span class="line">    </span><br><span class="line">    NSString* tokenStr = [NSString stringWithFormat:@&quot;%@&quot;, deviceToken];</span><br><span class="line">    NSLog(@&quot;deviceToken: %@&quot;, tokenStr);</span><br><span class="line">    if(tokenStr.length == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Device Token Invalid!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	// 然后我们需要将该DeviceToken发给我们自己的服务器进行保存；</span><br><span class="line">    [self sendDeviceToken:deviceToken]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果注册失败，会收到错误信息，包含错误原因</span><br><span class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error &#123;</span><br><span class="line">    PRINT_FUNC</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;***************************************\n&quot;);</span><br><span class="line">    NSLog(@&quot;Failed to Register The Notification!!!!\n&quot;);</span><br><span class="line">    NSLog(@&quot;error = %@&quot;, error);</span><br><span class="line">    NSLog(@&quot;***************************************\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以在AppDelegate中添加处理代码，当用户点击通知栏的通知或者处于运行状态时，App代码会执行- (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo代理方法，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo &#123;</span><br><span class="line">    PRINT_FUNC</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;收到推送通知: %@&quot;, userInfo);</span><br><span class="line">    </span><br><span class="line">    // userInfo是一个字典数据类型，具体Key Value由客户端和服务器进行协商确定</span><br><span class="line">    NSString* orderId = [userInfo objectForKey:@&quot;carryOrderId&quot;];</span><br><span class="line">    NSLog(@&quot;收到订单消息通知，订单号：%@&quot;,orderId);</span><br><span class="line">	</span><br><span class="line">	// .... 其余逻辑，拿到具体关键信息之后进行下一步处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*! This delegate method offers an opportunity for applications with the &quot;remote-notification&quot; background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you&apos;re finished performing that operation, so the system can accurately estimate its power and data cost.</span><br><span class="line"> </span><br><span class="line"> This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !*/</span><br><span class="line"> </span><br><span class="line">- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler;</span><br></pre></td></tr></table></figure><p>我发现这两个方法在APP处于后台或者前台展示，也就是App存活期会同样调用，但当APP并未启动或者被后台销毁之后，用户点击通知象虽然都会调起App，但是前者这个方法就不会被触发，而后者依然会被触发。注释中也说明了该方法即使在其中或者休眠状态下都会由于远端通知而被调用而且会优先于上一个方法。而且后者可以让你和服务器进行一定的数据交互，比如订单状态变化了，我们在该方法中向服务器请求最新的订单信息等等。</p><p>官方文档是这样描述这两个方法的，一目了然：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Tells the delegate that the running app received a remote notification.</span><br><span class="line">	- application:didReceiveRemoteNotification:</span><br><span class="line"></span><br><span class="line">// Tells the app that a remote notification arrived that indicates there is data to be fetched.</span><br><span class="line">	- application:didReceiveRemoteNotification:fetchCompletionHandler:</span><br></pre></td></tr></table></figure><hr><p>####服务器端代码实现</p><p>Apple官方APNs地址：</p><ol><li>测试地址 gateway.sandbox.push.apple.com:2195</li><li>正式发布地址 gateway.push.apple.com:2195</li></ol><p>简单的通知数据格式，以二进制形式发送，网络字节序。<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushSimple%20Notification%20Format.png" alt="简单的推送通知格式"></p><p>服务器端代码也可以自己使用原生的Socket写，这里我使用Javapns这个开源代码实现，比较简单，Payload数据格式也已经被封装，你只需要add，add，add。代码如下：<br>其中就需要用到我们之前生成的Push.p12</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testApplePush;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javapns.Push;</span><br><span class="line"><span class="keyword">import</span> javapns.notification.PushNotificationPayload;</span><br><span class="line"><span class="keyword">import</span> javapns.notification.PushedNotifications;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testApplePush</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> </span><br><span class="line">       &#123;</span><br><span class="line">          PushNotificationPayload payload = <span class="keyword">new</span> PushNotificationPayload();</span><br><span class="line"></span><br><span class="line">          payload.addAlert(<span class="string">"这是一条推送通知!"</span>); <span class="comment">// 通知主体内容</span></span><br><span class="line">          payload.addBadge(<span class="number">1</span>); <span class="comment">// 角标数字</span></span><br><span class="line">          payload.addSound(<span class="string">"default"</span>); <span class="comment">// 通知铃音</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 加入自定义信息</span></span><br><span class="line">          payload.addCustomDictionary(<span class="string">"carryOrderId"</span>, <span class="string">"121212121212121212121212"</span>);</span><br><span class="line"> </span><br><span class="line">		    <span class="comment">// 服务器端记录的DeviceToken</span></span><br><span class="line">          String deviceToken = <span class="string">"************************************************"</span>;</span><br><span class="line">          PushedNotifications notifications = Push.payload(payload, 	<span class="comment">// 自定义payload</span></span><br><span class="line">												          <span class="string">"Push.p12"</span>,	<span class="comment">// 前面生成的证书</span></span><br><span class="line">												          <span class="string">"111111111"</span>, 	<span class="comment">// 证书导出时的密码</span></span><br><span class="line">												          <span class="keyword">false</span>,		<span class="comment">// 是否发送到发布地址</span></span><br><span class="line">												          deviceToken); <span class="comment">// 客户端DeviceToken</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> numOfFailedNotifications = notifications.getFailedNotifications()</span><br><span class="line">                    .size();</span><br><span class="line">            <span class="keyword">int</span> numOfSuccessfulNotificatios = notifications</span><br><span class="line">                    .getSuccessfulNotifications().size();</span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(</span><br><span class="line">                    <span class="string">"Successful Send: %d, Failed Send: %d"</span>,</span><br><span class="line">                    numOfSuccessfulNotificatios, numOfFailedNotifications));</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前这里只是发送一条，如果需要批量发送，貌似Javapns支持的不是太好。这里使用的证书就是上面我们导出的.p12格式证书（<strong>Windows平台使用没问题。有些教程说是Win系统不识别是不正确的</strong>），接下来还有一份PHP写的代码，供大家查阅。但是这其中需要将我们的p12格式证书转换成pem格式证书。具体教程如下：</p><ul><li>将我们之前生成的推送证书aps_developement.cer文件以及Push.p12文件放在同一文件夹下；</li><li>在Terminal中切换到该目录下，然后执行命令将aps_developement.cer文件转换成pem格式文件，之后会在本目录下生成PushCert.pem文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in aps_development.cer -inform der -out PushCert.pem</span><br></pre></td></tr></table></figure><ul><li>紧接着执行命令将Push.p12文件转换成pem格式文件，之后在本目录下生成PushKey.pem文件，其中会提示你先输入之前生成Push.p12文件的时候的密码，然后需要为新生成的证书文件添加密码，这个密码是要提供给服务端使用的；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -nocerts -out Pushkey.pem -in Push.p12</span><br></pre></td></tr></table></figure><ul><li>然后将这两个pem文件合成成一个pem文件，Push.pem<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat PushCert.pem PushKey.pem &gt; Push.pem</span><br></pre></td></tr></table></figure></li></ul><p>整个过程如下图所示：<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushXCode9.png" alt="pem文件生成过程"></p><p>证书生成完毕之后，我们就可以在代码中使用了。<br>如下为PHP写的推送通知服务。代码很简单，主要是注意其中证书为上一步生成的Push.pem，密码就是生成时输入的密码。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// DeviceToken 不包含空格</span></span><br><span class="line">$deviceToken = <span class="string">'********************************************************'</span>;</span><br><span class="line"><span class="comment">// 证书密码</span></span><br><span class="line">$passphrase = <span class="string">'1111111111'</span>;</span><br><span class="line"><span class="comment">// 通知主体内容</span></span><br><span class="line">$alert = <span class="string">'这是一条推送通知!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">$ctx = stream_context_create();</span><br><span class="line">stream_context_set_option($ctx, <span class="string">'ssl'</span>, <span class="string">'local_cert'</span>, <span class="string">'Push.pem'</span>);		<span class="comment">// ck.pem证书上有提及</span></span><br><span class="line">stream_context_set_option($ctx, <span class="string">'ssl'</span>, <span class="string">'passphrase'</span>, $passphrase);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open a connection to the APNS server</span></span><br><span class="line">$fp = stream_socket_client(</span><br><span class="line">		<span class="string">'ssl://gateway.sandbox.push.apple.com:2195'</span>, 			<span class="comment">// 远端测试地址</span></span><br><span class="line">		$err,													</span><br><span class="line">		$errstr, </span><br><span class="line">		<span class="number">60</span>, 													<span class="comment">// 超时时间</span></span><br><span class="line">		STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT,</span><br><span class="line">		$ctx);</span><br><span class="line"><span class="keyword">if</span> (!$fp)</span><br><span class="line">	<span class="keyword">exit</span>(<span class="string">"Failed to connect: $err $errstr"</span> . PHP_EOL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'Connected to APNS'</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立字典数据</span></span><br><span class="line">$body[<span class="string">'aps'</span>] = <span class="keyword">array</span>(</span><br><span class="line">	<span class="string">'alert'</span> =&gt; $alert,</span><br><span class="line">	<span class="string">'sound'</span> =&gt; <span class="string">'default'</span>,</span><br><span class="line">	<span class="string">'badge'</span> =&gt; <span class="number">66</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典数据转换成JSON</span></span><br><span class="line">$payload = json_encode($body);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组织二进制数据格式，具体格式参照apple官方文档，本文中也有提及。</span></span><br><span class="line"><span class="comment">// Command + Token length + deviceToken + Payload length + payload</span></span><br><span class="line">$msg = chr(<span class="number">0</span>) . pack(<span class="string">'n'</span>, <span class="number">32</span>) . pack(<span class="string">'H*'</span>, $deviceToken) . pack(<span class="string">'n'</span>, strlen($payload)) . $payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送组成的数据给APNs</span></span><br><span class="line">$result = fwrite($fp, $msg, strlen($msg));</span><br><span class="line"><span class="keyword">if</span> (!$result)</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'Fail to delivery Notification'</span> . PHP_EOL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'Delivery Notification successfully'</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">fclose($fp);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行下下测试：<br><img src="http://7xilk1.com1.z0.glb.clouddn.com/iosPushResult.png" alt="最终测试效果"></p><p>参考：<br>[1]. <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1</a><br>[2]. <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/" target="_blank" rel="noopener">https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/</a><br>[3]. <a href="http://blog.csdn.net/shenjie12345678/article/details/41120637" target="_blank" rel="noopener">http://blog.csdn.net/shenjie12345678/article/details/41120637</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://hechen.xyz/2015/07/30/iOS-Push-Notification/">http://hechen.xyz/2015/07/30/iOS-Push-Notification/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/Push-Notification/">Push Notification</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2015/08/18/leetCode-018-LengthOfLastWord/"><i class="fa fa-chevron-left"></i><span>leetCode[018]Length Of Last Word</span></a></div><div class="next-post pull-right"><a href="/2015/05/07/关于单链表的那些事儿/"><span>关于单链表的那些事儿</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused=null,disqus_config=function(){this.page.url="http://hechen.xyz/2015/07/30/iOS-Push-Notification/",this.page.identifier="2015/07/30/iOS-Push-Notification/",this.page.title="iOS 远端推送部署详解"},d=document,s=d.createElement("script");s.src="https://stoneman.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script id="dsq-count-src" src="https://stoneman.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2019 By Chen</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>